Changes to original SimLab distribution of Weyl
===============================================
Thu 20 Mar 12:23:24 CET 2025

;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-		;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-
;;; ===========================================================================		;;; ===========================================================================
;;;			  Algebraic Domains						;;;			  Algebraic Domains
;;; ===========================================================================		;;; ===========================================================================
;;; (c) Copyright 1989, 1994 Cornell University						;;; (c) Copyright 1989, 1994 Cornell University

;;; algebraic-domains.lisp,v 1.18 1995/05/24 17:41:57 rz Exp				;;; algebraic-domains.lisp,v 1.18 1995/05/24 17:41:57 rz Exp

(in-package "WEYLI")								    |	(in-package :weyli)

(make::adjust-version-numbers Weyl "1.18")					    |	;;; DELETE (make::adjust-version-numbers Weyl "1.18")

(defclass set (domain)									(defclass set (domain)
     ()											  ()
  (:documentation "A class for finite, unordered sets"))			    |	  (:documentation
										    >	   "A class for finite, unordered sets"))

;; Some objects and/or domains have names.  If so the following class		    |	;;; Some objects and/or domains have names. If so the following class
;; should always be included.							    |	;;; should always be included.

(defclass has-name ()									(defclass has-name ()
     ((name :initarg :name :accessor name-of)))					    |	  ((name :initarg :name :accessor name-of))
										    >	  (:documentation
										    >	   "Include this class in objects and/or domains that have names."))
										    >
										    >	(defgeneric binary= (x y)
										    >	  (:documentation
										    >	   "Elements of a set are assumed to be comparable using binary=. For
										    >	more complex set structures, the binary= operation looks up the
										    >	comparison function in EQUAL-FUNCTION slot."))

;; Elements of a set are assumed to be comparable using binary=.  For		    |	;; Ordered set's presume the existence of a > predicate.  We provide a
;; more complex set structures, the binary= operation looksup the		    |	;; default for >= but that is likely to also be provided primitively.
;; comparison function in EQUAL-FUNCTION slot.					    |	;; < and <= are handled via macros since they just involve changing
										    |	;; the order of the arguments.
(defgeneric binary= (x y))							    |
(defgeneric make-element (domain obj &rest rest))				    |	(defgeneric binary> (x y)
										    |	  (:documentation
;; Some data structure need to have ready access to equality and		    |	   "Elements of a set are assumed to be comparable using binary>. For
;; inequality comparison functions.  For instance, AVL trees, the		    |	more complex set structures, the binary> operation looks up the
;; exponent comparison function of expanded polynomials, etc.  The		    |	comparison function in greater-funcion slot."))
;; following classes provides a canonical place to cache this			    |
;; information									    |	(defgeneric binary>= (x y)
										    >	  (:method (x y)
										    >	    (or (binary> x y) (binary= x y))))
										    >
										    >	(defsubst binary< (x y) (binary> y x))
										    >
										    >	(defsubst binary<= (x y) (binary>= y x))
										    >
										    >	(defgeneric make-element (domain obj &rest rest)
										    >	  (:documentation
										    >	   "The purpose of this method is unknown."))
										    >
										    >	;;; Some data structure need to have ready access to equality and
										    >	;;; inequality comparison functions.  For instance, AVL trees, the
										    >	;;; exponent comparison function of expanded polynomials, etc.  The
										    >	;;; following classes provides a canonical place to cache this
										    >	;;; information

(defclass has-equality ()								(defclass has-equality ()
     ((equal-function :initform #'binary=					    |	  ((equal-function
										    >	    :initform #'binary=
			:initarg :equal-function					    :initarg :equal-function
			:accessor equal-function-of)))				    |	    :accessor equal-function-of))
										    >	  (:documentation
										    >	   "A canonical place to cache equality function information."))

(defclass has-comparison ()								(defclass has-comparison ()
     ((greater-function :initform #'binary>					    |	  ((greater-function
										    >	    :initform #'binary>
			:initarg :greater-function					    :initarg :greater-function
			:accessor greater-function-of)))			    |	    :accessor greater-function-of))
										    |	  (:documentation
;; Whether or not a set is ordered is a property, but elements of an		    |	   "A cononical place to cache inequality function information."))
;; ordered set can be compared using binary>.					    |
										    |	;;; Whether or not a set is ordered is a property, but elements of an
;; Properties indicate additional axioms that can be true about a		    |	;;; ordered set can be compared using binary>.
;; domain. All the properties of an algebraic domain (e.g. field-ness)		    |
;; could treated as axioms, and in many ways this would be preferable,		    |	;;; Properties indicate additional axioms that can be true about a
;; but I'm not quite willing to do this at this point.  --RZ			    |	;;; domain. All the properties of an algebraic domain (e.g. field-ness)
										    |	;;; could treated as axioms, and in many ways this would be preferable,
;; When looking up a property, two values are returned: whether the		    |	;;; but I'm not quite willing to do this at this point.  --RZ
;; property is true and whether we are certain of the result.			    |
										    |	;;; When looking up a property, two values are returned: whether the
;; Non strict domains!!  Non-Strict domains have all possible			    |	;;; property is true and whether we are certain of the result.
;; properties.  I.e. if it is syntactically possible to do an			    |
;; operation on the operands, then Weyl will go ahead and do it			    |	;;; Non strict domains!!  Non-Strict domains have all possible
;; without checking any properties of the domain.				    |	;;; properties.  I.e. if it is syntactically possible to do an
										    >	;;; operation on the operands, then Weyl will go ahead and do it
										    >	;;; without checking any properties of the domain.

(defclass non-strict-domain ()								(defclass non-strict-domain ()
     ())										  ())

										    >	;;; FIXME : Move these to the top of the file.
(defvar *empty-property* (list nil))							(defvar *empty-property* (list nil))

(defvar *math-properties* ())								(defvar *math-properties* ())

										    >	;;; FIXME : Add support for declarations and documentation.
										    >	;;; AUDIT : Needs a detailed audit.
(defmacro define-math-property (property-name subsumed-properties)			(defmacro define-math-property (property-name subsumed-properties)
  (let ((predicate-name (intern (format nil "~A?" property-name)))			  (let ((predicate-name (intern (format nil "~A?" property-name)))
	(keyword (intern (symbol-name property-name)						(keyword (intern (symbol-name property-name)
			 (find-package 'keyword)))								 (find-package 'keyword)))
	(assert-name (intern (format nil "ASSERT-~A" property-name))))				(assert-name (intern (format nil "ASSERT-~A" property-name))))
    `(progn										    `(progn
										    >	      (defgeneric ,predicate-name (domain))
       (defmethod ,predicate-name ((domain domain))					      (defmethod ,predicate-name ((domain domain))
	 (let ((val (getf domain ,keyword *empty-property*)))				        (let ((val (getf domain ,keyword *empty-property*)))
	   (if (eql val *empty-property*)						          (if (eql val *empty-property*)
	       (values nil nil)								              (values nil nil)
	     (values val t))))								              (values val t))))
       (defmethod ,predicate-name ((domain non-strict-domain))				      (defmethod ,predicate-name ((domain non-strict-domain))
	 t)										        t)
										    |	      (defgeneric ,assert-name (domain))
       (defmethod ,assert-name ((domain domain))					      (defmethod ,assert-name ((domain domain))
	 ,@(loop for prop in subsumed-properties					        ,@(loop for prop in subsumed-properties
		 collect `(,(intern (format nil "ASSERT-~A" prop)) domain))		                collect `(,(intern (format nil "ASSERT-~A" prop)) domain))
	 (setf (getf domain ,keyword) t))						        (setf (getf domain ,keyword) t))
											      (pushnew ',property-name *math-properties*))))
       (pushnew ',property-name *math-properties*))))
											(define-math-property ordered-domain ())
(define-math-property ordered-domain ())
										    (
;; Ordered set's presume the existence of a > predicate.  We provide a		    <
;; default for >= but that is likely to also be provided primitively.		    <
;; < and <= are handled via macros since they just involve changing		    <
;; the order of the arguments.							    <
										    <
(defgeneric binary> (x y))							    <
										    <
(defgeneric binary>= (x y))							    <
(defmethod binary>= (x y)							    <
  (or (binary> x y) (binary= x y)))						    <
										    <
(defsubst binary< (x y) (binary> y x))						    <
										    <
(defsubst binary<= (x y) (binary>= y x))					    <
										    <
										    <
;; The following property is used to determine if floating point			;; The following property is used to determine if floating point
;; numbers can be elements of the domain.						;; numbers can be elements of the domain.

(define-math-property complete-set ())							(define-math-property complete-set ())

;; Define-operations for sets is in sets.lisp						;; Define-operations for sets is in sets.lisp

(defclass semigroup (set)								(defclass semigroup (set)
  ())											  ())

(defsubst semigroup? (domain) (typep domain 'semigroup))				(defsubst semigroup? (domain) (typep domain 'semigroup))

(define-operations semigroup								(define-operations semigroup
  (times (element self) (element self)) -> (element self)				  (times (element self) (element self)) -> (element self)
  (expt (element self) positive-integer) -> (element self))				  (expt (element self) positive-integer) -> (element self))

(defgeneric times (x y))								(defgeneric times (x y))
(defgeneric expt (x y))
											(defgeneric expt (x y))
(defclass monoid (semigroup)
  ())											(defclass monoid (semigroup)
											  ())
(defsubst monoid? (domain) (typep domain 'monoid))
											(defsubst monoid? (domain) (typep domain 'monoid))
(define-operations monoid
  (one self) -> (element monoid)							(define-operations monoid
  (1? (element self)) -> Boolean							  (one self) -> (element monoid)
  (expt (element self) integer) -> (element self))					  (1? (element self)) -> Boolean
											  (expt (element self) integer) -> (element self))
(defgeneric one (x))
(defmethod one ((domain domain))							(defgeneric one (x))
  (coerce 1 domain))
											(defmethod one ((domain domain))
(defgeneric 1? (x))									  (coerce 1 domain))

(defclass group (monoid)								(defgeneric 1? (x))
  ())
											(defclass group (monoid)
(defsubst group? (domain) (typep domain 'group))					  ())

(define-operations group								(defsubst group? (domain) (typep domain 'group))
  (recip (element self)) -> (element self)
  (expt (element self) Integer) -> (element self))					(define-operations group
											  (recip (element self)) -> (element self)
(defgeneric recip (x))									  (expt (element self) Integer) -> (element self))

(defclass abelian-semigroup (set)							(defgeneric recip (x))
  ())
											(defclass abelian-semigroup (set)
										    )	  ())
										    )
(defsubst abelian-semigroup? (domain) (typep domain 'abelian-group))		    |	(defsubst abelian-semigroup? (domain) (typep domain 'abelian-semigroup))

(define-operations abelian-semigroup							(define-operations abelian-semigroup
  (plus (element self) (element self)) -> (element self)				  (plus (element self) (element self)) -> (element self)
  (times Integer (element self)) -> (element self))					  (times Integer (element self)) -> (element self))

(defgeneric plus (x y))									(defgeneric plus (x y))

(defclass abelian-monoid (abelian-semigroup)						(defclass abelian-monoid (abelian-semigroup)
  ())											  ())

(defsubst abelian-monoid? (domain) (typep domain 'abelian-monoid))			(defsubst abelian-monoid? (domain) (typep domain 'abelian-monoid))

(define-operations abelian-monoid							(define-operations abelian-monoid
  (zero self) -> (element self)								  (zero self) -> (element self)
  (0? (element self)) -> Boolean							  (0? (element self)) -> Boolean
  (times integer (element self)) -> (element self))					  (times integer (element self)) -> (element self))

(defgeneric zero (domain))								(defgeneric zero (domain))
(defmethod zero ((domain domain))
  (coerce 0 domain))									(defmethod zero ((domain domain))
											  (coerce 0 domain))
(defgeneric 0? (x))
											(defgeneric 0? (x))
(defclass abelian-group (abelian-monoid)
  ())											(defclass abelian-group (abelian-monoid)
											  ())
(defsubst abelian-group? (domain) (typep domain 'abelian-group))
											(defsubst abelian-group? (domain) (typep domain 'abelian-group))
(define-operations abelian-group
  (minus (element self)) -> (element self)						(define-operations abelian-group
  (difference (element self) (element self)) -> (element self)				  (minus (element self)) -> (element self)
  (times integer (element self)) -> (element self))					  (difference (element self) (element self)) -> (element self)
											  (times integer (element self)) -> (element self))
(defgeneric minus (x))
(defgeneric difference (x y))								(defgeneric minus (x))

;; This is the mathematical definition of a RING.  It has just the			(defgeneric difference (x y))
;; operations plus and times, and times distributes over plus.  In
;; most cases however we usually mean somewhat more.					;; This is the mathematical definition of a RING.  It has just the
(defclass rng (semigroup abelian-group)							;; operations plus and times, and times distributes over plus.  In
  ())											;; most cases however we usually mean somewhat more.
											(defclass rng (semigroup abelian-group)
#+IGNORE										  ())
(defaxiom rng ()
  (leftdistributive times plus)								#+IGNORE
  (rightDistributive times plus))							(defaxiom rng ()
											  (leftdistributive times plus)
											  (rightDistributive times plus))
(defclass simple-ring (rng monoid)
     ())										(defclass simple-ring (rng monoid)
											  ())
(defsubst simple-ring? (domain) (typep domain 'simple-ring))
											(defsubst simple-ring? (domain) (typep domain 'simple-ring))
(define-operations simple-ring
  (characteristic self) -> Integer							(define-operations simple-ring
  (one self) -> (element self)								  (characteristic self) -> Integer
  (1? (element self)) -> (element self)							  (one self) -> (element self)
  (recip (element self)) -> (element self))						  (1? (element self)) -> (element self)
											  (recip (element self)) -> (element self))
(defclass has-coefficient-domain ()
										    )	(defclass has-coefficient-domain ()
  ((coefficient-domain :initform nil						    |	  ((coefficient-domain
										    >	    :initform nil
		       :initarg :coefficient-domain					    :initarg :coefficient-domain
		       :reader coefficient-domain-of)))					    :reader coefficient-domain-of)))

(defvar *coefficient-domain* ()								(defvar *coefficient-domain* ()
  "Within the context of a polynomial operation, the coefficient domain")	    |	  "Within the context of a polynomial operation, the coefficient
										    >	domain")

(defmethod %bind-dynamic-domain-context							(defmethod %bind-dynamic-domain-context
    ((domain has-coefficient-domain) function)						    ((domain has-coefficient-domain) function)
  (let ((*coefficient-domain* (coefficient-domain-of domain)))				  (let ((*coefficient-domain* (coefficient-domain-of domain)))
    (call-next-method)))								    (call-next-method)))

(defclass module (abelian-group has-coefficient-domain)					(defclass module (abelian-group has-coefficient-domain)
     ())										  ())

(defsubst module? (domain) (typep domain 'module))					(defsubst module? (domain) (typep domain 'module))

										    >	(defgeneric characteristic (domain)
										    >	  (:documentation
										    >	   "The purpose of this method is not known."))
										    >
(defmethod characteristic ((domain module))						(defmethod characteristic ((domain module))
  (characteristic (coefficient-domain-of domain)))					  (characteristic (coefficient-domain-of domain)))

;; The coefficient domain of an algebra should be a SIMPLE-RING 			;; The coefficient domain of an algebra should be a SIMPLE-RING 
(defclass algebra (module semigroup)							(defclass algebra (module semigroup)
  ())											  ())

(defsubst algebra? (domain) (typep domain 'algebra))					(defsubst algebra? (domain) (typep domain 'algebra))

(defclass ring (algebra simple-ring)							(defclass ring (algebra simple-ring)
     ()											  ()
  ;; Also has the distributive law							  ;; Also has the distributive law
  )											  )

(defsubst ring? (domain) (typep domain 'ring))						(defsubst ring? (domain) (typep domain 'ring))

(defmethod-sd max-pair ((x domain-element) (y domain-element))				(defmethod-sd max-pair ((x domain-element) (y domain-element))
  (if (> x y) x y))									  (if (> x y) x y))

(defmethod-sd min-pair ((x domain-element) (y domain-element))				(defmethod-sd min-pair ((x domain-element) (y domain-element))
  (if (> x y) y x))									  (if (> x y) y x))


											(define-math-property integral-domain ())
(define-math-property integral-domain ())
											;; A GCD can be defined
;; A GCD can be defined									(define-math-property euclidean-domain (integral-domain))
(define-math-property euclidean-domain (integral-domain))
											;; A GCD algorithm exists
;; A GCD algorithm exists								(define-math-property gcd-domain (euclidean-domain))
(define-math-property gcd-domain (euclidean-domain))
											(defgeneric binary-gcd (x y))
(defgeneric binary-gcd (x y))
(defgeneric binary-lcm (x y))								(defgeneric binary-lcm (x y))

(define-math-property unique-factorization-domain (euclidean-domain))			(define-math-property unique-factorization-domain (euclidean-domain))

											;; Every field is an integral domain.
;; Every field is an integral domain.							(defclass field (ring)
(defclass field (ring)									  ())
  ())
											(defsubst field? (domain) (typep domain 'field))
(defsubst field? (domain) (typep domain 'field))
											(defmethod initialize-instance :after ((domain field) &rest plist)
(defmethod initialize-instance :after ((domain field) &rest plist)			  (declare (ignore plist))  
  (declare (ignore plist))  								  (assert-integral-domain domain))
  (assert-integral-domain domain))
											(define-operations field
(define-operations field								  (quotient (element self) (element self)) -> (element self)
  (quotient (element self) (element self)) -> (element self)				  (recip (element self)) -> (element self))
  (recip (element self)) -> (element self))
											(defclass finite-field (field finite-set)
(defclass finite-field (field finite-set)						  ())
  ())
											(defclass factor-domain (domain)
(defclass factor-domain (domain)						    (
     ((factor-numer :initarg :numerator						    |	  ((factor-numer
										    >	    :initarg :numerator
		    :accessor factor-numer-of)						    :accessor factor-numer-of)
      (factor-denom :initarg :denominator					    |	   (factor-denom
										    >	    :initarg :denominator
		    :accessor factor-denom-of)))					    :accessor factor-denom-of)))

										    >	(defgeneric factor-domain-print-object (domain stream))
										    >
(defmethod factor-domain-print-object (domain stream)					(defmethod factor-domain-print-object (domain stream)
  (format stream "~S/~S" (factor-numer-of domain) (factor-denom-of domain)))		  (format stream "~S/~S" (factor-numer-of domain) (factor-denom-of domain)))

(defmethod initialize-instance :after ((domain factor-domain) &rest plist)		(defmethod initialize-instance :after ((domain factor-domain) &rest plist)
  (declare (ignore plist))								  (declare (ignore plist))
  (with-slots (print-function) domain							  (with-slots (print-function) domain
    (setf print-function 'factor-domain-print-object)))					    (setf print-function 'factor-domain-print-object)))

(defclass factor-group (factor-domain group)						(defclass factor-group (factor-domain group)
     ())										  ())

(defclass factor-module (factor-domain module)						(defclass factor-module (factor-domain module)
     ())										  ())

(defclass factor-ring (factor-domain ring)						(defclass factor-ring (factor-domain ring)
     ())										  ())

(defclass algebraic-extension (ring)							(defclass algebraic-extension (ring)
     ())										  ())

(defclass simple-field-extension (algebraic-extension field)				(defclass simple-field-extension (algebraic-extension field)
     ())										  ())

;; A domain that has a dimension							;; A domain that has a dimension
(defclass dimensional-domain (domain)							(defclass dimensional-domain (domain)
     ((dimension :initform nil							    |	  ((dimension
										    >	    :initform nil
		 :initarg :dimension							    :initarg :dimension
		 :reader dimension-of)))						    :reader dimension-of)))

										    >	(defgeneric dimensions (domain))
										    >
;;;added following to conform to manual -- rsp						;;;added following to conform to manual -- rsp
(defmethod dimensions ((d dimensional-domain))						(defmethod dimensions ((d dimensional-domain))
  (list (dimension-of d)))								  (list (dimension-of d)))

(defclass free-module (module dimensional-domain)					(defclass free-module (module dimensional-domain)
  ())											  ())

(defsubst free-module? (domain) (typep domain 'free-module))				(defsubst free-module? (domain) (typep domain 'free-module))

(defclass vector-space (free-module)							(defclass vector-space (free-module)
     ()											  ()
  ;; Coefficient domain must be a field							  ;; Coefficient domain must be a field
  )											  )

(defsubst vector-space? (domain) (typep domain 'vector-space))				(defsubst vector-space? (domain) (typep domain 'vector-space))

(defclass projective-space (free-module)						(defclass projective-space (free-module)
	 ())										  ())

(defsubst projective-space? (domain) (typep domain 'projective-space))			(defsubst projective-space? (domain) (typep domain 'projective-space))

(defclass differential-ring (ring)							(defclass differential-ring (ring)
     ())										  ())

(defsubst differential-ring? (domain) (typep domain 'differential-ring))		(defsubst differential-ring? (domain) (typep domain 'differential-ring))

(define-operations differential-ring							(define-operations differential-ring
  (deriv (element self)) -> (element self))						  (deriv (element self)) -> (element self))

(defclass quotient-ring (domain)							(defclass quotient-ring (domain)
  ())											  ())

;; Quotient Fields									;; Quotient Fields

(defclass quotient-field (field)  							(defclass quotient-field (field)  
  ((ring :initform nil :initarg :ring							  ((ring :initform nil :initarg :ring
	 :reader QF-ring)									 :reader QF-ring)
   (zero :initform nil)									   (zero :initform nil)
   (one :initform nil)))								   (one :initform nil)))

(defmethod characteristic ((domain quotient-field))					(defmethod characteristic ((domain quotient-field))
  (characteristic (QF-ring domain)))							  (characteristic (QF-ring domain)))

;; The accessors here must not be numerator and denominator because			;; The accessors here must not be numerator and denominator because
;; sometimes the internal structure is not a domain element and we			;; sometimes the internal structure is not a domain element and we
;; actually want to get our hands on the internal structure.				;; actually want to get our hands on the internal structure.
;; NUMERATOR and DENOMINATOR always return domain elements.				;; NUMERATOR and DENOMINATOR always return domain elements.

(defclass quotient-element (domain-element)						(defclass quotient-element (domain-element)
  ((numerator :accessor qo-numerator							  ((numerator :accessor qo-numerator
	      :initarg :numerator)								      :initarg :numerator)
   (denominator :accessor qo-denominator						   (denominator :accessor qo-denominator
		:initarg :denominator)))								:initarg :denominator)))

#+Genera										#+Genera
(defmacro with-numerator-and-denominator						(defmacro with-numerator-and-denominator
    ((num denom) quotient-element &body body &environment env)				    ((num denom) quotient-element &body body &environment env)
  (scl:once-only (quotient-element &environment env)					  (scl:once-only (quotient-element &environment env)
    `(let ((,num (qo-numerator ,quotient-element))					    `(let ((,num (qo-numerator ,quotient-element))
	   (,denom (qo-denominator ,quotient-element)))						   (,denom (qo-denominator ,quotient-element)))
       ,@body)))									      ,@body)))

#-Genera										#-Genera
(defmacro with-numerator-and-denominator						(defmacro with-numerator-and-denominator
    ((num denom) quotient-element &body body)						    ((num denom) quotient-element &body body)
  `(let ((,num (qo-numerator ,quotient-element))					  `(let ((,num (qo-numerator ,quotient-element))
	 (,denom (qo-denominator ,quotient-element)))						 (,denom (qo-denominator ,quotient-element)))
     ,@body))										    ,@body))
											
;;; Concrete classes									;;; Concrete classes

;; Sets											;; Sets

(defclass mutable-set (set)								(defclass mutable-set (set)
     ()											  ()
  (:documentation "Sets built from this class can be modified"))			  (:documentation "Sets built from this class can be modified"))


(defclass finite-set (set)								(defclass finite-set (set)
  ())											  ())

(defclass set-element (domain-element)							(defclass set-element (domain-element)
  ((key :reader element-key								  ((key :reader element-key
	   :initarg :key)))								        :initarg :key)))

(defclass set-element1 (set-element)							(defclass set-element1 (set-element)
  ())											  ())

(defclass set-element2 (set-element)							(defclass set-element2 (set-element)
  ((value :accessor element-value							  ((value :accessor element-value
	     :initarg :value)))								          :initarg :value)))

(defclass set-elements-as-singletons (set)						(defclass set-elements-as-singletons (set)
  ())											  ())

(defclass set-elements-as-pairs (set)							(defclass set-elements-as-pairs (set)
  ())											  ())

(defclass set-with-element-list (finite-set has-equality)				(defclass set-with-element-list (finite-set has-equality)
     ((elements :accessor set-element-list					    |	  ((elements
										    >	    :accessor set-element-list
		:initform (list nil)							    :initform (list nil)
		:initarg :elements)))							    :initarg :elements)))

(defclass mutable-set-with-element-list (set-with-element-list mutable-set)		(defclass mutable-set-with-element-list (set-with-element-list mutable-set)
  ())											  ())

(defclass set-with-sorted-element-list (set-with-element-list has-comparison)		(defclass set-with-sorted-element-list (set-with-element-list has-comparison)
  ())											  ())

(defclass mutable-set-with-sorted-element-list						(defclass mutable-set-with-sorted-element-list
    (mutable-set-with-element-list has-comparison)					    (mutable-set-with-element-list has-comparison)
  ())											  ())

;; The intiable sets classes								;; The intiable sets classes

(defclass simple-set (mutable-set-with-element-list set-elements-as-singletons)		(defclass simple-set (mutable-set-with-element-list set-elements-as-singletons)
  ())											  ())

(defclass set-of-pairs (mutable-set-with-element-list set-elements-as-pairs)		(defclass set-of-pairs (mutable-set-with-element-list set-elements-as-pairs)
  ())											  ())

(defclass ordered-simple-set								(defclass ordered-simple-set
    (mutable-set-with-sorted-element-list set-elements-as-singletons)			    (mutable-set-with-sorted-element-list set-elements-as-singletons)
  ())											  ())

(defclass ordered-set-of-pairs								(defclass ordered-set-of-pairs
    (mutable-set-with-sorted-element-list set-elements-as-pairs) 			    (mutable-set-with-sorted-element-list set-elements-as-pairs) 
  ())											  ())

											
;; Numbers of all sorts									;; Numbers of all sorts

;; The following class is included in the numeric and					;; The following class is included in the numeric and
;; general-expression classes to minimize the number of different			;; general-expression classes to minimize the number of different
;; methods that have to be created.  In the general expression code,			;; methods that have to be created.  In the general expression code,
;; we usually want to treat numeric quantities the same as				;; we usually want to treat numeric quantities the same as
;; general-expressions.  So, instead of generating two different methods we dispat	;; general-expressions.  So, instead of generating two different methods we dispat

(defclass ge-or-numeric (domain-element) ())						(defclass ge-or-numeric (domain-element) ())

;; All numeric quantities are built from this class (including				;; All numeric quantities are built from this class (including
;; transcendental elements like e and pi when they exist).				;; transcendental elements like e and pi when they exist).
(defclass numeric (ge-or-numeric)							(defclass numeric (ge-or-numeric)
     ())										  ())

;; All domains that consist solely of numeric elements contain this class		;; All domains that consist solely of numeric elements contain this class
(defclass numeric-domain (domain)							(defclass numeric-domain (domain)
  ())											  ())

(defsubst number? (x)									(defsubst number? (x)
  (or (typep x 'cl:number)								  (or (typep x 'cl:number)
      (typep x 'numeric)))								      (typep x 'numeric)))

;; Rational integers									;; Rational integers

(defclass rational-integers (ring caching-zero-and-one numeric-domain)			(defclass rational-integers (ring caching-zero-and-one numeric-domain)
  ())											  ())

(defmethod characteristic ((domain rational-integers))					(defmethod characteristic ((domain rational-integers))
  0)											  0)

(defclass rational-integer (numeric)							(defclass rational-integer (numeric)
     ((value :initarg :value								  ((value :initarg :value
	     :reader integer-value)))							          :reader integer-value)))

;; Real numbers 									;; Real numbers 

(defclass real-numbers (field numeric-domain)						(defclass real-numbers (field numeric-domain)
     ())										  ())

(defmethod initialize-instance :after ((domain real-numbers) &rest plist)		(defmethod initialize-instance :after ((domain real-numbers) &rest plist)
  (declare (ignore plist))								  (declare (ignore plist))
  (assert-ordered-domain domain)							  (assert-ordered-domain domain)
  (assert-complete-set domain))								  (assert-complete-set domain))

(defmethod characteristic ((domain real-numbers))					(defmethod characteristic ((domain real-numbers))
  0)											  0)

(defclass real-number (numeric)								(defclass real-number (numeric)
     ())										  ())

(defclass floating-point-number (real-number)						(defclass floating-point-number (real-number)
     ((value :initarg :value								  ((value :initarg :value
	     :reader fp-value)))							          :reader fp-value)))

(defclass bigfloat (real-number)							(defclass bigfloat (real-number)
     ((mantissa :reader bigfloat-mantissa					    |	  ((mantissa
										    >	    :reader bigfloat-mantissa
		:initarg :mantissa)							    :initarg :mantissa)
      (exponent :reader bigfloat-exponent					    |	   (exponent
										    >	    :reader bigfloat-exponent
		:initarg :exponent)))							    :initarg :exponent)))


(defclass complex-numbers (algebraic-extension field numeric-domain)			(defclass complex-numbers (algebraic-extension field numeric-domain)
     ())										  ())

(defmethod initialize-instance :after ((domain complex-numbers) &rest plist)		(defmethod initialize-instance :after ((domain complex-numbers) &rest plist)
  (declare (ignore plist))								  (declare (ignore plist))
  (assert-complete-set domain))								  (assert-complete-set domain))

(defmethod characteristic ((domain complex-numbers))					(defmethod characteristic ((domain complex-numbers))
  0)											  0)

(defclass complex-number (numeric)							(defclass complex-number (numeric)
     ((real :initarg :realpart							    |	  ((real
										    >	    :initarg :realpart
	    :reader cn-realpart)							    :reader cn-realpart)
      (imag :initarg :imagpart							    |	   (imag
										    >	    :initarg :imagpart
	     :reader cn-imagpart)))							    :reader cn-imagpart)))

;;  Rational Numbers									;;  Rational Numbers

(defclass rational-numbers (field numeric-domain)					(defclass rational-numbers (field numeric-domain)
     ())										  ())

(defmethod initialize-instance :after ((domain rational-numbers) &rest plist)		(defmethod initialize-instance :after ((domain rational-numbers) &rest plist)
  (declare (ignore plist))								  (declare (ignore plist))
  (assert-ordered-domain domain))							  (assert-ordered-domain domain))

(defmethod characteristic ((domain rational-numbers))					(defmethod characteristic ((domain rational-numbers))
  0)											  0)

(defclass rational-number (quotient-element numeric)					(defclass rational-number (quotient-element numeric)
     ())										  ())

											;; Finite fields 
;; Finite fields 
											(defclass GFp (field numeric-domain)
(defclass GFp (field numeric-domain)						    (
     ((characteristic :initform 0						    |	  ((characteristic
										    >	    :initform 0
		      :initarg :characteristic						    :initarg :characteristic
		      :reader characteristic)))						    :reader characteristic)))

(defclass GFq (GFp)									(defclass GFq (GFp)
     ((degree :initarg :degree							    |	  ((degree
										    >	    :initarg :degree
	      :reader field-degree)))							    :reader field-degree)))

(defclass GFp-element (numeric)								(defclass GFp-element (numeric)
  ((value :reader gfp-value							    |	  ((value
										    >	    :reader gfp-value
	  :initarg :value)))								    :initarg :value)))

(defclass GF2^n (GFq)									(defclass GF2^n (GFq)
     ((reduction-table :initarg :reduction-table				    |	  ((reduction-table
										    >	    :initarg :reduction-table
		       :reader GFp-reduction-table)))					    :reader GFp-reduction-table)))

(defclass GFm (rng numeric-domain)							(defclass GFm (rng numeric-domain)
  ())											  ())

(defclass GFm-element (numeric)								(defclass GFm-element (numeric)
  ((value :initarg :value :reader value)						  ((value :initarg :value :reader value)
   (modulus :initarg :modulus :reader modulus)))					   (modulus :initarg :modulus :reader modulus)))
											
;; Polynomials										;; Polynomials

;; These are the pieces that are common to all polynomial domains and			;; These are the pieces that are common to all polynomial domains and
;; polynomial representations.								;; polynomial representations.
(defclass has-ring-variables ()								(defclass has-ring-variables ()
     ((variables :initform nil							    |	  ((variables
										    >	    :initform nil
		 :initarg :variables							    :initarg :variables
		 :reader ring-variables)))						    :reader ring-variables)))

(defclass polynomial-ring (ring module has-ring-variables)				(defclass polynomial-ring (ring module has-ring-variables)
  ())											  ())

;;FIXTHIS I don't think this is quite right.  I.e. Its not a GCD			;;FIXTHIS I don't think this is quite right.  I.e. Its not a GCD
;;domain for any coefficient domain.							;;domain for any coefficient domain.
(defmethod initialize-instance :after ((domain polynomial-ring) &rest plist)		(defmethod initialize-instance :after ((domain polynomial-ring) &rest plist)
  (declare (ignore plist))								  (declare (ignore plist))
  (assert-integral-domain domain))							  (assert-integral-domain domain))

;; Multivariate Polynomial rings need some structure to manage the their		;; Multivariate Polynomial rings need some structure to manage the their
;; variables.  This class provides hash tables and accessor methods of			;; variables.  This class provides hash tables and accessor methods of
;; this purpose.  This class is implementational.					;; this purpose.  This class is implementational.
(defclass variable-hash-table (has-ring-variables)  					(defclass variable-hash-table (has-ring-variables)  
  ((variable-hash-table :initform nil						    |	  ((variable-hash-table
										    >	    :initform nil
			:accessor variable-hash-table)					    :accessor variable-hash-table)
   (variable-table :initform nil						    |	   (variable-table
										    >	    :initform nil
		   :accessor variable-index-table)))					    :accessor variable-index-table)))

;; It is often useful to cache the values of zero and one since they are		;; It is often useful to cache the values of zero and one since they are
;; often needed.  Need to include the class domain here to make				;; often needed.  Need to include the class domain here to make
;; caching... more specific than just domain.						;; caching... more specific than just domain.
(defclass caching-zero-and-one (domain)							(defclass caching-zero-and-one (domain)
     ((zero)										  ((zero)
      (one)))										   (one)))

;; Multivariate polynomials								;; Multivariate polynomials

(defclass multivariate-polynomial-ring							(defclass multivariate-polynomial-ring
	  (polynomial-ring variable-hash-table caching-zero-and-one)			    (polynomial-ring variable-hash-table caching-zero-and-one)
  ())											  ())

											;; This is just the root of the polynomial structural type hierarchy.
;; This is just the root of the polynomial structural type hierarchy.			(defclass polynomial (domain-element)
(defclass polynomial (domain-element)							  ())
     ())
											;; The following are the two different representation that are used.
;; The following are the two different representation that are used.			;; An mpolynomial uses a recursive structure in the variables, while a
;; An mpolynomial uses a recursive structure in the variables, while a			;; epolynomial is an expanded representation that uses exponent vectors.
;; epolynomial is an expanded representation that uses exponent vectors.
											(defclass mpolynomial (polynomial)
(defclass mpolynomial (polynomial)						    (
  ((form :reader poly-form							    |	  ((form
										    >	    :reader poly-form
	 :initarg :form)))								    :initarg :form)))

(defclass epolynomial (polynomial has-comparison)  					(defclass epolynomial (polynomial has-comparison)  
  ((form :reader poly-form							    |	  ((form
										    >	    :reader poly-form
	 :initarg :form)))								    :initarg :form)))

;; Univariate polynomials								;; Univariate polynomials

(defclass upolynomial (polynomial)							(defclass upolynomial (polynomial)
  ((coef-list :reader poly-form							    |	  ((coef-list
										    >	    :reader poly-form
              :initarg :form)))								    :initarg :form)))

;; Power Series										;; Power Series

(defclass power-series-domain (has-coefficient-domain caching-zero-and-one)		(defclass power-series-domain (has-coefficient-domain caching-zero-and-one)
     ())										  ())

(defclass tpower-series-domain (power-series-domain)					(defclass tpower-series-domain (power-series-domain)
     ())										  ())

(defclass tpower-series-ring (ring has-ring-variables tpower-series-domain)		(defclass tpower-series-ring (ring has-ring-variables tpower-series-domain)
     ())										  ())

(defclass tpower-series-field (field has-ring-variables tpower-series-domain)		(defclass tpower-series-field (field has-ring-variables tpower-series-domain)
     ())										  ())

(defclass power-series (domain-element)							(defclass power-series (domain-element)
     ())										  ())

;; Elements of truncated power series domains.  valence, branch-order,			;; Elements of truncated power series domains.  valence, branch-order,
;; and order should always be LISP integers (for now), and coeffs			;; and order should always be LISP integers (for now), and coeffs
;; should be a LISP simple vector whose elements are elements of the			;; should be a LISP simple vector whose elements are elements of the
;; coefficient domain									;; coefficient domain
;;											;;
;; Here is an example illustrating the use of branch-order, valence and			;; Here is an example illustrating the use of branch-order, valence and
;; order.										;; order.
;; Consider the power series 1/x + 1 + x^1/2 + x + x^2 + ... .				;; Consider the power series 1/x + 1 + x^1/2 + x + x^2 + ... .
;; We first eliminate the fractional exponent "1/2" by putting u = x^1/2.		;; We first eliminate the fractional exponent "1/2" by putting u = x^1/2.
;; Now the series is u^-2 + 1 + u + u^2 + u^4 + ... with branch order 1/2.		;; Now the series is u^-2 + 1 + u + u^2 + u^4 + ... with branch order 1/2.
;; Now, we normalize the series by multiplying it with u^2.				;; Now, we normalize the series by multiplying it with u^2.
;; Now, we have 1 + u^2 + u^3 + u^4 + u^6 + ... with valence -2.			;; Now, we have 1 + u^2 + u^3 + u^4 + u^6 + ... with valence -2.
;; Finally, we truncate the series using order.						;; Finally, we truncate the series using order.
;;                                                     -- Sekhar 8/2/94.		;;                                                     -- Sekhar 8/2/94.

(defclass tpower-series (power-series)							(defclass tpower-series (power-series)
  ((valence :initform 0 :initarg :valence :reader valence)			    |	  ((valence
   (branch-order :initform 1 :initarg :branch-order :reader branch-order)	    |	    :initform 0
   (order :initform *positive-infinity* :initarg :order :reader order)		    |	    :initarg :valence
   (coeffs :initarg :coeffs :reader coeffs)))					    |	    :reader valence)
										    |	   (branch-order
										    >	    :initform 1
										    >	    :initarg :branch-order
										    >	    :reader branch-order)
										    >	   (order
										    >	    :initform *positive-infinity*
										    >	    :initarg :order
										    >	    :reader order)
										    >	   (coeffs
										    >	    :initarg :coeffs
										    >	    :reader coeffs)))

;; Rational functions									;; Rational functions

(defclass rational-function-field (quotient-field)  					(defclass rational-function-field (quotient-field)  
  ())											  ())

(defclass rational-function (quotient-element)						(defclass rational-function (quotient-element)
  ())											  ())

;; Morphisms										;; Morphisms

(defclass morphism ()									(defclass morphism ()
     ((domain :reader morphism-domain						    |	  ((domain
										    >	    :reader morphism-domain
	      :initarg :domain)								    :initarg :domain)
      (map :reader morphism-map							    |	   (map
										    >	    :reader morphism-map
	   :initarg :map)								    :initarg :map)
      (range :reader morphism-range						    |	   (range
	     :initarg :range))							    |	    :reader morphism-range
  )										    |	    :initarg :range)))

(defclass homomorphism (morphism)							(defclass homomorphism (morphism)
     ())										  ())

(defclass automorphism (homomorphism)							(defclass automorphism (homomorphism)
     ())										  ())

;; Differential domains									;; Differential domains

(defclass differential-polynomial-ring							(defclass differential-polynomial-ring
    (multivariate-polynomial-ring differential-ring)					    (multivariate-polynomial-ring differential-ring)
  ())											  ())

;; This is the base class of all ideals.  Recall that an ideal of a			;; This is the base class of all ideals.  Recall that an ideal of a
;; ring R is an R module.  The ring slot is included to indicate the			;; ring R is an R module.  The ring slot is included to indicate the
;; domain that the generators lie in.  The generators themselves are only 		;; domain that the generators lie in.  The generators themselves are only 
(defclass ideal (module)								(defclass ideal (module)
     ((ring :initarg :ring :reader ring-of)					    |	  ((ring
										    >	    :initarg :ring
										    >	    :reader ring-of)
      ;; The current list of generators							   ;; The current list of generators
      (generators :initform ()							    |	   (generators
										    >	    :initform ()
		  :initarg :generators							    :initarg :generators
		  :reader generators-of)))						    :reader generators-of)))

;; Ideals over principal ideal domains are instances of this class			;; Ideals over principal ideal domains are instances of this class
(defclass PID-ideal (ideal) ())								(defclass PID-ideal (ideal) ())

(defclass grobner-basis (ideal has-comparison)						(defclass grobner-basis (ideal has-comparison)
  (;; The exponent comparison function is managed by HAS-COMPARISON		    |	  ;; The exponent comparison function is managed by HAS-COMPARISON
										    |	  ((undones :initform ())
   (undones :initform ())							    <
   ;; A list of triples pairs (lt f g), lt(f)<=lt(g), of elements of			   ;; A list of triples pairs (lt f g), lt(f)<=lt(g), of elements of
   ;; GENERATORS such that if any pair is not in the list, its s-poly			   ;; GENERATORS such that if any pair is not in the list, its s-poly
   ;; is guaranteed to be writable as a linear combination of				   ;; is guaranteed to be writable as a linear combination of
   ;; GENERATORS, with smaller s-degs							   ;; GENERATORS, with smaller s-degs
   											   (reducibles :initform nil :accessor reducibles-of)
   (reducibles :initform nil :accessor reducibles-of)				    (
   (possibles :initform nil)							    |	   (possibles :initform nil)))
   ))										    <

;; Algebraic Extensions									;; Algebraic Extensions

(defclass algebraic-extension-ring 							(defclass algebraic-extension-ring 
     (algebraic-extension multivariate-polynomial-ring)					    (algebraic-extension multivariate-polynomial-ring)
     ())										  ())

(defclass algebraic-object (mpolynomial)						(defclass algebraic-object (mpolynomial)
     ())										  ())


;; Direct Sums										;; Direct Sums

;; These are the root classes.  Classes like DIRECT-SUM-SEMIGROUP are			;; These are the root classes.  Classes like DIRECT-SUM-SEMIGROUP are
;; created in the direct-sum.lisp file along with several support			;; created in the direct-sum.lisp file along with several support
;; methods.										;; methods.

(defclass direct-sum (tuple domain) ())							(defclass direct-sum (tuple domain) ())

(defclass direct-sum-element (tuple domain-element) ())					(defclass direct-sum-element (tuple domain-element) ())

											;; Vector Spaces
;; Vector Spaces
											(defclass free-module-element (tuple domain-element)
(defclass free-module-element (tuple domain-element)					  ())
     ())
											(defclass vector-space-element (free-module-element)
(defclass vector-space-element (free-module-element)					  ())
     ())
											;; This optimization is included because lisp vectors are used as
;; This optimization is included because lisp vectors are used as			;; exponents in the expanded polynomial representation.
;; exponents in the expanded polynomial representation.					(defclass lisp-vector-space (vector-space)
(defclass lisp-vector-space (vector-space)						  ())
  ())
											(defclass lisp-vector (vector-space-element)
(defclass lisp-vector (vector-space-element)						  ())
     ())
											;; Projective spaces
;; Projective spaces
											(defclass projective-space-element (vector-space-element)
(defclass projective-space-element (vector-space-element)				  ())
     ())
											;; Matrices
;; Matrices
											;; This is is the domain of all matrices over a given ring.
;; This is is the domain of all matrices over a given ring.				(defclass matrix-space (module) ())
(defclass matrix-space (module) ())
											(defclass real-matrix-space (matrix-space) ())
(defclass real-matrix-space (matrix-space) ())
(defclass complex-matrix-space (matrix-space) ())					(defclass complex-matrix-space (matrix-space) ())

(defclass GL-n (group has-coefficient-domain dimensional-domain) 			(defclass GL-n (group has-coefficient-domain dimensional-domain) 
     ()											  ()
  (:documentation "General linear group"))						  (:documentation "General linear group"))

(defclass PSL-n (GL-n)									(defclass PSL-n (GL-n)
     ())										  ())

(defclass SL-n (PSL-n)									(defclass SL-n (PSL-n)
     ())										  ())

(defclass O-n (GL-n)									(defclass O-n (GL-n)
     ())										  ())

(defclass SO-n (O-n)									(defclass SO-n (O-n)
     ())										  ())

(defclass matrix-element (domain-element)						(defclass matrix-element (domain-element)
     ((value :initarg :value							    |	  ((value
										    >	    :initarg :value
	     :reader matrix-value)))							    :reader matrix-value)))

(defclass matrix-space-element (matrix-element)						(defclass matrix-space-element (matrix-element)
     ((dimension1 :initarg :dimension1)							  ((dimension1 :initarg :dimension1)
      (dimension2 :initarg :dimension2)))						   (dimension2 :initarg :dimension2)))

;; These two classes are for efficiency							;; These two classes are for efficiency
(defclass real-matrix-space-element (matrix-space-element) ())				(defclass real-matrix-space-element (matrix-space-element) ())
(defclass complex-matrix-space-element (matrix-space-element) ())
											(defclass complex-matrix-space-element (matrix-space-element) ())
(defclass GL-n-element (matrix-element)
     ())										(defclass GL-n-element (matrix-element)
											  ())
(defclass PSL-n-element (GL-n-element)
     ())										(defclass PSL-n-element (GL-n-element)
											  ())
(defclass SL-n-element (PSL-n-element)
     ())										(defclass SL-n-element (PSL-n-element)
											  ())
(defclass O-n-element (GL-n-element)
     ())										(defclass O-n-element (GL-n-element)
											  ())
(defclass SO-n-element (O-n-element)
     ())										(defclass SO-n-element (O-n-element)
											  ())
;; Quaternions
											;; Quaternions
(defclass quaternion-domain (vector-space algebra)
     ()											(defclass quaternion-domain (vector-space algebra)
  (:documentation "algebra of quaternions"))						  ()
											  (:documentation "algebra of quaternions"))
(define-operations quaternion-domain
  (conjugate (element self)) ->(element self))						(define-operations quaternion-domain
											  (conjugate (element self)) ->(element self))
(defclass unit-quaternion-domain
     (group dimensional-domain has-coefficient-domain)					(defclass unit-quaternion-domain
     ()											    (group dimensional-domain has-coefficient-domain)
  (:documentation "group of unit quaternions"))						  ()
											  (:documentation "group of unit quaternions"))
(defclass quaternion-with-multiplication ()
     ())										(defclass quaternion-with-multiplication ()
											  ())
(defclass quaternion-domain-element
     (quaternion-with-multiplication vector-space-element)				(defclass quaternion-domain-element
     ())										    (quaternion-with-multiplication vector-space-element)
(defclass unit-quaternion-domain-element						  ())
     (quaternion-with-multiplication tuple domain-element)
     ())										(defclass unit-quaternion-domain-element
											    (quaternion-with-multiplication tuple domain-element)
										    )	  ())
;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-		;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-
;;; ===========================================================================		;;; ===========================================================================
;;;				  Finite Algebraic Extension				;;;				  Finite Algebraic Extension
;;; ===========================================================================		;;; ===========================================================================
;;; (c) Copyright 1989, 1993 Cornell University						;;; (c) Copyright 1989, 1993 Cornell University

;; algebraic-extension.lisp,v 1.5 1994/10/04 22:30:39 rz Exp				;; algebraic-extension.lisp,v 1.5 1994/10/04 22:30:39 rz Exp

(in-package "WEYLI")								    |	(in-package :weyli)

(make::adjust-version-numbers Weyl "1.5")					    |	;;; DELETE (make::adjust-version-numbers Weyl "1.5")

(define-domain-creator factor-ring ((ring ring) (ideal ideal))			    |	(eval-when (:compile-toplevel :load-toplevel)
										    >	  (define-domain-creator factor-ring ((ring ring) (ideal ideal))
  (cond ((eql (ring-of ideal) ring)							    (cond ((eql (ring-of ideal) ring)
	 (make-instance 'factor-ring :numerator ring :denominator ideal))		           (make-instance 'factor-ring :numerator ring :denominator ideal))
	(t (error "Don't know how to compute ~S/~S" ring ideal)))			          (t (error "Don't know how to compute ~S/~S" ring ideal)))
  :predicate										    :predicate
  #'(lambda (d)										    #'(lambda (d)
      (and (typep d 'factor-ring)							        (and (typep d 'factor-ring)
	   (eql (factor-numer-of d) ring)						             (eql (factor-numer-of d) ring)
	   (= (factor-denom-of d) ideal))))					    |	             (= (factor-denom-of d) ideal)))))

(define-domain-creator algebraic-extension					    |	(eval-when (:compile-toplevel :load-toplevel)
										    >	  (define-domain-creator algebraic-extension
    ((coefficient-domain ring) variables)						      ((coefficient-domain ring) variables)
  (progn										    (progn
    (unless (integral-domain? coefficient-domain)					      (unless (integral-domain? coefficient-domain)
      (error "Can only create algebraic extensions of integral domains: ~S"		        (error "Can only create algebraic extensions of integral domains: ~S"
	     coefficient-domain))							               coefficient-domain))
    (let ((domain									      (let ((domain
	    (make-instance 'algebraic-extension-ring					             (make-instance 'algebraic-extension-ring
			   :variables (loop for var in variables			                            :variables (loop for var in variables
					    collect (coerce var *general*))		                                             collect (coerce var *general*))
			   :coefficient-domain coefficient-domain)))			                            :coefficient-domain coefficient-domain)))
      (make-homomorphism coefficient-domain						        (make-homomorphism coefficient-domain
			 #'(lambda (c) (make-polynomial domain c))			                           #'(lambda (c) (make-polynomial domain c))
			 domain)							                           domain)
      domain))										        domain))
  :predicate										    :predicate
  #'(lambda (d);; FIXTHIS: the predicate needs to be improved			    |	    #'(lambda (d) ;; FIXTHIS: the predicate needs to be improved
      (and (typep d 'algebraic-extension-ring)						        (and (typep d 'algebraic-extension-ring)
	   (eql (coefficient-domain-of d) coefficient-domain)				             (eql (coefficient-domain-of d) coefficient-domain)
	   (equal (ring-variables d) variables))))				    |	             (equal (ring-variables d) variables)))))

;; Use the polynomial print-object method for now					;; Use the polynomial print-object method for now

;; This returns the term list for the minimal polynomial of the main			;; This returns the term list for the minimal polynomial of the main
;; variable of the polynomial.  This polynomial is expected to be monic.		;; variable of the polynomial.  This polynomial is expected to be monic.
(defmacro variable-minimal-polynomial (domain var)					(defmacro variable-minimal-polynomial (domain var)
  `(get-variable-number-property ,domain (poly-order-number ,var)			  `(get-variable-number-property ,domain (poly-order-number ,var)
				 :minimal-polynomial))									 :minimal-polynomial))
										    >
										    >	(defgeneric minimal-polynomial (domain variable)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))

(defmethod minimal-polynomial ((domain algebraic-extension-ring) variable)  		(defmethod minimal-polynomial ((domain algebraic-extension-ring) variable)  
  (with-slots (variables) domain							  (with-slots (variables) domain
    (unless (member variable variables :test #'ge-equal)				    (unless (member variable variables :test #'ge-equal)
      (error "~'i~A~ is not a variable of ~S" variable domain)))			      (error "~'i~A~ is not a variable of ~S" variable domain)))
  (get-variable-number-property domain (variable-index domain variable)			  (get-variable-number-property domain (variable-index domain variable)
				:minimal-polynomial))									:minimal-polynomial))

(defmethod minimal-polynomial								(defmethod minimal-polynomial
    ((domain algebraic-extension-ring) (variable integer))  				    ((domain algebraic-extension-ring) (variable integer))  
  (get-variable-number-property domain variable :minimal-polynomial))			  (get-variable-number-property domain variable :minimal-polynomial))

(defmethod set-minimal-polynomial							(defmethod set-minimal-polynomial
	   ((domain algebraic-extension-ring) variable minimal-polynomial)			   ((domain algebraic-extension-ring) variable minimal-polynomial)
  (setq variable (coerce variable *general*))						  (setq variable (coerce variable *general*))
  (with-slots (variables) domain    							  (with-slots (variables) domain    
    (unless (member variable variables :test #'ge-equal)				    (unless (member variable variables :test #'ge-equal)
      (error "~'i~A~ is not a variable of ~S" variable domain)))			      (error "~'i~A~ is not a variable of ~S" variable domain)))
  (unless (eql (domain-of minimal-polynomial) domain)					  (unless (eql (domain-of minimal-polynomial) domain)
    (error "The algebraic relation ~S is not an element of ~S" 				    (error "The algebraic relation ~S is not an element of ~S" 
	   minimal-polynomial domain))								   minimal-polynomial domain))
  (let ((poly-form (poly-form minimal-polynomial))					  (let ((poly-form (poly-form minimal-polynomial))
	(var-index (variable-index domain variable)))						(var-index (variable-index domain variable)))
    (unless (= var-index (poly-order-number poly-form))					    (unless (= var-index (poly-order-number poly-form))
      (error "~S is not the most main variable of ~S"					      (error "~S is not the most main variable of ~S"
	     (with-output-to-string (string)							     (with-output-to-string (string)
	       (display variable string))							       (display variable string))
	       minimal-polynomial))								       minimal-polynomial))
    (setf (get-variable-number-property domain var-index :minimal-polynomial)		    (setf (get-variable-number-property domain var-index :minimal-polynomial)
	  (poly-terms poly-form))))								  (poly-terms poly-form))))

(defsetf minimal-polynomial set-minimal-polynomial)					(defsetf minimal-polynomial set-minimal-polynomial)

(defmethod make-polynomial ((domain algebraic-extension-ring) form)			(defmethod make-polynomial ((domain algebraic-extension-ring) form)
  (make-instance 'algebraic-object :domain domain :form form))				  (make-instance 'algebraic-object :domain domain :form form))

(defmethod-sd times ((x algebraic-object) (y algebraic-object))				(defmethod-sd times ((x algebraic-object) (y algebraic-object))
  (bind-domain-context domain								  (bind-domain-context domain
    (make-polynomial domain (alg-poly-times (poly-form x) (poly-form y)))))		    (make-polynomial domain (alg-poly-times (poly-form x) (poly-form y)))))

(defun alg-poly-times (x y)								(defun alg-poly-times (x y)
  (cond ((poly-coef? x)									  (cond ((poly-coef? x)
	 (if (poly-coef? y) (* x y)								 (if (poly-coef? y) (* x y)
	     (poly-simp y (terms-mon-times (poly-terms y) (e0) x))))				     (poly-simp y (terms-mon-times (poly-terms y) (e0) x))))
	((poly-coef? y)										((poly-coef? y)
	 (poly-simp x (terms-mon-times (poly-terms x) (e0) y)))					 (poly-simp x (terms-mon-times (poly-terms x) (e0) y)))
	((same-variable? x y)									((same-variable? x y)
	 (let ((min-poly (minimal-polynomial *domain* (poly-order-number x))))			 (let ((min-poly (minimal-polynomial *domain* (poly-order-number x))))
	   (poly-simp x (if min-poly								   (poly-simp x (if min-poly
			    (terms-pseudo-remainder								    (terms-pseudo-remainder
			     (terms-times (poly-terms x) (poly-terms y))					     (terms-times (poly-terms x) (poly-terms y))
			     min-poly)										     min-poly)
			    (terms-times (poly-terms x) (poly-terms y))))))					    (terms-times (poly-terms x) (poly-terms y))))))
	((more-main? x y)									((more-main? x y)
	 (poly-simp x (terms-mon-times (poly-terms x) (e0) y)))					 (poly-simp x (terms-mon-times (poly-terms x) (e0) y)))
	(t (poly-simp y (terms-mon-times (poly-terms y) (e0) x)))))				(t (poly-simp y (terms-mon-times (poly-terms y) (e0) x)))))

(defmethod expt ((base algebraic-object) (expt integer))				(defmethod expt ((base algebraic-object) (expt integer))
  (let ((domain (domain-of base)))							  (let ((domain (domain-of base)))
    (bind-domain-context domain								    (bind-domain-context domain
      (make-polynomial domain								      (make-polynomial domain
		       (%funcall (repeated-squaring #'alg-poly-times					       (%funcall (repeated-squaring #'alg-poly-times
							(one *coefficient-domain*)								(one *coefficient-domain*)
				     (poly-form base) expt)))))								     (poly-form base) expt)))))
;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-		;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-
;;; ===========================================================================		;;; ===========================================================================
;;;				    AVL trees						;;;				    AVL trees
;;; ===========================================================================		;;; ===========================================================================
;;; (c) Copyright 1989, 1993 Cornell University						;;; (c) Copyright 1989, 1993 Cornell University

;;; avl.lisp,v 1.6 1994/10/24 14:23:30 rz Exp						;;; avl.lisp,v 1.6 1994/10/24 14:23:30 rz Exp

(in-package "WEYLI")								    |	(in-package :weyli)

(make::adjust-version-numbers Weyl "1.6")					    |	;;; DELETE (make::adjust-version-numbers Weyl "1.6")

;; FIXTHIS:  This is a stupid place for this code					;; FIXTHIS:  This is a stupid place for this code

(defmacro choose (seq (var n . options) &body body)					(defmacro choose (seq (var n . options) &body body)
  (cond ((%getf options :allow-repeats)							  (cond ((%getf options :allow-repeats)
	 `(%choose-repeats ,seq ,n #'(lambda (,var) ,@body)))					 `(%choose-repeats ,seq ,n #'(lambda (,var) ,@body)))
	(t `(%choose ,seq ,n #'(lambda (,var) ,@body)))))					(t `(%choose ,seq ,n #'(lambda (,var) ,@body)))))

										    >	(defgeneric %choose (variables number function)
										    >	  (:documentation
										    >	   "The purpose of this method is unknown."))
										    >
(defmethod %choose ((vars list) n fn)							(defmethod %choose ((vars list) n fn)
  (unless (or (null n) (cl:integerp n))							  (unless (or (null n) (cl:integerp n))
    (error "Invalid count argument to CHOOSE: ~D" n))					    (error "Invalid count argument to CHOOSE: ~D" n))
  (labels ((pick (vars n so-far)							  (labels ((pick (vars n so-far)
	     (declare (fixnum n))								     (declare (fixnum n))
	     (cond ((cl:zerop n)								     (cond ((cl:zerop n)
		    (%funcall fn so-far))								    (%funcall fn so-far))
		   (t (pick (rest vars) (cl:1- n) (cons (first vars) so-far))				   (t (pick (rest vars) (cl:1- n) (cons (first vars) so-far))
		      (if (> (length vars) n)								      (if (> (length vars) n)
			  (pick (rest vars) n so-far)))))							  (pick (rest vars) n so-far)))))
	   (pick-null (vars so-far)								   (pick-null (vars so-far)
	     (when vars										     (when vars
	       (let ((new-so-far (cons (first vars) so-far)))					       (let ((new-so-far (cons (first vars) so-far)))
 	         (%funcall fn new-so-far)						 	         (%funcall fn new-so-far)
		 (pick-null (rest vars) new-so-far)							 (pick-null (rest vars) new-so-far)
		 (when (rest vars)									 (when (rest vars)
		   (pick-null (rest vars) so-far))))))							   (pick-null (rest vars) so-far))))))
    (let ((len (length vars)))								    (let ((len (length vars)))
      (declare (fixnum len))								      (declare (fixnum len))
      (cond ((null n)									      (cond ((null n)
	     (%funcall fn nil)									     (%funcall fn nil)
	     (pick-null vars ()))								     (pick-null vars ()))
	    ((cl:> n len)									    ((cl:> n len)
	     (error "Not that many elements in vars"))						     (error "Not that many elements in vars"))
	    ((or (cl:= n len) (cl:zerop len))							    ((or (cl:= n len) (cl:zerop len))
	     (%funcall fn vars))								     (%funcall fn vars))
	    ((cl:minusp n)									    ((cl:minusp n)
	     (pick vars (cl:+ len n) ()))	   						     (pick vars (cl:+ len n) ()))	   
	    (t (pick vars n ()))))))								    (t (pick vars n ()))))))

										    >	(defgeneric %choose-repeats (variables number function)
										    >	  (:documentation
										    >	   "The purpose of this method is unknown."))
										    >
(defmethod %choose-repeats ((vars list) n fn)						(defmethod %choose-repeats ((vars list) n fn)
  (unless (or (null n) (cl:integerp n))							  (unless (or (null n) (cl:integerp n))
    (error "Invalid count argument to CHOOSE: ~D" n))					    (error "Invalid count argument to CHOOSE: ~D" n))
  (labels ((pick (vars n so-far)							  (labels ((pick (vars n so-far)
	     (declare (fixnum n))								     (declare (fixnum n))
	     (cond ((cl:zerop n)								     (cond ((cl:zerop n)
		    (%funcall fn so-far))								    (%funcall fn so-far))
		   (t (loop while vars do								   (t (loop while vars do
		     (pick vars (cl:1- n) (cons (first vars) so-far))			                            (pick vars (cl:1- n) (cons (first vars) so-far))
		     (setq vars (rest vars)))))))					                            (setq vars (rest vars)))))))
    (let ((len (length vars)))								    (let ((len (length vars)))
      (declare (fixnum len))								      (declare (fixnum len))
      (cond ((cl:> n len)								      (cond ((cl:> n len)
	     (error "Not that many elements in vars"))						     (error "Not that many elements in vars"))
	    ((cl:minusp n)									    ((cl:minusp n)
	     (pick vars (cl:+ len n) ()))	   						     (pick vars (cl:+ len n) ()))	   
	    (t (pick vars n ()))))))								    (t (pick vars n ()))))))

;; FIXTHIS: At some point put in code for even and odd permutations.			;; FIXTHIS: At some point put in code for even and odd permutations.
(defmacro permute (seq (var . options) &body body)					(defmacro permute (seq (var . options) &body body)
  (declare (ignore options))								  (declare (ignore options))
  `(permute% ,seq #'(lambda (,var) ,@body)))						  `(permute% ,seq #'(lambda (,var) ,@body)))

										    >	(defgeneric permute% (sequence function)
										    >	  (:documentation
										    >	   "The purpose of this method is unknown."))
										    >
(defmethod permute% ((seq list) fun)							(defmethod permute% ((seq list) fun)
  (labels ((pick (vars so-far)								  (labels ((pick (vars so-far)
	     (cond ((null vars) (%funcall fun so-far))						     (cond ((null vars) (%funcall fun so-far))
		   (t (loop for v in vars								   (t (loop for v in vars
			    do (pick (remove v vars) (cons v so-far)))))))					    do (pick (remove v vars) (cons v so-far)))))))
    (pick seq nil)))									    (pick seq nil)))

(defun %partition1 (n fun)								(defun %partition1 (n fun)
  (labels ((part-int (n min list) 							  (labels ((part-int (n min list) 
             (declare (type fixnum n))							             (declare (type fixnum n))
             (cond ((cl:zerop n) (funcall fun list))					             (cond ((cl:zerop n) (funcall fun list))
                   (t (loop for i fixnum upfrom min below (cl:+ 1 n)			                   (t (loop for i fixnum upfrom min below (cl:+ 1 n)
                            do (part-int (cl:- n i) i (cons i list)))))))		                            do (part-int (cl:- n i) i (cons i list)))))))
    (part-int n 1 nil)									    (part-int n 1 nil)
    (values)))										    (values)))

;; N is the number to be partitioned, FUN is the function to apply to			;; N is the number to be partitioned, FUN is the function to apply to
;; the partition.									;; the partition.

;; NUM-PARTS is the number of parts to be used in the partitioning.			;; NUM-PARTS is the number of parts to be used in the partitioning.
;; If negative, then any number of parts can be used.					;; If negative, then any number of parts can be used.
;; MAXIMUM-PART is the maximum size of any component in the partition. 			;; MAXIMUM-PART is the maximum size of any component in the partition. 

(defun %partition2 (n fun num-parts minimum-part maximum-part distinct?)		(defun %partition2 (n fun num-parts minimum-part maximum-part distinct?)
  (labels ((part-int (n min parts list)							  (labels ((part-int (n min parts list)
	     (declare (fixnum n parts))								     (declare (fixnum n parts))
             (cond ((cl:zerop n)							             (cond ((cl:zerop n)
		    (if (not (cl:plusp parts)) (funcall fun list)))					    (if (not (cl:plusp parts)) (funcall fun list)))
		   ((or (cl:minusp n) (cl:zerop parts)))						   ((or (cl:minusp n) (cl:zerop parts)))
                   (t (loop for i fixnum upfrom min below maximum-part			                   (t (loop for i fixnum upfrom min below maximum-part
                            do (part-int (cl:- n i)					                            do (part-int (cl:- n i)
					 (if distinct? (cl:1+ i) i)								 (if distinct? (cl:1+ i) i)
					 (cl:-  parts 1)									 (cl:-  parts 1)
                                         (cons i list)))))))				                                         (cons i list)))))))
    (part-int n minimum-part num-parts nil)						    (part-int n minimum-part num-parts nil)
    (values)))										    (values)))

(defmacro partition ((var n . options) &body body)					(defmacro partition ((var n . options) &body body)
  (let ((num-parts (or (getf options :number-of-parts) -1))				  (let ((num-parts (or (getf options :number-of-parts) -1))
	(minimum-part (or (getf options :minimum-part) 1))					(minimum-part (or (getf options :minimum-part) 1))
	(maximum-part `(cl:1+ ,(or (getf options :maximum-part) '.number.))))			(maximum-part `(cl:1+ ,(or (getf options :maximum-part) '.number.))))
    (loop for (keyword nil) on options by #'cddr					    (loop for (keyword nil) on options by #'cddr
	  with bad-keywords									  with bad-keywords
	  do (unless (member keyword								  do (unless (member keyword
			     '( :number-of-parts :minimum-part :maximum-part					     '( :number-of-parts :minimum-part :maximum-part
			       :distinct?))									       :distinct?))
	       (push keyword bad-keywords))							       (push keyword bad-keywords))
	  finally (when bad-keywords								  finally (when bad-keywords
		    (error "Invalid options to partition: ~S"						    (error "Invalid options to partition: ~S"
			   bad-keywords)))									   bad-keywords)))
    (cond ((and (null num-parts)							    (cond ((and (null num-parts)
		(null maximum-part))									(null maximum-part))
           `(%partition1 ,n #'(lambda (,var) ,@body)))					           `(%partition1 ,n #'(lambda (,var) ,@body)))
          (t `(let ((.number. ,n))							          (t `(let ((.number. ,n))
		(%partition2 .number. #'(lambda (,var) ,@body)				               (%partition2 .number. #'(lambda (,var) ,@body)
			     ,num-parts ,minimum-part ,maximum-part			                ,num-parts ,minimum-part ,maximum-part
			     ,(getf options :distinct?)))))))				                ,(getf options :distinct?)))))))

#| Partition Demonstation routines |							#| Partition Demonstation routines |
(defun part-count (n)									(defun part-count (n)
  (let ((cnt 0))									  (let ((cnt 0))
    (partition (l n)									    (partition (l n)
      (declare (ignore l))								      (declare (ignore l))
      (incf cnt))									      (incf cnt))
    cnt))										    cnt))
||#											||#

(defmacro map-over-tree (node (root . options) &body body)				(defmacro map-over-tree (node (root . options) &body body)
  (let ((collection-fun (or (%getf options :collection-fun) 'identity))			  (let ((collection-fun (or (%getf options :collection-fun) 'identity))
	(breadth-first? (%getf options :breadth-first?))					(breadth-first? (%getf options :breadth-first?))
	(depth-first? (%getf options :depth-first?)))						(depth-first? (%getf options :depth-first?)))
    (when (and breadth-first? depth-first?)						    (when (and breadth-first? depth-first?)
      (error "Can't specify both breadth and depth first in MAP-OVER-TREE"))		      (error "Can't specify both breadth and depth first in MAP-OVER-TREE"))
    (cond (breadth-first?								    (cond (breadth-first?
	   `(let ((.collections. (list ,root))							   `(let ((.collections. (list ,root))
		  .temp. .new-collections.)								  .temp. .new-collections.)
	      (loop while .collections. do						             (loop while .collections. do
		(loop for ,node in .collections. do					              (loop for ,node in .collections. do
		  (macrolet ((terminate-branch ()					               (macrolet ((terminate-branch ()
			       `(return-from .mapper.block. nil)))			                            `(return-from .mapper.block. nil)))
		    (block .mapper.block.						                 (block .mapper.block.
		      ,@body								                   ,@body
		      (when (cl:listp (setq .temp. (,collection-fun ,node)))		                   (when (cl:listp (setq .temp. (,collection-fun ,node)))
			(setq .new-collections.						                     (setq .new-collections.
			      (nconc .new-collections. (copy-list .temp.)))))))		                           (nconc .new-collections. (copy-list .temp.)))))))
		(setq .collections. .new-collections.)					              (setq .collections. .new-collections.)
		(setq .new-collections. nil))))						              (setq .new-collections. nil))))
	  (depth-first?										  (depth-first?
	   `(labels ((mapper.fn (,node)								   `(labels ((mapper.fn (,node)
		       (macrolet ((terminate-branch ()					                      (macrolet ((terminate-branch ()
				    `(return-from .mapper.block. nil)))			                                   `(return-from .mapper.block. nil)))
			 (block .mapper.block.						                        (block .mapper.block.
			   ,@body							                          ,@body
			   (let ((.collection. (,collection-fun ,node)))		                          (let ((.collection. (,collection-fun ,node)))
			     (when (cl:listp .collection.) 				                            (when (cl:listp .collection.) 
			       (loop for .node. in .collection.				                              (loop for .node. in .collection.
				     do (mapper.fn .node.))))))))			                                    do (mapper.fn .node.))))))))
	      (mapper.fn ,root)))							             (mapper.fn ,root)))
	  (t (error "Must specify either breadth or depth first in MAP-OVER-TREE")		  (t (error "Must specify either breadth or depth first in MAP-OVER-TREE")
											
;; Need to do the non-mutating version also.  I think this can be done			;; Need to do the non-mutating version also.  I think this can be done
;; by just changin update-node...							;; by just changin update-node...

;; This code comes is derived from code that was originally written by			;; This code comes is derived from code that was originally written by
;; Bruce Donald.									;; Bruce Donald.

;; AVL trees										;; AVL trees

(defclass avl-tree (has-comparison)							(defclass avl-tree (has-comparison)
  ((root :initform nil								    |	  ((root
										    >	    :initform nil
	 :accessor avl-root)))								    :accessor avl-root)))

(defclass avl-node (set-element)							(defclass avl-node (set-element)
     ((left :initform nil :initarg :left :accessor avl-left)			    |	  ((left
      (right :initform nil :initarg :right :accessor avl-right)			    |	    :initform nil
      (balance :initform 0 :initarg balance :accessor avl-balance)))		    |	    :initarg :left
										    >	    :accessor avl-left)
										    >	   (right
										    >	    :initform nil
										    >	    :initarg :right
										    >	    :accessor avl-right)
										    >	   (balance
										    >	    :initform 0
										    >	    :initarg balance
										    >	    :accessor avl-balance)))

(defclass avl-tree-elements-as-singletons (set-elements-as-singletons)			(defclass avl-tree-elements-as-singletons (set-elements-as-singletons)
     ())										  ())

(defclass avl-node-as-pairs (set-element2 avl-node)					(defclass avl-node-as-pairs (set-element2 avl-node)
     ())										  ())

(defclass avl-tree-elements-as-pairs (set-elements-as-pairs)				(defclass avl-tree-elements-as-pairs (set-elements-as-pairs)
     ())										  ())

(defclass simple-avl-tree (avl-tree avl-tree-elements-as-singletons)			(defclass simple-avl-tree (avl-tree avl-tree-elements-as-singletons)
     ())										  ())

(defclass avl-tree-of-pairs (avl-tree avl-tree-elements-as-pairs)			(defclass avl-tree-of-pairs (avl-tree avl-tree-elements-as-pairs)
     ())										  ())

										    >	(defgeneric avl-size (tree)
										    >	  (:documentation
										    >	   "Return the size of the avl-tree."))
										    >
										    >	(defmethod avl-size ((tree avl-tree))
										    >	  (let ((root (avl-root tree)))
										    >	    (if root (avl-size root)
										    >		0)))
										    >
										    >	(defmethod avl-size ((node avl-node))
										    >	  (let ((left (avl-left node))
										    >		(right (avl-right node)))
										    >	    (1+ (cl:+ (if left (avl-size left) 0)
										    >	              (if right (avl-size right) 0)))))
										    >
(defmethod print-object ((tree avl-tree) stream)					(defmethod print-object ((tree avl-tree) stream)
  (format stream "#<AVL tree: ~D elts>" (avl-size tree)))				  (format stream "#<AVL tree: ~D elts>" (avl-size tree)))

(defmethod print-object ((node avl-node) stream)					(defmethod print-object ((node avl-node) stream)
  (format stream "<AVL~[-~;=~;+~]: ~S>"							  (format stream "<AVL~[-~;=~;+~]: ~S>"
	  (1+ (avl-balance node)) (element-key node)))						  (1+ (avl-balance node)) (element-key node)))

#+ignore ;; This is for debugging						    |	;;; This is for debugging
										    >	#+ignore
(defmethod pretty-print-object ((node avl-node) &optional (stream *standard-output	(defmethod pretty-print-object ((node avl-node) &optional (stream *standard-output
  (labels ((indent (n)									  (labels ((indent (n)
	     (loop for i below n do (princ " " stream)))					     (loop for i below n do (princ " " stream)))
	   (pp (node indent)									   (pp (node indent)
	     (when (avl-left node)								     (when (avl-left node)
	       (indent indent)									       (indent indent)
	       (format stream  "L: ~S~%" (avl-left node))					       (format stream  "L: ~S~%" (avl-left node))
	       (pp (avl-left node) (cl:+ 2 indent)))						       (pp (avl-left node) (cl:+ 2 indent)))
	     (when (avl-right node)								     (when (avl-right node)
	       (indent indent)									       (indent indent)
	       (format stream  "R: ~S~%" (avl-right node))					       (format stream  "R: ~S~%" (avl-right node))
	       (pp (avl-right node) (cl:+ 2 indent)))))						       (pp (avl-right node) (cl:+ 2 indent)))))
    (format stream "~&Root: ~S~%" node)							    (format stream "~&Root: ~S~%" node)
    (pp node 2)))									    (pp node 2)))

;; This is used to update a node with new information since we don't		    |	(defgeneric update-node (node balance left right &rest args)
;; know all the information that could be stored in a node we've assumed	    |	  (:documentation
;; they can all be lumped into args. 						    |	   "This is used to pudate a node with new information since we don't
										    >	know all the information that could be stored in a node we've assumed
										    >	they can all be lumped into args."))
										    >
(defmethod update-node ((node avl-node) balance left right &rest args)			(defmethod update-node ((node avl-node) balance left right &rest args)
  (declare (ignore args))								  (declare (ignore args))
  (setf (avl-balance node) balance)							  (setf (avl-balance node) balance)
  (setf (avl-left node) left)								  (setf (avl-left node) left)
  (setf (avl-right node) right)								  (setf (avl-right node) right)
  node)											  node)

(defmethod avl-size ((tree avl-tree))						    |	(defgeneric empty? (tree)
  (let ((root (avl-root tree)))							    |	  (:documentation
    (if root (avl-size root)							    |	   "Return true if the tree is empty.")
	0)))									    |	  (:method ((tree avl-tree))
										    |	    (null (avl-root tree))))
(defmethod avl-size ((node avl-node))						    |
  (let ((left (avl-left node))							    |	(defgeneric avl-height (tree)
	(right (avl-right node)))						    |	  (:documentation
    (1+ (cl:+ (if left (avl-size left) 0)					    |	   "This determines the height of an AVL tree and also checks if your
	   (if right (avl-size right) 0)))))					    |	tree is out of balance or 'Koyaanisquatsi' in Hopi Indian. Actual
										    |	height difference should be the same as the balance value, and should
(defmethod empty? ((tree avl-tree))						    |	be in the range {-1,0,1}."))
  (null (avl-root tree)))							    <
										    <
;; This determines the height of an AVL tree and also checks if your		    <
;; tree is out of balance or "Koyaanisquatsi" in Hopi Indian. Actual		    <
;; height difference should be the same as the balance value, and		    <
;; should be in the range {-1,0,1}.						    <

(defmethod avl-height ((tree avl-tree))							(defmethod avl-height ((tree avl-tree))
  (let ((root (avl-root tree)))								  (let ((root (avl-root tree)))
    (if root (avl-height root) 0)))							    (if root (avl-height root) 0)))

(defmethod avl-height ((node avl-node))							(defmethod avl-height ((node avl-node))
  (let ((hl (if (avl-left node) (avl-height (avl-left node))				  (let ((hl (if (avl-left node) (avl-height (avl-left node))
		0))											0))
	(hr (if (avl-right node) (avl-height (avl-right node))					(hr (if (avl-right node) (avl-height (avl-right node))
		0)))											0)))
    (cond ((not (eql (cl:- hr hl) (avl-balance node)))					    (cond ((not (eql (cl:- hr hl) (avl-balance node)))
	   (format t "~										   (format t "~
              The actual height difference ~S does not agree with the ~%~		              The actual height difference ~S does not agree with the ~%~
              balance entry ~S for node ~S"						              balance entry ~S for node ~S"
		   (cl:- hr hl) (avl-balance node) node))						   (cl:- hr hl) (avl-balance node) node))
	  ((cl:> (cl:abs (avl-balance node)) 1)							  ((cl:> (cl:abs (avl-balance node)) 1)
	   (format t "Node ~S is Koyaanisquatsi, its balance value is ~S"			   (format t "Node ~S is Koyaanisquatsi, its balance value is ~S"
		   node (avl-balance node))))								   node (avl-balance node))))
    (cl:1+ (cl:max hl hr))))								    (cl:1+ (cl:max hl hr))))

(defmethod avl-maximum ((tree avl-tree))					    |	(defgeneric left-most (node)
  (left-most (avl-root tree)))							    |	  (:documentation
										    >	   "Return true if the node is the left most node of the tree."))

(defmethod left-most ((node avl-node))							(defmethod left-most ((node avl-node))
  (labels ((find-left-most (node)							  (labels ((find-left-most (node)
	     (cond ((null (avl-left node)) node)						     (cond ((null (avl-left node)) node)
		   (t (find-left-most (avl-left node))))))						   (t (find-left-most (avl-left node))))))
    (find-left-most node)))								    (find-left-most node)))

										    >	(defgeneric avl-maximum (tree)
										    >	  (:documentation
										    >	   "The purpose of this method is unknown.")
										    >	  (:method ((tree avl-tree))
										    >	    (left-most (avl-root tree))))
										    >
										    >	(defgeneric map-over-each-node (tree function)
										    >	  (:documentation
										    >	   "Map over each node of the tree applying the function."))
										    >
(defmethod map-over-each-node ((tree avl-tree) function)				(defmethod map-over-each-node ((tree avl-tree) function)
  (labels ((map-over (node)								  (labels ((map-over (node)
	     (unless (null (avl-left node))							     (unless (null (avl-left node))
	       (map-over (avl-left node)))							       (map-over (avl-left node)))
	     (%funcall function node)								     (%funcall function node)
	     (unless (null (avl-right node))							     (unless (null (avl-right node))
	       (map-over (avl-right node)))))							       (map-over (avl-right node)))))
    (let ((root (avl-root tree)))							    (let ((root (avl-root tree)))
      (when root 									      (when root 
	(map-over root)))))									(map-over root)))))

										    >	(defgeneric make-generator (tree)
										    >	  (:documentation
										    >	   "The purpose of this method is unknown."))
										    >
(defmethod make-generator ((tree avl-tree))						(defmethod make-generator ((tree avl-tree))
  (let (stack)										  (let (stack)
    (macrolet ((current-state () `(first (first stack)))				    (macrolet ((current-state () `(first (first stack)))
	       (set-current-state (state) `(setf (first (first stack)) ,state))			       (set-current-state (state) `(setf (first (first stack)) ,state))
	       (current-node () `(rest (first stack)))						       (current-node () `(rest (first stack)))
	       (new-node (node) `(push (cons :left ,node) stack)))				       (new-node (node) `(push (cons :left ,node) stack)))
      (labels ((scan ()									      (labels ((scan ()
		 (cond ((null stack) nil)								 (cond ((null stack) nil)
		       ((eql (current-state) :left) 							       ((eql (current-state) :left) 
			(cond ((null (avl-left (current-node))) 						(cond ((null (avl-left (current-node))) 
			       (set-current-state :right)							       (set-current-state :right)
			       (current-node))									       (current-node))
			      (t (set-current-state :here)							      (t (set-current-state :here)
				 (new-node (avl-left (current-node)))							 (new-node (avl-left (current-node)))
				 (scan))))										 (scan))))
		       ((eql (current-state) :here)							       ((eql (current-state) :here)
			(set-current-state :right)								(set-current-state :right)
			(current-node))										(current-node))
		       (t ;; (eql (current-state) :right)						       (t ;; (eql (current-state) :right)
			(cond ((null (avl-right (current-node)))						(cond ((null (avl-right (current-node)))
			       (pop stack)									       (pop stack)
			       (scan))										       (scan))
			      (t (new-node									      (t (new-node
				  (prog1 (avl-right (current-node))							  (prog1 (avl-right (current-node))
				    (pop stack)))									    (pop stack)))
				 (scan))))										 (scan))))
		       )))										       )))
	(new-node (avl-root tree))								(new-node (avl-root tree))
	#'scan))))    										#'scan))))    

(defmethod avl-minimum ((tree avl-tree))					    |	(defgeneric right-most (node)
  (right-most (avl-root tree)))							    |	  (:documentation
										    >	   "Return true if the node is the right most of the tree."))

(defmethod right-most ((node avl-node))							(defmethod right-most ((node avl-node))
  (labels ((find-right-most (node)							  (labels ((find-right-most (node)
	     (cond ((null (avl-right node)) node)						     (cond ((null (avl-right node)) node)
		   (t (find-right-most (avl-right node))))))						   (t (find-right-most (avl-right node))))))
    (find-right-most node)))								    (find-right-most node)))

										    >	(defgeneric avl-minimum (tree)
										    >	  (:documentation
										    >	   "The purpose of this method is unknown.")
										    >	  (:method ((tree avl-tree))
										    >	    (right-most (avl-root tree))))
										    >
										    >	(defgeneric avl-next (key tree-or-node)
										    >	  (:documentation
										    >	   "Return the next item of the tree or node."))
										    >
(defmethod avl-next (key (tree avl-tree))						(defmethod avl-next (key (tree avl-tree))
  (avl-next key (avl-root tree)))							  (avl-next key (avl-root tree)))

(defmethod avl-next (key (node avl-node))						(defmethod avl-next (key (node avl-node))
  (labels ((next-loop (node)								  (labels ((next-loop (node)
	     (and node										     (and node
		  (if (not (> node key))								  (if (not (> node key))
		      (next-loop (avl-right node))							      (next-loop (avl-right node))
		      (or (next-loop (avl-left node))							      (or (next-loop (avl-left node))
			  node)))))										  node)))))
    (next-loop node)))									    (next-loop node)))

										    >	(defgeneric avl-previous (key tree-or-node)
										    >	  (:documentation
										    >	   "Return the next item of the tree or node."))
										    >
(defmethod avl-previous (key (tree avl-tree))						(defmethod avl-previous (key (tree avl-tree))
  (avl-previous key (avl-root tree)))							  (avl-previous key (avl-root tree)))

(defmethod avl-previous (key (node avl-node))						(defmethod avl-previous (key (node avl-node))
  (labels ((next-loop (node)								  (labels ((next-loop (node)
	     (and node										     (and node
		  (if (not (> key node))								  (if (not (> key node))
		      (next-loop (avl-left node))							      (next-loop (avl-left node))
		      (or (next-loop (avl-right node))							      (or (next-loop (avl-right node))
			  node)))))										  node)))))
    (next-loop node)))									    (next-loop node)))

										    >	(defgeneric balance-right (node height-change)
										    >	  (:documentation
										    >	   "Balance a TREE that is right-Koyaanisquatsi, i.e. the right
										    >	subtree is 2 levels higher than the left subtree. HEIGHT-CHANGE is the
										    >	height of TREE relative to its value before the delete/insert
										    >	operation. Balance-right returns a node and the height of that node
										    >	relative to the original height of TREE."))

;; The first interesting operation on AVL trees. This inserts THING		    |	(defmethod balance-right ((node avl-node) height-change)
;; into the tree and returns a new tree and an integer which is the		    |	  (let ((r (avl-right node)))
;; change in height of the tree.						    |	    (cond ((cl:plusp (avl-balance r))
										    >		   (setq node (update-node node 0 (avl-left node) (avl-left r)))
										    >		   (setq r (update-node r 0 node (avl-right r)))
										    >		   (values r (1- height-change)))
										    >		  ((cl:zerop (avl-balance r))
										    >		   (setq node (update-node node 1 (avl-left node) (avl-left r)))
										    >		   (setq r (update-node r -1 node (avl-right r)))
										    >		   (values r height-change))
										    >		  (t (let ((lr (avl-left r)))
										    >		       (setq r (update-node r (if (cl:minusp (avl-balance lr)) 1 0)
										    >					    (avl-right lr) (avl-right r)))
										    >		       (setq node (update-node node
										    >					       (if (cl:plusp (avl-balance lr)) -1 0)
										    >					       (avl-left node) (avl-left lr)))
										    >		       (setq lr (update-node lr 0 node r))
										    >		       (values lr (1- height-change)))))))
										    >
										    >	(defgeneric balance-left (node height-change)
										    >	  (:documentation
										    >	   "Balance a TREE that is left-Koyaanisquatsi, i.e. the left subtree
										    >	is 2 levels higher than the right subtree. HEIGHT-CHANGE is the height
										    >	of TREE relative to its value before the delete/insert operation.
										    >	Balance-left returns a node and the height of that node relative to
										    >	the original height of TREE."))
										    >
										    >	(defmethod balance-left ((node avl-node) height-change)
										    >	  (let ((l (avl-left node)))
										    >	    (cond ((cl:minusp (avl-balance l))
										    >		   (setq node (update-node node 0 (avl-right l) (avl-right node)))
										    >		   (setq l (update-node l 0 (avl-left l) node))
										    >		   (values l (1- height-change)))
										    >		  ((cl:zerop (avl-balance l))
										    >		   (setq node (update-node node -1 (avl-right l) (avl-right node)))
										    >		   (setq l (update-node l 1 (avl-left l) node))
										    >		   (values l height-change))
										    >		  (t (let ((rl (avl-right l)))
										    >		       (setq l (update-node l (if (cl:plusp (avl-balance rl)) -1 0)
										    >					    (avl-left l) (avl-left rl)))
										    >		       (setq node (update-node node (if (cl:minusp (avl-balance rl))
										    >							1 0)
										    >					       (avl-right rl) (avl-right node)))
										    >		       (setq rl (update-node rl 0 l node))
										    >		       (values rl (1- height-change)))))))
										    >
										    >	(defgeneric insert (item tree &rest args)
										    >	  (:documentation
										    >	   "The first interesting operation on AVL trees. This inserts THING
										    >	into the tree and returns a new tree and an integer which is the
										    >	change in height of the tree."))

(defmethod insert (item (tree avl-tree) &rest args)					(defmethod insert (item (tree avl-tree) &rest args)
  (labels										  (labels
      ((avl-insert (node)								      ((avl-insert (node)
	 (if (null node)									 (if (null node)
	     (values (%apply #'make-element tree item args) 1)					     (values (%apply #'make-element tree item args) 1)
	     (cond ((= item node)								     (cond ((= item node)
		    (values        ;; Just update the value field if necessary				    (values ;; Just update the value field if necessary
		      (%apply #'update-node node (avl-balance node)			                     (%apply #'update-node node (avl-balance node)
			     (avl-left node) (avl-right node)							     (avl-left node) (avl-right node)
			     args)										     args)
		      0))								                     0))
		   ((> item node) 									   ((> item node) 
		    (multiple-value-bind (subtree height-change)					    (multiple-value-bind (subtree height-change)
			(avl-insert (avl-right node)) 								(avl-insert (avl-right node)) 
		      (setq node 									      (setq node 
			    (update-node node									    (update-node node
					 (cl:+ (avl-balance node)								 (cl:+ (avl-balance node)
						 height-change)				                                               height-change)
					 (avl-left node) subtree))								 (avl-left node) subtree))
		      (if (cl:> (avl-balance node) 1)							      (if (cl:> (avl-balance node) 1)
			  (balance-right node 1)								  (balance-right node 1)
			  (values node (if (cl:plusp (avl-balance node))					  (values node (if (cl:plusp (avl-balance node))
					   height-change									   height-change
					   0)))))										   0)))))
		   (t (multiple-value-bind (subtree height-change)					   (t (multiple-value-bind (subtree height-change)
			  (avl-insert (avl-left node))								  (avl-insert (avl-left node))
			(setq node										(setq node
			      (update-node node									      (update-node node
					   (cl:- (avl-balance node)								   (cl:- (avl-balance node)
						   height-change)			                                                 height-change)
					   subtree										   subtree
					   (avl-right node)))									   (avl-right node)))
			(if (cl:< (avl-balance node) -1)							(if (cl:< (avl-balance node) -1)
			    (balance-left node 1)								    (balance-left node 1)
			    (values node									    (values node
				    (if (cl:minusp (avl-balance node))							    (if (cl:minusp (avl-balance node))
					height-change										height-change
					0)))))))))										0)))))))))
    (setf (avl-root tree) (avl-insert (avl-root tree)))					    (setf (avl-root tree) (avl-insert (avl-root tree)))
    tree))										    tree))

										    >	(defgeneric delete-head (tree)
										    >	  (:documentation
										    >	   "This returns the head (leftmost element) in the tree, and removes
										    >	it from the tree. Useful for implementing priority queues as AVL
										    >	trees. Values returned are the value of the leftmost element, the
										    >	modified tree, and the change in height of the tree."))

;; Balance a TREE that is right-Koyaanisquatsi, i.e. the right subtree		    |	(defmethod delete-head ((tree avl-tree))  
;; is 2 levels higher than the left subtree. HEIGHT-CHANGE is the		    |	  (multiple-value-bind (tail new-root height-change)
;; height of TREE relative to its value before the delete/insert		    |	      (delete-head (avl-root tree))
;; operation. Balance-right returns a node and the height of that node		    |	    (setf (avl-root tree) new-root)
;; relative to the original height of TREE.					    |	    (values tail height-change)))

(defmethod balance-right ((node avl-node) height-change)			    |	(defmethod delete-head ((node avl-node))
  (let ((r (avl-right node)))							    |	  (cond ((null node) nil)
    (cond ((cl:plusp (avl-balance r))						    |		((null (avl-left node))
	   (setq node (update-node node 0 (avl-left node) (avl-left r)))	    |		 (values node (avl-right node) -1))
	   (setq r (update-node r 0 node (avl-right r)))			    |		(t (multiple-value-bind (head-value subnode height-change)
	   (values r (1- height-change)))					    |		       (delete-head (avl-left node))
	  ((cl:zerop (avl-balance r))						    |		     (setq node (update-node node (cl:- (avl-balance node)
	   (setq node (update-node node 1 (avl-left node) (avl-left r)))	    |	                                                height-change)
	   (setq r (update-node r -1 node (avl-right r)))			    |					     subnode (avl-right node)))
	   (values r height-change))						    |		     (if (> (avl-balance node) 1)
	  (t (let ((lr (avl-left r)))						    |			 (multiple-value-setq (node height-change)
	       (setq r (update-node r (if (cl:minusp (avl-balance lr)) 1 0)	    |			   (balance-right node 0))
				    (avl-right lr) (avl-right r)))		    |			 (if (not (cl:zerop (avl-balance node)))
	       (setq node (update-node node					    |			     (setq height-change 0)))
				       (if (cl:plusp (avl-balance lr)) -1 0)	    |		     (values head-value node height-change))))) 
				       (avl-left node) (avl-left lr)))		    <
	       (setq lr (update-node lr 0 node r))				    <
	       (values lr (1- height-change)))))))				    <

; Balance a TREE that is left-Koyaanisquatsi, i.e. the left subtree is		    |	(defgeneric delete-tail (tree)
;; 2 levels higher than the right subtree. HEIGHT-CHANGE is the height		    |	  (:documentation
;; of TREE relative to its value before the delete/insert operation.		    |	   "This returns the tail (rightmost element) in the tree, and removes
;; Balance-left returns a node and the height of that node relative to		    |	it from the tree.  Values returned are the value of the rightmost
;; the original height of TREE.							    |	element, the modified tree, and the change in height of the tree."))

(defmethod balance-left ((node avl-node) height-change)				    |	(defmethod delete-tail ((tree avl-tree))
  (let ((l (avl-left node)))							    |	  (multiple-value-bind (tail new-root height-change)
    (cond ((cl:minusp (avl-balance l))						    |	      (delete-tail (avl-root tree))
	   (setq node (update-node node 0 (avl-right l) (avl-right node)))	    |	    (setf (avl-root tree) new-root)
	   (setq l (update-node l 0 (avl-left l) node))				    |	    (values tail height-change)))
	   (values l (1- height-change)))					    <
	  ((cl:zerop (avl-balance l))						    <
	   (setq node (update-node node -1 (avl-right l) (avl-right node)))	    <
	   (setq l (update-node l 1 (avl-left l) node))				    <
	   (values l height-change))						    <
	  (t (let ((rl (avl-right l)))						    <
	       (setq l (update-node l (if (cl:plusp (avl-balance rl)) -1 0)	    <
				    (avl-left l) (avl-left rl)))		    <
	       (setq node (update-node node (if (cl:minusp (avl-balance rl))	    <
						1 0)				    <
				       (avl-right rl) (avl-right node)))	    <
	       (setq rl (update-node rl 0 l node))				    <
	       (values rl (1- height-change)))))))				    <

;; This deletes an entry from an AVL tree.					    |	(defmethod delete-tail ((node avl-node))
										    >	  (cond ((null node) nil)
										    >		((null (avl-right node))
										    >		 (values node (avl-left node) -1))
										    >		(t (multiple-value-bind (tail-value subnode height-change)
										    >		       (delete-tail (avl-right node))
										    >		     (setq node (update-node node (cl:+ (avl-balance node)
										    >	                                                height-change)
										    >					     (avl-left node) subnode))
										    >		     (if (cl:< (avl-balance node) -1)
										    >			 (multiple-value-setq (node height-change)
										    >			   (balance-left node 0))
										    >			 (if (not (cl:zerop (avl-balance node)))
										    >			     (setq height-change 0)))
										    >		     (values tail-value node height-change)))))
										    >
										    >	(defgeneric erase-node (node)
										    >	  (:documentation
										    >	   "This gets rid of a value that has been found in the tree. NODE is
										    >	the node containing the value. If the right subtree of NODE is higher
										    >	than its left, replace the value of NODE with the value of the
										    >	left-most leaf of the right subtree, and remove this leaf from the
										    >	right subtree. Otherwise replace NODE's value with the value of the
										    >	right-most leaf of the left subtree of NODE, and remove this leaf from
										    >	the left subtree."))
										    >
										    >	(defmethod erase-node ((node avl-node))
										    >	  (cond ((and (null (avl-left node)) (null (avl-right node)))
										    >		 (values nil -1))
										    >		((cl:plusp (avl-balance node))
										    >		 (multiple-value-bind (head-node subtree height-change)
										    >		     (delete-head (avl-right node))
										    >		   (setq node (update-node head-node
										    >					   (cl:+ (avl-balance node)
										    >	                                         height-change)
										    >					   (avl-left node) subtree))
										    >		   (values node height-change)))
										    >		(t (multiple-value-bind (tail-node subtree height-change)
										    >		       (delete-tail (avl-left node))
										    >		     (setq node (update-node tail-node
										    >					     (cl:- (avl-balance node) height-change)
										    >	                                     subtree (avl-right node)))
										    >		     (values node (if (cl:zerop (avl-balance node))
										    >				      height-change 0))))))

(defmethod delete (item (tree avl-tree) &rest rest)					(defmethod delete (item (tree avl-tree) &rest rest)
										    >	  "This deletes an entry from an AVL tree."
  (declare (ignore rest))								  (declare (ignore rest))
  (let ((root (avl-root tree)))								  (let ((root (avl-root tree)))
    (labels										    (labels
      ((delete-left (node parent)							        ((delete-left (node parent)
	 (cond ((null node)								           (cond ((null node)
		(values nil 0))								                  (values nil 0))
	       ((= item node)								                 ((= item node)
		(multiple-value-bind (new-left height-change) (erase-node node)		                  (multiple-value-bind (new-left height-change) (erase-node node)
		  (setf (avl-left parent) new-left)					                    (setf (avl-left parent) new-left)
		  (values new-left height-change)))					                    (values new-left height-change)))
	       (t (avl-delete node))))							                 (t (avl-delete node))))
       (delete-right (node parent)							         (delete-right (node parent)
	 (cond ((null node)								           (cond ((null node)
		(values nil 0))								                  (values nil 0))
	       ((= item node)								                 ((= item node)
		(multiple-value-bind (new-right height-change)				                  (multiple-value-bind (new-right height-change)
		    (erase-node node)							                      (erase-node node)
		  (setf (avl-right parent) new-right)					                    (setf (avl-right parent) new-right)
		  (values new-right height-change)))					                    (values new-right height-change)))
	       (t (avl-delete node))))							                 (t (avl-delete node))))
       (avl-delete (node)								         (avl-delete (node)
	 (cond ((> item node)								           (cond ((> item node)
		(multiple-value-bind (subtree height-change)				                  (multiple-value-bind (subtree height-change)
		    (delete-right (avl-right node) node)				                      (delete-right (avl-right node) node)
		  (setq node (update-node node						                    (setq node (update-node node
					  (cl:+ (avl-balance node)			                                            (cl:+ (avl-balance node)
						  height-change)									  height-change)
					  (avl-left node) subtree))			                                            (avl-left node) subtree))
		  (if (cl:< (avl-balance node) -1)					                    (if (cl:< (avl-balance node) -1)
		      (balance-left node 0)						                        (balance-left node 0)
		      (values node (if (cl:zerop (avl-balance node))			                        (values node (if (cl:zerop (avl-balance node))
				       height-change 0)))))				                                         height-change 0)))))
	       (t (multiple-value-bind (subtree height-change)				                 (t (multiple-value-bind (subtree height-change)
		      (delete-left (avl-left node) node)				                        (delete-left (avl-left node) node)
		    (setq node (update-node node					                      (setq node (update-node node
					    (cl:- (avl-balance node)			                                              (cl:- (avl-balance node)
						    height-change)									    height-change)
					    subtree (avl-right node)))			                                              subtree (avl-right node)))
		    (if (cl:> (avl-balance node) 1)					                      (if (cl:> (avl-balance node) 1)
			(balance-right node 0)						                          (balance-right node 0)
			(values node (if (cl:zerop (avl-balance node))			                          (values node (if (cl:zerop (avl-balance node))
					 height-change 0))))))))			                                           height-change 0))))))))
      (cond ((null root)								      (cond ((null root)
	     (values nil 0))									     (values nil 0))
	    ((= item root)									    ((= item root)
	     (setf (avl-root tree) (erase-node root)))						     (setf (avl-root tree) (erase-node root)))
	    ((> item root)									    ((> item root)
	     (delete-right (avl-right root) root))						     (delete-right (avl-right root) root))
	    (t (delete-left (avl-left root) root)))						    (t (delete-left (avl-left root) root)))
      tree)))										      tree)))

(defmethod member (item (tree avl-tree) &rest rest)					(defmethod member (item (tree avl-tree) &rest rest)
  (declare (ignore rest))								  (declare (ignore rest))
  (labels ((search-node (node)								  (labels ((search-node (node)
	     (cond ((null node) nil)								     (cond ((null node) nil)
		   ((= item node) node)									   ((= item node) node)
		   ((> item node)									   ((> item node)
		    (search-node (avl-right node)))							    (search-node (avl-right node)))
		   (t (search-node (avl-left node))))))							   (t (search-node (avl-left node))))))
    (search-node (avl-root tree))))							    (search-node (avl-root tree))))

;; This gets rid of a value that has been found in the tree. NODE is		    <
;; the node containing the value. If the right subtree of NODE is		    <
;; higher than its left, replace the value of NODE with the value of		    <
;; the left-most leaf of the right subtree, and remove this leaf from		    <
;; the right subtree. Otherwise replace NODE's value with the value of		    <
;; the right-most leaf of the left subtree of NODE, and remove this		    <
;; leaf from the left subtree.							    <
										    <
(defmethod erase-node ((node avl-node))						    <
  (cond ((and (null (avl-left node)) (null (avl-right node)))			    <
	 (values nil -1))							    <
	((cl:plusp (avl-balance node))						    <
	 (multiple-value-bind (head-node subtree height-change)			    <
	     (delete-head (avl-right node))					    <
	   (setq node (update-node head-node					    <
				   (cl:+ (avl-balance node)			    <
					   height-change)			    <
				   (avl-left node) subtree))			    <
	   (values node height-change)))					    <
	(t (multiple-value-bind (tail-node subtree height-change)		    <
	       (delete-tail (avl-left node))					    <
	     (setq node (update-node tail-node					    <
				     (cl:- (avl-balance node) height-change)	    <
				      subtree (avl-right node)))		    <
	     (values node (if (cl:zerop (avl-balance node))			    <
			      height-change 0))))))				    <
										    <
; This returns the head (leftmost element) in the tree, and removes it		    <
;; from the tree.  Useful for implementing priority queues as AVL		    <
;; trees.  Values returned are the value of the leftmost element, the		    <
;; modified tree, and the change in height of the tree.				    <
										    <
(defmethod delete-head ((tree avl-tree))  					    <
  (multiple-value-bind (tail new-root height-change)				    <
      (delete-head (avl-root tree))						    <
    (setf (avl-root tree) new-root)						    <
    (values tail height-change)))						    <
										    <
(defmethod delete-head ((node avl-node))					    <
  (cond ((null node) nil)							    <
	((null (avl-left node))							    <
	 (values node (avl-right node) -1))					    <
	(t (multiple-value-bind (head-value subnode height-change)		    <
	       (delete-head (avl-left node))					    <
	     (setq node (update-node node (cl:- (avl-balance node)		    <
						  height-change)		    <
				     subnode (avl-right node)))			    <
	     (if (> (avl-balance node) 1)					    <
		 (multiple-value-setq (node height-change)			    <
		   (balance-right node 0))					    <
		 (if (not (cl:zerop (avl-balance node)))			    <
		     (setq height-change 0)))					    <
	     (values head-value node height-change))))) 			    <
										    <
; This returns the tail (rightmost element) in the tree, and removes		    <
;; it from the tree.  Values returned are the value of the rightmost		    <
;; element, the modified tree, and the change in height of the tree.		    <
										    <
(defmethod delete-tail ((tree avl-tree))					    <
  (multiple-value-bind (tail new-root height-change)				    <
      (delete-tail (avl-root tree))						    <
    (setf (avl-root tree) new-root)						    <
    (values tail height-change)))						    <
										    <
(defmethod delete-tail ((node avl-node))					    <
  (cond ((null node) nil)							    <
	((null (avl-right node))						    <
	 (values node (avl-left node) -1))					    <
	(t (multiple-value-bind (tail-value subnode height-change)		    <
	       (delete-tail (avl-right node))					    <
	     (setq node (update-node node (cl:+ (avl-balance node)		    <
						  height-change)		    <
				     (avl-left node) subnode))			    <
	     (if (cl:< (avl-balance node) -1)					    <
		 (multiple-value-setq (node height-change)			    <
		   (balance-left node 0))					    <
		 (if (not (cl:zerop (avl-balance node)))			    <
		     (setq height-change 0)))					    <
	     (values tail-value node height-change)))))				    <
										    <
(defmethod make-element ((tree avl-tree-elements-as-singletons) key &rest rest)		(defmethod make-element ((tree avl-tree-elements-as-singletons) key &rest rest)
  (declare (ignore rest))								  (declare (ignore rest))
  (make-instance 'avl-node :domain tree :key key))					  (make-instance 'avl-node :domain tree :key key))

(defmethod make-element ((tree avl-tree-elements-as-pairs) key &rest rest)		(defmethod make-element ((tree avl-tree-elements-as-pairs) key &rest rest)
  (make-instance 'avl-node-as-pairs :domain tree :key key :value (first rest)))		  (make-instance 'avl-node-as-pairs :domain tree :key key :value (first rest)))
										    (
;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-		;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-

;; bigfloat.lisp,v 1.3 1994/10/21 18:16:34 rz Exp					;; bigfloat.lisp,v 1.3 1994/10/21 18:16:34 rz Exp

;; Arbitrary Precision Real Arithmetic System						;; Arbitrary Precision Real Arithmetic System
;;  by Tateaki  Sasaki									;;  by Tateaki  Sasaki
;;  The UNIVERSITY OF UTAH,  MARCH 1979							;;  The UNIVERSITY OF UTAH,  MARCH 1979

;; For design philosophy and characteristics of this system, see T. Sasaki, 		;; For design philosophy and characteristics of this system, see T. Sasaki, 
;; ``An Arbitrary Precision Real Arithmetic Package In Reduce,''			;; ``An Arbitrary Precision Real Arithmetic Package In Reduce,''
;;  Proceedings of Eurosam '79, Marseille (FRANCE), June 1979.				;;  Proceedings of Eurosam '79, Marseille (FRANCE), June 1979.

;; For Implementation notes and using this system, see T. Sasaki, 			;; For Implementation notes and using this system, see T. Sasaki, 
;; ``Manual For Arbitrary Precision Real Arithmetic System in Reduce,' 			;; ``Manual For Arbitrary Precision Real Arithmetic System in Reduce,' 
;; Operating Report of Utah Symbolic Computation Group					;; Operating Report of Utah Symbolic Computation Group

;;  In order to speed up this system, you have only to rewrite four			;;  In order to speed up this system, you have only to rewrite four
;; routines (DECPREC!, INCPREC!, PRECI!, AND ROUND!LAST)				;; routines (DECPREC!, INCPREC!, PRECI!, AND ROUND!LAST)
;; machine-dependently.									;; machine-dependently.

;;  This function constructs an internal representation of a number			;;  This function constructs an internal representation of a number
;; 'n' composed of the mantissa MT and the exponent EP with the base			;; 'n' composed of the mantissa MT and the exponent EP with the base
;; 10.  The magnitude of the number thus constructed is hence				;; 10.  The magnitude of the number thus constructed is hence
;; MT*10^EP.										;; MT*10^EP.

;; **** CAUTION!  MT and EP are integers.  So, EP denotes the order of			;; **** CAUTION!  MT and EP are integers.  So, EP denotes the order of
;;                the last figure in 'N', WHERE order(N)=K if 10**K <=			;;                the last figure in 'N', WHERE order(N)=K if 10**K <=
;;                ABS(N) < 10**(K+1), with the exception order(0)=0. 			;;                ABS(N) < 10**(K+1), with the exception order(0)=0. 
;;											;;

;; The number 'n' is said to be of precision 'k' if its mantissa is a			;; The number 'n' is said to be of precision 'k' if its mantissa is a
;; k-figure number.  MT and EP are any integers (positive or				;; k-figure number.  MT and EP are any integers (positive or
;; negative).  So, you can handle any big or small numbers.  in this			;; negative).  So, you can handle any big or small numbers.  in this
;; sense, 'BF' denotes a big-floating-point number.  Hereafter, an			;; sense, 'BF' denotes a big-floating-point number.  Hereafter, an
;; internal representation of a number constructed by MAKE-BIGFLOAT is			;; internal representation of a number constructed by MAKE-BIGFLOAT is
;; referred to as a big-float representation.						;; referred to as a big-float representation.
 											 
(in-package "WEYLI")								    |	(in-package :weyli)

(make::adjust-version-numbers Weyl "1.3")					    |	;;; DELETE (make::adjust-version-numbers Weyl "1.3")

										    >	;;; FIXME : The precision should be specified in a class allocated
										    >	;;; slot.
(EVAL-WHEN (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL)						(eval-when (:compile-toplevel :load-toplevel)
  (proclaim '(special *real-precision*)))						  (proclaim '(special *real-precision*)))

(defsubst make-bigfloat (domain mantissa exponent)					(defsubst make-bigfloat (domain mantissa exponent)
  (make-instance 'bigfloat :domain domain						  (make-instance 'bigfloat :domain domain
		 :mantissa mantissa :exponent exponent))						 :mantissa mantissa :exponent exponent))

;; This function returns t if x is a big-float representation, else it			;; This function returns t if x is a big-float representation, else it
;; returns NIL.										;; returns NIL.
(defun bigfloatp (x)									(defun bigfloatp (x)
  (eql (class-name (class-of x)) 'bigfloat))						  (eql (class-name (class-of x)) 'bigfloat))
 
;; This function counts the precision of a bigfloat 'n'.			    <
;;										    <
;; FIXTHIS:  The 1+ below is total kludge.  This whole package needs		    <
;; to be rewritten sometime soon.  						    <
(defun preci! (nmbr)								    <
  (let* ((mt (1+ (cl:abs (bigfloat-mantissa nmbr))))				    <
	 (len (integer-length mt)))						    <
    (values									    <
     (if (cl:< len 10)								    <
	 (cl:ceiling (cl:log mt 10))						    <
	 (cl:ceiling								    <
	  (cl:+ (cl:/ (cl:+ len -10) #.(cl:log 10 2))				    <
		  (cl:log (cl:ash mt (cl:- 10 len)) 10)))))))			    <
 										    <
;; This function counts the order of a bigfloat 'n'.				    <
;; **** ORDER(N)=K IF 10**K <= ABS(N) < 10**(K+1) 				    <
;; ****     WHEN N IS NOT 0, AND ORDER(0)=0.      				    <
(defun order! (nmbr)								    <
  (if (cl:zerop (bigfloat-mantissa nmbr)) 0					    <
      (cl:+ (preci! nmbr) (bigfloat-exponent nmbr) -1)))			    <
										    <
(defun convert-number->characters (number)					    <
  (if (cl:zerop number) (list #\0)						    <
      (let ((chars ()))								    <
	(loop with n = number							    <
	      and digit								    <
	      while (not (cl:zerop n))						    <
	      do (multiple-value-setq (n digit) (cl:truncate n 10))		    <
		 (push (digit-char digit) chars))				    <
	chars)))								    <
										    <
(defmethod print-object ((number bigfloat) stream)				    <
  (setq number (round!mt number (cl:- *REAL-PRECISION* 2)))			    <
  (with-slots (mantissa exponent) number 					    <
    (let ((u (convert-number->characters (cl:abs mantissa)))			    <
	  k)									    <
      (flet ((bfprin1 (u)							    <
	       (when (cl:minusp mantissa)					    <
		 (push #\- u))							    <
	       ;; Suppress trailing zeroes					    <
	       (loop for v on (reverse u)					    <
		     while (and (char= (first v) #\0)				    <
				(if (rest v) (char/= (second v) #\.)		    <
				    t))						    <
		     finally (setq u (nreverse v)))				    <
	       ;; Now print the number						    <
	       (loop for char in u						    <
		     do (write-char char stream))))				    <
	(or (rest u) (push #\0 (rest u)))					    <
	(push #\. (rest u))							    <
	(bfprin1 u)								    <
	(princ "B" stream)							    <
	(setq u (convert-number->characters (cl:abs (setq k (order! number)))))	    <
	(setq u (cons (if (cl:< k 0) #\- #\+)					    <
		      u))							    <
	(loop for char in u							    <
	      do (write-char char stream))					    <
	number))))								    <
										    <
										    <
;;; Routines For Converting A Big-Float Number						;;; Routines For Converting A Big-Float Number
 											 
;; This function converts a number N to an equivalent number the			;; This function converts a number N to an equivalent number the
;; precision of which is decreased by K.						;; precision of which is decreased by K.
(defun decprec! (number k)								(defun decprec! (number k)
  (with-slots (exponent mantissa) number						  (with-slots (exponent mantissa) number
    (make-bigfloat *domain*								    (make-bigfloat *domain*
		   (cl:truncate mantissa (cl:expt 10 k))						   (cl:truncate mantissa (cl:expt 10 k))
		   (cl:+ exponent k))))									   (cl:+ exponent k))))
 											 
;;  This function converts a number N to an equivalent 					;;  This function converts a number N to an equivalent 
;;       number the precision of which is increased by K.				;;       number the precision of which is increased by K.
(defun incprec! (number k)								(defun incprec! (number k)
  (with-slots (exponent mantissa) number						  (with-slots (exponent mantissa) number
    (make-bigfloat *domain*								    (make-bigfloat *domain*
		   (cl:* mantissa (cl:expt 10 k))							   (cl:* mantissa (cl:expt 10 k))
		   (cl:- exponent k))))									   (cl:- exponent k))))
 											 
;; This function converts a number to an equivalent number of precision			;; This function converts a number to an equivalent number of precision
;; k by rounding or adding '0's.							;; k by rounding or adding '0's.
(defun conv!mt (number k)								(defun conv!mt (number k)
  (unless (bigfloatp number)								  (unless (bigfloatp number)
    (error "Expected ~S to be a bigfloat" number))					    (error "Expected ~S to be a bigfloat" number))
  (unless (and (integerp k) (cl:> k 0))							  (unless (and (integerp k) (cl:> k 0))
    (error "Expected ~S to be a positive integer" k))					    (error "Expected ~S to be a positive integer" k))
  (cond ((cl:zerop (setq k (cl:- (preci! number) k)))					  (cond ((cl:zerop (setq k (cl:- (preci! number) k)))
	 number)										 number)
	((cl:< k 0) (incprec! number (cl:- k)))							((cl:< k 0) (incprec! number (cl:- k)))
	(t (round!last (decprec! number (1- k))))))						(t (round!last (decprec! number (1- k))))))
 											 
;; This function converts a number 'n' to an equivalent number having			;; This function converts a number 'n' to an equivalent number having
;; the exponent k by rounding 'n' or adding '0's to 'n'.				;; the exponent k by rounding 'n' or adding '0's to 'n'.
(defun conv!ep (nmbr k)									(defun conv!ep (nmbr k)
  (unless (bigfloatp nmbr) 								  (unless (bigfloatp nmbr) 
    (error "Invalid argument to conv!ep: ~S" nmbr))					    (error "Invalid argument to conv!ep: ~S" nmbr))
  (unless (integerp k)									  (unless (integerp k)
    (error "Invalid second argument to conv!ep: ~S" k))					    (error "Invalid second argument to conv!ep: ~S" k))
  (cond ((cl:zerop (setq k (cl:- k (bigfloat-exponent nmbr))))				  (cond ((cl:zerop (setq k (cl:- k (bigfloat-exponent nmbr))))
	 nmbr)											 nmbr)
	((cl:< k 0) (incprec! nmbr (cl:- k)))							((cl:< k 0) (incprec! nmbr (cl:- k)))
	(t (round!last (decprec! nmbr (cl:- k 1))))))						(t (round!last (decprec! nmbr (cl:- k 1))))))
 											 
;; This function returns a given number N unchanged if its precision			;; This function returns a given number N unchanged if its precision
;; is not greater than K, else it cuts off its mantissa at the (K+1)th			;; is not greater than K, else it cuts off its mantissa at the (K+1)th
;; place and returns an equivalent number of precision K.				;; place and returns an equivalent number of precision K.
;;  **** CAUTION!  NO ROUNDING IS MADE.                  				;;  **** CAUTION!  NO ROUNDING IS MADE.                  
(defun cut!mt (nmbr k)									(defun cut!mt (nmbr k)
  (declare (fixnum k))									  (declare (fixnum k))
  (unless (bigfloatp nmbr)								  (unless (bigfloatp nmbr)
    (error "Invalid argument to cut!mt: ~S" nmbr))					    (error "Invalid argument to cut!mt: ~S" nmbr))
  (unless (and (integerp k) (cl:> k 0))							  (unless (and (integerp k) (cl:> k 0))
    (error "Invalid precision to cut!mt: ~D" k))  					    (error "Invalid precision to cut!mt: ~D" k))  
  (if (cl:plusp (setq k (cl:- (preci! nmbr) k)))					  (if (cl:plusp (setq k (cl:- (preci! nmbr) k)))
      (decprec! nmbr k)									      (decprec! nmbr k)
      nmbr)) 										      nmbr)) 

;; This function returns a given number N unchanged if its exponent is			;; This function returns a given number N unchanged if its exponent is
;; not less than K, else it cuts off its mantissa and returns an			;; not less than K, else it cuts off its mantissa and returns an
;; equivalent number of exponent K.							;; equivalent number of exponent K.
;;  **** CAUTION!  NO ROUNDING IS MADE.                  				;;  **** CAUTION!  NO ROUNDING IS MADE.                  
(defun cut!ep (nmbr k)									(defun cut!ep (nmbr k)
  (unless (bigfloatp nmbr)								  (unless (bigfloatp nmbr)
    (error "Invalid argument to cut!ep: ~S" nmbr))					    (error "Invalid argument to cut!ep: ~S" nmbr))
  (unless (integerp k)									  (unless (integerp k)
    (error "Invalid precision to cut!ep: ~D" k))  					    (error "Invalid precision to cut!ep: ~D" k))  
  (if (not (cl:> (setq k (cl:- k (bigfloat-exponent nmbr))) 0))				  (if (not (cl:> (setq k (cl:- k (bigfloat-exponent nmbr))) 0))
      nmbr										      nmbr
      (decprec! nmbr k)))								      (decprec! nmbr k)))
											 
										    >	;; This function counts the precision of a bigfloat 'n'.
										    >	;;
										    >	;; FIXTHIS:  The 1+ below is total kludge.  This whole package needs
										    >	;; to be rewritten sometime soon.  
										    >	(defun preci! (nmbr)
										    >	  (let* ((mt (1+ (cl:abs (bigfloat-mantissa nmbr))))
										    >		 (len (integer-length mt)))
										    >	    (values
										    >	     (if (cl:< len 10)
										    >		 (cl:ceiling (cl:log mt 10))
										    >		 (cl:ceiling
										    >		  (cl:+ (cl:/ (cl:+ len -10) #.(cl:log 10 2))
										    >	                (cl:log (cl:ash mt (cl:- 10 len)) 10)))))))
										    >	 
										    >	;; This function counts the order of a bigfloat 'n'.
										    >	;; **** ORDER(N)=K IF 10**K <= ABS(N) < 10**(K+1) 
										    >	;; ****     WHEN N IS NOT 0, AND ORDER(0)=0.      
										    >	(defun order! (nmbr)
										    >	  (if (cl:zerop (bigfloat-mantissa nmbr)) 0
										    >	      (cl:+ (preci! nmbr) (bigfloat-exponent nmbr) -1)))
										    >
										    >	(defun convert-number->characters (number)
										    >	  (if (cl:zerop number) (list #\0)
										    >	      (let ((chars ()))
										    >		(loop with n = number
										    >		      and digit
										    >		      while (not (cl:zerop n))
										    >		      do (multiple-value-setq (n digit) (cl:truncate n 10))
										    >	              (push (digit-char digit) chars))
										    >		chars)))
										    >
										    >	;; This function rounds a number N at its last place.
										    >	(defun round!last (nmbr)
										    >	  (let ((abs-nmbr (cl:abs (bigfloat-mantissa nmbr)))
										    >		n)
										    >	    (setq n (if (cl:< (rem abs-nmbr 10) 5)
										    >			(cl:truncate abs-nmbr 10)
										    >			(1+ (cl:truncate abs-nmbr 10))))
										    >	    (if (cl:minusp (bigfloat-mantissa nmbr)) (setq n (cl:- n)))
										    >	    (make-bigfloat *domain*  n (cl:1+ (bigfloat-exponent nmbr)))))
										    >
;; This function rounds a number N at the (K+1)th place and returns an			;; This function rounds a number N at the (K+1)th place and returns an
;; equivalent number of precision K if the precision of N is greater			;; equivalent number of precision K if the precision of N is greater
;; than K, else it returns the given number unchanged.					;; than K, else it returns the given number unchanged.
(defun round!mt (nmbr k)								(defun round!mt (nmbr k)
  (unless (bigfloatp nmbr)								  (unless (bigfloatp nmbr)
    (error "Invalid argument to round!mt: ~S" nmbr))					    (error "Invalid argument to round!mt: ~S" nmbr))
  (unless (and (integerp k) (not (cl:minusp k)))					  (unless (and (integerp k) (not (cl:minusp k)))
    (error "Invalid precision to round!mt: ~D" k))  					    (error "Invalid precision to round!mt: ~D" k))  
  (cond ((cl:minusp (setq k (cl:- (preci! nmbr) k 1)))					  (cond ((cl:minusp (setq k (cl:- (preci! nmbr) k 1)))
	 nmbr)											 nmbr)
	((equal k 0) (round!last nmbr))								((equal k 0) (round!last nmbr))
	(t (round!last (decprec! nmbr k)))))							(t (round!last (decprec! nmbr k)))))

;; This function rounds a number N and returns an equivalent number			;; This function rounds a number N and returns an equivalent number
;; having the exponent K if the exponent of N is less than K, else it			;; having the exponent K if the exponent of N is less than K, else it
;; returns the given number unchanged.							;; returns the given number unchanged.
(defun round!ep (nmbr k)								(defun round!ep (nmbr k)
  (unless (bigfloatp nmbr)								  (unless (bigfloatp nmbr)
    (error "Invalid argument to cut!ep: ~S" nmbr))					    (error "Invalid argument to cut!ep: ~S" nmbr))
  (unless (integerp k)									  (unless (integerp k)
    (error "Invalid precision to cut!ep: ~D" k))  					    (error "Invalid precision to cut!ep: ~D" k))  
  (cond ((cl:< (setq k (cl:- (cl:1- k) (bigfloat-exponent nmbr))) 0)			  (cond ((cl:< (setq k (cl:- (cl:1- k) (bigfloat-exponent nmbr))) 0)
	 nmbr)											 nmbr)
	((equal k 0) (round!last nmbr))								((equal k 0) (round!last nmbr))
	(t (round!last (decprec! nmbr k)))))							(t (round!last (decprec! nmbr k)))))
 
;; This function rounds a number N at its last place.				    |	(defmethod print-object ((number bigfloat) stream)
(defun round!last (nmbr)							    |	  (setq number (round!mt number (cl:- *REAL-PRECISION* 2)))
  (let ((abs-nmbr (cl:abs (bigfloat-mantissa nmbr)))				    |	  (with-slots (mantissa exponent) number 
	n)									    |	    (let ((u (convert-number->characters (cl:abs mantissa)))
    (setq n (if (cl:< (rem abs-nmbr 10) 5)					    |		  k)
		(cl:truncate abs-nmbr 10)					    |	      (flet ((bfprin1 (u)
		(1+ (cl:truncate abs-nmbr 10))))				    |		       (when (cl:minusp mantissa)
    (if (cl:minusp (bigfloat-mantissa nmbr)) (setq n (cl:- n)))			    |			 (push #\- u))
    (make-bigfloat *domain*  n (cl:1+ (bigfloat-exponent nmbr)))))		    |		       ;; Suppress trailing zeroes
										    >		       (loop for v on (reverse u)
										    >			     while (and (char= (first v) #\0)
										    >					(if (rest v) (char/= (second v) #\.)
										    >					    t))
										    >			     finally (setq u (nreverse v)))
										    >		       ;; Now print the number
										    >		       (loop for char in u
										    >			     do (write-char char stream))))
										    >		(or (rest u) (push #\0 (rest u)))
										    >		(push #\. (rest u))
										    >		(bfprin1 u)
										    >		(princ "B" stream)
										    >		(setq u (convert-number->characters (cl:abs (setq k (order! number)))))
										    >		(setq u (cons (if (cl:< k 0) #\- #\+)
										    >			      u))
										    >		(loop for char in u
										    >		      do (write-char char stream))
										    >		number))))

;;; Routines for reading/printing numbers						;;; Routines for reading/printing numbers
 											 
;; This function reads a long number N represented by a list in a way			;; This function reads a long number N represented by a list in a way
;; described below, and constructs a big-float representation of N.			;; described below, and constructs a big-float representation of N.
;; Using this function, you can input any long floating-point numbers			;; Using this function, you can input any long floating-point numbers
;; without difficulty.  L is a list of integers, the first element of			;; without difficulty.  L is a list of integers, the first element of
;; which gives the order of N and all the next elements when				;; which gives the order of N and all the next elements when
;; concatenated give the mantissa of N.							;; concatenated give the mantissa of N.
;;    **** ORDER(N)=K IF 10**K <= ABS(N) < 10**(K+1).					;;    **** ORDER(N)=K IF 10**K <= ABS(N) < 10**(K+1).

(defun read!lnum (l)									(defun read!lnum (l)
  (loop for q in l									  (loop for q in l
	unless (integerp q)									unless (integerp q)
	  do (error "Invalid argument to read!lnum: ~S" q))				        do (error "Invalid argument to read!lnum: ~S" q))
  (loop for term in (rest l)								  (loop for term in (rest l)
	for k = (cl:ceiling (integer-length term) #.(cl:log 10 2))				for k = (cl:ceiling (integer-length term) #.(cl:log 10 2))
	with mt = 0										with mt = 0
	and ep = (1+ (first l))									and ep = (1+ (first l))
	do (setq mt (cl:+ (cl:* mt (cl:expt 10 k)) (cl:abs term)))				do (setq mt (cl:+ (cl:* mt (cl:expt 10 k)) (cl:abs term)))
	   (setq ep (cl:- ep k))							        (setq ep (cl:- ep k))
	finally (return 									finally (return 
		  (make-bigfloat *domain*								  (make-bigfloat *domain*
		    (if (cl:plusp (second l)) mt (cl:- mt))				                                 (if (cl:plusp (second l)) mt (cl:- mt))
		    ep))))								                                 ep))))

;; This function reads a long number N represented by a list in a way			;; This function reads a long number N represented by a list in a way
;; described below, and constructs a big-float representation of N.			;; described below, and constructs a big-float representation of N.
;; Using this function, you can input any long floating-point numbers			;; Using this function, you can input any long floating-point numbers
;; without difficulty.  L is a list of integers, the first element of			;; without difficulty.  L is a list of integers, the first element of
;; which gives the order of N and all the next elements when				;; which gives the order of N and all the next elements when
;; concatenated give the mantissa of N.							;; concatenated give the mantissa of N.
;;  **** ORDER(N)=K IF 10**K <= ABS(N) < 10**(K+1).       				;;  **** ORDER(N)=K IF 10**K <= ABS(N) < 10**(K+1).       

(defun read!num (n)									(defun read!num (n)
  (let ((exponent 0))									  (let ((exponent 0))
    (multiple-value-bind (integer j)							    (multiple-value-bind (integer j)
	(parse-integer n :junk-allowed t)							(parse-integer n :junk-allowed t)
      (unless integer									      (unless integer
	(setq integer 0))									(setq integer 0))
      (cond ((char= (aref n j) #\.)							      (cond ((char= (aref n j) #\.)
	     (multiple-value-bind (fraction i)							     (multiple-value-bind (fraction i)
		 (parse-integer n :start (1+ j) :junk-allowed t)					 (parse-integer n :start (1+ j) :junk-allowed t)
	       (setq integer (cl:+ (cl:* integer						       (setq integer (cl:+ (cl:* integer
					     (cl:expt 10 (cl:- i j 1)))			                                         (cl:expt 10 (cl:- i j 1)))
				     fraction))						                                   fraction))
	       (decf exponent (cl:- i j 1)))))							       (decf exponent (cl:- i j 1)))))
      (make-bigfloat *domain* integer exponent))))					      (make-bigfloat *domain* integer exponent))))

										    >	(defgeneric convert-to-bigfloat (number)
										    >	  (:documentation
										    >	   "Return the bigfloat representation of the number."))
										    >
(defmethod convert-to-bigfloat ((x rational-integer))					(defmethod convert-to-bigfloat ((x rational-integer))
  (make-bigfloat (domain-of x) (integer-value x) 0))					  (make-bigfloat (domain-of x) (integer-value x) 0))

(defmethod convert-to-bigfloat ((x rational-number))					(defmethod convert-to-bigfloat ((x rational-number))
  (let ((domain (domain-of x)))								  (let ((domain (domain-of x)))
     (/ (make-bigfloat domain (qo-numerator x) 0)					    (/ (make-bigfloat domain (qo-numerator x) 0)
	(make-bigfloat domain (qo-denominator x) 0))))					       (make-bigfloat domain (qo-denominator x) 0))))

(defmethod convert-to-bigfloat ((x floating-point-number))				(defmethod convert-to-bigfloat ((x floating-point-number))
  (let ((domain (domain-of x))								  (let ((domain (domain-of x))
	(float (fp-value x)))									(float (fp-value x)))
    (multiple-value-bind (mantissa expt sign) (integer-decode-float float)		    (multiple-value-bind (mantissa expt sign) (integer-decode-float float)
      (if (cl:minusp expt)								      (if (cl:minusp expt)
	  (/ (make-bigfloat domain (cl:* mantissa sign) 0)					  (/ (make-bigfloat domain (cl:* mantissa sign) 0)
	     (make-bigfloat domain (cl:expt (float-radix float) (cl:- expt)) 0))		     (make-bigfloat domain (cl:expt (float-radix float) (cl:- expt)) 0))
	  (* (make-bigfloat domain (cl:* mantissa sign) 0)					  (* (make-bigfloat domain (cl:* mantissa sign) 0)
	     (make-bigfloat domain (cl:expt (float-radix float) expt) 0))))))			     (make-bigfloat domain (cl:expt (float-radix float) expt) 0))))))

 											;;;  Arithmetic manipulation routines
;;;  Arithmetic manipulation routines
 											(defun bf-abs (nmbr)
(defun bf-abs (nmbr)									  (if (cl:> (bigfloat-mantissa nmbr) 0) nmbr
  (if (cl:> (bigfloat-mantissa nmbr) 0) nmbr						      (make-bigfloat *domain*
      (make-bigfloat *domain*								                     (cl:- (bigfloat-mantissa nmbr))
	(cl:- (bigfloat-mantissa nmbr))							                     (bigfloat-exponent nmbr))))
	(bigfloat-exponent nmbr))))
											(defun bf-minus (nmbr)
(defun bf-minus (nmbr)									  (make-bigfloat *domain*
  (make-bigfloat *domain*								                 (cl:- (bigfloat-mantissa nmbr))
    (cl:- (bigfloat-mantissa nmbr))							                 (bigfloat-exponent nmbr)))
    (bigfloat-exponent nmbr)))								 
 											(defun bf-plus (n1 n2)
(defun bf-plus (n1 n2)									  (let ((e1 (bigfloat-exponent n1)) (e2 (bigfloat-exponent n2)))
  (let ((e1 (bigfloat-exponent n1)) (e2 (bigfloat-exponent n2)))			    (cond ((cl:= e1 e2)
    (cond ((cl:= e1 e2)										   (make-bigfloat *domain*
	   (make-bigfloat *domain*							                          (cl:+ (bigfloat-mantissa n1) (bigfloat-mantissa n2))
	     (cl:+ (bigfloat-mantissa n1) (bigfloat-mantissa n2))			                          e1))
	     e1))										  ((cl:> e1 e2)
	  ((cl:> e1 e2)										   (make-bigfloat *domain*
	   (make-bigfloat *domain*							                          (cl:+ (bigfloat-mantissa (incprec! n1 (cl:- e1 e2)))
	     (cl:+ (bigfloat-mantissa (incprec! n1 (cl:- e1 e2)))			                                (bigfloat-mantissa n2))
		     (bigfloat-mantissa n2))						                          e2))
	     e2))										  (t (make-bigfloat *domain*
	  (t (make-bigfloat *domain*							                            (cl:+ (bigfloat-mantissa n1)
	       (cl:+ (bigfloat-mantissa n1)						                                  (bigfloat-mantissa (incprec! n2 (cl:- e2 e1))))
		       (bigfloat-mantissa (incprec! n2 (cl:- e2 e1))))			                            e1))))) 
	       e1))))) 
											(defun bf-difference (n1 n2)
(defun bf-difference (n1 n2)								  (let ((e1 (bigfloat-exponent n1)) (e2 (bigfloat-exponent n2)))
  (let ((e1 (bigfloat-exponent n1)) (e2 (bigfloat-exponent n2)))			    (cond ((cl:= e1 e2)
    (cond ((cl:= e1 e2)										   (make-bigfloat *domain*
	   (make-bigfloat *domain*							                          (cl:- (bigfloat-mantissa n1) (bigfloat-mantissa n2))
	     (cl:- (bigfloat-mantissa n1) (bigfloat-mantissa n2))			                          e1))
	     e1))										  ((cl:> e1 e2)
	  ((cl:> e1 e2)										   (make-bigfloat *domain*
	   (make-bigfloat *domain*							                          (cl:- (bigfloat-mantissa (incprec! n1 (cl:- e1 e2)))
	     (cl:- (bigfloat-mantissa (incprec! n1 (cl:- e1 e2)))			                                (bigfloat-mantissa n2))
		     (bigfloat-mantissa n2))						                          e2))
	     e2))										  (t 
	  (t 											   (make-bigfloat *domain*
	   (make-bigfloat *domain*							                          (cl:- (bigfloat-mantissa n1)
	       (cl:- (bigfloat-mantissa n1)						                                (bigfloat-mantissa (incprec! n2 (cl:- e2 e1))))
		       (bigfloat-mantissa (incprec! n2 (cl:- e2 e1))))			                          e1)))))
	       e1)))))
											(defun bf-times (n1 n2)
(defun bf-times (n1 n2)									  (make-bigfloat *domain*
  (make-bigfloat *domain*								                 (cl:* (bigfloat-mantissa n1) (bigfloat-mantissa n2))
    (cl:* (bigfloat-mantissa n1) (bigfloat-mantissa n2))				                 (cl:+ (bigfloat-exponent n1) (bigfloat-exponent n2)))) 
    (cl:+ (bigfloat-exponent n1) (bigfloat-exponent n2)))) 				 
 											(defun bf-quotient (n1 n2 k)
(defun bf-quotient (n1 n2 k)								  (round!mt
  (round!mt										   (with-slots (mantissa exponent) (conv!mt n1 (cl:+ k (preci! n2) 1))
   (with-slots (mantissa exponent) (conv!mt n1 (cl:+ k (preci! n2) 1))			     (make-bigfloat *domain*
     (make-bigfloat *domain*								                    (cl:truncate mantissa (bigfloat-mantissa n2))
       (cl:truncate mantissa (bigfloat-mantissa n2))					                    (cl:- exponent (bigfloat-exponent n2))))
       (cl:- exponent (bigfloat-exponent n2))))						   k)) 
   k)) 											 
 											;; This function calculates the kth power of 'n'. The result will
;; This function calculates the kth power of 'n'. The result will			;; become a long number if abs(k) >> 1.                             
;; become a long number if abs(k) >> 1.                             			(defun bf-expt (number k precision)
(defun bf-expt (number k precision)							  (if (cl:< k 0)
  (if (cl:< k 0)									      (/ (make-bigfloat *domain* 1 0)
      (/ (make-bigfloat *domain* 1 0)								 (bf-expt number (cl:- k) precision))
	 (bf-expt number (cl:- k) precision))						      (%funcall (repeated-squaring
      (%funcall (repeated-squaring							                 #'(lambda (a b) (round!mt (bf-times a b) precision))
		      #'(lambda (a b) (round!mt (bf-times a b) precision))		                 (make-bigfloat *domain* 1 0))
		      (make-bigfloat *domain* 1 0))					                number k)))
		    number k)))
											;; This function calculates the integer quotient of 'n1' and 'n2',
;; This function calculates the integer quotient of 'n1' and 'n2',			;; just as the quotient" for integers does.
;; just as the quotient" for integers does.						(defun bf-floor (n1 n2)
(defun bf-floor (n1 n2)									  (let ((e1 (bigfloat-exponent n1))
  (let ((e1 (bigfloat-exponent n1))								(e2 (bigfloat-exponent n2)))
	(e2 (bigfloat-exponent n2)))							    (cond ((cl:= e1 e2)
    (cond ((cl:= e1 e2)										   (make-bigfloat *domain*
	   (make-bigfloat *domain*							                          (cl:truncate (bigfloat-mantissa n1) (bigfloat-mantissa n
	     (cl:truncate (bigfloat-mantissa n1) (bigfloat-mantissa n2))		                          0))
	     0))										  ((cl:> e1 e2)
	  ((cl:> e1 e2)										   (bf-floor (incprec! n1 (cl:- e1 e2)) n2))
	   (bf-floor (incprec! n1 (cl:- e1 e2)) n2))						  (t  (bf-floor n1 (incprec! n2 (cl:- e2 e1)))))))
	  (t  (bf-floor n1 (incprec! n2 (cl:- e2 e1)))))))
											(defun bf-integer-part (num)
(defun bf-integer-part (num)								  (with-slots (exponent mantissa) num
  (with-slots (exponent mantissa) num							    (if (cl:zerop exponent) mantissa
    (if (cl:zerop exponent) mantissa								(cl:* mantissa (cl:expt 10 exponent)))))
	(cl:* mantissa (cl:expt 10 exponent)))))
											;; This returns a lisp integer as its first return value  (perhaps
;; This returns a lisp integer as its first return value  (perhaps			;; this should be a floating point integer)?
;; this should be a floating point integer)?
										    (
										    >	(defgeneric floor1 (number)
										    >	  (:documentation
										    >	   "Return the quotient truncated towards negative infinity."))
										    >
(defmethod floor1 ((number bigfloat))							(defmethod floor1 ((number bigfloat))
  (let ((domain (domain-of number))							  (let ((domain (domain-of number))
	quo)											quo)
    (bind-domain-context domain								    (bind-domain-context domain
      (setq quo (cut!ep number 0))							      (setq quo (cut!ep number 0))
      (values (bf-integer-part quo)							      (values (bf-integer-part quo)
	      (bf-difference number quo)))))							      (bf-difference number quo)))))

(defmethod floor2 ((number bigfloat) modulus)						(defmethod floor2 ((number bigfloat) modulus)
  (let ((domain (domain-of number))							  (let ((domain (domain-of number))
	quo)											quo)
    (bind-domain-context domain								    (bind-domain-context domain
      (setq modulus (coerce modulus (domain-of number)))				      (setq modulus (coerce modulus (domain-of number)))
      (setq quo (bf-floor number modulus))						      (setq quo (bf-floor number modulus))
      (values (bf-integer-part quo)							      (values (bf-integer-part quo)
	      (bf-difference number (bf-times quo modulus))))))					      (bf-difference number (bf-times quo modulus))))))

										    >	(defgeneric ceiling1 (number)
										    >	  (:documentation
										    >	   "Return the quotient truncated towards positive infinity."))
										    >
(defmethod ceiling1 ((number bigfloat))							(defmethod ceiling1 ((number bigfloat))
  (let ((domain (domain-of number))							  (let ((domain (domain-of number))
	quo)											quo)
    (bind-domain-context domain								    (bind-domain-context domain
      (setq quo (cut!ep number 0))							      (setq quo (cut!ep number 0))
      (unless (eql quo number)								      (unless (eql quo number)
	(setq quo (+ 1 quo)))									(setq quo (+ 1 quo)))
      (values (bf-integer-part quo)							      (values (bf-integer-part quo)
	      (bf-difference number quo)))))							      (bf-difference number quo)))))

(defmethod ceiling2 ((number bigfloat) modulus)						(defmethod ceiling2 ((number bigfloat) modulus)
  (let ((domain (domain-of number))							  (let ((domain (domain-of number))
	quo)											quo)
    (bind-domain-context domain								    (bind-domain-context domain
      (setq modulus (coerce modulus (domain-of number)))				      (setq modulus (coerce modulus (domain-of number)))
      (setq quo (bf-floor number modulus))						      (setq quo (bf-floor number modulus))
      (unless (eql quo (cut!ep quo 0))							      (unless (eql quo (cut!ep quo 0))
	(setq quo (+ 1 quo)))									(setq quo (+ 1 quo)))
      (values (bf-integer-part quo)							      (values (bf-integer-part quo)
	      (bf-difference number (bf-times quo modulus))))))					      (bf-difference number (bf-times quo modulus))))))

										    >	(defgeneric round1 (number)
										    >	  (:documentation
										    >	   "Return the quotient rounded to the nearest integer."))
										    >
(defmethod round1 ((number bigfloat))							(defmethod round1 ((number bigfloat))
  (let ((domain (domain-of number))							  (let ((domain (domain-of number))
	quo)											quo)
    (bind-domain-context domain								    (bind-domain-context domain
      (setq quo (floor (+ (coerce 1/2 domain) number))) 				      (setq quo (floor (+ (coerce 1/2 domain) number))) 
      (values quo (bf-difference number (coerce quo domain))))))			      (values quo (bf-difference number (coerce quo domain))))))

(defmethod round2 ((number bigfloat) modulus)						(defmethod round2 ((number bigfloat) modulus)
  (let ((domain (domain-of number))							  (let ((domain (domain-of number))
	quo)											quo)
    (bind-domain-context domain								    (bind-domain-context domain
      (setq modulus (coerce modulus domain))						      (setq modulus (coerce modulus domain))
      (setq quo (bf-floor (+ number (* (coerce 1/2 domain) modulus))			      (setq quo (bf-floor (+ number (* (coerce 1/2 domain) modulus))
			  modulus))										  modulus))
      (values quo									      (values quo
	      (bf-difference									      (bf-difference
	       number										       number
	       (bf-times (coerce quo domain) modulus))))))					       (bf-times (coerce quo domain) modulus))))))

										    >	(defgeneric truncate1 (number)
										    >	  (:documentation
										    >	   "Return a quotient that has been truncated towards zero."))
										    >
(defmethod truncate1 ((num bigfloat))							(defmethod truncate1 ((num bigfloat))
  (if (plus? num)									  (if (plus? num)
      (floor1 num)									      (floor1 num)
      (ceiling1 num)))									      (ceiling1 num)))

(defmethod truncate2 ((num bigfloat) modulus)						(defmethod truncate2 ((num bigfloat) modulus)
  (if (plus? num)									  (if (plus? num)
      (floor2 num modulus)      							      (floor2 num modulus)      
      (ceiling2 num modulus)))								      (ceiling2 num modulus)))

;;;  Arithmetic predicates								;;;  Arithmetic predicates
 											 
(defun bf-binary= (n1 n2)  								(defun bf-binary= (n1 n2)  
  (with-slots ((e1 exponent)) n1							  (with-slots ((e1 exponent)) n1
    (with-slots ((e2 exponent)) n2							    (with-slots ((e2 exponent)) n2
      (and (cl:=  e1 e2)								      (and (cl:=  e1 e2)
	   (cl:= (bigfloat-mantissa n1) (bigfloat-mantissa n2))))))				   (cl:= (bigfloat-mantissa n1) (bigfloat-mantissa n2))))))
 											 
(defun bf-binary>= (n1 n2)								(defun bf-binary>= (n1 n2)
  (with-slots ((e1 exponent)) n1							  (with-slots ((e1 exponent)) n1
    (with-slots ((e2 exponent)) n2							    (with-slots ((e2 exponent)) n2
      (cond ((cl:=  e1 e2)								      (cond ((cl:=  e1 e2)
	     (cl:>= (bigfloat-mantissa n1) (bigfloat-mantissa n2)))				     (cl:>= (bigfloat-mantissa n1) (bigfloat-mantissa n2)))
	    ((cl:> e1 e2)									    ((cl:> e1 e2)
	     (cl:> (bigfloat-mantissa (incprec! n1 (cl:- e1 e2)))				     (cl:> (bigfloat-mantissa (incprec! n1 (cl:- e1 e2)))
		     (bigfloat-mantissa n2)))						                   (bigfloat-mantissa n2)))
	    ((cl:>= (bigfloat-mantissa n1)							    ((cl:>= (bigfloat-mantissa n1)
		      (bigfloat-mantissa (incprec! n2 (cl:- e2 e1))))			                    (bigfloat-mantissa (incprec! n2 (cl:- e2 e1))))
	     t)											     t)
	    (t nil)))))										    (t nil)))))

(defun bf-binary> (n1 n2)								(defun bf-binary> (n1 n2)
  (with-slots ((e1 exponent)) n1							  (with-slots ((e1 exponent)) n1
    (with-slots ((e2 exponent)) n2							    (with-slots ((e2 exponent)) n2
      (cond ((cl:=  e1 e2)								      (cond ((cl:=  e1 e2)
	     (cl:> (bigfloat-mantissa n1) (bigfloat-mantissa n2)))				     (cl:> (bigfloat-mantissa n1) (bigfloat-mantissa n2)))
	    ((cl:> e1 e2)									    ((cl:> e1 e2)
	     (cl:> (bigfloat-mantissa (incprec! n1 (cl:- e1 e2)))				     (cl:> (bigfloat-mantissa (incprec! n1 (cl:- e1 e2)))
		     (bigfloat-mantissa n2)))						                   (bigfloat-mantissa n2)))
	    ((cl:> (bigfloat-mantissa n1)							    ((cl:> (bigfloat-mantissa n1)
		     (bigfloat-mantissa (incprec! n2 (cl:- e2 e1))))			                   (bigfloat-mantissa (incprec! n2 (cl:- e2 e1))))
	     t)											     t)
	    (t nil)))))										    (t nil)))))
 											 
(defun bf-integerp (x)									(defun bf-integerp (x)
  (and (bigfloatp x)									  (and (bigfloatp x)
       (not (cl:minusp (bigfloat-exponent x)))))					       (not (cl:minusp (bigfloat-exponent x)))))

;; Elementary Constants									;; Elementary Constants
 											 
;; This function returns the value of constant CNST of the precision			;; This function returns the value of constant CNST of the precision
;; K, if it was calculated previously with, at least, the precision K,			;; K, if it was calculated previously with, at least, the precision K,
;; else it returns :NOT-FOUND.								;; else it returns :NOT-FOUND.
(defun get!const (cnst k)								(defun get!const (cnst k)
  (unless (atom cnst)									  (unless (atom cnst)
    (error "Invalid argument to get!const: ~S" cnst))					    (error "Invalid argument to get!const: ~S" cnst))
  (unless (and (integerp k) (> k 0))							  (unless (and (integerp k) (> k 0))
    (error "Invalid precision to get!const: ~D" k))  					    (error "Invalid precision to get!const: ~D" k))  
  (let ((u (get cnst 'save!c)))								  (let ((u (get cnst 'save!c)))
    (cond ((or (null u) (cl:< (car u) k)) nil)						    (cond ((or (null u) (cl:< (car u) k)) nil)
	  ((equal (car u) k) (cdr u))								  ((equal (car u) k) (cdr u))
	  (t (round!mt (cdr u) k))))) 								  (t (round!mt (cdr u) k))))) 
 											 
;; This function saves the value of constant CNST for the later use.			;; This function saves the value of constant CNST for the later use.
(defun save!const (cnst nmbr)								(defun save!const (cnst nmbr)
  (unless (atom cnst)									  (unless (atom cnst)
    (error "Invalid constant for save!const: ~S" cnst))					    (error "Invalid constant for save!const: ~S" cnst))
  (unless (bigfloatp nmbr)								  (unless (bigfloatp nmbr)
    (error "Invalid argument to  save!const: ~S" nmbr))					    (error "Invalid argument to  save!const: ~S" nmbr))
  (setf (get cnst 'save!c) (cons (preci! nmbr) nmbr)))					  (setf (get cnst 'save!c) (cons (preci! nmbr) nmbr)))

;; This function sets the value of constant CNST.  CNST is the name of			;; This function sets the value of constant CNST.  CNST is the name of
;; the constant.  L is a list of integers, which represents the value			;; the constant.  L is a list of integers, which represents the value
;; of the constant in the way described in the function READ!LNUM.			;; of the constant in the way described in the function READ!LNUM.
(defmacro set!const (constant digits)							(defmacro set!const (constant digits)
  `(progn (save!const ',constant (read!lnum ',digits))					  `(progn (save!const ',constant (read!lnum ',digits))
	  ',constant))									    ',constant))
 											 
(set!const !pi										(set!const !pi
  (0 31415926535897932384626433832795028841971693993751058209749))			           (0 31415926535897932384626433832795028841971693993751058209749))
 											 
(set!const !e										(set!const !e
  (0 27182818284590452353602874713526624977572470936999595749669))			           (0 27182818284590452353602874713526624977572470936999595749669))

(defmacro define-bfloat-constant (name &body form)					(defmacro define-bfloat-constant (name &body form)
  `(defun ,name (prec)									  `(defun ,name (prec)
     (let ((u (get!const ',name prec)))							    (let ((u (get!const ',name prec)))
       (when (eq u :not-found)								      (when (eq u :not-found)
	 (setq u ,@form)								        (setq u ,@form)
	 (save!const ',name u))								        (save!const ',name u))
       u)))										      u)))

(defmethod pi-value ((domain real-numbers))					    <
  (bind-domain-context domain							    <
    (bf-pi *REAL-PRECISION*)))							    <
										    <
(defun bf-pi (precision)							    <
  (cond ((cl:< precision 20)							    <
	 (round!mt (make-bigfloat *domain* 314159265358979323846 -20)		    <
		   precision))							    <
	((get!const '!pi precision))						    <
	((cl:< precision 1000) (bf-pi-machin precision))			    <
	(t (bf-pi-agm precision))))						    <
										    <
;;  This function calculates the value of  `pi' with the precision K by       		;;  This function calculates the value of  `pi' with the precision K by       
;; using Machin's identity:           							;; using Machin's identity:           
;;          PI = 16*ATAN(1/5) - 4*ATAN(1/239).         					;;          PI = 16*ATAN(1/5) - 4*ATAN(1/239).         
;; The calculation is performed mainly on integers.  					;; The calculation is performed mainly on integers.  
(defun bf-pi-machin (k)									(defun bf-pi-machin (k)
  (let* ((k+3 (+ k 3))									  (let* ((k+3 (+ k 3))
	 s											 s
	 (ss (cl:truncate (expt 10 k+3) 5))							 (ss (cl:truncate (expt 10 k+3) 5))
	 (n ss)											 (n ss)
	 (m 1)											 (m 1)
	 (x -25)										 (x -25)
	 u)											 u)
    (loop while (not (cl:zerop n)) do							    (loop while (not (cl:zerop n)) do
      (setq n (cl:truncate n x))							      (setq n (cl:truncate n x))
      (setq ss (+ ss (cl:truncate n (setq m (+ m 2))))))				      (setq ss (+ ss (cl:truncate n (setq m (+ m 2))))))
    (setq s (setq n (cl:truncate (expt 10 k+3) 239)))					    (setq s (setq n (cl:truncate (expt 10 k+3) 239)))
    (setq x (- (expt 239 2)))								    (setq x (- (expt 239 2)))
    (setq m 1)										    (setq m 1)
    (loop while (not (cl:zerop n)) do							    (loop while (not (cl:zerop n)) do
      (setq n (cl:truncate n x))							      (setq n (cl:truncate n x))
      (setq s (+ s (cl:truncate n (setq m (+ m 2))))))					      (setq s (+ s (cl:truncate n (setq m (+ m 2))))))
    (setq u (round!mt (make-bigfloat *domain* (- (* 16 ss) (* 4 s)) (- k+3))		    (setq u (round!mt (make-bigfloat *domain* (- (* 16 ss) (* 4 s)) (- k+3))
		      k))										      k))
    (save!const '!pi u)									    (save!const '!pi u)
    u))											    u))
 
										    >	;; This function calculates the square root of X with the precision K,
										    >	;; by Newton's iteration method.
										    >	(defun bf-sqrt (x k)
										    >	  (if (0? x) (coerce 0 *domain*)
										    >	      (let* ((k2 (+ k 2))
										    >		     (ncut (- k2 (cl:truncate (1+ (order! x)) 2)))
										    >		     (half (coerce 1/2 *domain*))
										    >		     (dcut (make-bigfloat *domain* 10 (- ncut)))
										    >		     (dy (make-bigfloat *domain* 20 (- ncut)))
										    >		     (nfig 1)
										    >		     (y0 (conv!mt x 2))
										    >		     y u)
										    >		(setq y0 (if (cl:zerop (rem (bigfloat-exponent y0) 2))
										    >			     (make-bigfloat *domain*
										    >			       (+ 3 (* 2 (cl:truncate (bigfloat-mantissa y0) 25)))
										    >			       (cl:truncate (bigfloat-exponent y0) 2))
										    >			     (make-bigfloat *domain*
										    >			       (+ 10 (* 2 (cl:truncate (bigfloat-mantissa y0) 9)))
										    >			       (cl:truncate (- (bigfloat-exponent y0) 1) 2))))
										    >		(loop while (or (< nfig k2)
										    >				(> (bf-abs dy) dcut))
										    >		      do (if (> (setq nfig (* 2 nfig)) k2)
										    >			     (setq nfig k2))
										    >			 (setq u (bf-quotient x y0 nfig))
										    >			 (setq y (bf-times (bf-plus y0 u) half))
										    >			 (setq dy (bf-difference y y0))
										    >			 (setq y0 y))
										    >		(round!mt y k)))) 
										    >	 
;; This function calculates the value of 'PI', with the precision K, by			;; This function calculates the value of 'PI', with the precision K, by
;; the arithmetic-geometric mean method.  (R. Brent, JACM vol.23, #2,			;; the arithmetic-geometric mean method.  (R. Brent, JACM vol.23, #2,
;; pp.242-251(1976).)									;; pp.242-251(1976).)
(defun bf-pi-agm (k)									(defun bf-pi-agm (k)
  (let* ((n 1)										  (let* ((n 1)
	 (k2 (+ k 2))										 (k2 (+ k 2))
	 (u (coerce 1/4 *domain*))								 (u (coerce 1/4 *domain*))
	 (half (coerce 1/2 *domain*))								 (half (coerce 1/2 *domain*))
	 (dcut (make-bigfloat *domain* 10 (- k2)))						 (dcut (make-bigfloat *domain* 10 (- k2)))
	 (x (coerce 1 *domain*))								 (x (coerce 1 *domain*))
	 (y (bf-quotient x (bf-sqrt (coerce 2 *domain*) k2) k2))				 (y (bf-quotient x (bf-sqrt (coerce 2 *domain*) k2) k2))
	 v)											 v)
    (loop while (> (bf-abs (bf-difference x y)) dcut) do				    (loop while (> (bf-abs (bf-difference x y)) dcut) do
      (setq v x)									          (setq v x)
      (setq x (bf-times (bf-plus x y) half))						          (setq x (bf-times (bf-plus x y) half))
      (setq y (bf-sqrt (cut!ep (bf-times y v) (- k2)) k2))				          (setq y (bf-sqrt (cut!ep (bf-times y v) (- k2)) k2))
      (setq v (bf-difference x v))							          (setq v (bf-difference x v))
      (setq v (bf-times (bf-times v v) (coerce n *domain*)))				          (setq v (bf-times (bf-times v v) (coerce n *domain*)))
      (setq u (bf-difference u (cut!ep v (- k2))))					          (setq u (bf-difference u (cut!ep v (- k2))))
      (setq n (* 2 n)))									          (setq n (* 2 n)))
    (setq v (cut!mt (bf-expt (bf-plus x y) 2 k2) k2))					    (setq v (cut!mt (bf-expt (bf-plus x y) 2 k2) k2))
    (setq u (bf-quotient v (bf-times (coerce 4 *domain*) u) k))				    (setq u (bf-quotient v (bf-times (coerce 4 *domain*) u) k))
    (save!const '!pi u)									    (save!const '!pi u)
    u))											    u))

;; This function calculates the value of 'E', the base of the natural		    |	(defun bf-pi (precision)
;; logarithm, with precision K, by summing the Taylor series for		    |	  (cond ((cl:< precision 20)
;; EXP(X=1).									    |		 (round!mt (make-bigfloat *domain* 314159265358979323846 -20)
(defmethod e-value ((domain real-numbers))					    |			   precision))
										    >		((get!const '!pi precision))
										    >		((cl:< precision 1000) (bf-pi-machin precision))
										    >		(t (bf-pi-agm precision))))
										    >
										    >	(defgeneric pi-value (domain)
										    >	  (:documentation
										    >	   "Return the value of PI with the proper precision."))
										    >
										    >	(defmethod pi-value ((domain real-numbers))
  (bind-domain-context domain								  (bind-domain-context domain
    (bf-e *REAL-PRECISION*)))							    |	    (bf-pi *REAL-PRECISION*)))

(defun bf-e (precision)									(defun bf-e (precision)
  (cond ((not (> precision 20))								  (cond ((not (> precision 20))
	 (round!mt (make-bigfloat *domain* 271828182845904523536 -20)				 (round!mt (make-bigfloat *domain* 271828182845904523536 -20)
		   precision))										   precision))
	(t (let* ((u (get!const '!e precision))							(t (let* ((u (get!const '!e precision))
		  (k2 (+ precision 2))									  (k2 (+ precision 2))
		  (m 1)											  (m 1)
		  (n (expt 10 k2))									  (n (expt 10 k2))
		  (ans 0))										  (ans 0))
	     (when (null u)									     (when (null u)
	       (loop while (not (cl:zerop n))							       (loop while (not (cl:zerop n))
		     do (incf ans (setq n (cl:truncate n (incf m)))))					     do (incf ans (setq n (cl:truncate n (incf m)))))
	       (setq ans (+ ans (* 2 (expt 10 k2))))						       (setq ans (+ ans (* 2 (expt 10 k2))))
	       (setq u (round!mt (make-bigfloat *domain* ans (- k2))				       (setq u (round!mt (make-bigfloat *domain* ans (- k2))
				 precision))										 precision))
	       (save!const '!e u))								       (save!const '!e u))
	     u))))										     u))))
 
;;;  Elementary Functions. 							    |	(defgeneric e-value (domain)
 										    |	  (:documentation
;; This function calculates the square root of X with the precision K,		    |	   "Return the value of e with the proper precision."))
;; by Newton's iteration method.						    <
(defun bf-sqrt (x k)								    <
  (if (0? x) (coerce 0 *domain*)						    <
      (let* ((k2 (+ k 2))							    <
	     (ncut (- k2 (cl:truncate (1+ (order! x)) 2)))			    <
	     (half (coerce 1/2 *domain*))					    <
	     (dcut (make-bigfloat *domain* 10 (- ncut)))			    <
	     (dy (make-bigfloat *domain* 20 (- ncut)))				    <
	     (nfig 1)								    <
	     (y0 (conv!mt x 2))							    <
	     y u)								    <
	(setq y0 (if (cl:zerop (rem (bigfloat-exponent y0) 2))			    <
		     (make-bigfloat *domain*					    <
		       (+ 3 (* 2 (cl:truncate (bigfloat-mantissa y0) 25)))	    <
		       (cl:truncate (bigfloat-exponent y0) 2))			    <
		     (make-bigfloat *domain*					    <
		       (+ 10 (* 2 (cl:truncate (bigfloat-mantissa y0) 9)))	    <
		       (cl:truncate (- (bigfloat-exponent y0) 1) 2))))		    <
	(loop while (or (< nfig k2)						    <
			(> (bf-abs dy) dcut))					    <
	      do (if (> (setq nfig (* 2 nfig)) k2)				    <
		     (setq nfig k2))						    <
		 (setq u (bf-quotient x y0 nfig))				    <
		 (setq y (bf-times (bf-plus y0 u) half))			    <
		 (setq dy (bf-difference y y0))					    <
		 (setq y0 y))							    <
	(round!mt y k)))) 							    <
 
										    >	;; This function calculates the value of 'E', the base of the natural
										    >	;; logarithm, with precision K, by summing the Taylor series for
										    >	;; EXP(X=1).
										    >	(defmethod e-value ((domain real-numbers))
										    >	  (bind-domain-context domain
										    >	    (bf-e *REAL-PRECISION*)))
 
;; This function calculates the value of the exponential function at		    |	;;;  Elementary Functions.
;; the point 'x', with the precision k, by summing terms of the Taylor		    <
;; series for exp(z), 0 < z < 1.						    <
(defmethod exp ((number bigfloat))						    <
  (bind-domain-context (domain-of number)					    <
    (bf-exp number *REAL-PRECISION*)))						    <

(defun bf-exp (x k)									(defun bf-exp (x k)
  (cond ((0? x) (coerce 1 *domain*))							  (cond ((0? x) (coerce 1 *domain*))
	(t (let* ((k2 (+ k 2))									(t (let* ((k2 (+ k 2))
		  (one (coerce 1 *domain*))								  (one (coerce 1 *domain*))
		  (y (bf-abs x))									  (y (bf-abs x))
		  (m (floor y))										  (m (floor y))
		  (q (coerce m *domain*))								  (q (coerce m *domain*))
		  (r (bf-difference y q))								  (r (bf-difference y q))
		  yq yr)										  yq yr)
	     (setq yq (if (cl:zerop m) one							     (setq yq (if (cl:zerop m) one
			  (bf-expt (bf-e k2) m k2)))								  (bf-expt (bf-e k2) m k2)))
	     (cond ((0? r) (setq yr one))							     (cond ((0? r) (setq yr one))
		   (t (let ((j 0) (n 0)									   (t (let ((j 0) (n 0)
			    (dcut (make-bigfloat *domain* 10 (- k2)))						    (dcut (make-bigfloat *domain* 10 (- k2)))
			    (ri one) (tm one)									    (ri one) (tm one)
			    fctrial)										    fctrial)
			(setq yr one)										(setq yr one)
			(setq m 1)										(setq m 1)
			(loop while (> tm dcut) do								(loop while (> tm dcut) do
			  (setq fctrial							                              (setq fctrial
				(coerce							                                    (coerce
				  (setq m (* m (setq j (1+ j)))) *domain*))		                                     (setq m (* m (setq j (1+ j)))) *domain*))
			  (setq ri (cut!ep (bf-times ri r) (- k2)))			                              (setq ri (cut!ep (bf-times ri r) (- k2)))
			  (setq n (max 1 (+ (- k2 (order! fctrial))			                              (setq n (max 1 (+ (- k2 (order! fctrial))
					    (order! ri))))				                                                (order! ri))))
			  (setq tm (bf-quotient ri fctrial n))				                              (setq tm (bf-quotient ri fctrial n))
			  (setq yr (bf-plus yr tm))					                              (setq yr (bf-plus yr tm))
			  (cond ((cl:zerop (rem j 10))					                              (cond ((cl:zerop (rem j 10))
				 (setq yr (cut!ep yr (- k2)))))))))			                                     (setq yr (cut!ep yr (- k2)))))))))
	     (setq y (cut!mt (bf-times yq yr) (1+ k)))						     (setq y (cut!mt (bf-times yq yr) (1+ k)))
	     (if (minus? x) (bf-quotient one y k)						     (if (minus? x) (bf-quotient one y k)
		 (round!last y)))))) 									 (round!last y)))))) 
 
 										    |	;; This function calculates the value of the exponential function at
;; This function calculates log(x) by summing terms of the     			    |	;; the point 'x', with the precision k, by summing terms of the Taylor
;; Taylor series for LOG(1+Z), 0 < Z < 0.10518. 				    |	;; series for exp(z), 0 < z < 1.
(defmethod log ((x bigfloat))							    |	(defmethod exp ((number bigfloat))
  (bind-domain-context (domain-of x)						    |	  (bind-domain-context (domain-of number)
    (bf-log x *REAL-PRECISION*)))						    |	    (bf-exp number *REAL-PRECISION*)))
										    <
(defmethod-sd log2 ((x bigfloat) (base bigfloat))				    <
  (let ((k2 (+ 2 *REAL-PRECISION*)))						    <
    (bind-domain-context domain							    <
      (bf-quotient (bf-log x k2) (bf-log base k2) (- k2 2)))))			    <

(defun bf-log (x k)									(defun bf-log (x k)
  (when (not (plus? x))									  (when (not (plus? x))
    (error "Invalid argument to log: ~S" x))						    (error "Invalid argument to log: ~S" x))
  (unless (and (integerp k) (> k 0))							  (unless (and (integerp k) (> k 0))
    (error "Invalid precision to log: ~D" k))						    (error "Invalid precision to log: ~D" k))
  (cond ((= x 1)									  (cond ((= x 1)
	 (coerce 0 *domain*))									 (coerce 0 *domain*))
	(t (let* ((m 0)										(t (let* ((m 0)
		  (k2 (+ k 2))										  (k2 (+ k 2))
		  (one (coerce 1 *domain*))								  (one (coerce 1 *domain*))
		  (ee (bf-e k2))									  (ee (bf-e k2))
		  (es (bf-exp (coerce 0.1 *domain*) k2))						  (es (bf-exp (coerce 0.1 *domain*) k2))
		  sign l y z)										  sign l y z)
	     (cond ((> x one) (setq sign one) (setq y x))					     (cond ((> x one) (setq sign one) (setq y x))
		   (t (setq sign (bf-minus one))							   (t (setq sign (bf-minus one))
		      (setq y (bf-quotient one x k2))))							      (setq y (bf-quotient one x k2))))
	     (cond ((< y ee)									     (cond ((< y ee)
		    (setq z y))										    (setq z y))
		   (t 											   (t 
		    (cond ((cl:zerop									    (cond ((cl:zerop
			    (setq m (cl:truncate (* (order! y) 23) 10)))					    (setq m (cl:truncate (* (order! y) 23) 10)))
			   (setq z y))										   (setq z y))
			  (t (setq z (bf-quotient y (bf-expt ee m k2) k2))))					  (t (setq z (bf-quotient y (bf-expt ee m k2) k2))))
		    (loop while (> z ee) do								    (loop while (> z ee) do
		      (setq m (1+ m))							                          (setq m (1+ m))
		      (setq z (bf-quotient z ee k2)))))					                          (setq z (bf-quotient z ee k2)))))
	     (setq l (coerce m *domain*))							     (setq l (coerce m *domain*))
	     (setq y (coerce 0.1 *domain*))							     (setq y (coerce 0.1 *domain*))
	     (loop while (> z es) do								     (loop while (> z es) do
	       (setq l (bf-plus l y))							                   (setq l (bf-plus l y))
	       (setq z (bf-quotient z es k2)))						                   (setq z (bf-quotient z es k2)))
	     (setq z (bf-difference z one))							     (setq z (bf-difference z one))
	     (prog (n dcut tm zi)								     (prog (n dcut tm zi)
	       (setq n 0)								                (setq n 0)
	       (setq y (setq tm (setq zi z)))						                (setq y (setq tm (setq zi z)))
	       (setq z (bf-minus z))							                (setq z (bf-minus z))
	       (setq dcut (make-bigfloat *domain* 10 (- k2)))				                (setq dcut (make-bigfloat *domain* 10 (- k2)))
	       (setq m 1)								                (setq m 1)
	       (loop while (> (bf-abs tm) dcut) do					                (loop while (> (bf-abs tm) dcut) do
		 (setq zi (cut!ep (bf-times zi z) (- k2)))				                      (setq zi (cut!ep (bf-times zi z) (- k2)))
		 (setq n (max 1 (+ k2 (order! zi))))					                      (setq n (max 1 (+ k2 (order! zi))))
		 (setq tm								                      (setq tm
		       (bf-quotient zi (coerce (setq m (1+ m)) *domain*)		                            (bf-quotient zi (coerce (setq m (1+ m)) *domain*)
			  n))								                                         n))
		 (setq y (bf-plus y tm))						                      (setq y (bf-plus y tm))
		 (cond ((cl:zerop (rem m 10))						                      (cond ((cl:zerop (rem m 10))
			(setq y (cut!ep y (- k2)))))))					                             (setq y (cut!ep y (- k2)))))))
	     (setq y (bf-plus y l))								     (setq y (bf-plus y l))
	     (round!mt (bf-times sign y) k)))))							     (round!mt (bf-times sign y) k)))))
 											 
;; This function calculates log(x), the value of the logarithmic			;; This function calculates log(x), the value of the logarithmic
;; function at the point 'x', with the precision k, by solving x =			;; function at the point 'x', with the precision k, by solving x =
;; exp(y) by Newton's method.								;; exp(y) by Newton's method.
;;  x > 0, k is a positive integer                        				;;  x > 0, k is a positive integer                        
#+Ignore										#+Ignore
(defun bf-log-newton (x k)								(defun bf-log-newton (x k)
  (when (not (plus? x))									  (when (not (plus? x))
    (error "Invalid argument to log: ~S" x))						    (error "Invalid argument to log: ~S" x))
  (unless (and (integerp k) (> k 0))							  (unless (and (integerp k) (> k 0))
    (error "Invalid precision to log: ~D" k))						    (error "Invalid precision to log: ~D" k))
  (cond ((bf-equal x (coerce 1 *domain*))						  (cond ((bf-equal x (coerce 1 *domain*))
	 (coerce 0 *domain*))									 (coerce 0 *domain*))
	(t (let* ((k2 (+ k 2))									(t (let* ((k2 (+ k 2))
		  m (one (coerce 1 *domain*))								  m (one (coerce 1 *domain*))
		  (ee (bf-e (+ k2 2)))									  (ee (bf-e (+ k2 2)))
		  sign y z)										  sign y z)
	     (cond ((> x one)									     (cond ((> x one)
		    (setq sign one)									    (setq sign one)
		    (setq y x))										    (setq y x))
		   (t (setq sign (bf-minus one))							   (t (setq sign (bf-minus one))
		      (setq y (bf-quotient one x k2))))							      (setq y (bf-quotient one x k2))))
	     (if (< y ee)									     (if (< y ee)
		 (setq m 0 z y)										 (setq m 0 z y)
		 (cond ((cl:zerop									 (cond ((cl:zerop
			 (setq m (cl:truncate (cl:* (order! y) 23) 10)))					 (setq m (cl:truncate (cl:* (order! y) 23) 10)))
			(setq z y))										(setq z y))
		       (t (setq z (bf-quotient y (bf-expt ee m k2) k2))					       (t (setq z (bf-quotient y (bf-expt ee m k2) k2))
			  (loop while (> z ee) do								  (loop while (> z ee) do
			    (setq m (1+ m))						                                (setq m (1+ m))
			    (setq z (bf-quotient z ee k2))))))				                                (setq z (bf-quotient z ee k2))))))
	     (let ((nfig 0) (n 0)								     (let ((nfig 0) (n 0)
		   (dcut (make-bigfloat *domain* 10 (- k2)))						   (dcut (make-bigfloat *domain* 10 (- k2)))
		   dx											   dx
		   (dy (make-bigfloat *domain* 20 (- k2)))						   (dy (make-bigfloat *domain* 20 (- k2)))
		   x0)											   x0)
	       (setq y (bf-quotient (bf-difference z one)					       (setq y (bf-quotient (bf-difference z one)
				    (coerce 1.72 *domain*) 2))								    (coerce 1.72 *domain*) 2))
	       (setq nfig 1)									       (setq nfig 1)
	       (loop while (or (< nfig k2) (> (bf-abs dy) dcut)) do				       (loop while (or (< nfig k2) (> (bf-abs dy) dcut)) do
		 (cond									                     (cond
		   ((> (setq nfig (* 2 nfig)) k2)					                       ((> (setq nfig (* 2 nfig)) k2)
		    (setq nfig k2)))							                        (setq nfig k2)))
		 (setq x0 (exp* y nfig))						                     (setq x0 (exp* y nfig))
		 (setq dx (bf-difference z x0))						                     (setq dx (bf-difference z x0))
		 (setq n (max 1 (+ nfig (order! dx))))					                     (setq n (max 1 (+ nfig (order! dx))))
		 (setq dy (bf-quotient dx x0 n))					                     (setq dy (bf-quotient dx x0 n))
		 (setq y (bf-plus y dy))))						                     (setq y (bf-plus y dy))))
	     (setq y (bf-plus (coerce m *domain*) y))						     (setq y (bf-plus (coerce m *domain*) y))
	     (round!mt (bf-times sign y) k)))))							     (round!mt (bf-times sign y) k)))))
 
;; This function calculates sin(x), the value of the sine function at		    |	(defmethod-sd log2 ((x bigfloat) (base bigfloat))
;; the point 'x', with the precision k, by summing terms of the Taylor		    |	  (let ((k2 (+ 2 *REAL-PRECISION*)))
;; series for:   sin(z), 0 < Z < PI/4.    					    |	    (bind-domain-context domain
(defmethod sin ((number bigfloat))						    |	      (bf-quotient (bf-log x k2) (bf-log base k2) (- k2 2)))))
  (bind-domain-context (domain-of number)					    <
    (bf-sin number *REAL-PRECISION*)))						    <
										    <
(defun bf-sin (x k)								    <
  (cond ((0? x) (coerce 0 *domain*))						    <
	((minus? x) (bf-minus (bf-sin (bf-minus x) k)))				    <
	(t (let* ((k2 (+ k 2))							    <
		  (m (preci! x))						    <
		  (pi4 (bf-times (bf-pi (+ k2 m)) (coerce 1/4 *domain*)))	    <
		  sign q r y)							    <
	     (cond ((< x pi4)							    <
		    (setq m 0)							    <
		    (setq r x))							    <
		   (t (setq m (floor (setq q (bf-floor x pi4))))		    <
		      (setq r (bf-difference x (bf-times q pi4)))))		    <
	     (setq sign (coerce 1 *domain*))					    <
	     (cond ((not (< m 8)) (setq m (rem m 8))))				    <
	     (cond ((not (< m 4))						    <
		    (setq sign (bf-minus sign))					    <
		    (setq m (- m 4))))						    <
	     (cond ((equal m 1)							    <
		    (setq r (cut!mt (bf-difference pi4 r) k2))			    <
		    (bf-times sign (bf-cos r k)))				    <
		   ((equal m 2)							    <
		    (setq r (cut!mt r k2))					    <
		    (bf-times sign (bf-cos r k)))				    <
		   (t (unless (equal m 0)					    <
			(setq r (cut!mt (bf-difference pi4 r) k2)))		    <
		      (let* ((ncut (- k2 (min 0 (1+ (order! r)))))		    <
			     (dcut (make-bigfloat *domain* 10 (- ncut)))	    <
			     (tm r) (ri r) (j 1) n fctrial)			    <
			(setq y r)						    <
			(setq r (bf-minus (cut!ep (bf-times r r) (- ncut))))	    <
			(setq m 1)						    <
			(loop while (> (bf-abs tm) dcut) do			    <
			  (setq j (+ j 2))					    <
			  (setq fctrial						    <
				(coerce						    <
				  (setq m (* m j (1- j))) *domain*))		    <
			  (setq ri (cut!ep (bf-times ri r) (- ncut)))		    <
			  (setq n (max 1 (+ (- k2 (order! fctrial)) (order! ri))))  <
			  (setq tm (bf-quotient ri fctrial n))			    <
			  (setq y (bf-plus y tm))				    <
			  (cond ((cl:zerop (rem j 20))				    <
				 (setq y (cut!ep y (- ncut)))))))		    <
		      (round!mt (bf-times sign y) k)))))))			    <

;; This function calculates cos(x), the value of the cosine function at		    |	;; This function calculates log(x) by summing terms of the     
;; the point 'x', with the precision k, by summing terms of the Taylor		    |	;; Taylor series for LOG(1+Z), 0 < Z < 0.10518. 
;; series for:   cos(z), 0 < Z < PI/4.    					    |	(defmethod log ((x bigfloat))
(defmethod cos ((number bigfloat))						    |	  (bind-domain-context (domain-of x)
  (bind-domain-context (domain-of number)					    |	    (bf-log x *REAL-PRECISION*)))
    (bf-cos number *REAL-PRECISION*)))						    <

(defun bf-cos (x k)									(defun bf-cos (x k)
  (unless (and (integerp k) (> k 0))							  (unless (and (integerp k) (> k 0))
    (error "Invalid precision to cos: ~D" k))						    (error "Invalid precision to cos: ~D" k))
  (cond ((0? x) (coerce 1 *domain*))							  (cond ((0? x) (coerce 1 *domain*))
	(t (when (minus? x)									(t (when (minus? x)
	     (setq x  (- x)))									     (setq x  (- x)))
	   (let* ((k2 (+ k 2))									   (let* ((k2 (+ k 2))
		  (m (preci! x))									  (m (preci! x))
		  (pi4 (/ (bf-pi (+ k2 m)) 4))								  (pi4 (/ (bf-pi (+ k2 m)) 4))
		  sign q r y)										  sign q r y)
	     (cond ((< x pi4)									     (cond ((< x pi4)
		    (setq m 0)										    (setq m 0)
		    (setq r x))										    (setq r x))
		   (t (setq m (floor (setq q (floor x pi4))))						   (t (setq m (floor (setq q (floor x pi4))))
		      (setq r (- x (* q pi4)))))							      (setq r (- x (* q pi4)))))
	     (setq sign (coerce 1 *domain*))							     (setq sign (coerce 1 *domain*))
	     (cond ((not (< m 8)) (setq m (rem m 8))))						     (cond ((not (< m 8)) (setq m (rem m 8))))
	     (cond ((not (< m 4))								     (cond ((not (< m 4))
		    (setq sign (- sign))								    (setq sign (- sign))
		    (setq m (- m 4))))									    (setq m (- m 4))))
	     (cond ((not (< m 2)) (setq sign (- sign))))					     (cond ((not (< m 2)) (setq sign (- sign))))
	     (cond ((equal m 1)									     (cond ((equal m 1)
		    (setq r (cut!mt (- pi4 r) k2))							    (setq r (cut!mt (- pi4 r) k2))
		    (bf-times sign (bf-sin r k)))							    (bf-times sign (bf-sin r k)))
		   ((equal m 2)										   ((equal m 2)
		    (setq r (cut!mt r k2))								    (setq r (cut!mt r k2))
		    (bf-times sign (bf-sin r k)))							    (bf-times sign (bf-sin r k)))
		   (t (when (= m 3)									   (t (when (= m 3)
			(setq r (cut!mt (- pi4 r) k2)))								(setq r (cut!mt (- pi4 r) k2)))
		      (let ((j 0) (n 0)									      (let ((j 0) (n 0)
			    (dcut (make-bigfloat *domain* 10 (- k2)))						    (dcut (make-bigfloat *domain* 10 (- k2)))
			    fctrial ri tm)									    fctrial ri tm)
			(setq y (setq ri (setq tm (coerce 1 *domain*))))					(setq y (setq ri (setq tm (coerce 1 *domain*))))
			(setq r (- (cut!ep (* r r) (- k2))))							(setq r (- (cut!ep (* r r) (- k2))))
			(setq m 1)										(setq m 1)
			(loop while (> (bf-abs tm) dcut) do							(loop while (> (bf-abs tm) dcut) do
			  (setq j (+ j 2))						                              (setq j (+ j 2))
			  (setq fctrial							                              (setq fctrial
				(coerce							                                    (coerce
				  (setq m (* m j (- j 1))) *domain*))			                                     (setq m (* m j (- j 1))) *domain*))
			  (setq ri (cut!ep (* ri r) (- k2)))				                              (setq ri (cut!ep (* ri r) (- k2)))
			  (setq n (max 1 (+ (- k2 (order! fctrial))			                              (setq n (max 1 (+ (- k2 (order! fctrial))
					    (order! ri))))				                                                (order! ri))))
			  (setq tm (bf-quotient ri fctrial n))				                              (setq tm (bf-quotient ri fctrial n))
			  (setq y (+ y tm))						                              (setq y (+ y tm))
			  (cond ((equal (rem j 20) 0)					                              (cond ((equal (rem j 20) 0)
				 (setq y (cut!ep y (- k2)))))))				                                     (setq y (cut!ep y (- k2)))))))
		      (round!mt (* sign y) k)))))))							      (round!mt (* sign y) k)))))))

;; This function calculates tan(x), the value of the tangent function		    |	(defun bf-sin (x k)
;; at the point 'x', with the precision k, by calculating       		    |	  (cond ((0? x) (coerce 0 *domain*))
;;          sin(x)  or  cos(x) = sin(pi/2-x).       				    |		((minus? x) (bf-minus (bf-sin (bf-minus x) k)))
(defmethod tan ((number bigfloat))						    |		(t (let* ((k2 (+ k 2))
										    >			  (m (preci! x))
										    >			  (pi4 (bf-times (bf-pi (+ k2 m)) (coerce 1/4 *domain*)))
										    >			  sign q r y)
										    >		     (cond ((< x pi4)
										    >			    (setq m 0)
										    >			    (setq r x))
										    >			   (t (setq m (floor (setq q (bf-floor x pi4))))
										    >			      (setq r (bf-difference x (bf-times q pi4)))))
										    >		     (setq sign (coerce 1 *domain*))
										    >		     (cond ((not (< m 8)) (setq m (rem m 8))))
										    >		     (cond ((not (< m 4))
										    >			    (setq sign (bf-minus sign))
										    >			    (setq m (- m 4))))
										    >		     (cond ((equal m 1)
										    >			    (setq r (cut!mt (bf-difference pi4 r) k2))
										    >			    (bf-times sign (bf-cos r k)))
										    >			   ((equal m 2)
										    >			    (setq r (cut!mt r k2))
										    >			    (bf-times sign (bf-cos r k)))
										    >			   (t (unless (equal m 0)
										    >				(setq r (cut!mt (bf-difference pi4 r) k2)))
										    >			      (let* ((ncut (- k2 (min 0 (1+ (order! r)))))
										    >				     (dcut (make-bigfloat *domain* 10 (- ncut)))
										    >				     (tm r) (ri r) (j 1) n fctrial)
										    >				(setq y r)
										    >				(setq r (bf-minus (cut!ep (bf-times r r) (- ncut))))
										    >				(setq m 1)
										    >				(loop while (> (bf-abs tm) dcut) do
										    >	                              (setq j (+ j 2))
										    >	                              (setq fctrial
										    >	                                    (coerce
										    >	                                     (setq m (* m j (1- j))) *domain*))
										    >	                              (setq ri (cut!ep (bf-times ri r) (- ncut)))
										    >	                              (setq n (max 1 (+ (- k2 (order! fctrial)) (order! ri
										    >	                              (setq tm (bf-quotient ri fctrial n))
										    >	                              (setq y (bf-plus y tm))
										    >	                              (cond ((cl:zerop (rem j 20))
										    >	                                     (setq y (cut!ep y (- ncut)))))))
										    >			      (round!mt (bf-times sign y) k)))))))
										    >
										    >	;; This function calculates sin(x), the value of the sine function at
										    >	;; the point 'x', with the precision k, by summing terms of the Taylor
										    >	;; series for:   sin(z), 0 < Z < PI/4.    
										    >	(defmethod sin ((number bigfloat))
  (bind-domain-context (domain-of number)						  (bind-domain-context (domain-of number)
    (bf-tan number *REAL-PRECISION*)))						    |	    (bf-sin number *REAL-PRECISION*)))
										    >
										    >	;; This function calculates cos(x), the value of the cosine function at
										    >	;; the point 'x', with the precision k, by summing terms of the Taylor
										    >	;; series for:   cos(z), 0 < Z < PI/4.    
										    >	(defmethod cos ((number bigfloat))
										    >	  (bind-domain-context (domain-of number)
										    >	    (bf-cos number *REAL-PRECISION*)))

(defun bf-tan (x k)									(defun bf-tan (x k)
  (unless (and (integerp k) (> k 0))							  (unless (and (integerp k) (> k 0))
    (error "Invalid precision to tan: ~D" k))						    (error "Invalid precision to tan: ~D" k))
  (cond ((0? x) (coerce 0 *domain*))							  (cond ((0? x) (coerce 0 *domain*))
	((minus? x) (bf-minus (bf-tan (bf-minus x) k)))						((minus? x) (bf-minus (bf-tan (bf-minus x) k)))
	(t (let* ((k2 (+ k 2))									(t (let* ((k2 (+ k 2))
		  (one (coerce 1 *domain*))								  (one (coerce 1 *domain*))
		  (m (preci! x))									  (m (preci! x))
		  (pi4 (bf-times (bf-pi (+ k2 m)) (coerce 1/4 *domain*)))				  (pi4 (bf-times (bf-pi (+ k2 m)) (coerce 1/4 *domain*)))
		  sign q r)										  sign q r)
	     (cond ((< x pi4)									     (cond ((< x pi4)
		    (setq m 0)										    (setq m 0)
		    (setq r x))										    (setq r x))
		   (t (setq m (floor (setq q (bf-floor x pi4))))					   (t (setq m (floor (setq q (bf-floor x pi4))))
		      (setq r (bf-difference x (bf-times q pi4)))))					      (setq r (bf-difference x (bf-times q pi4)))))
	     (cond ((not (< m 4)) (setq m (rem m 4))))						     (cond ((not (< m 4)) (setq m (rem m 4))))
	     (setq sign (if (< m 2) one (bf-minus one)))					     (setq sign (if (< m 2) one (bf-minus one)))
	     (cond ((or (= m 1) (= m 3))							     (cond ((or (= m 1) (= m 3))
		    (setq r (bf-difference pi4 r))))							    (setq r (bf-difference pi4 r))))
	     (setq r (cut!mt r k2))								     (setq r (cut!mt r k2))
	     (cond ((or (equal m 0) (equal m 3))						     (cond ((or (equal m 0) (equal m 3))
		    (setq r (bf-sin r k2))								    (setq r (bf-sin r k2))
		    (setq q (bf-difference one (bf-times r r)))						    (setq q (bf-difference one (bf-times r r)))
		    (setq q (bf-sqrt (cut!mt q k2) k2))							    (setq q (bf-sqrt (cut!mt q k2) k2))
		    (bf-times sign (bf-quotient r q k)))						    (bf-times sign (bf-quotient r q k)))
		   (t (setq r (bf-sin r k2))								   (t (setq r (bf-sin r k2))
		      (setq q (bf-difference one (bf-times r r)))					      (setq q (bf-difference one (bf-times r r)))
		      (setq q (bf-sqrt (cut!mt q k2) k2))						      (setq q (bf-sqrt (cut!mt q k2) k2))
		      (bf-times sign (bf-quotient q r k))))))))						      (bf-times sign (bf-quotient q r k))))))))

;; This function calculates asin(x), the value of the arcsine function		    |	;; This function calculates tan(x), the value of the tangent function
;; at the point 'x', with the precision k, by calculating        			;; at the point 'x', with the precision k, by calculating       
;;          atan(x/sqrt(1-x**2))  						    |	;;          sin(x)  or  cos(x) = sin(pi/2-x).       
;; The answer is in the range <-pi/2 , pi/2>.  					    |	(defmethod tan ((number bigfloat))
(defmethod asin ((number bigfloat))						    <
  (bind-domain-context (domain-of number)						  (bind-domain-context (domain-of number)
    (bf-asin number *REAL-PRECISION*)))						    |	    (bf-tan number *REAL-PRECISION*)))
										    >
										    >	(defun bf-atan (x k)
										    >	  (unless (and (integerp k) (> k 0))
										    >	    (error "Invalid precision to atan: ~D" k))
										    >	  (cond ((0? x) (coerce 0 *domain*))
										    >		((minus? x) (bf-minus (bf-atan (bf-minus x) k)))
										    >		(t (let* ((k2 (+ k 2))
										    >			  (one (coerce 1 *domain*))
										    >			  (pi4 (bf-times (bf-pi k2) (coerce 1/4 *domain*)))
										    >			  y z)
										    >		     (cond ((= x 1)
										    >			    (round!mt pi4 k))
										    >			   ((> x one)
										    >			    (round!mt
										    >			     (bf-difference (bf-plus pi4 pi4)
										    >					    (bf-atan (bf-quotient one x k2) (+ k 1)))
										    >			     k))
										    >			   ((< x (coerce 0.42 *domain*))
										    >			    (let* ((m 1) (n 0)
										    >				   (ncut (- k2 (min 0 (+ (order! x) 1))))
										    >				   (dcut (make-bigfloat *domain* 10 (- ncut)))
										    >				   (zi x)
										    >				   (tm x))
										    >			      (setq y tm)
										    >			      (setq z (bf-minus (cut!ep (bf-times x x) (- ncut))))
										    >			      (loop while (> (bf-abs tm) dcut) do
										    >	                            (setq zi (cut!ep (bf-times zi z) (- ncut)))
										    >	                            (setq n (max 1 (+ k2 (order! zi))))
										    >	                            (setq tm (bf-quotient
										    >	                                      zi (coerce (setq m (+ m 2)) *domain*)
										    >	                                      n))
										    >	                            (setq y (bf-plus y tm))
										    >	                            (cond ((cl:zerop (rem m 20))
										    >	                                   (setq y (cut!ep y (- ncut)))))))
										    >			    (round!mt y k))
										    >			   (t (setq y (bf-plus one (cut!mt (bf-times x x) k2)))
										    >			      (setq y (bf-plus one (bf-sqrt y k2)))
										    >			      (setq y (bf-atan (bf-quotient x y k2) (+ k 1)))
										    >			      (round!mt (bf-times y (coerce 2 *domain*)) k)))))))
										    >
										    >	;; this function calculates atan(x), the value of the arctangent
										    >	;; function at the point 'x', with the precision k, by summing terms
										    >	;; of the Taylor series for atan(z)  if  0 < z < 0.42.  
										    >	;;   otherwise the following identities are used!  
										    >	;;       atan(x) = pi/2 - atan(1/x)  if  1 < x  and 
										    >	;;       atan(x) = 2*atan(x/(1+sqrt(1+x**2)))       
										    >	;;             if  0.42 <= x <= 1.                     
										    >	;; the answer is in the range [-pi/2, pi/2).    
										    >	(defmethod atan ((number bigfloat) &optional base)
										    >	  (when base
										    >	    (error "Two argument atan not implemented yet"))
										    >	  (bind-domain-context (domain-of number)
										    >	    (bf-atan number *REAL-PRECISION*)))

(defun bf-asin (x k)									(defun bf-asin (x k)
  (when (or (> (bf-abs x) (coerce 1 *domain*)))						  (when (or (> (bf-abs x) (coerce 1 *domain*)))
    (error "Invalid argument to asin: ~S" x))						    (error "Invalid argument to asin: ~S" x))
  (unless (and (integerp k) (> k 0))							  (unless (and (integerp k) (> k 0))
    (error "Invalid precision to asin: ~D" k))						    (error "Invalid precision to asin: ~D" k))
  (cond ((minus? x) (bf-minus (bf-asin (bf-minus x) k)))				  (cond ((minus? x) (bf-minus (bf-asin (bf-minus x) k)))
	(t (let ((k2 (+ k 2))									(t (let ((k2 (+ k 2))
		 (one (coerce 1 *domain*)))								 (one (coerce 1 *domain*)))
	     (cond ((< (bf-difference one x)							     (cond ((< (bf-difference one x)
		       (make-bigfloat *domain* 10 (- k2)))						       (make-bigfloat *domain* 10 (- k2)))
		    (round!mt (bf-times (bf-pi (1+ k)) (coerce 1/2 *domain*))				    (round!mt (bf-times (bf-pi (1+ k)) (coerce 1/2 *domain*))
			      k))										      k))
		   (t (bf-atan										   (t (bf-atan
		       (bf-quotient x (bf-sqrt (cut!mt (- 1 (* x x)) k2) k2)				       (bf-quotient x (bf-sqrt (cut!mt (- 1 (* x x)) k2) k2)
				    k2)											    k2)
		       k))))))) 									       k))))))) 
 
 										    |	;; This function calculates asin(x), the value of the arcsine function
;; This function calculates acos(x), the value of the arccosine			    |	;; at the point 'x', with the precision k, by calculating        
;; function at the point 'x', with the precision k, by calculating        	    |	;;          atan(x/sqrt(1-x**2))  
;;          atan(sqrt(1-x**2)/x)  if  x > 0  or      				    |	;; The answer is in the range <-pi/2 , pi/2>.  
;;          atan(sqrt(1-x**2)/x) + pi  if  x < 0.    				    |	(defmethod asin ((number bigfloat))
;; the answer is in the range [0 , pi).        					    <
(defmethod acos ((number bigfloat))						    <
  (bind-domain-context (domain-of number)						  (bind-domain-context (domain-of number)
    (bf-acos number *REAL-PRECISION*)))						    |	    (bf-asin number *REAL-PRECISION*)))

(defun bf-acos (x k)									(defun bf-acos (x k)
  (when (or (> (bf-abs x) (coerce 1 *domain*)))						  (when (or (> (bf-abs x) (coerce 1 *domain*)))
    (error "Invalid argument to acos: ~S" x))						    (error "Invalid argument to acos: ~S" x))
  (unless (and (integerp k) (> k 0))							  (unless (and (integerp k) (> k 0))
    (error "Invalid precision to acos: ~D" k))						    (error "Invalid precision to acos: ~D" k))
  (let ((k2 (+ k 2))									  (let ((k2 (+ k 2))
	y)											y)
    (cond ((< (bf-abs x) (make-bigfloat *domain* 50 (- k2)))				    (cond ((< (bf-abs x) (make-bigfloat *domain* 50 (- k2)))
	   (round!mt (bf-times (bf-pi (+ k 1)) (coerce 1/2 *domain*))				   (round!mt (bf-times (bf-pi (+ k 1)) (coerce 1/2 *domain*))
		     k))										     k))
	  (t (setq y (bf-quotient								  (t (setq y (bf-quotient
		      (bf-sqrt (cut!mt									      (bf-sqrt (cut!mt
				(bf-difference (coerce 1 *domain*)							(bf-difference (coerce 1 *domain*)
					       (bf-times x x))									       (bf-times x x))
				k2) k2)											k2) k2)
		      (bf-abs x)									      (bf-abs x)
		      k2))										      k2))
	     (if (minus? x)									     (if (minus? x)
		 (round!mt (bf-difference (bf-pi (+ k 1)) (bf-atan y k))				 (round!mt (bf-difference (bf-pi (+ k 1)) (bf-atan y k))
			   k)											   k)
		 (bf-atan y k))))))									 (bf-atan y k))))))
 
;; this function calculates atan(x), the value of the arctangent		    |	;; This function calculates acos(x), the value of the arccosine
;; function at the point 'x', with the precision k, by summing terms		    |	;; function at the point 'x', with the precision k, by calculating        
;; of the Taylor series for atan(z)  if  0 < z < 0.42.  			    |	;;          atan(sqrt(1-x**2)/x)  if  x > 0  or      
;;   otherwise the following identities are used!  				    |	;;          atan(sqrt(1-x**2)/x) + pi  if  x < 0.    
;;       atan(x) = pi/2 - atan(1/x)  if  1 < x  and 				    |	;; the answer is in the range [0 , pi).        
;;       atan(x) = 2*atan(x/(1+sqrt(1+x**2)))       				    |	(defmethod acos ((number bigfloat))
;;             if  0.42 <= x <= 1.                     				    <
;; the answer is in the range [-pi/2, pi/2).    				    <
(defmethod atan ((number bigfloat) &optional base)				    <
  (when base									    <
    (error "Two argument atan not implemented yet"))				    <
  (bind-domain-context (domain-of number)						  (bind-domain-context (domain-of number)
      (bf-atan number *REAL-PRECISION*)))					    |	    (bf-acos number *REAL-PRECISION*)))
										    <
(defun bf-atan (x k)								    <
  (unless (and (integerp k) (> k 0))						    <
    (error "Invalid precision to atan: ~D" k))					    <
  (cond ((0? x) (coerce 0 *domain*))						    <
	((minus? x) (bf-minus (bf-atan (bf-minus x) k)))			    <
	(t (let* ((k2 (+ k 2))							    <
		  (one (coerce 1 *domain*))					    <
		  (pi4 (bf-times (bf-pi k2) (coerce 1/4 *domain*)))		    <
		  y z)								    <
	     (cond ((= x 1)							    <
		    (round!mt pi4 k))						    <
		   ((> x one)							    <
		    (round!mt							    <
		     (bf-difference (bf-plus pi4 pi4)				    <
				    (bf-atan (bf-quotient one x k2) (+ k 1)))	    <
		     k))							    <
		   ((< x (coerce 0.42 *domain*))				    <
		    (let* ((m 1) (n 0)						    <
			   (ncut (- k2 (min 0 (+ (order! x) 1))))		    <
			   (dcut (make-bigfloat *domain* 10 (- ncut)))		    <
			   (zi x)						    <
			   (tm x))						    <
		      (setq y tm)						    <
		      (setq z (bf-minus (cut!ep (bf-times x x) (- ncut))))	    <
		      (loop while (> (bf-abs tm) dcut) do			    <
			(setq zi (cut!ep (bf-times zi z) (- ncut)))		    <
			(setq n (max 1 (+ k2 (order! zi))))			    <
			(setq tm (bf-quotient					    <
				    zi (coerce (setq m (+ m 2)) *domain*)	    <
				    n))						    <
			(setq y (bf-plus y tm))					    <
			(cond ((cl:zerop (rem m 20))				    <
			       (setq y (cut!ep y (- ncut)))))))			    <
		    (round!mt y k))						    <
		   (t (setq y (bf-plus one (cut!mt (bf-times x x) k2)))		    <
		      (setq y (bf-plus one (bf-sqrt y k2)))			    <
		      (setq y (bf-atan (bf-quotient x y k2) (+ k 1)))		    <
		      (round!mt (bf-times y (coerce 2 *domain*)) k)))))))	    <

;; this function calculates arcsin(x), the value of the arcsine				;; this function calculates arcsin(x), the value of the arcsine
;; function at the point 'x', with the precision k, by solving				;; function at the point 'x', with the precision k, by solving
;;    x = sin(y)  if  0 < x <= 0.72,  or       						;;    x = sin(y)  if  0 < x <= 0.72,  or       
;;    sqrt(1-x**2) = sin(y)  if  0.72 < x,     						;;    sqrt(1-x**2) = sin(y)  if  0.72 < x,     
;; by Newton's iteration method.               						;; by Newton's iteration method.               
;; the answer is in the range [-pi/2, pi/2).						;; the answer is in the range [-pi/2, pi/2).
#+Ignore										#+Ignore
(defun bf-asin-newton (x k)								(defun bf-asin-newton (x k)
  (when (or (> (bf-abs x) (coerce 1 *domain*)))						  (when (or (> (bf-abs x) (coerce 1 *domain*)))
    (error "Invalid argument to asin: ~S" x))						    (error "Invalid argument to asin: ~S" x))
  (unless (and (integerp k) (> k 0))							  (unless (and (integerp k) (> k 0))
    (error "Invalid precision to asin: ~D" k))						    (error "Invalid precision to asin: ~D" k))
  (cond ((0? x) (coerce 0 *domain*))							  (cond ((0? x) (coerce 0 *domain*))
	((minus? x) (bf-minus (bf-asin-newton (bf-minus x) k)))					((minus? x) (bf-minus (bf-asin-newton (bf-minus x) k)))
	(t (let* ((k2 (+ k 2))									(t (let* ((k2 (+ k 2))
		  (dcut (make-bigfloat *domain* 10 (+ (- k2) (order! x) 1)))				  (dcut (make-bigfloat *domain* 10 (+ (- k2) (order! x) 1)))
		  (one (coerce 1 *domain*))								  (one (coerce 1 *domain*))
		  (pi2 (bf-times (bf-pi (+ k2 2)) (coerce 1/2 *domain*)))				  (pi2 (bf-times (bf-pi (+ k2 2)) (coerce 1/2 *domain*)))
		  y)	       										  y)	       
	     (cond ((< (- 1 x) dcut)								     (cond ((< (- 1 x) dcut)
		    (round!mt pi2 k))									    (round!mt pi2 k))
		   ((> x (coerce 0.72 *domain*))							   ((> x (coerce 0.72 *domain*))
		    (setq y (cut!mt (bf-difference one (bf-times x x)) k2))				    (setq y (cut!mt (bf-difference one (bf-times x x)) k2))
		    (setq y (bf-asin-newton (bf-sqrt y k2) k))						    (setq y (bf-asin-newton (bf-sqrt y k2) k))
		    (round!mt (bf-difference pi2 y) k))							    (round!mt (bf-difference pi2 y) k))
		   (t (let ((nfig 1)									   (t (let ((nfig 1)
			    (n 0)										    (n 0)
			    (dy one)										    (dy one)
			    cx dx x0)										    cx dx x0)
			(setq y x)										(setq y x)
			(loop while (or (< nfig k2)								(loop while (or (< nfig k2)
					(> (bf-abs dy) dcut))									(> (bf-abs dy) dcut))
			      do (cond ((> (setq nfig (* 2 nfig)) k2)						      do (cond ((> (setq nfig (* 2 nfig)) k2)
					(setq nfig k2)))									(setq nfig k2)))
				 (setq x0 (bf-sin y nfig))								 (setq x0 (bf-sin y nfig))
				 (setq cx (bf-sqrt (cut!mt (- 1 (* x0 x0))						 (setq cx (bf-sqrt (cut!mt (- 1 (* x0 x0))
							   nfig)										   nfig)
					     nfig))										     nfig))
				 (setq dx (- x x0))									 (setq dx (- x x0))
				 (setq n (max 1 (+ nfig (order! dx))))							 (setq n (max 1 (+ nfig (order! dx))))
				 (setq dy (bf-quotient dx cx n))							 (setq dy (bf-quotient dx cx n))
				 (setq y (bf-plus y dy)))								 (setq y (bf-plus y dy)))
			(round!mt y k))))))))									(round!mt y k))))))))
 											 
;; This function calculates arccos(x), the value of the arccosine			;; This function calculates arccos(x), the value of the arccosine
;; function at the point 'x', with the precision k, by calculating			;; function at the point 'x', with the precision k, by calculating
;;    arcsin(sqrt(1-x**2))  if  x > 0.72  and    					;;    arcsin(sqrt(1-x**2))  if  x > 0.72  and    
;;    pi/2 - arcsin(x)  otherwise.							;;    pi/2 - arcsin(x)  otherwise.
;; The answer is in the range [0, pi).          					;; The answer is in the range [0, pi).          
#+ignore										#+ignore
(defun bf-acos-newton (x k)								(defun bf-acos-newton (x k)
  (when (or (> (bf-abs x) (coerce 1 *domain*)))						  (when (or (> (bf-abs x) (coerce 1 *domain*)))
    (error "Invalid argument to acos: ~S" x))						    (error "Invalid argument to acos: ~S" x))
  (unless (and (integerp k) (> k 0))							  (unless (and (integerp k) (> k 0))
    (error "Invalid precision to acos: ~D" k))						    (error "Invalid precision to acos: ~D" k))
  (cond ((bf-<= x (coerce 0.72 *domain*))						  (cond ((bf-<= x (coerce 0.72 *domain*))
         (round!mt									         (round!mt
	  (bf-difference									  (bf-difference
	   (bf-times (bf-pi (+ k 1)) (coerce 1/2 *domain*))					   (bf-times (bf-pi (+ k 1)) (coerce 1/2 *domain*))
	   (bf-asin-newton x k))								   (bf-asin-newton x k))
	  k))											  k))
	(t (bf-asin-newton									(t (bf-asin-newton
	    (bf-sqrt										    (bf-sqrt
	     (cut!mt (bf-difference (coerce 1 *domain*) (* x x))				     (cut!mt (bf-difference (coerce 1 *domain*) (* x x))
		     (+ k 2))										     (+ k 2))
	     (+ k 2))										     (+ k 2))
	    k))))										    k))))
 											 
;; This function calculates arctan(x), the value of the arctangent			;; This function calculates arctan(x), the value of the arctangent
;; function at the point 'x', with the precision k, by calculating			;; function at the point 'x', with the precision k, by calculating
;;     arcsin(x/sqrt(1+x**2))								;;     arcsin(x/sqrt(1+x**2))
;; The answer is in the range [-pi/2, pi/2).  						;; The answer is in the range [-pi/2, pi/2).  
#+Ignore										#+Ignore
(defun bf-atan-newton (x k)								(defun bf-atan-newton (x k)
  (unless (and (integerp k) (> k 0))							  (unless (and (integerp k) (> k 0))
    (error "Invalid precision to atan: ~D" k))						    (error "Invalid precision to atan: ~D" k))
  (cond ((minus? x) (bf-minus (bf-atan-newton (bf-minus x) k)))				  (cond ((minus? x) (bf-minus (bf-atan-newton (bf-minus x) k)))
	(t (bf-asin-newton									(t (bf-asin-newton
	    (bf-quotient x (bf-sqrt (cut!mt (+ 1 (* x x)) (+ k 2))				    (bf-quotient x (bf-sqrt (cut!mt (+ 1 (* x x)) (+ k 2))
				    (+ k 2))										    (+ k 2))
			 (+ k 2))										 (+ k 2))
	    k))))										    k))))

(defmethod-sd expt ((x bigfloat) (y bigfloat))						(defmethod-sd expt ((x bigfloat) (y bigfloat))
  (bind-domain-context domain								  (bind-domain-context domain
    (cond ((bf-integerp y) (expt x (floor y)))						    (cond ((bf-integerp y) (expt x (floor y)))
	  ((minus? y)										  ((minus? y)
	   (/ 1 (expt x (bf-minus y))))								   (/ 1 (expt x (bf-minus y))))
	  (t (let ((n *REAL-PRECISION*)								  (t (let ((n *REAL-PRECISION*)
		   (xp (cl:abs x))									   (xp (cl:abs x))
		   yp) 											   yp) 
	       (cond ((bf-integerp (bf-times y (coerce 2 domain)))				       (cond ((bf-integerp (bf-times y (coerce 2 domain)))
		      (setq xp (incprec! xp 1)) 							      (setq xp (incprec! xp 1)) 
		      (setq yp (round!mt								      (setq yp (round!mt
				(bf-times (expt xp (floor y))								(bf-times (expt xp (floor y))
					  (bf-sqrt xp (+ n 1)))									  (bf-sqrt xp (+ n 1)))
				n)))											n)))
		     (t (setq yp (bf-exp (* y (bf-log xp (1+ n))) n))))					     (t (setq yp (bf-exp (* y (bf-log xp (1+ n))) n))))
	       (cond ((minus? x) (bf-minus yp)) (t yp)))))))					       (cond ((minus? x) (bf-minus yp)) (t yp)))))))
										    (
;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-		;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-
;;; ===========================================================================		;;; ===========================================================================
;;;			     Differential Rings						;;;			     Differential Rings
;;; ===========================================================================		;;; ===========================================================================
;;; (c) Copyright 1989, 1993 Cornell University						;;; (c) Copyright 1989, 1993 Cornell University

;;; differential-domains.lisp,v 1.7 1995/05/24 17:41:58 rz Exp				;;; differential-domains.lisp,v 1.7 1995/05/24 17:41:58 rz Exp

(in-package "WEYLI")								    |	(in-package :weyli)

(make::adjust-version-numbers Weyl "1.7")					    |	;;; DELETE (make::adjust-version-numbers Weyl "1.7")

(defmethod ring-variables ((domain differential-polynomial-ring))			(defmethod ring-variables ((domain differential-polynomial-ring))
  (with-slots ((vars variables)) domain							  (with-slots ((vars variables)) domain
    (loop for v in vars									    (loop for v in vars
	  when (or (atom v) (not (eql (first v) 'derivation)))					  when (or (atom v) (not (eql (first v) 'derivation)))
	    collect v)))									    collect v)))

(defsetf variable-derivation set-variable-derivation)					(defsetf variable-derivation set-variable-derivation)

(define-domain-creator differential-ring ((coefficient-domain ring) variables) 	    |	(eval-when (:compile-toplevel :load-toplevel)
										    >	  (define-domain-creator differential-ring ((coefficient-domain ring) variables) 
  (progn										    (progn
    (setq variables (loop for var in variables						      (setq variables (loop for var in variables
			  collect (coerce var *general*)))				                            collect (coerce var *general*)))
    (let ((ring (make-instance 'differential-polynomial-ring 				      (let ((ring (make-instance 'differential-polynomial-ring 
			       :variables variables					                                 :variables variables
			       :coefficient-domain coefficient-domain			                                 :coefficient-domain coefficient-domain
			       :print-function 'differential-ring-print-object)))	                                 :print-function 'differential-ring-print-object))
      (loop for var in variables do							        (loop for var in variables do
	(setf (variable-derivation ring var) :generate))				              (setf (variable-derivation ring var) :generate))
      ring))										        ring))
  :predicate 										    :predicate 
  #'(lambda (d)  									    #'(lambda (d)  
      (and (eql (class-name (class-of d)) 'differential-polynomial-ring) 		        (and (eql (class-name (class-of d)) 'differential-polynomial-ring) 
	   (eql (coefficient-domain-of d) coefficient-domain)				             (eql (coefficient-domain-of d) coefficient-domain)
	   (eql (ring-variables d) variables)						             (eql (ring-variables d) variables)
	   ;; And check that the derivations are the same.				             ;; And check that the derivations are the same.
	   ))) 									    |	             )))) 

(defun differential-ring-print-object (d stream)					(defun differential-ring-print-object (d stream)
  (format stream "~A<" (coefficient-domain-of d))					  (format stream "~A<" (coefficient-domain-of d))
  (display-list (ring-variables d))							  (display-list (ring-variables d))
  (princ ">" stream))									  (princ ">" stream))

(defmethod coerce ((variable list) (domain differential-polynomial-ring))		(defmethod coerce ((variable list) (domain differential-polynomial-ring))
  (cond ((member variable (ring-variables domain))					  (cond ((member variable (ring-variables domain))
	 (make-polynomial domain								 (make-polynomial domain
	    (cons (variable-index domain variable)						    (cons (variable-index domain variable)
		  (make-terms 1 (one (coefficient-domain-of domain))))))				  (make-terms 1 (one (coefficient-domain-of domain))))))
	((and (not (atom variable))								((and (not (atom variable))
	      (eql (first variable) 'deriv))							      (eql (first variable) 'deriv))
	 (loop for i below (third variable)							 (loop for i below (third variable)
	       for p = (deriv (coerce (second variable) domain)) then (deriv p)			       for p = (deriv (coerce (second variable) domain)) then (deriv p)
	       finally (return p)))								       finally (return p)))
	((coercible? variable (coefficient-domain-of domain)))					((coercible? variable (coefficient-domain-of domain)))
	(t (call-next-method))))								(t (call-next-method))))

;; Derivations are more complex than differentation.					;; Derivations are more complex than differentation.
;; This returns the derivation of the main variable of the polynomial.			;; This returns the derivation of the main variable of the polynomial.
;; In general this polynomial is expected to be of degree 1 with			;; In general this polynomial is expected to be of degree 1 with
;; coefficient 1.									;; coefficient 1.
(defmacro variable-derivation (domain var)						(defmacro variable-derivation (domain var)
  `(get-variable-number-property ,domain (poly-order-number ,var)			  `(get-variable-number-property ,domain (poly-order-number ,var)
				 :derivation))										 :derivation))

(defmacro variable-derivative-order (domain var)					(defmacro variable-derivative-order (domain var)
  `(get-variable-number-property ,domain (poly-order-number ,var)			  `(get-variable-number-property ,domain (poly-order-number ,var)
				 :derivative-order))									 :derivative-order))

										    >	(defgeneric set-variable-derivation (domain variable derivation)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
										    >	(defmethod set-variable-derivation
										    >	    ((domain differential-polynomial-ring)
										    >	     (variable symbol) derivation)
										    >	  (setq variable (coerce variable *general*))
										    >	  (with-slots (variables) domain
										    >	    (unless (member variable variables :test #'ge-equal)
										    >	      #+Genera
										    >	      (error "~'i~A~ is not a variable of ~S" variable domain)
										    >	      #-Genera      
										    >	      (error "~A is not a variable of ~S" variable domain)))
										    >	  (cond ((eql derivation :generate)
										    >		 (setf (get-variable-number-property domain
										    >						     (variable-index domain variable)
										    >						     :derivation)
										    >		       :generate))
										    >		(t (cond ((eql (domain-of derivation) *general*)
										    >			  (setq derivation (coerce derivation domain)))
										    >			 ((not (eql (domain-of derivation) domain))
										    >			  (error "The derivation ~S is not an element of ~S" 
										    >				 derivation domain)))
										    >		   (setf (get-variable-number-property domain 
										    >						       (variable-index domain variable)
										    >						       :derivation)
										    >			 (poly-form derivation)))))
										    >
(defmethod set-variable-derivation							(defmethod set-variable-derivation
    ((domain differential-polynomial-ring)						    ((domain differential-polynomial-ring)
     (variable (or symbol general-expression)) derivation)			    |	     (variable general-expression) derivation)
  (setq variable (coerce variable *general*))						  (setq variable (coerce variable *general*))
  (with-slots (variables) domain							  (with-slots (variables) domain
    (unless (member variable variables :test #'ge-equal)				    (unless (member variable variables :test #'ge-equal)
      #+Genera										      #+Genera
      (error "~'i~A~ is not a variable of ~S" variable domain)				      (error "~'i~A~ is not a variable of ~S" variable domain)
      #-Genera      									      #-Genera      
      (error "~A is not a variable of ~S" variable domain)))				      (error "~A is not a variable of ~S" variable domain)))
  (cond ((eql derivation :generate)							  (cond ((eql derivation :generate)
	 (setf (get-variable-number-property domain						 (setf (get-variable-number-property domain
					     (variable-index domain variable)							     (variable-index domain variable)
					     :derivation)									     :derivation)
	       :generate))									       :generate))
	(t (cond ((eql (domain-of derivation) *general*)					(t (cond ((eql (domain-of derivation) *general*)
		  (setq derivation (coerce derivation domain)))						  (setq derivation (coerce derivation domain)))
		 ((not (eql (domain-of derivation) domain))						 ((not (eql (domain-of derivation) domain))
		  (error "The derivation ~S is not an element of ~S" 					  (error "The derivation ~S is not an element of ~S" 
			 derivation domain)))									 derivation domain)))
	   (setf (get-variable-number-property domain 						   (setf (get-variable-number-property domain 
					       (variable-index domain variable)							       (variable-index domain variable)
					       :derivation)									       :derivation)
		 (poly-form derivation)))))								 (poly-form derivation)))))

(defmethod add-new-variable ((domain differential-ring) variable)			(defmethod add-new-variable ((domain differential-ring) variable)
  (prog1										  (prog1
    (call-next-method)									    (call-next-method)
    (setq variable (coerce variable *general*))						    (setq variable (coerce variable *general*))
    (setf (variable-derivation domain variable) :generate)))				    (setf (variable-derivation domain variable) :generate)))

(defun standard-derivation (p)								(defun standard-derivation (p)
  (let ((deriv (variable-derivation *domain* p)))					  (let ((deriv (variable-derivation *domain* p)))
    (cond ((null deriv) (zero *coefficient-domain*))					    (cond ((null deriv) (zero *coefficient-domain*))
	  ((eql deriv :generate)								  ((eql deriv :generate)
	   (let* ((old-var (variable-symbol *domain* (poly-order-number p)))			   (let* ((old-var (variable-symbol *domain* (poly-order-number p)))
		  (new-order										  (new-order
		   (cond ((ge-variable? old-var) 1)							   (cond ((ge-variable? old-var) 1)
			 ((eql (first old-var) 'derivation)							 ((eql (first old-var) 'derivation)
			  (1+ (third old-var)))									  (1+ (third old-var)))
			 (t 1)))										 (t 1)))
		  (new-var `(derivation									  (new-var `(derivation
			     ,(if (or (ge-variable? old-var)							     ,(if (or (ge-variable? old-var)
				      (not (eql (first old-var) 'derivation)))						      (not (eql (first old-var) 'derivation)))
				  old-var										  old-var
				  (second old-var))									  (second old-var))
			     ,new-order))									     ,new-order))
		  new-var-num)										  new-var-num)
	     (add-new-variable *domain* new-var)						     (add-new-variable *domain* new-var)
	     (setq new-var-num (variable-index *domain* new-var))				     (setq new-var-num (variable-index *domain* new-var))
	     (setf (variable-derivation *domain* old-var) new-var)				     (setf (variable-derivation *domain* old-var) new-var)
	     #+ignore										     #+ignore
	     (setf (variable-derivative-order *domain* new-var) new-order)			     (setf (variable-derivative-order *domain* new-var) new-order)
	     (cons new-var-num (make-terms 1 (one *coefficient-domain*)))))			     (cons new-var-num (make-terms 1 (one *coefficient-domain*)))))
 	  (t deriv))))									 	  (t deriv))))

(defun poly-derivation (p &optional (derivation #'standard-derivation))			(defun poly-derivation (p &optional (derivation #'standard-derivation))
  (let ((deriv nil) (temp nil))								  (let ((deriv nil) (temp nil))
    (cond ((poly-coef? p) (zero *coefficient-domain*))					    (cond ((poly-coef? p) (zero *coefficient-domain*))
	  (t (setq deriv (%funcall derivation p))						  (t (setq deriv (%funcall derivation p))
	     (poly-plus										     (poly-plus
	       (if (poly-0? deriv) deriv							       (if (poly-0? deriv) deriv
		   (poly-times										   (poly-times
		     (make-poly-form									     (make-poly-form
		       p										       p
		       (map-over-each-term (poly-terms p) (e c)						       (map-over-each-term (poly-terms p) (e c)
			 (unless (e0? e)									 (unless (e0? e)
			   (unless (poly-0?									   (unless (poly-0?
				     (setq temp										     (setq temp
					   (poly-times										   (poly-times
					    (coerce e *coefficient-domain*)							    (coerce e *coefficient-domain*)
					    c)))										    c)))
			     (collect-term (e1- e) temp)))))							     (collect-term (e1- e) temp)))))
		     deriv))										     deriv))
	       (poly-differentiate-coefs p derivation))))))					       (poly-differentiate-coefs p derivation))))))

(defun poly-differentiate-coefs (p derivation)						(defun poly-differentiate-coefs (p derivation)
  (let* ((dc nil)									  (let* ((dc nil)
	 (one (one *coefficient-domain*))							 (one (one *coefficient-domain*))
	 (terms (poly-terms p))									 (terms (poly-terms p))
	 (sum (poly-times (make-poly-form p (make-terms (le terms) one))			 (sum (poly-times (make-poly-form p (make-terms (le terms) one))
			  (poly-derivation (lc terms) derivation))))						  (poly-derivation (lc terms) derivation))))
    (map-over-each-term (red terms) (e c)						    (map-over-each-term (red terms) (e c)
      (setq dc (poly-derivation c derivation))						      (setq dc (poly-derivation c derivation))
      (setq sum (poly-plus sum 								      (setq sum (poly-plus sum 
			   (poly-times dc									   (poly-times dc
				       (make-poly-form p 								       (make-poly-form p 
						       (make-terms e one))))))								       (make-terms e one))))))
    sum))										    sum))

(defmethod derivation ((poly polynomial))						(defmethod derivation ((poly polynomial))
  (let ((domain (domain-of poly)))							  (let ((domain (domain-of poly)))
    (unless (typep domain 'differential-ring)						    (unless (typep domain 'differential-ring)
      (error "No derivation operator for ~S" domain))					      (error "No derivation operator for ~S" domain))
    (bind-domain-context domain								    (bind-domain-context domain
      (make-polynomial domain (poly-derivation (poly-form poly))))))			      (make-polynomial domain (poly-derivation (poly-form poly))))))

(defmethod derivation ((rat rational-function))						(defmethod derivation ((rat rational-function))
  (let ((domain (domain-of rat)))    							  (let ((domain (domain-of rat)))    
    (unless (typep (qf-ring domain) 'differential-ring)					    (unless (typep (qf-ring domain) 'differential-ring)
      (error "No derivation operator for ~S" domain))					      (error "No derivation operator for ~S" domain))
    (with-numerator-and-denominator (n d) rat						    (with-numerator-and-denominator (n d) rat
      (bind-domain-context (qf-ring domain)						      (bind-domain-context (qf-ring domain)
	(ratfun-reduce domain									(ratfun-reduce domain
		       (poly-difference									       (poly-difference
			(poly-times (poly-derivation n) d)							(poly-times (poly-derivation n) d)
			(poly-times (poly-derivation d) n))							(poly-times (poly-derivation d) n))
		       (poly-times d d))))))								       (poly-times d d))))))
;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-		;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-
;;; ===========================================================================		;;; ===========================================================================
;;;				  Direct Sums						;;;				  Direct Sums
;;; ===========================================================================		;;; ===========================================================================
;;; (c) Copyright 1991,1993 Cornell University						;;; (c) Copyright 1991,1993 Cornell University

;;; direct-sums.lisp,v 1.4 1995/05/24 17:41:59 rz Exp					;;; direct-sums.lisp,v 1.4 1995/05/24 17:41:59 rz Exp

(in-package "WEYLI")								    |	(in-package :weyli)

(make::adjust-version-numbers Weyl "1.4")					    |	;;; DELETE (make::adjust-version-numbers Weyl "1.4")

(defmethod dimension-of ((domain direct-sum))						(defmethod dimension-of ((domain direct-sum))
  (length (tuple-value domain)))							  (length (tuple-value domain)))

(defmethod initialize-instance :after ((domain direct-sum) &rest plist)			(defmethod initialize-instance :after ((domain direct-sum) &rest plist)
  (declare (ignore plist))								  (declare (ignore plist))
  (with-slots (print-function) domain							  (with-slots (print-function) domain
    (setf print-function 'direct-sum-print-object)))					    (setf print-function 'direct-sum-print-object)))

(defun direct-sum-print-object (domain stream)						(defun direct-sum-print-object (domain stream)
  (%apply #'format stream "~S~@{ (+) ~S~}"						  (%apply #'format stream "~S~@{ (+) ~S~}"
	  (loop with v = (tuple-value domain)							  (loop with v = (tuple-value domain)
		for i below (array-dimension v 0)							for i below (array-dimension v 0)
		collect (aref v i))))									collect (aref v i))))

										    >	(defgeneric %make-direct-sum (domain1 domain2)
										    >	  (:documentation
										    >	   "The purpose of this method is unknown."))
										    >
										    >	(defmacro define-direct-sum (domain-name classes
										    >				     &optional other-domain-classes other-elt-classes)
										    >	  (let ((ds-domain (intern (format nil "DIRECT-SUM-~A" domain-name)))
										    >		(ds-domain-elt (intern (format nil "DIRECT-SUM-~A-ELT" domain-name))))
										    >	    `(progn
										    >	      (defclass ,ds-domain 
										    >	          (,@(loop for name in classes 
										    >	                   collect (intern (format nil "DIRECT-SUM-~A" name)))
										    >	             ,domain-name ,@other-domain-classes direct-sum) ())
										    >	      (defclass ,ds-domain-elt 
										    >	          (,@(loop for name in classes 
										    >	                   collect (intern (format nil "DIRECT-SUM-~A-ELT" name))) 
										    >	             ,@other-elt-classes direct-sum-element) ())
										    >	      (define-domain-element-classes ,ds-domain ,ds-domain-elt)
										    >	      (defmethod %make-direct-sum ((a ,domain-name) (b ,domain-name))
										    >	        (%make-direct-sum-internal ',ds-domain a b))
										    >	      (defmethod make-element ((domain ,ds-domain) elt1 &rest elts)
										    >	        (%apply #'make-instance ',ds-domain-elt 
										    >	                :domain domain
										    >	                :values (cons elt1 elts)))
										    >	      (defmethod weyl::make-element ((domain ,ds-domain) elt1 &rest elts)
										    >	        (let* ((domains (tuple-value domain))
										    >	               (len (array-dimension domains 0)))
										    >	          (unless (cl:= (1- len) (length elts))
										    >	            (error "Incorrect number of elements to MAKE-ELMENT ~A" domain))
										    >	          (make-instance ',ds-domain-elt
										    >	                         :domain domain
										    >	                         :values (cons (coerce elt1 (aref domains 0))
										    >	                                       (loop for i upfrom 1 below len
										    >	                                             for elt in elts
										    >	                                             collect (coerce elt (aref domains i))
										    >
(defun make-direct-sum* (domain1 &rest domains)						(defun make-direct-sum* (domain1 &rest domains)
  (when (null domains) 									  (when (null domains) 
    (error "Illegal number of arguments to MAKE-DIRECT-SUM"))				    (error "Illegal number of arguments to MAKE-DIRECT-SUM"))
  (labels ((iterate (values)								  (labels ((iterate (values)
	     (cond ((null (rest values))							     (cond ((null (rest values))
		    (first values))									    (first values))
		   (t (%make-direct-sum (first values)							   (t (%make-direct-sum (first values)
					(iterate (rest values)))))))								(iterate (rest values)))))))
    (let ((domain (iterate (cons domain1 domains)))					    (let ((domain (iterate (cons domain1 domains)))
	  (Z (get-rational-integers)))								  (Z (get-rational-integers)))
      (make-homomorphism Z #'(lambda (x)			     			      (make-homomorphism Z #'(lambda (x)			     
			       (map-with-domain									       (map-with-domain
				 (first (domain-element-classes domain))		                                (first (domain-element-classes domain))
				 domain							                                domain
				 #'(lambda (d) (coerce x d)) domain))			                                #'(lambda (d) (coerce x d)) domain))
			 domain)										 domain)
      domain)))										      domain)))

(defun make-direct-sum (domain1 &rest domains)						(defun make-direct-sum (domain1 &rest domains)
  (add-domain #'false 									  (add-domain #'false 
    (%apply #'make-direct-sum* domain1 domains)))					    (%apply #'make-direct-sum* domain1 domains)))

(defun %make-direct-sum-internal (type a b)						(defun %make-direct-sum-internal (type a b)
  (flet ((domain-list (a)								  (flet ((domain-list (a)
	   (loop for i below (dimension-of a)							   (loop for i below (dimension-of a)
		 collect (ref a i))))									 collect (ref a i))))
    (cond ((typep a 'direct-sum)							    (cond ((typep a 'direct-sum)
	   (if (typep b 'direct-sum)								   (if (typep b 'direct-sum)
	       (make-instance type :values (nconc (domain-list a) (domain-list b))		       (make-instance type :values (nconc (domain-list a) (domain-list b))
	       (make-instance type :values (nconc (domain-list a) (list b)))))			       (make-instance type :values (nconc (domain-list a) (list b)))))
	  ((typep b 'direct-sum)								  ((typep b 'direct-sum)
	   (make-instance type :values (cons a (domain-list b))))				   (make-instance type :values (cons a (domain-list b))))
	  (t (make-instance type :values (list a b))))))					  (t (make-instance type :values (list a b))))))

(defun get-direct-sum (domain1 &rest domains)						(defun get-direct-sum (domain1 &rest domains)
  (add-domain #'(lambda (d) 								  (add-domain #'(lambda (d) 
		  (and (typep d 'direct-sum)								  (and (typep d 'direct-sum)
		       (eql domain1 (ref d 0))								       (eql domain1 (ref d 0))
		       (cl:= (1- (dimension-of d)) (length domains))					       (cl:= (1- (dimension-of d)) (length domains))
		       (loop for i below (dimension-of d)						       (loop for i below (dimension-of d)
			     for dom in domains									     for dom in domains
			     when (not (eql (ref d i) dom))							     when (not (eql (ref d i) dom))
			       do (return nil)						                             do (return nil)
			     finally (return t))))								     finally (return t))))
    (%apply #'make-direct-sum* domain1 domains)))					    (%apply #'make-direct-sum* domain1 domains)))

(defmethod print-object ((domain direct-sum-element) stream)				(defmethod print-object ((domain direct-sum-element) stream)
  (%apply #'format stream "~S~@{ (+) ~S~}"						  (%apply #'format stream "~S~@{ (+) ~S~}"
	  (loop with v = (tuple-value domain)							  (loop with v = (tuple-value domain)
		for i below (array-dimension v 0)							for i below (array-dimension v 0)
		collect (aref v i))))									collect (aref v i))))

(defmacro define-direct-sum (domain-name classes				    <
			     &optional other-domain-classes other-elt-classes)	    <
  (let ((ds-domain (intern (format nil "DIRECT-SUM-~A" domain-name)))		    <
	(ds-domain-elt (intern (format nil "DIRECT-SUM-~A-ELT" domain-name))))	    <
    `(progn									    <
       (defclass ,ds-domain 							    <
		 (,@(loop for name in classes 					    <
			  collect (intern (format nil "DIRECT-SUM-~A" name)))	    <
		  ,domain-name ,@other-domain-classes direct-sum) ())		    <
       (defclass ,ds-domain-elt 						    <
		 (,@(loop for name in classes 					    <
			  collect (intern (format nil "DIRECT-SUM-~A-ELT" name)))   <
		  ,@other-elt-classes direct-sum-element) ())			    <
       (define-domain-element-classes ,ds-domain ,ds-domain-elt)		    <
       (defmethod %make-direct-sum ((a ,domain-name) (b ,domain-name))		    <
	 (%make-direct-sum-internal ',ds-domain a b))				    <
       (defmethod make-element ((domain ,ds-domain) elt1 &rest elts)		    <
	 (%apply #'make-instance ',ds-domain-elt 				    <
		 :domain domain							    <
		 :values (cons elt1 elts)))					    <
       (defmethod weyl::make-element ((domain ,ds-domain) elt1 &rest elts)	    <
	 (let* ((domains (tuple-value domain))					    <
		(len (array-dimension domains 0)))				    <
	   (unless (cl:= (1- len) (length elts))				    <
	     (error "Incorrect number of elements to MAKE-ELMENT ~A" domain))	    <
	   (make-instance ',ds-domain-elt					    <
			  :domain domain					    <
			  :values (cons (coerce elt1 (aref domains 0))		    <
					(loop for i upfrom 1 below len		    <
					      for elt in elts			    <
						  collect (coerce elt (aref domain  <
										    <
										    <
(define-direct-sum semigroup ())							(define-direct-sum semigroup ())

(defmethod-sd times ((a direct-sum-semigroup-elt) (b direct-sum-semigroup-elt))		(defmethod-sd times ((a direct-sum-semigroup-elt) (b direct-sum-semigroup-elt))
  (map-with-domain 'direct-sum-semigroup-elt domain #'times a b))			  (map-with-domain 'direct-sum-semigroup-elt domain #'times a b))

(define-direct-sum monoid (semigroup))							(define-direct-sum monoid (semigroup))

(defmethod one ((domain direct-sum-monoid))						(defmethod one ((domain direct-sum-monoid))
  (map 'direct-sum-monoid-elt #'one domain))						  (map 'direct-sum-monoid-elt #'one domain))

(defmethod 0? ((x direct-sum-monoid-elt))						(defmethod 0? ((x direct-sum-monoid-elt))
  (let ((v (tuple-value x)))								  (let ((v (tuple-value x)))
    (loop for i below (array-dimension v 0)						    (loop for i below (array-dimension v 0)
	  when (not (0? (aref v i)))								  when (not (0? (aref v i)))
	    do (return nil)								          do (return nil)
	  finally (return t))))									  finally (return t))))

(define-direct-sum group (monoid))							(define-direct-sum group (monoid))

(defmethod-sd quotient ((a direct-sum-group-elt) (b direct-sum-group-elt))		(defmethod-sd quotient ((a direct-sum-group-elt) (b direct-sum-group-elt))
  (map-with-domain 'direct-sum-semigroup-elt domain #'quotient a b))			  (map-with-domain 'direct-sum-semigroup-elt domain #'quotient a b))

(defmethod recip ((a direct-sum-group-elt))						(defmethod recip ((a direct-sum-group-elt))
  (map-with-domain 'direct-sum-semigroup-elt (domain-of a) #'recip a))			  (map-with-domain 'direct-sum-semigroup-elt (domain-of a) #'recip a))

											(define-direct-sum abelian-semigroup ())
(define-direct-sum abelian-semigroup ())
											(defmethod-sd plus ((a direct-sum-semigroup-elt) (b direct-sum-semigroup-elt))
(defmethod-sd plus ((a direct-sum-semigroup-elt) (b direct-sum-semigroup-elt))		  (map-with-domain 'direct-sum-semigroup-elt domain #'plus a b))
  (map-with-domain 'direct-sum-semigroup-elt domain #'plus a b))
											(define-direct-sum abelian-monoid (abelian-semigroup))

(define-direct-sum abelian-monoid (abelian-semigroup))					(defmethod zero ((domain direct-sum-monoid))
											  (map 'direct-sum-monoid-elt #'zero domain))
(defmethod zero ((domain direct-sum-monoid))
  (map 'direct-sum-monoid-elt #'zero domain))					    (
										    (
 (defmethod 1? ((x direct-sum-monoid-elt))					    |	(defmethod 1? ((x direct-sum-monoid-elt))
  (let ((v (tuple-value x)))								  (let ((v (tuple-value x)))
    (loop for i below (array-dimension v 0)						    (loop for i below (array-dimension v 0)
	  when (not (1? (aref v i)))								  when (not (1? (aref v i)))
	    do (return nil)								          do (return nil)
	  finally (return t))))									  finally (return t))))

											(define-direct-sum abelian-group (abelian-monoid))
(define-direct-sum abelian-group (abelian-monoid))
											(defmethod-sd difference ((a direct-sum-abelian-group-elt) (b direct-sum-abelian-g
(defmethod-sd difference ((a direct-sum-abelian-group-elt) (b direct-sum-abelian-g	  (map-with-domain 'direct-sum-semigroup-elt domain #'difference a b))
  (map-with-domain 'direct-sum-semigroup-elt domain #'difference a b))
											(defmethod minus ((a direct-sum-abelian-group-elt))
(defmethod minus ((a direct-sum-abelian-group-elt))					  (map-with-domain 'direct-sum-semigroup-elt (domain-of a) #'minus a))
  (map-with-domain 'direct-sum-semigroup-elt (domain-of a) #'minus a))
											(define-direct-sum module (abelian-group) (has-coefficient-domain))
(define-direct-sum module (abelian-group) (has-coefficient-domain))
											(define-direct-sum algebra (module semigroup))

(define-direct-sum algebra (module semigroup))						(define-direct-sum ring (algebra monoid))
										    (
										    (
(define-direct-sum ring (algebra monoid))					    (
;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-		;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-
;;; ===========================================================================		;;; ===========================================================================
;;;				  Domains						;;;				  Domains
;;; ===========================================================================		;;; ===========================================================================
;;; (c) Copyright 1989, 1993 Cornell University						;;; (c) Copyright 1989, 1993 Cornell University

;;; domain-support.lisp,v 1.7 1995/05/24 17:41:59 rz Exp				;;; domain-support.lisp,v 1.7 1995/05/24 17:41:59 rz Exp

(in-package "WEYLI")									(in-package "WEYLI")

(make::adjust-version-numbers Weyl "1.7")					    |	;;; DELETE (make::adjust-version-numbers Weyl "1.7")

(defclass has-property-list ()								(defclass has-property-list ()
     ((property-list :initform nil							  ((property-list :initform nil
		     :accessor property-list-of)))					                  :accessor property-list-of)))

(defmethod getf ((obj has-property-list) key &optional (default nil))			(defmethod getf ((obj has-property-list) key &optional (default nil))
  (cl:getf (property-list-of obj) key default))					    |	  (common-lisp:getf (property-list-of obj) key default))

(defmethod putf ((obj has-property-list) key value)					(defmethod putf ((obj has-property-list) key value)
  (setf (cl:getf (property-list-of obj) key) value))				    |	  (setf (common-lisp:getf (property-list-of obj) key) value))

(defun domain-print-object (d stream)							(defun domain-print-object (d stream)
  (format stream "#<Domain: ~A>" (class-name (class-of d))))				  (format stream "#<Domain: ~A>" (class-name (class-of d))))

(defclass domain (has-property-list)							(defclass domain (has-property-list)
  ((operation-table :initform (make-hash-table))					  ((operation-table :initform (make-hash-table))
   (super-domains :initform nil								   (super-domains :initform nil
		  :initarg :super-domains								  :initarg :super-domains
		  :accessor super-domains-of)								  :accessor super-domains-of)
   (morphisms-from :initform nil							   (morphisms-from :initform nil
	      :accessor domain-morphisms-from)						                   :accessor domain-morphisms-from)
   (morphisms-to :initform nil								   (morphisms-to :initform nil
	      :accessor domain-morphisms-to)						                 :accessor domain-morphisms-to)
   (print-function :initform #'domain-print-object					   (print-function :initform #'domain-print-object
		 :initarg :print-function)))						                   :initarg :print-function)))

										    >	;;; FIXME : Merge with domain-print-object.
(defmethod print-object ((d domain) stream)						(defmethod print-object ((d domain) stream)
  (with-slots (print-function) d							  (with-slots (print-function) d
    ;; This is so that you can pretty print objects in lucid.  It			    ;; This is so that you can pretty print objects in lucid.  It
    ;; appears, that you are not supposed to use PRINC inside these			    ;; appears, that you are not supposed to use PRINC inside these
    ;; methods.										    ;; methods.
    #+Lucid										    #+Lucid
    (let ((*print-pretty* nil))								    (let ((*print-pretty* nil))
      (funcall print-function d stream))						      (funcall print-function d stream))
    #-Lucid										    #-Lucid
    (funcall print-function d stream)))							    (funcall print-function d stream)))

											(defmacro define-operations (domain &body operations)
(defmacro define-operations (domain &body operations)					  `(defmethod parse-operations :after ((d ,domain))
  `(defmethod parse-operations :after ((d ,domain))					    (parse-operation-list d ',operations)))
     (parse-operation-list d ',operations)))
										    (
										    >	(defgeneric parse-operation-list (domain operation-list)
										    >	  (:documentation
										    >	   "The purpose of this method is not known."))
										    >
(defmethod parse-operation-list ((d domain) operation-list)				(defmethod parse-operation-list ((d domain) operation-list)
  (with-slots (operation-table) d							  (with-slots (operation-table) d
    (loop for ((operation . arguments) nil values) on operation-list by #'cdddr		    (loop for ((operation . arguments) nil values) on operation-list by #'cdddr
	  do (setf (gethash operation operation-table)						  do (setf (gethash operation operation-table)
		   (list operation arguments values)))))						   (list operation arguments values)))))

;; Need a dummy primary method to hang all the :after methods on.		    |	;;; Need a dummy primary method to hang all the :after methods on.
(defmethod parse-operations ((d domain))					    |	;;; FIXME : Organize so that the primary method is not useless.
										    >	(defgeneric parse-operations (domain)
										    >	  (:method ((domain domain))
  nil)											    nil)
										    >	  (:documentation
										    >	   "The purpose of this method is not known."))

										    >	;;; FIXME : Audit for merging with parse-operations.
(defmethod initialize-instance :after ((d domain) &rest plist)				(defmethod initialize-instance :after ((d domain) &rest plist)
  (declare (ignore plist))								  (declare (ignore plist))
  (parse-operations d))									  (parse-operations d))

										    >	(defgeneric list-operations (domain)
										    >	  (:documentation
										    >	   "Return a list of operations for the domain."))
										    >
										    >	;;; FIXME : Convert the maphash to a LOOP.
(defmethod list-operations ((d domain))							(defmethod list-operations ((d domain))
  (with-slots (operation-table) d							  (with-slots (operation-table) d
    (let (ops)										    (let (ops)
      (maphash #'(lambda (key value)							      (maphash #'(lambda (key value)
		   (declare (ignore value))								   (declare (ignore value))
		   (push key ops))									   (push key ops))
	       operation-table)									       operation-table)
      ops)))										      ops)))

										    >	(defgeneric operation-arguments (domain operation)
										    >	  (:documentation
										    >	   "The purpose of this method is not known."))
										    >
(defmethod operation-arguments ((d domain) operation)					(defmethod operation-arguments ((d domain) operation)
  (with-slots (operation-table) d							  (with-slots (operation-table) d
    (subst (class-name (class-of d)) 'self						    (subst (class-name (class-of d)) 'self
	   (second (gethash operation operation-table)))))					   (second (gethash operation operation-table)))))

										    >	(defgeneric operation-values (domain operation)
										    >	  (:documentation
										    >	   "The purpose of this method is not known."))
										    >
(defmethod operation-values ((d domain) operation)					(defmethod operation-values ((d domain) operation)
  (with-slots (operation-table) d							  (with-slots (operation-table) d
    (subst (class-name (class-of d)) 'self						    (subst (class-name (class-of d)) 'self
	   (third (gethash operation operation-table)))))					   (third (gethash operation operation-table)))))

										    >	(defgeneric describe-operations (domain &optional no-complaints)
										    >	  (:documentation
										    >	   "The purpose of this method is not known."))
										    >
#+Genera										#+Genera
(defmethod describe-operations ((d domain) &optional no-complaints)			(defmethod describe-operations ((d domain) &optional no-complaints)
  (declare (ignore no-complaints))							  (declare (ignore no-complaints))
  (let* ((class-name (class-name (class-of d)))						  (let* ((class-name (class-name (class-of d)))
	 (domain-element (cond ((null (rest (get class-name 'domain-elements)))			 (domain-element (cond ((null (rest (get class-name 'domain-elements)))
				(first (get class-name 'domain-elements)))						(first (get class-name 'domain-elements)))
			       (t (format nil "~A element" class-name)))))					       (t (format nil "~A element" class-name)))))
    (labels ((canonicalize-class (name)							    (labels ((canonicalize-class (name)
	       (cond ((eql name 'self) class-name)						       (cond ((eql name 'self) class-name)
		     ((atom name) name)									     ((atom name) name)
		     ((equal name '(element self))							     ((equal name '(element self))
		      domain-element)									      domain-element)
		     (t (mapcar #'canonicalize-class name)))))						     (t (mapcar #'canonicalize-class name)))))
      (format t "~&~S is a ~A~%" d class-name)						      (format t "~&~S is a ~A~%" d class-name)
      (fresh-line)									      (fresh-line)
      (with-slots (operation-table) d							      (with-slots (operation-table) d
	(scl:formatting-table ()								(scl:formatting-table ()
	  (scl:with-character-style ('(nil :italic nil))					  (scl:with-character-style ('(nil :italic nil))
	    (scl:formatting-row ()								    (scl:formatting-row ()
	      (scl:formatting-cell ()								      (scl:formatting-cell ()
		(princ "Operation"))									(princ "Operation"))
	      (scl:formatting-cell ()								      (scl:formatting-cell ()
		(princ "Arguments"))									(princ "Arguments"))
	      (scl:formatting-cell ()								      (scl:formatting-cell ()
		(princ "Values"))))									(princ "Values"))))
	  (maphash #'(lambda (key value)							  (maphash #'(lambda (key value)
		       (declare (ignore key))								       (declare (ignore key))
		       (scl:formatting-row ()								       (scl:formatting-row ()
			 (scl:formatting-cell ()								 (scl:formatting-cell ()
			   (princ (first value)))								   (princ (first value)))
			 (scl:formatting-cell ()								 (scl:formatting-cell ()
			   (format t "~A~{, ~A~}"								   (format t "~A~{, ~A~}"
				   (canonicalize-class (first (second value)))						   (canonicalize-class (first (second value)))
				   (mapcar #'canonicalize-class								   (mapcar #'canonicalize-class
					   (rest (second value)))))								   (rest (second value)))))
			 (scl:formatting-cell ()								 (scl:formatting-cell ()
			   (princ (canonicalize-class (third value))))))					   (princ (canonicalize-class (third value))))))
		   operation-table))))))								   operation-table))))))

#-Genera										#-Genera
(defmethod describe-operations ((d domain) &optional no-complaints)			(defmethod describe-operations ((d domain) &optional no-complaints)
  (declare (ignore no-complaints))							  (declare (ignore no-complaints))
  (let* ((class-name (class-name (class-of d)))						  (let* ((class-name (class-name (class-of d)))
	 (element-classes (get class-name 'element-classes))					 (element-classes (get class-name 'element-classes))
	 (domain-element (cond ((and element-classes						 (domain-element (cond ((and element-classes
				     (null (rest element-classes)))							     (null (rest element-classes)))
				(first element-classes))								(first element-classes))
			       (t (format nil "~A element" class-name)))))					       (t (format nil "~A element" class-name)))))
    (labels ((canonicalize-class (name)							    (labels ((canonicalize-class (name)
	       (cond ((eql name 'self) class-name)						       (cond ((eql name 'self) class-name)
		     ((atom name) name)									     ((atom name) name)
		     ((equal name '(element self))							     ((equal name '(element self))
		      domain-element)									      domain-element)
		     (t (mapcar #'canonicalize-class name)))))						     (t (mapcar #'canonicalize-class name)))))
      (format t "~&~S is a ~A~%" d class-name)						      (format t "~&~S is a ~A~%" d class-name)
      (fresh-line)									      (fresh-line)
      (with-slots (operation-table) d							      (with-slots (operation-table) d
	(format t "Operation Arguments Values")							(format t "Operation Arguments Values")
	(maphash #'(lambda (key value)								(maphash #'(lambda (key value)
		     (declare (ignore key))								     (declare (ignore key))
		     (format t "~&(~A ~A~{, ~A~}) -> ~A~%"						     (format t "~&(~A ~A~{, ~A~}) -> ~A~%"
			     (first value)									     (first value)
			     (canonicalize-class (first (second value)))					     (canonicalize-class (first (second value)))
			     (mapcar #'canonicalize-class							     (mapcar #'canonicalize-class
				     (rest (second value)))								     (rest (second value)))
			     (canonicalize-class (third value))))						     (canonicalize-class (third value))))
		 operation-table)))))									 operation-table)))))

										    >	(defgeneric required-operations (domain &optional fun)
										    >	  (:documentation
										    >	   "The purpose of this method is not known."))
										    >
(defmethod required-operations ((d domain) &optional fun)				(defmethod required-operations ((d domain) &optional fun)
  (let* ((class-name (class-name (class-of d)))						  (let* ((class-name (class-name (class-of d)))
	 (element-classes (get class-name 'element-classes))					 (element-classes (get class-name 'element-classes))
	 (domain-element (cond ((and element-classes						 (domain-element (cond ((and element-classes
				     (null (rest element-classes)))							     (null (rest element-classes)))
				(first element-classes))								(first element-classes))
			       (t (cons 'or element-classes))))							       (t (cons 'or element-classes))))
	list)										         list)
    (labels ((canonicalize-class (name)							    (labels ((canonicalize-class (name)
	       (cond ((eql name 'self) class-name)						       (cond ((eql name 'self) class-name)
		     ((atom name) name)									     ((atom name) name)
		     ((equal name '(element self))							     ((equal name '(element self))
		      domain-element)									      domain-element)
		     (t (mapcar #'canonicalize-class name)))))						     (t (mapcar #'canonicalize-class name)))))
      											      
      (unless fun									      (unless fun
	(setq fun #'(lambda (form)								(setq fun #'(lambda (form)
		      (push (cons (first form)								      (push (cons (first form)
				  (mapcar #'canonicalize-class (second form)))						  (mapcar #'canonicalize-class (second form)))
			    list))))										    list))))
    (with-slots (operation-table) d							      (with-slots (operation-table) d
      (maphash #'(lambda (key value)							        (maphash #'(lambda (key value)
		   (declare (ignore key))						                     (declare (ignore key))
		   (%funcall fun value))						                     (%funcall fun value))
	       operation-table))							                 operation-table))
    list)))										      list)))

#+PCL										    <
(defmethod check-domain ((d domain))						    <
  (required-operations d							    <
    #'(lambda (form)								    <
        (let ((operation (first form))						    <
	      (args (rest form))) 						    <
	     (map-over-arglist-combinations (class-name (class-of d)) args	    <
		#'(lambda (arg-names) 						    <
		    (let ((args (loop for type in arg-names			    <
				      collect (find-class type nil))))		    <
			 (loop for method in (pcl::generic-function-methods	    <
					      (symbol-function operation))	    <
			       do (when (equal args				    <
					       (pcl::method-type-specifiers method  <
				    (return t))					    <
			       finally (format t "No method for ~S~%"		    <
						 (cons operation arg-names))))))))  <
										    <
(defun map-over-arglist-combinations (self arglist fun)					(defun map-over-arglist-combinations (self arglist fun)
  (labels ((recur (arglist types) 							  (labels ((recur (arglist types) 
	     (cond ((null arglist)								     (cond ((null arglist)
		    (%funcall fun (reverse types)))							    (%funcall fun (reverse types)))
		   ((atom (first arglist))								   ((atom (first arglist))
		    (recur (rest arglist) (cons (first arglist) types)))				    (recur (rest arglist) (cons (first arglist) types)))
		   ((eql (first (first arglist)) 'or)							   ((eql (first (first arglist)) 'or)
		    (loop for type in (rest (first arglist))						    (loop for type in (rest (first arglist))
			  do (recur (cons type (rest arglist)) types)))						  do (recur (cons type (rest arglist)) types)))
		   ((eql (first (first arglist)) 'element)						   ((eql (first (first arglist)) 'element)
		    (loop for type in (get self 'element-classes)					    (loop for type in (get self 'element-classes)
			  do (recur (cons type (rest arglist)) types)))						  do (recur (cons type (rest arglist)) types)))
		   (t (error "Don't understand arglist entry: ~S"					   (t (error "Don't understand arglist entry: ~S"
			     (first arglist))))))								     (first arglist))))))
    (recur (first arglist) ())))  							    (recur (first arglist) ())))  

										    >	;;; DELETE : The method does not appear to be used anywhere.
										    >	(defgeneric check-domain (domain)
										    >	  (:documentation
										    >	   "The purspose of this method is not known."))
										    >
										    >	;;; FIXME : SBCL specific. Need to abstract for other implementations.
										    >	#+SB-MOP
										    >	(defmethod check-domain ((d domain))
										    >	  (required-operations
										    >	   d
										    >	   (lambda (form)
										    >	     (let ((operation (first form))
										    >	           (args (rest form))) 
										    >	       (map-over-arglist-combinations
										    >	        (class-name (class-of d)) args
										    >	        #'(lambda (arg-names) 
										    >	            (let ((args (loop for type in arg-names
										    >	                              collect (find-class type nil))))
										    >	              (loop for method in (sb-mop:generic-function-methods
										    >	                                   (symbol-function operation))
										    >	                    do (when (equal args
										    >	                                    (sb-mop::method-specializers method))
										    >	                         (return t))
										    >	                    finally (format t "No method for ~S~%"
										    >	                                    (cons operation arg-names))))))))))
										    >
;; Domain creators									;; Domain creators

										    >	;;; FIXME : Need to make creating domains atomic so that domains are
										    >	;;; not added to the list unless they are actually created.
(defvar *domains* ()									(defvar *domains* ()
  "List of domains currently in use")							  "List of domains currently in use")

(defvar *general* ()  									(defvar *general* ()  
  "The general representation domain")							  "The general representation domain")

(defun reset-domains ()									(defun reset-domains ()
  (setq *domains* nil)									  (setq *domains* nil)
  (setf (domain-morphisms-from *general*) nil)  					  (setf (domain-morphisms-from *general*) nil)  
  (setf (domain-morphisms-to *general*) nil))						  (setf (domain-morphisms-to *general*) nil))

(defmacro add-domain (predicate &body body)						(defmacro add-domain (predicate &body body)
  `(add-domain-internal ,predicate #'(lambda () ,@body)))				  `(add-domain-internal ,predicate #'(lambda () ,@body)))

(defun add-domain-internal (predicate body)						(defun add-domain-internal (predicate body)
  (let ((domain (find nil *domains* :test #'(lambda (a b) 			    |	  (let ((domain (find nil *domains*
										    >	                      :test #'(lambda (a b) 
					    (declare (ignore a))			                                (declare (ignore a))
					    (%funcall predicate b)))))			                                (%funcall predicate b)))))
     (when (null domain)								    (when (null domain)
       (setq domain (%funcall body))							      (setq domain (%funcall body))
       (push domain *domains*))								      (push domain *domains*))
     domain))										    domain))

(defun false (&rest args)								(defun false (&rest args)
  (declare (ignore args))								  (declare (ignore args))
  nil)											  nil)

(defun true (&rest args)								(defun true (&rest args)
  (declare (ignore args))								  (declare (ignore args))
  t)											  t)

;; Use this macro to define domain creators.					    |	;;; FIXME : Need to ensure that the generic function is defined prior
										    >	;;; to the methods. The exact semantics depend on how this is used. It
										    >	;;; either needs to test for the existing of a generic function and
										    >	;;; create one if it doesn't exist or just create one if there should
										    >	;;; not already be one.
(defmacro define-domain-creator (name args creator &key predicate body)			(defmacro define-domain-creator (name args creator &key predicate body)
  (labels ((parse-args (args)								  (labels ((parse-args (args)
	     (cond ((null args)									     (cond ((null args)
		    args)										    args)
		   ((member (first args) '(&optional &key))						   ((member (first args) '(&optional &key))
		    (parse-args (rest args)))								    (parse-args (rest args)))
		   ((eql (first args) '&rest)								   ((eql (first args) '&rest)
		    (error "Can't handle &rest args here"))						    (error "Can't handle &rest args here"))
		   ((atom (first args))									   ((atom (first args))
		    (cons (first args) (parse-args (rest args))))					    (cons (first args) (parse-args (rest args))))
		   (t (cons (first (first args))							   (t (cons (first (first args))
			    (parse-args (rest args)))))))							    (parse-args (rest args)))))))
    (let ((internal-fun (intern (format nil "MAKE-~A*" name)))				    (let ((internal-fun (intern (format nil "MAKE-~A*" name)))
	  (true-args (parse-args args)))							  (true-args (parse-args args)))
      `(progn										      `(progn
	 (defmethod ,internal-fun ,args ,creator)					        (defmethod ,internal-fun ,args ,creator)
	 (defmethod ,(intern (format nil "MAKE-~A" name)) ,args				        (defmethod ,(intern (format nil "MAKE-~A" name)) ,args
	   (add-domain #'false (,internal-fun ,@true-args)))				          (add-domain #'false (,internal-fun ,@true-args)))
	 ,@(when predicate								        ,@(when predicate
	     `((defmethod ,(intern (format nil "GET-~A" name)) ,args			                `((defmethod ,(intern (format nil "GET-~A" name)) ,args
		 (add-domain ,predicate (,internal-fun ,@true-args)))))			                    (add-domain ,predicate (,internal-fun ,@true-args)))))
	 ,@(when body									        ,@(when body
	     `((defmethod ,(intern (format nil "GET-~A" name)) ,args			                `((defmethod ,(intern (format nil "GET-~A" name)) ,args
		 ,body)))))))								                    ,body)))))))

(defmacro with-new-weyl-context ((plist) &body body)					(defmacro with-new-weyl-context ((plist) &body body)
  `(let ((*domains* nil)								  `(let ((*domains* nil)
	 (*allow-coercions*									 (*allow-coercions*
	  ,(or (%getf plist :allow-coercions) '*allow-coercions*)))				  ,(or (%getf plist :allow-coercions) '*allow-coercions*)))
     ,@body))  										    ,@body))  

;; All elements of a domain should include this class					;; All elements of a domain should include this class

(defclass domain-element ()								(defclass domain-element ()
  ((domain :initarg :domain								  ((domain :initarg :domain
	   :reader domain-of)))									   :reader domain-of)))

											(defmacro define-domain-element-classes (domain &body element-classes)
(defmacro define-domain-element-classes (domain &body element-classes)			  `(progn
  `(progn										    ;; At one time we thought there would be a one to one
     ;; At one time we thought there would be a one to one				    ;; correspondence between classes of domains and the classes of
     ;; correspondence between classes of domains and the classes of			    ;; their elements.  This isn't the case.  In addition, no uses
     ;; their elements.  This isn't the case.  In addition, no uses			    ;; the element-class to domain-class correspondence, as you would
     ;; the element-class to domain-class correspondence, as you would			    ;; expect, so I'm not bothering to keep track of it.   --RZ 7/12/94
     ;; expect, so I'm not bothering to keep track of it.   --RZ 7/12/94		    #+ignore
     #+ignore										    ,@(loop for element-class in element-classes
     ,@(loop for element-class in element-classes					            collect
	     collect									            `(cond ((eql (get ',element-class 'domain-class) ',domain))
	     `(cond ((eql (get ',element-class 'domain-class) ',domain))		              (t
	            (t									               (when (get ',element-class 'domain-class)
		     (when (get ',element-class 'domain-class)				                 (format t "WARNING: Reset domain-class of ~S~%"
		       (format t "WARNING: Reset domain-class of ~S~%"			                         ',element-class))
			       ',element-class))					               (setf (get ',element-class 'domain-class) ',domain))))
		     (setf (get ',element-class 'domain-class) ',domain))))		    (setf (get ',domain 'element-classes) ',element-classes)))
    (setf (get ',domain 'element-classes) ',element-classes)))
										    (
(defmethod domain-element-classes ((domain domain))				    |	(defgeneric domain-element-classes (domain)
										    >	  (:method ((domain domain))
  (get (class-name (class-of domain)) 'element-classes))				    (get (class-name (class-of domain)) 'element-classes))
										    >	  (:documentation
										    >	   "The purpose of this method is not known."))

;; This is so that you can pretty print objects in lucid.  It appears,			;; This is so that you can pretty print objects in lucid.  It appears,
;; that you are not supposed to use PRINC inside these methods.				;; that you are not supposed to use PRINC inside these methods.
#+Lucid											#+Lucid
;; This must be an :around method since it must come before all the			;; This must be an :around method since it must come before all the
;; primary methods.									;; primary methods.
(defmethod print-object :around ((object domain-element) stream)			(defmethod print-object :around ((object domain-element) stream)
  (let ((*print-pretty* nil))								  (let ((*print-pretty* nil))
    (call-next-method)))								    (call-next-method)))

(defgeneric coerce (elt domain))						    |	(defgeneric coerce (elt domain)
(defgeneric coercible? (elt domain))						    |	  (:documentation
										    >	   "Coerce the element into the domain."))
										    >
										    >	(defgeneric coercible? (elt domain)
										    >	  (:documentation
										    >	   "Return true if the element is coercible into the domain."))

(defmacro defmethod-sd (op (x-spec y-spec) &body body)					(defmacro defmethod-sd (op (x-spec y-spec) &body body)
  #+Genera										  #+Genera
  (declare (zwei:indentation . wei:indent-for-clos-defmethod))				  (declare (zwei:indentation . wei:indent-for-clos-defmethod))
  (let ((x (if (atom x-spec) x-spec (first x-spec)))					  (let ((x (if (atom x-spec) x-spec (first x-spec)))
	(y (if (atom y-spec) y-spec (first y-spec))))						(y (if (atom y-spec) y-spec (first y-spec))))
    `(defmethod ,op (,x-spec ,y-spec)							    `(defmethod ,op (,x-spec ,y-spec)
       (let ((domain (domain-of ,x)))							      (let ((domain (domain-of ,x)))
	 (cond ((eql domain (domain-of ,y))						        (cond ((eql domain (domain-of ,y))
		,@body)									               ,@body)
	       (t (call-next-method)))))))						              (t (call-next-method)))))))

											;; These are often of use when defining generic operations for domains.
;; These are often of use when defining generic operations for domains.
											(defvar *domain* ()
(defvar *domain* ()									  "Within the context of an operation, the current domain")
  "Within the context of an operation, the current domain")
										    (
										    >	(defgeneric %bind-dynamic-domain-context (domain function)
										    >	  (:documentation
										    >	   "The purpose of this method is not known.")
										    >	  (:method ((domain domain) function)
										    >	    (let ((*domain* domain))
										    >	      (%funcall function))))
										    >
(defmacro bind-domain-context (domain &body body)					(defmacro bind-domain-context (domain &body body)
  `(%bind-dynamic-domain-context ,domain 						  `(%bind-dynamic-domain-context ,domain 
      #'(lambda ()								    |	    (lambda ()
	#+Genera (declare (sys:downward-function))					      #+Genera (declare (sys:downward-function))
	,@body)))									      ,@body)))
										    <
(defmethod %bind-dynamic-domain-context ((domain domain) function)		    <
  (let ((*domain* domain))							    <
    (%funcall function)))							    <
;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-		;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-
;;; ===========================================================================		;;; ===========================================================================
;;;			      Expanded Polynomials					;;;			      Expanded Polynomials
;;; ===========================================================================		;;; ===========================================================================
;;; (c) Copyright 1989, 1993 Cornell University						;;; (c) Copyright 1989, 1993 Cornell University

;;; epolynomial.lisp,v 1.9 1994/11/15 19:55:25 rz Exp					;;; epolynomial.lisp,v 1.9 1994/11/15 19:55:25 rz Exp

(in-package "WEYLI")								    |	(in-package :weyli)

(make::adjust-version-numbers Weyl "1.9")					    |	;;; DELETE (make::adjust-version-numbers Weyl "1.9")
										    >
										    >	(defgeneric make-epolynomial* (domain greater-function terms)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))

(defmethod make-epolynomial*								(defmethod make-epolynomial*
    ((domain multivariate-polynomial-ring) greater-function terms)			    ((domain multivariate-polynomial-ring) greater-function terms)
  (make-instance 'epolynomial :domain domain						  (make-instance 'epolynomial :domain domain
		 :greater-function greater-function							 :greater-function greater-function
		 :form terms))										 :form terms))

										    >	(defgeneric make-epolynomial (domain greater-function poly)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod make-epolynomial								(defmethod make-epolynomial
    ((domain multivariate-polynomial-ring) greater-function (poly mpolynomial))		    ((domain multivariate-polynomial-ring) greater-function (poly mpolynomial))
  (make-epolynomial domain greater-function (poly-form poly)))				  (make-epolynomial domain greater-function (poly-form poly)))

(defmethod make-epolynomial								(defmethod make-epolynomial
    ((domain multivariate-polynomial-ring) greater-function (poly epolynomial))		    ((domain multivariate-polynomial-ring) greater-function (poly epolynomial))
  (if (eql greater-function (greater-function-of poly)) poly				  (if (eql greater-function (greater-function-of poly)) poly
      (make-epolynomial* domain greater-function					      (make-epolynomial* domain greater-function
			 (sort (poly-form poly) greater-function))))						 (sort (poly-form poly) greater-function))))

(defmethod make-epolynomial 								(defmethod make-epolynomial 
    ((domain multivariate-polynomial-ring) greater-function				    ((domain multivariate-polynomial-ring) greater-function
     (r rational-function))								     (r rational-function))
  (let ((c (coercible? r (coefficient-domain-of domain)))				  (let ((c (coercible? r (coefficient-domain-of domain)))
	term)											term)
    (cond ((null c) (call-next-method))							    (cond ((null c) (call-next-method))
	  ((0? c)										  ((0? c)
	   (make-epolynomial* domain greater-function ()))					   (make-epolynomial* domain greater-function ()))
	  (t (setq term (make-array (cl:1+ (length (ring-variables domain)))			  (t (setq term (make-array (cl:1+ (length (ring-variables domain)))
				    :initial-element 0))								    :initial-element 0))
	     (setf (aref term 0) c)								     (setf (aref term 0) c)
	     (make-epolynomial* domain greater-function (list term))))))			     (make-epolynomial* domain greater-function (list term))))))

(defmethod make-epolynomial								(defmethod make-epolynomial
	   ((domain multivariate-polynomial-ring) greater-function (form list))			   ((domain multivariate-polynomial-ring) greater-function (form list))
  (let* ((dimension (length (ring-variables domain)))					  (let* ((dimension (length (ring-variables domain)))
	 poly-form)										 poly-form)
    (labels ((scan-poly-form (form exp next-var)					    (labels ((scan-poly-form (form exp next-var)
	       (cond ((poly-coef? form)								       (cond ((poly-coef? form)
		      (unless (0? form)									      (unless (0? form)
			(loop for i fixnum upfrom next-var below dimension					(loop for i fixnum upfrom next-var below dimension
			      do (push 0 exp))									      do (push 0 exp))
			(push (make-array (1+ dimension) 							(push (make-array (1+ dimension) 
					  :initial-contents									  :initial-contents
					  (cons form (reverse exp)))								  (cons form (reverse exp)))
			      poly-form)))									      poly-form)))
		     (t (let ((var-index (poly-order-number form)))					     (t (let ((var-index (poly-order-number form)))
			  (loop for i fixnum upfrom next-var below var-index					  (loop for i fixnum upfrom next-var below var-index
				do (push 0 exp))									do (push 0 exp))
			  (setq var-index (1+ var-index))							  (setq var-index (1+ var-index))
			  (map-over-each-term (poly-terms form) (e c)						  (map-over-each-term (poly-terms form) (e c)
			    (scan-poly-form c (cons e exp)							    (scan-poly-form c (cons e exp)
					    var-index)))))))									    var-index)))))))
      (scan-poly-form form () 0)							      (scan-poly-form form () 0)
      (setq greater-function 								      (setq greater-function 
	    (get-comparison-fun dimension greater-function))					    (get-comparison-fun dimension greater-function))
      (make-epolynomial* domain greater-function					      (make-epolynomial* domain greater-function
			(sort poly-form greater-function)))))							(sort poly-form greater-function)))))
												
(defmethod print-object ((poly epolynomial) stream)					(defmethod print-object ((poly epolynomial) stream)
  (if (0? poly) (princ 0 stream)							  (if (0? poly) (princ 0 stream)
      (with-slots (var-count) poly							      (with-slots (var-count) poly
        (let* ((first? t)								        (let* ((first? t)
	       (variables (ring-variables (domain-of poly)))					       (variables (ring-variables (domain-of poly)))
	       (dim (cl:1+ (length variables))))						       (dim (cl:1+ (length variables))))
	  (loop for term in (poly-form poly)							  (loop for term in (poly-form poly)
		for c = (svref term 0)									for c = (svref term 0)
		do (cond ((minus? c)									do (cond ((minus? c)
			  (setq c (minus c))									  (setq c (minus c))
			  (if (and (1? c) (not (gterm-constant? term dim)))					  (if (and (1? c) (not (gterm-constant? term dim)))
			      (princ " -" stream)								      (princ " -" stream)
			      (format stream " - ~S" c)))							      (format stream " - ~S" c)))
			 ((null first?)										 ((null first?)
			  (if (and (1? c) (not (gterm-constant? term dim)))					  (if (and (1? c) (not (gterm-constant? term dim)))
			      (princ " + " stream)								      (princ " + " stream)
			      (format stream " + ~S" c)))							      (format stream " + ~S" c)))
			 (t (unless (and (1? c) (not (gterm-constant? term dim)))				 (t (unless (and (1? c) (not (gterm-constant? term dim)))
			      (format stream "~S" c))))								      (format stream "~S" c))))
	    (loop for var in variables								    (loop for var in variables
		  for i fixnum upfrom 1									  for i fixnum upfrom 1
		  for exp = (svref term i) do								  for exp = (svref term i) do
              (unless (cl:zerop exp)							              (unless (cl:zerop exp)
		(princ " " stream)									(princ " " stream)
		(display var stream)									(display var stream)
		(unless (eql 1 exp)									(unless (eql 1 exp)
		  (format stream "^~D" exp))))								  (format stream "^~D" exp))))
		(setq first? nil))))))									(setq first? nil))))))

(defmethod 0? ((x epolynomial))								(defmethod 0? ((x epolynomial))
  (null (poly-form x)))									  (null (poly-form x)))

(defmethod 1? ((x epolynomial))								(defmethod 1? ((x epolynomial))
  (let ((form (poly-form x)))								  (let ((form (poly-form x)))
    (and (null (rest form))								    (and (null (rest form))
	 (0? (le form))										 (0? (le form))
	 (1? (lc form)))))									 (1? (lc form)))))

(defmethod binary= ((p epolynomial) (q epolynomial))					(defmethod binary= ((p epolynomial) (q epolynomial))
  (0? (- p q)))										  (0? (- p q)))

(defun get-comparison-fun (num-vars name)						(defun get-comparison-fun (num-vars name)
  (cond ((and (not (symbolp name)) (functionp name))					  (cond ((and (not (symbolp name)) (functionp name))
	 name)											 name)
	((fboundp name) (symbol-function name))							((fboundp name) (symbol-function name))
	((eql name :lexical)									((eql name :lexical)
	 (make-comparison-fun num-vars 								 (make-comparison-fun num-vars 
			      (loop for i fixnum below num-vars 						      (loop for i fixnum below num-vars 
				    collect (cl:1+ i))									    collect (cl:1+ i))
			      :total? nil :reverse? nil))							      :total? nil :reverse? nil))
	((eql name :revlex)									((eql name :revlex)
	 (make-comparison-fun num-vars 								 (make-comparison-fun num-vars 
			      (reverse										      (reverse
				(loop for i fixnum below num-vars							(loop for i fixnum below num-vars
				      collect (cl:1+ i)))								      collect (cl:1+ i)))
			      :total? t :reverse? t))								      :total? t :reverse? t))
	((eql name :total-lexical)								((eql name :total-lexical)
	 (make-comparison-fun num-vars								 (make-comparison-fun num-vars
			      (loop for i fixnum below num-vars							      (loop for i fixnum below num-vars
				    collect (cl:1+ i))									    collect (cl:1+ i))
			      :total? t :reverse nil))				    |				      :total? t :reverse? nil))
	((eql name :total-revlex)								((eql name :total-revlex)
	 (make-comparison-fun num-vars								 (make-comparison-fun num-vars
			      (reverse 										      (reverse 
				(loop for i fixnum below num-vars							(loop for i fixnum below num-vars
				      collect (cl:1+ i)))								      collect (cl:1+ i)))
			      :total? t :reverse t))				    |				      :total? t :reverse? t))
	(t (error "Unknown comparison function ~S" name))))					(t (error "Unknown comparison function ~S" name))))

(defun make-comparison-fun (num-vars var-order &key total? reverse? new?)		(defun make-comparison-fun (num-vars var-order &key total? reverse? new?)
 (let ((name (intern (format nil "COMPARE<~D>-~D~{.~D~}-~S-~S"				 (let ((name (intern (format nil "COMPARE<~D>-~D~{.~D~}-~S-~S"
			     num-vars (first var-order) (rest var-order)					     num-vars (first var-order) (rest var-order)
			     total? reverse?)))									     total? reverse?)))
       great less)									       great less)
   (if (null reverse?)									   (if (null reverse?)
       (setq great 'cl:> less 'cl:<)							       (setq great 'cl:> less 'cl:<)
       (setq great 'cl:< less 'cl:>))							       (setq great 'cl:< less 'cl:>))
   (unless (and (null new?) (fboundp name))						   (unless (and (null new?) (fboundp name))
     (compile name 									     (compile name 
       `(lambda (a b)									       `(lambda (a b)
	  (let (a-temp b-temp)									  (let (a-temp b-temp)
	       (declare (fixnum a-temp b-temp)							       (declare (fixnum a-temp b-temp)
			(optimize (safety 0)))									(optimize (safety 0)))
	    (cond										    (cond
	      ,@(when total?									      ,@(when total?
		  `(((cl:plusp										  `(((cl:plusp
		       ,(if (> num-vars 10)								       ,(if (> num-vars 10)
			    `(loop for i fixnum upfrom 1 below ,num-vars					    `(loop for i fixnum upfrom 1 below ,num-vars
				   summing										   summing
				   (the fixnum										   (the fixnum
					(- (the fixnum (svref a i))								(- (the fixnum (svref a i))
					   (the fixnum (svref b i)))))								   (the fixnum (svref b i)))))
			    `(cl:+ ,@(loop for i upfrom 1 below num-vars					    `(cl:+ ,@(loop for i upfrom 1 below num-vars
					   collect										   collect
					   `(the fixnum										   `(the fixnum
						 (- (the fixnum (svref a ,i))								 (- (the fixnum (svref a ,i))
						    (the fixnum (svref b ,i)))))))							    (the fixnum (svref b ,i)))))))
		     t)											     t)
		    ((cl:< a-temp b-temp) nil)))							    ((cl:< a-temp b-temp) nil)))
	      ,@(loop for v in var-order							      ,@(loop for v in var-order
		      append `(((,great (setq a-temp (svref a ,v))					      append `(((,great (setq a-temp (svref a ,v))
				      (setq b-temp (svref b ,v)))							      (setq b-temp (svref b ,v)))
				   t)											   t)
			       ((,less a-temp b-temp) nil))))))))						       ((,less a-temp b-temp) nil))))))))
   (values (symbol-function name) name)))						   (values (symbol-function name) name)))

(defmethod make-polynomial 								(defmethod make-polynomial 
    ((domain multivariate-polynomial-ring) (epol epolynomial))				    ((domain multivariate-polynomial-ring) (epol epolynomial))
  (unless (eql domain (domain-of epol))							  (unless (eql domain (domain-of epol))
    (error "Don't understand this: ~S" epol))						    (error "Don't understand this: ~S" epol))
  (let* ((terms (poly-form epol))							  (let* ((terms (poly-form epol))
         (dim (cl:- (array-dimension (first terms) 0) 1)))				         (dim (cl:- (array-dimension (first terms) 0) 1)))
    (labels ((convert-term (term i)							    (labels ((convert-term (term i)
	       (cond ((cl:zerop i) (aref term 0))						       (cond ((cl:zerop i) (aref term 0))
		     ((cl:zerop (aref term i))								     ((cl:zerop (aref term i))
		      (convert-term term (cl:- i 1)))							      (convert-term term (cl:- i 1)))
		     (t (cons (cl:- i 1) 								     (t (cons (cl:- i 1) 
			      (make-terms (aref term i) 							      (make-terms (aref term i) 
					  (convert-term term (cl:- i 1))))))))							  (convert-term term (cl:- i 1))))))))
      (loop with ans = (convert-term (first terms) dim)					      (loop with ans = (convert-term (first terms) dim)
	    for term in (rest terms)								    for term in (rest terms)
	    do (setq ans (poly-plus ans (convert-term term dim)))				    do (setq ans (poly-plus ans (convert-term term dim)))
	    finally (return (make-polynomial domain ans))))))					    finally (return (make-polynomial domain ans))))))
  											  
(defmethod coerce ((p epolynomial) (d general-expressions))				(defmethod coerce ((p epolynomial) (d general-expressions))
  (let* ((domain (domain-of p))								  (let* ((domain (domain-of p))
	 (vars (ring-variables domain))								 (vars (ring-variables domain))
	 (n (length vars)))									 (n (length vars)))
    (labels ((transform-term (term)							    (labels ((transform-term (term)
	       (let ((factors (list (coerce (aref term 0) d))))					       (let ((factors (list (coerce (aref term 0) d))))
		 (loop for i below n									 (loop for i below n
		       for e = (aref term (cl:1+ i))							       for e = (aref term (cl:1+ i))
		       do (unless (cl:zerop e)								       do (unless (cl:zerop e)
			    (push (expt (nth i vars) e) factors)))						    (push (expt (nth i vars) e) factors)))
		 (simp-times-terms d factors))))							 (simp-times-terms d factors))))
       (simp-plus-terms d (loop for term in (poly-form p)				       (simp-plus-terms d (loop for term in (poly-form p)
				collect (transform-term term))))))							collect (transform-term term))))))
											
;;; ===========================================================================		;;; ===========================================================================
;;;			Polynomial Arithmetic						;;;			Polynomial Arithmetic
;;; ===========================================================================		;;; ===========================================================================

;; Notice that we can use MAP-OVER-EACH-TERM since it doesn't depend			;; Notice that we can use MAP-OVER-EACH-TERM since it doesn't depend
;; upon the exponent arithmetic, while UPDATE-TERMS does.				;; upon the exponent arithmetic, while UPDATE-TERMS does.

(defmacro same-greater-functions ((x y) &body body)					(defmacro same-greater-functions ((x y) &body body)
  `(with-slots (greater-function) x							  `(with-slots (greater-function) x
     (unless (eq greater-function (slot-value ,y 'greater-function))			     (unless (eq greater-function (slot-value ,y 'greater-function))
       (error "EPolynomials don't have same compare function: ~S and ~S"		       (error "EPolynomials don't have same compare function: ~S and ~S"
	      ,x ,y))										      ,x ,y))
    ,@body))										    ,@body))

(defun make-eterm (exp coef)								(defun make-eterm (exp coef)
  (declare (type simple-array exp)							  (declare (type simple-array exp)
	   (optimize (safety 0)))								   (optimize (safety 0)))
  (let* ((dim (array-dimension exp 0))							  (let* ((dim (array-dimension exp 0))
	 (term (make-array dim)))								 (term (make-array dim)))
    (declare (fixnum dim)								    (declare (fixnum dim)
	     (type simple-array term))								     (type simple-array term))
    (setf (svref term 0) coef)								    (setf (svref term 0) coef)
    (do ((i 1 (cl:1+ i)))								    (do ((i 1 (cl:1+ i)))
	((cl:> i dim) term)									((cl:> i dim) term)
      (declare (fixnum i))								      (declare (fixnum i))
      (setf (svref term i) (svref exp i)))))						      (setf (svref term i) (svref exp i)))))

;; These should really check to make sure that the number of variables			;; These should really check to make sure that the number of variables
;; hasn't changed.									;; hasn't changed.
(defmethod-sd plus ((x epolynomial) (y epolynomial))					(defmethod-sd plus ((x epolynomial) (y epolynomial))
  (same-greater-functions (x y)								  (same-greater-functions (x y)
    (bind-domain-context domain								    (bind-domain-context domain
      (make-epolynomial* domain greater-function					      (make-epolynomial* domain greater-function
			 (gterms-plus greater-function (poly-form x) (poly-form y)				 (gterms-plus greater-function (poly-form x) (poly-form y)

(defun gterms-plus (greater-function x y) ;x and y are term lists			(defun gterms-plus (greater-function x y) ;x and y are term lists
  (let ((ans-terms (list nil))								  (let ((ans-terms (list nil))
	(terms nil)										(terms nil)
	sum)											sum)
    (macrolet										    (macrolet
	((collect-term (.e. .c.)								((collect-term (.e. .c.)
	   `(progn (setf (rest terms) (list (make-eterm , .e. , .c.)))				   `(progn (setf (rest terms) (list (make-eterm , .e. , .c.)))
		   (setf terms (rest terms))))								   (setf terms (rest terms))))
	 (collect-old-term (term)								 (collect-old-term (term)
	   `(progn (setf (rest terms) (list ,term))						   `(progn (setf (rest terms) (list ,term))
		   (setf terms (rest terms)))))								   (setf terms (rest terms)))))
      (setq terms ans-terms)								      (setq terms ans-terms)
      (loop										      (loop
       (cond ((terms0? x)								       (cond ((terms0? x)
	      (cond ((terms0? y) (return (rest ans-terms)))					      (cond ((terms0? y) (return (rest ans-terms)))
		    (t (collect-old-term (lt y))							    (t (collect-old-term (lt y))
		       (setq y (red y)))))								       (setq y (red y)))))
	     ((or (terms0? y)									     ((or (terms0? y)
		  (%funcall greater-function (lt x) (lt y)))						  (%funcall greater-function (lt x) (lt y)))
	      (collect-old-term (lt x))								      (collect-old-term (lt x))
	      (setq x (red x)))									      (setq x (red x)))
	     ((%funcall greater-function (lt y) (lt x))						     ((%funcall greater-function (lt y) (lt x))
	      (collect-old-term (lt y))								      (collect-old-term (lt y))
	      (setq y (red y)))									      (setq y (red y)))
	     (t (setq sum (+ (svref (lt x) 0) (svref (lt y) 0)))				     (t (setq sum (+ (svref (lt x) 0) (svref (lt y) 0)))
		(unless (0? sum)									(unless (0? sum)
		  (collect-term (lt x) sum))								  (collect-term (lt x) sum))
		(setq x (red x) y (red y))))))))							(setq x (red x) y (red y))))))))

(defmethod minus ((x epolynomial))							(defmethod minus ((x epolynomial))
  (let ((domain (domain-of x)))								  (let ((domain (domain-of x)))
    (bind-domain-context domain      							    (bind-domain-context domain      
      (make-epolynomial* domain (slot-value x 'greater-function)			      (make-epolynomial* domain (slot-value x 'greater-function)
			 (gterms-minus (poly-form x))))))							 (gterms-minus (poly-form x))))))

(defun gterms-minus (x)									(defun gterms-minus (x)
  (loop for term in x									  (loop for term in x
	collect (make-eterm term (- (svref term 0)))))						collect (make-eterm term (- (svref term 0)))))

(defmethod-sd difference ((x epolynomial) (y epolynomial))				(defmethod-sd difference ((x epolynomial) (y epolynomial))
  (same-greater-functions (x y)								  (same-greater-functions (x y)
    (bind-domain-context domain								    (bind-domain-context domain
      (make-epolynomial* domain greater-function					      (make-epolynomial* domain greater-function
			 (gterms-difference greater-function							 (gterms-difference greater-function
					    (poly-form x) (poly-form y))))))							    (poly-form x) (poly-form y))))))

(defun gterms-difference (greater-function x y) ;x and y are term lists			(defun gterms-difference (greater-function x y) ;x and y are term lists
  (let ((ans-terms (list nil))								  (let ((ans-terms (list nil))
	(terms nil)										(terms nil)
	sum)											sum)
    (macrolet										    (macrolet
	((collect-term (.e. .c.)								((collect-term (.e. .c.)
	   `(progn (setf (rest terms) (list (make-eterm , .e. , .c.)))				   `(progn (setf (rest terms) (list (make-eterm , .e. , .c.)))
		   (setf terms (rest terms))))								   (setf terms (rest terms))))
	 (collect-old-term (term)								 (collect-old-term (term)
	   `(progn (setf (rest terms) (list ,term))						   `(progn (setf (rest terms) (list ,term))
		   (setf terms (rest terms)))))								   (setf terms (rest terms)))))
      (setq terms ans-terms)								      (setq terms ans-terms)
      (loop										      (loop
       (cond ((terms0? x)								       (cond ((terms0? x)
	      (cond ((terms0? y) (return (rest ans-terms)))					      (cond ((terms0? y) (return (rest ans-terms)))
		    (t (collect-term (lt y) (- (svref y 0)))			    |			    (t (collect-term (lt y) (- (elt y 0)))
		       (setq y (red y)))))								       (setq y (red y)))))
	     ((or (terms0? y)									     ((or (terms0? y)
		  (%funcall greater-function (lt x) (lt y)))						  (%funcall greater-function (lt x) (lt y)))
	      (collect-old-term (lt x))								      (collect-old-term (lt x))
	      (setq x (red x)))									      (setq x (red x)))
	     ((%funcall greater-function (lt y) (lt x))						     ((%funcall greater-function (lt y) (lt x))
	      (collect-term (lt y) (- (svref (lt y) 0)))			    |		      (collect-term (lt y) (- (elt (lt y) 0)))
	      (setq y (red y)))									      (setq y (red y)))
	     (t (setq sum (- (svref (lt x) 0) (svref (lt y) 0)))		    |		     (t (setq sum (- (elt (lt x) 0) (elt (lt y) 0)))
		(unless (0? sum)									(unless (0? sum)
		  (collect-term (lt x) sum))								  (collect-term (lt x) sum))
		(setq x (red x) y (red y)))))))) 							(setq x (red x) y (red y)))))))) 

(defmethod-sd times ((x epolynomial) (y epolynomial))					(defmethod-sd times ((x epolynomial) (y epolynomial))
  (same-greater-functions (x y)								  (same-greater-functions (x y)
    (bind-domain-context domain								    (bind-domain-context domain
      (make-epolynomial* domain greater-function					      (make-epolynomial* domain greater-function
			 (gterms-times greater-function								 (gterms-times greater-function
				       (poly-form x) (poly-form y))))))							       (poly-form x) (poly-form y))))))

;; Assumes we are working over an integral domain.					;; Assumes we are working over an integral domain.
(defun gterms-mon-times (poly-terms term)						(defun gterms-mon-times (poly-terms term)
  (let ((c (svref term 0))								  (let ((c (svref term 0))
	(dim (array-dimension term 0)))								(dim (array-dimension term 0)))
    (if (0? c) (terms0)									    (if (0? c) (terms0)
	(loop for pterm in poly-terms								(loop for pterm in poly-terms
	      collect (let ((nterm (make-array dim)))						      collect (let ((nterm (make-array dim)))
			(setf (svref nterm 0)									(setf (svref nterm 0)
			      (* (svref pterm 0) (svref term 0)))						      (* (svref pterm 0) (svref term 0)))
			(loop for i fixnum upfrom 1 below dim							(loop for i fixnum upfrom 1 below dim
			      do (setf (svref nterm i)								      do (setf (svref nterm i)
				       (cl:+  (svref pterm i)								       (cl:+  (svref pterm i)
						(svref term i))))									(svref term i))))
			nterm)))))										nterm)))))

(defun gterm-times (x-term y-term dim)							(defun gterm-times (x-term y-term dim)
  (declare (type simple-array x-term y-term)						  (declare (type simple-array x-term y-term)
	   (optimize (safety 0)))								   (optimize (safety 0)))
  (let ((e (make-array dim)))								  (let ((e (make-array dim)))
    (loop for i fixnum upfrom 1 below dim						    (loop for i fixnum upfrom 1 below dim
	  do (setf (svref e i)									  do (setf (svref e i)
		   (the fixnum (cl:+ (the fixnum (svref x-term i))					   (the fixnum (cl:+ (the fixnum (svref x-term i))
				       (the fixnum (svref y-term i))))))						       (the fixnum (svref y-term i))))))
    e))											    e))

(defun gterm-quot (x-term y-term dim)							(defun gterm-quot (x-term y-term dim)
  (declare (type simple-array x-term y-term)						  (declare (type simple-array x-term y-term)
	   (optimize (safety 0)))								   (optimize (safety 0)))
  (let ((e (make-array dim)))								  (let ((e (make-array dim)))
    (loop for i fixnum upfrom 1 below dim						    (loop for i fixnum upfrom 1 below dim
	  do (setf (svref e i)									  do (setf (svref e i)
		   (the fixnum (cl:- (the fixnum (svref x-term i))					   (the fixnum (cl:- (the fixnum (svref x-term i))
				       (the fixnum (svref y-term i))))))						       (the fixnum (svref y-term i))))))
    e))											    e))

(defun gterm-lcm (x-term y-term dim)							(defun gterm-lcm (x-term y-term dim)
  (declare (type simple-array x-term y-term)						  (declare (type simple-array x-term y-term)
	   (optimize (safety 0)))								   (optimize (safety 0)))
  (let ((e (make-array dim)))								  (let ((e (make-array dim)))
    (loop for i fixnum upfrom 1 below dim						    (loop for i fixnum upfrom 1 below dim
	  do (setf (svref e i) (cl:max (the fixnum (svref x-term i))				  do (setf (svref e i) (cl:max (the fixnum (svref x-term i))
					(the fixnum (svref y-term i)))))							(the fixnum (svref y-term i)))))
    e))											    e))

(defun gterm-disjoint (x-term y-term dim)						(defun gterm-disjoint (x-term y-term dim)
  (declare (type simple-array x-term y-term)						  (declare (type simple-array x-term y-term)
	   (optimize (safety 0)))								   (optimize (safety 0)))
  (loop for i fixnum upfrom 1 below dim							  (loop for i fixnum upfrom 1 below dim
	when (not (or (cl:zerop (the fixnum (svref x-term i)))					when (not (or (cl:zerop (the fixnum (svref x-term i)))
		      (cl:zerop (the fixnum (svref y-term i)))))					      (cl:zerop (the fixnum (svref y-term i)))))
	  do (return nil)									  do (return nil)
	finally (return t)))									finally (return t)))

(defun gterm-dominates (x-term y-term dim)						(defun gterm-dominates (x-term y-term dim)
  (declare (type simple-array x-term y-term)						  (declare (type simple-array x-term y-term)
	   (optimize (safety 0)))								   (optimize (safety 0)))
  (loop for i fixnum upfrom 1 below dim							  (loop for i fixnum upfrom 1 below dim
	when (cl:< (the fixnum (svref x-term i))						when (cl:< (the fixnum (svref x-term i))
		     (the fixnum (svref y-term i)))							     (the fixnum (svref y-term i)))
	  do (return nil)									  do (return nil)
	finally (return t)))									finally (return t)))

(defun gterm-equal (x-term y-term dim)							(defun gterm-equal (x-term y-term dim)
  (declare (type simple-array x-term y-term)						  (declare (type simple-array x-term y-term)
	   (optimize (safety 0)))								   (optimize (safety 0)))
  (loop for i fixnum upfrom 1 below dim							  (loop for i fixnum upfrom 1 below dim
	do (when (not (cl:= (the fixnum (svref x-term i))					do (when (not (cl:= (the fixnum (svref x-term i))
			      (the fixnum (svref y-term i))))							      (the fixnum (svref y-term i))))
	     (return nil))									     (return nil))
	finally (return t)))									finally (return t)))

(defun gterm-constant? (term dim)							(defun gterm-constant? (term dim)
  (declare (type simple-array term)							  (declare (type simple-array term)
	   (optimize (safety 0)))								   (optimize (safety 0)))
  (loop for i fixnum upfrom 1 below dim							  (loop for i fixnum upfrom 1 below dim
	do (when (not (cl:zerop (the fixnum (svref term i))))					do (when (not (cl:zerop (the fixnum (svref term i))))
	     (return nil))									     (return nil))
	finally (return t)))									finally (return t)))

(defun gterms-times (greater-function x y)						(defun gterms-times (greater-function x y)
  (let (;; Multiply x by the first term of y.  This is the initial			  (let (;; Multiply x by the first term of y.  This is the initial
	;; term list we will modify.								;; term list we will modify.
	(answer (gterms-mon-times x (lt y))) 							(answer (gterms-mon-times x (lt y))) 
	(dim (length (first x)))								(dim (length (first x)))
	e c)											e c)
    (setq answer (cons nil answer))							    (setq answer (cons nil answer))
    (loop for y-term in (red y)								    (loop for y-term in (red y)
	  for ans = answer do									  for ans = answer do
      (loop for x-term in x do								      (loop for x-term in x do
	(unless (0? (setq c (* (svref x-term 0) (svref y-term 0))))				(unless (0? (setq c (* (svref x-term 0) (svref y-term 0))))
	  (setq e (gterm-times x-term y-term dim))						  (setq e (gterm-times x-term y-term dim))
	  ;; Find place to insert this term.							  ;; Find place to insert this term.
	  (loop	for red-ans = (red ans) do							  (loop	for red-ans = (red ans) do
	    ;; Sure would be nice if the complier recognized and optimized			    ;; Sure would be nice if the complier recognized and optimized
	    ;; the usages of (red ans)								    ;; the usages of (red ans)
	    (cond ((or (terms0? red-ans)							    (cond ((or (terms0? red-ans)
		       (%funcall greater-function e (lt red-ans)))					       (%funcall greater-function e (lt red-ans)))
		   (setf (svref e 0) c)									   (setf (svref e 0) c)
		   (setf (red ans) (list e))								   (setf (red ans) (list e))
		   (return t))										   (return t))	
		  ((gterm-equal e (lt red-ans) dim)							  ((gterm-equal e (lt red-ans) dim)
		   (setf (svref (lt red-ans) 0)								   (setf (svref (lt red-ans) 0)
			 (+ (svref (lt red-ans) 0) c))								 (+ (svref (lt red-ans) 0) c))
		   (return t))										   (return t))
		  (t (setq ans red-ans)))))))								  (t (setq ans red-ans)))))))
    (loop for ans on answer								    (loop for ans on answer
	  do (when  (and (red ans) (0? (svref (lt (red ans)) 0)))				  do (when  (and (red ans) (0? (svref (lt (red ans)) 0)))
	       (setf (red ans) (red (red ans)))))						       (setf (red ans) (red (red ans)))))
    (red answer)))									    (red answer)))

(defmethod expt ((base epolynomial) (expt integer))					(defmethod expt ((base epolynomial) (expt integer))
  (let ((domain (domain-of base))							  (let ((domain (domain-of base))
	(cf (greater-function-of base)))							(cf (greater-function-of base)))
    (bind-domain-context domain								    (bind-domain-context domain
      (make-epolynomial* domain cf (gterms-expt cf (poly-form base) expt)))))		      (make-epolynomial* domain cf (gterms-expt cf (poly-form base) expt)))))

(defun gterms-expt (cf terms exp)							(defun gterms-expt (cf terms exp)
  (cond ((e0? exp)									  (cond ((e0? exp)
	 (list (make-eterm (lt terms) (one *coefficient-domain*))))				 (list (make-eterm (lt terms) (one *coefficient-domain*))))
	(t (let ((ans terms))									(t (let ((ans terms))
	     (loop for i below exp								     (loop for i below exp
		   do (setf ans (gterms-times cf ans terms)))						   do (setf ans (gterms-times cf ans terms)))
	     ans))))										     ans))))


(defmethod make-mpolynomial								(defmethod make-mpolynomial
    ((domain multivariate-polynomial-ring) (poly epolynomial))				    ((domain multivariate-polynomial-ring) (poly epolynomial))
  (let* ((dimension (length (ring-variables domain))))					  (let* ((dimension (length (ring-variables domain))))
    (labels ((convert-term (term i)							    (labels ((convert-term (term i)
	       (cond ((> i dimension)								       (cond ((> i dimension)
		      (svref term 0))									      (svref term 0))
		     ((cl:zerop (aref term i))								     ((cl:zerop (aref term i))
		      (convert-term term (cl:+ i 1)))							      (convert-term term (cl:+ i 1)))
		     (t `(,(cl:- i 1)									     (t `(,(cl:- i 1)
			   (,(aref term i) .									   (,(aref term i) .
			      ,(convert-term term (cl:+ i 1))))))))						      ,(convert-term term (cl:+ i 1))))))))
      (make-polynomial domain								      (make-polynomial domain
	(loop for term in (poly-form poly)							(loop for term in (poly-form poly)
	      for sum = (convert-term term 1)							      for sum = (convert-term term 1)
		then (poly-plus sum (convert-term term 1))						then (poly-plus sum (convert-term term 1))
	      finally (return sum))))))								      finally (return sum))))))
;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-		;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-
;;; ===========================================================================		;;; ===========================================================================
;;;			      Fourier Transforms					;;;			      Fourier Transforms
;;; ===========================================================================		;;; ===========================================================================
;;; (c) Copyright 1989, 1993 Cornell University						;;; (c) Copyright 1989, 1993 Cornell University

;;; fourier.lisp,v 1.3 1994/11/15 19:55:25 rz Exp					;;; fourier.lisp,v 1.3 1994/11/15 19:55:25 rz Exp

(in-package "WEYLI")								    |	(in-package :weyli)

(make::adjust-version-numbers Weyl "1.3")					    |	;;; DELETE (make::adjust-version-numbers Weyl "1.3")
										    >
										    >	(defgeneric make-ge-fourier (domain argument svar fvar)
										    >	  (:documentation
										    >	   "The purpose of this method is not known."))

(defmethod make-ge-fourier ((domain general-expressions) argument svar fvar)		(defmethod make-ge-fourier ((domain general-expressions) argument svar fvar)
  (make-instance 'ge-fourier :domain domain :argument argument				  (make-instance 'ge-fourier :domain domain :argument argument
		 :space-var svar :freq-var fvar))							 :space-var svar :freq-var fvar))

(defmethod print-object ((expr ge-fourier) stream)					(defmethod print-object ((expr ge-fourier) stream)
  (format stream "Four{~S, ~S->~S}"							  (format stream "Four{~S, ~S->~S}"
	  (argument-of expr) (space-var-of expr) (freq-var-of expr)))				  (argument-of expr) (space-var-of expr) (freq-var-of expr)))

(defmethod ge-equal ((x ge-fourier) (y ge-fourier))					(defmethod ge-equal ((x ge-fourier) (y ge-fourier))
  (and (ge-equal (argument-of x) (argument-of y))					  (and (ge-equal (argument-of x) (argument-of y))
       (ge-equal (space-var-of x) (space-var-of y))					       (ge-equal (space-var-of x) (space-var-of y))
       (ge-equal (freq-var-of x) (freq-var-of y))))					       (ge-equal (freq-var-of x) (freq-var-of y))))

(defmethod ge-great ((x ge-fourier) (y ge-fourier))					(defmethod ge-great ((x ge-fourier) (y ge-fourier))
  (cond ((ge-great (argument-of x) (argument-of y)) t)					  (cond ((ge-great (argument-of x) (argument-of y)) t)
	((ge-great (argument-of y) (argument-of x)) nil)					((ge-great (argument-of y) (argument-of x)) nil)
	((ge-great (space-var-of x) (space-var-of y)) t)					((ge-great (space-var-of x) (space-var-of y)) t)	
	((ge-great (space-var-of y) (space-var-of x)) nil)					((ge-great (space-var-of y) (space-var-of x)) nil)
	((ge-great (freq-var-of x) (freq-var-of y)) t)))					((ge-great (freq-var-of x) (freq-var-of y)) t)))

(defmethod fourier ((exp number) &rest vars)					    |	(defgeneric ge-fourier (exp svar fvar)
  (declare (ignore vars))							    |	  (:documentation
  (make-element *general* exp))							    |	   "The purpose of this method is unknown.")
										    |	  (:method (exp svar fvar)
(defmethod fourier ((exp numeric) &rest vars)					    <
  (declare (ignore vars))							    <
  exp)										    <
										    <
(defmethod fourier ((exp (or symbol general-expression)) &rest vars)		    <
  (setq exp (coerce exp *general*))						    <
  (loop for (sv fv) on vars by #'cddr						    <
	do (setq exp (ge-fourier exp (coerce sv *general*)			    <
				     (coerce fv *general*))))			    <
  exp)										    <
										    <
(defmethod ge-fourier (exp svar fvar)						    <
  (declare (ignore fvar))								    (declare (ignore fvar))
  (error "Don't know how to take the Fourier transform of ~S wrt ~S"			    (error "Don't know how to take the Fourier transform of ~S wrt ~S"
	 exp svar))								    |	           exp svar)))

(defmethod ge-fourier ((exp general-expression) (svar symbol) (fvar symbol))  		(defmethod ge-fourier ((exp general-expression) (svar symbol) (fvar symbol))  
  (ge-fourier exp (coerce svar (domain-of exp)) (coerce fvar (domain-of exp))))		  (ge-fourier exp (coerce svar (domain-of exp)) (coerce fvar (domain-of exp))))

(defmethod ge-fourier (exp (svar ge-variable) (fvar ge-variable))			(defmethod ge-fourier (exp (svar ge-variable) (fvar ge-variable))
  (make-ge-fourier (domain-of svar) (coerce exp (domain-of svar)) svar fvar))		  (make-ge-fourier (domain-of svar) (coerce exp (domain-of svar)) svar fvar))

(defmethod ge-fourier ((exp numeric) (svar ge-variable) (fvar ge-variable))		(defmethod ge-fourier ((exp numeric) (svar ge-variable) (fvar ge-variable))
  exp)											  exp)

(defmethod ge-fourier ((exp ge-variable) (svar ge-variable) (fvar ge-variable))		(defmethod ge-fourier ((exp ge-variable) (svar ge-variable) (fvar ge-variable))
  (let ((domain (domain-of exp)))							  (let ((domain (domain-of exp)))
    (unless (and (eql domain (domain-of svar))						    (unless (and (eql domain (domain-of svar))
		 (eql domain (domain-of fvar)))								 (eql domain (domain-of fvar)))
      (error "Taking Fourier transform from different domains"))			      (error "Taking Fourier transform from different domains"))
    (cond ((ge-equal exp svar) fvar)							    (cond ((ge-equal exp svar) fvar)
	  ((depends-on? exp svar)								  ((depends-on? exp svar)
	   (make-ge-fourier domain exp svar fvar))						   (make-ge-fourier domain exp svar fvar))
	  (t exp))))										  (t exp))))

(defmethod ge-fourier ((exp ge-plus) (svar ge-variable) (fvar ge-variable))		(defmethod ge-fourier ((exp ge-plus) (svar ge-variable) (fvar ge-variable))
  (let ((domain (domain-of exp)))							  (let ((domain (domain-of exp)))
    (cond ((and (eql domain (domain-of svar))						    (cond ((and (eql domain (domain-of svar))
		(eql domain (domain-of fvar)))								(eql domain (domain-of fvar)))
	   (call-next-method))									   (call-next-method))
	  (t (simplify										  (t (simplify
	      (make-ge-plus domain								      (make-ge-plus domain
		(loop for x in (terms-of exp)						                            (loop for x in (terms-of exp)
		      collect (ge-fourier x svar fvar))))))))				                                  collect (ge-fourier x svar fvar))))))))

(defmethod ge-fourier ((exp ge-times) (svar ge-variable) (fvar ge-variable))		(defmethod ge-fourier ((exp ge-times) (svar ge-variable) (fvar ge-variable))
  (let ((domain (domain-of exp))							  (let ((domain (domain-of exp))
	terms depend-term free-terms)								terms depend-term free-terms)
    (unless (and (eql domain (domain-of svar))						    (unless (and (eql domain (domain-of svar))
		 (eql domain (domain-of fvar)))								 (eql domain (domain-of fvar)))
      (error "Taking Fourier transform from different domains"))			      (error "Taking Fourier transform from different domains"))
  (setq terms (terms-of exp))								    (setq terms (terms-of exp))
  (loop for term in terms								    (loop for term in terms
	do (when (depends-on? term svar)						          do (when (depends-on? term svar)
	     (cond ((null depend-term)							               (cond ((null depend-term)
		    (setq depend-term term))						                      (setq depend-term term))
		   (t (return (setq free-terms :non-linear)))))				                     (t (return (setq free-terms :non-linear)))))
		 finally (setq free-terms						          finally (setq free-terms
			       (remove depend-term terms)))				                        (remove depend-term terms)))
  (cond ((eql free-terms :non-linear)							    (cond ((eql free-terms :non-linear)
	 (make-ge-fourier domain exp svar fvar))					           (make-ge-fourier domain exp svar fvar))
	((null depend-term)								          ((null depend-term)
	 exp)										           exp)
	(t (simplify									          (t (simplify
	    (make-ge-times domain							              (make-ge-times domain
	      (cons (ge-fourier depend-term svar fvar)					                             (cons (ge-fourier depend-term svar fvar)
		    free-terms)))))))							                                   free-terms)))))))

#+ignore										#+ignore
(defmethod ge-fourier ((exp ge-deriv) (svar ge-variable) (fvar ge-variable))		(defmethod ge-fourier ((exp ge-deriv) (svar ge-variable) (fvar ge-variable))
  (let ((domain (domain-of exp)))							  (let ((domain (domain-of exp)))
    (unless (and (eql domain (domain-of svar))						    (unless (and (eql domain (domain-of svar))
		 (eql domain (domain-of fvar)))								 (eql domain (domain-of fvar)))
      (error "Taking Fourier transform from different domains"))			      (error "Taking Fourier transform from different domains"))
  (loop for entry in (varlist-of exp)							    (loop for entry in (varlist-of exp)
	with varlist									          with varlist
	do (when (ge-equal svar (first entry))						          do (when (ge-equal svar (first entry))
	     (setq varlist (remove entry (varlist-of exp)))				               (setq varlist (remove entry (varlist-of exp)))
	     (return									               (return
	       (simplify								                 (simplify
		(* (expt fvar (second entry))						                  (* (expt fvar (second entry))
		   (if (null varlist)							                     (if (null varlist)
		       (ge-fourier (argument-of exp) svar fvar)				                         (ge-fourier (argument-of exp) svar fvar)
		       (make-ge-deriv domain						                         (make-ge-deriv domain
				      (ge-fourier (argument-of exp) svar fvar)		                                        (ge-fourier (argument-of exp) svar fvar)
				      varlist))))))					                                        varlist))))))
	   finally									          finally
	(return 									          (return 
	  (simplify									            (simplify
	   (make-ge-deriv domain							             (make-ge-deriv domain
			  (ge-fourier exp svar fvar)					                            (ge-fourier exp svar fvar)
			  (varlist-of exp)))))))					                            (varlist-of exp)))))))

										    >	(defgeneric fourier (expression &rest variables)
										    >	  (:documentation
										    >	   "The purpose of this method is unknown."))
										    >
										    >	(defmethod fourier ((exp number) &rest vars)
										    >	  (declare (ignore vars))
										    >	  (make-element *general* exp))
										    >
										    >	(defmethod fourier ((exp numeric) &rest vars)
										    >	  (declare (ignore vars))
										    >	  exp)
										    >
										    >	(defmethod fourier ((exp symbol) &rest vars)
										    >	  (setq exp (coerce exp *general*))
										    >	  (loop for (sv fv) on vars by #'cddr
										    >		do (setq exp (ge-fourier exp (coerce sv *general*)
										    >	                                 (coerce fv *general*))))
										    >	  exp)
										    >
										    >	(defmethod fourier ((exp general-expression) &rest vars)
										    >	  (setq exp (coerce exp *general*))
										    >	  (loop for (sv fv) on vars by #'cddr
										    >		do (setq exp (ge-fourier exp (coerce sv *general*)
										    >	                                 (coerce fv *general*))))
										    >	  exp)
										    >
;; Inverse Fourier Transforms								;; Inverse Fourier Transforms
										    >
										    >	(defgeneric make-ge-ifourier (domain argument svar fvar)
										    >	  (:documentation
										    >	   "The purpose of this method is unknown."))

(defmethod make-ge-ifourier ((domain general-expressions) argument svar fvar)		(defmethod make-ge-ifourier ((domain general-expressions) argument svar fvar)
  (make-instance 'ge-ifourier :domain domain :argument argument				  (make-instance 'ge-ifourier :domain domain :argument argument
		 :space-var svar :freq-var fvar))							 :space-var svar :freq-var fvar))

(defmethod print-object ((expr ge-ifourier) stream)					(defmethod print-object ((expr ge-ifourier) stream)
  (format stream "IFour{~S, ~S->~S}"							  (format stream "IFour{~S, ~S->~S}"
	  (argument-of expr) (space-var-of expr) (freq-var-of expr)))				  (argument-of expr) (space-var-of expr) (freq-var-of expr)))
;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-		;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-
;;; ===========================================================================		;;; ===========================================================================
;;;			      Special Functions 					;;;			      Special Functions 
;;; ===========================================================================		;;; ===========================================================================
;;; (c) Copyright 1989, 1993 Cornell University						;;; (c) Copyright 1989, 1993 Cornell University

;;; functions.lisp,v 1.2 1994/11/15 19:55:26 rz Exp					;;; functions.lisp,v 1.2 1994/11/15 19:55:26 rz Exp


(in-package "WEYLI")								    |	(in-package :weyli)
										    <
(make::adjust-version-numbers Weyl "1.2")					    <

										    >	;;; DELETE (make::adjust-version-numbers Weyl "1.2")

;; Symbolic Lambda expressions								;; Symbolic Lambda expressions

(defun make-app-function (args body)							(defun make-app-function (args body)
  (let* ((domain (domain-of body))							  (let* ((domain (domain-of body))
         (old-vars (mapcar #'(lambda (x) (coerce x domain)) args))			         (old-vars (mapcar #'(lambda (x) (coerce x domain)) args))
         (new-vars nil))								         (new-vars nil))
    (loop for i upfrom 1								    (loop for i upfrom 1
          for v in old-vars								          for v in old-vars
          for new-var =  (coerce (intern (format nil "V.~D" i)) domain)			          for new-var =  (coerce (intern (format nil "V.~D" i)) domain)
          do (cond ((ge-equal new-var v)						          do (cond ((ge-equal new-var v)
                    (push v new-vars))							                    (push v new-vars))
                   (t (setq body (substitute new-var v body))				                   (t (setq body (substitute new-var v body))
                      (push new-var new-vars))))					                      (push new-var new-vars))))
    (setq new-vars (reverse new-vars))							    (setq new-vars (reverse new-vars))
    (when (typep body 'general-expression)						    (when (typep body 'general-expression)
      (setq body (expand body)))							      (setq body (expand body)))
    (cond ((and (typep body 'ge-application)						    (cond ((and (typep body 'ge-application)
		(loop for v in new-vars									(loop for v in new-vars
		      for a in (args-of body)								      for a in (args-of body)
		      do (when (not (ge-equal a v))							      do (when (not (ge-equal a v))
			   (return nil))									   (return nil))
		      finally (return t)))								      finally (return t)))
	   (funct-of body))									   (funct-of body))
	  (t (make-instance 'applicable-function 						  (t (make-instance 'applicable-function 
			    :domain domain									    :domain domain
			    :bound-vars new-vars								    :bound-vars new-vars
			    :nargs (length args)								    :nargs (length args)
			    :body body)))))									    :body body)))))

(defmethod print-object ((fun applicable-function) stream)				(defmethod print-object ((fun applicable-function) stream)
  (format stream "(lambda ~S ~S)" (bound-vars-of fun) (body-of fun)))			  (format stream "(lambda ~S ~S)" (bound-vars-of fun) (body-of fun)))

(defmethod apply ((fun applicable-function) &rest args)					(defmethod apply ((fun applicable-function) &rest args)
  (setq args (accum-apply-args args))							  (setq args (accum-apply-args args))
  (unless (eql (nargs-of fun) (length args))						  (unless (eql (nargs-of fun) (length args))
    (error "Argument lengths don't match"))						    (error "Argument lengths don't match"))
  (let* ((body (body-of fun))								  (let* ((body (body-of fun))
         (domain (domain-of body)))							         (domain (domain-of body)))
    (loop for arg in args								    (loop for arg in args
          for v in (bound-vars-of fun)							          for v in (bound-vars-of fun)
          do (setq body (substitute (coerce arg domain) v body)))			          do (setq body (substitute (coerce arg domain) v body)))
    body))										    body))

(defun canonicalize-functions (x y)							(defun canonicalize-functions (x y)
  (unless (eql (nargs-of x) (nargs-of y))						  (unless (eql (nargs-of x) (nargs-of y))
    (error "Two functions have different number of arguments"))				    (error "Two functions have different number of arguments"))
  (let ((x-body (body-of x))								  (let ((x-body (body-of x))
        (y-body (body-of y)))								        (y-body (body-of y)))
    (loop for x-arg in (bound-vars-of x)						    (loop for x-arg in (bound-vars-of x)
          for y-arg in (bound-vars-of y)						          for y-arg in (bound-vars-of y)
          do (unless (ge-equal x-arg y-arg)						          do (unless (ge-equal x-arg y-arg)
               (setq y-body (substitute x-arg y-arg y-body))))				               (setq y-body (substitute x-arg y-arg y-body))))
    (values (bound-vars-of x) x-body y-body)))						    (values (bound-vars-of x) x-body y-body)))

										    >	;;; FIXME : The macro requires substantial auditing.
(defmacro define-applicable-function-binary (operator)					(defmacro define-applicable-function-binary (operator)
  `(progn										  `(progn
     (defmethod ,operator ((x applicable-function) y)					    (defmethod ,operator ((x applicable-function) y)
       (make-app-function (bound-vars-of x) (,operator (body-of x) y)))			      (make-app-function (bound-vars-of x) (,operator (body-of x) y)))

     (defmethod ,operator (x (y applicable-function))					    (defmethod ,operator (x (y applicable-function))
       (make-app-function (bound-vars-of y) (,operator x (body-of y))))			      (make-app-function (bound-vars-of y) (,operator x (body-of y))))

     (defmethod ,operator ((x applicable-function) (y domain-element))			    (defmethod ,operator ((x applicable-function) (y domain-element))
       (make-app-function (bound-vars-of x) (,operator (body-of x) y)))			      (make-app-function (bound-vars-of x) (,operator (body-of x) y)))

     (defmethod ,operator ((x domain-element) (y applicable-function))			    (defmethod ,operator ((x domain-element) (y applicable-function))
       (make-app-function (bound-vars-of y) (,operator x (body-of y))))			      (make-app-function (bound-vars-of y) (,operator x (body-of y))))

     (defmethod-sd ,operator ((x applicable-function) (y applicable-function))		    (defmethod-sd ,operator ((x applicable-function) (y applicable-function))
       (multiple-value-bind (args x-body y-body) (canonicalize-functions x y)		      (multiple-value-bind (args x-body y-body) (canonicalize-functions x y)
	 (make-app-function args (,operator x-body y-body))))				        (make-app-function args (,operator x-body y-body))))

     ;; FIXTHIS: Why do the following two methods need to be :around methods?		    ;; FIXTHIS: Why do the following two methods need to be :around methods?
     ;; The :around is only needed for MCL!!						    ;; The :around is only needed for MCL!!
     (defmethod ,operator #+MCL :around ((x applicable-function) (y ge-function)) 	    (defmethod ,operator #+MCL :around ((x applicable-function) (y ge-function)) 
       (unless (= (nargs-of x) (nargs-of y))						               (unless (= (nargs-of x) (nargs-of y))
	 (error "Can't add two functions with different arity: ~S ~S"			                 (error "Can't add two functions with different arity: ~S ~S"
		x y))									                        x y))
       (make-app-function (bound-vars-of x)						               (make-app-function (bound-vars-of x)
			  (,operator (body-of x) (apply y (bound-vars-of x)))))		                                  (,operator (body-of x) (apply y (bound-vars-of x

     (defmethod ,operator #+MCL :around ((y ge-function) (x applicable-function)) 	    (defmethod ,operator #+MCL :around ((y ge-function) (x applicable-function)) 
       (unless (= (nargs-of x) (nargs-of y))						               (unless (= (nargs-of x) (nargs-of y))
	 (error "Can't add two functions with different arity: ~S ~S"			                 (error "Can't add two functions with different arity: ~S ~S"
		x y))									                        x y))
       (make-app-function (bound-vars-of x)						               (make-app-function (bound-vars-of x)
			  (,operator (body-of x) (apply y (bound-vars-of x)))))		                                  (,operator (body-of x) (apply y (bound-vars-of x

     (defmethod ,operator ((x ge-function) y) 						    (defmethod ,operator ((x ge-function) y) 
       (make-app-function '(%temp%) (,operator (funcall x '%temp%) y)))			      (make-app-function '(%temp%) (,operator (funcall x '%temp%) y)))

     ;; This is needed because of precidence problems.					    ;; This is needed because of precidence problems.
     ;; (number domain-elt) comes before (t ge-function)				    ;; (number domain-elt) comes before (t ge-function)
     (defmethod ,operator ((x (or t number numeric)) (y ge-function))		    |	    (defmethod ,operator (x (y ge-function))
										    >	      (make-app-function '(%temp%) (,operator x (funcall y '%temp%))))
										    >
										    >	    (defmethod ,operator ((x number) (y ge-function))
										    >	      (make-app-function '(%temp%) (,operator x (funcall y '%temp%))))
										    >
										    >	    (defmethod ,operator ((x numeric) (y ge-function))
       (make-app-function '(%temp%) (,operator x (funcall y '%temp%))))			      (make-app-function '(%temp%) (,operator x (funcall y '%temp%))))

     (defmethod-sd ,operator ((x ge-function) (y domain-element))			    (defmethod-sd ,operator ((x ge-function) (y domain-element))
       (make-app-function '(%temp%) (,operator (funcall x '%temp%) y)))			      (make-app-function '(%temp%) (,operator (funcall x '%temp%) y)))

     (defmethod-sd ,operator ((x domain-element) (y ge-function))			    (defmethod-sd ,operator ((x domain-element) (y ge-function))
       (make-app-function '(%temp%) (,operator x (funcall y '%temp%))))			      (make-app-function '(%temp%) (,operator x (funcall y '%temp%))))

     (defmethod-sd ,operator ((x ge-function) (y ge-function))				    (defmethod-sd ,operator ((x ge-function) (y ge-function))
       (unless (= (nargs-of x) (nargs-of y))						      (unless (= (nargs-of x) (nargs-of y))
	 (error "Can't combine two functions with different arity: (~S ~S ~S)"		        (error "Can't combine two functions with different arity: (~S ~S ~S)"
		',operator x y))							               ',operator x y))
       (make-app-function '(%temp%)							      (make-app-function '(%temp%)
	    (,operator (funcall x '%temp%) (funcall  y '%temp%))))))			                         (,operator (funcall x '%temp%) (funcall  y '%temp%))))))

(defmethod 0? ((x applicable-function))							(defmethod 0? ((x applicable-function))
  (0? (body-of x)))									  (0? (body-of x)))

(defmethod 1? ((x applicable-function))							(defmethod 1? ((x applicable-function))
  (1? (body-of x)))									  (1? (body-of x)))

(define-applicable-function-binary plus)						(define-applicable-function-binary plus)
(define-applicable-function-binary difference)						(define-applicable-function-binary difference)

(defmethod minus ((x ge-function))							(defmethod minus ((x ge-function))
  (make-app-function '(%temp%) (minus (funcall x '%temp%))))				  (make-app-function '(%temp%) (minus (funcall x '%temp%))))

(defmethod minus ((x applicable-function))						(defmethod minus ((x applicable-function))
  (make-app-function (bound-vars-of x) (minus (body-of x))))				  (make-app-function (bound-vars-of x) (minus (body-of x))))

(define-applicable-function-binary times)						(define-applicable-function-binary times)
(define-applicable-function-binary quotient)						(define-applicable-function-binary quotient)

(defmethod recip ((x ge-function))							(defmethod recip ((x ge-function))
  (make-app-function '(%temp%) (recip (funcall x '%temp%))))				  (make-app-function '(%temp%) (recip (funcall x '%temp%))))

(defmethod recip ((x applicable-function))						(defmethod recip ((x applicable-function))
  (make-app-function (bound-vars-of x) (recip (body-of x))))				  (make-app-function (bound-vars-of x) (recip (body-of x))))

(defmethod expt ((x applicable-function) (y (or number symbol)))		    |	(defmethod expt ((x applicable-function) (y number))
										    >	  (make-app-function (bound-vars-of x) (expt (body-of x) y)))
										    >
										    >	(defmethod expt ((x applicable-function) (y symbol))
  (make-app-function (bound-vars-of x) (expt (body-of x) y)))				  (make-app-function (bound-vars-of x) (expt (body-of x) y)))

(defmethod-sd expt ((x applicable-function) (y domain-element))				(defmethod-sd expt ((x applicable-function) (y domain-element))
  (if (not (typep y 'abstract-function))						  (if (not (typep y 'abstract-function))
      (make-app-function (bound-vars-of x) (expt (body-of x) y))			      (make-app-function (bound-vars-of x) (expt (body-of x) y))
      (call-next-method)))								      (call-next-method)))

(defmethod expt ((x ge-function) (y (or number symbol)))			    |	(defmethod expt ((x ge-function) (y number))
										    >	  (make-app-function '(%temp%) (expt (funcall x '%temp%) y)))
										    >
										    >	(defmethod expt ((x ge-function) (y symbol))
  (make-app-function '(%temp%) (expt (funcall x '%temp%) y)))				  (make-app-function '(%temp%) (expt (funcall x '%temp%) y)))

(defmethod-sd expt ((x ge-function) (y domain-element))					(defmethod-sd expt ((x ge-function) (y domain-element))
  (if (not (typep y 'abstract-function))						  (if (not (typep y 'abstract-function))
      (make-app-function '(%temp%) (expt (funcall x '%temp%) y))			      (make-app-function '(%temp%) (expt (funcall x '%temp%) y))
      (call-next-method)))								      (call-next-method)))

(defmethod deriv ((exp applicable-function) &rest vars)					(defmethod deriv ((exp applicable-function) &rest vars)
  (make-app-function (bound-vars-of exp)					    |	  (make-app-function
     (apply #'deriv (cons (body-of exp)						    |	   (bound-vars-of exp)
										    >	   (apply
										    >	    #'deriv
										    >	    (cons (body-of exp)
        (loop for v in vars								          (loop for v in vars
	      collect (cond ((typep v 'symbol) v)					                collect (cond ((typep v 'symbol) v)
			    ((typep v 'ge-variable) v)					                              ((typep v 'ge-variable) v)
	                    ((and (typep v 'integer)					                              ((and (typep v 'integer)
				  (not (minusp v))					                                    (not (minusp v))
				  (< v (nargs-of exp)))					                                    (< v (nargs-of exp)))
			      (elt (bound-vars-of exp) v))				                               (elt (bound-vars-of exp) v))
			    (t (error "Cannot take deriv of ~A and ~A"			                              (t (error "Cannot take deriv of ~A and ~A"
				      exp v))))))))					                                        exp v))))))))

;; Special functions									;; Special functions

(defmacro def-ge-1oper (name (arg))							(defmacro def-ge-1oper (name (arg))
  (let ((maker-name (intern (format nil "MAKE-GE-~A" (string name))))			  (let ((maker-name (intern (format nil "MAKE-GE-~A" (string name))))
        (predicate-name (intern (format nil "GE-~A?" (string name)))))			        (predicate-name (intern (format nil "GE-~A?" (string name)))))
    `(progn										    `(progn
       (make-function nil ',name 1)							      (make-function nil ',name 1)
       (defun ,maker-name (domain ,arg)							      (defun ,maker-name (domain ,arg)
         (make-ge-funct domain (make-function domain ',name 1) ,arg))			        (make-ge-funct domain (make-function domain ',name 1) ,arg))
       (defun ,predicate-name (arg)							      (defun ,predicate-name (arg)
         (and (ge-application? arg)							        (and (ge-application? arg)
              (ge-function? (funct-of arg))						             (ge-function? (funct-of arg))
              (string-equal (name-of (funct-of arg)) ,(string name))))			             (string-equal (name-of (funct-of arg)) ,(string name))))
       (defmethod ,name ((,arg symbol))							      (defmethod ,name ((,arg symbol))
	 (simplify (,maker-name *general* (coerce ,arg *general*))))			        (simplify (,maker-name *general* (coerce ,arg *general*))))
       (defmethod ,name ((,arg numeric))						      (defmethod ,name ((,arg numeric))
	 (let* ((arg ,arg)								        (let* ((arg ,arg)
		domain)									               domain)
	   (cond ((typep (domain-of arg) 'general-expressions)				          (cond ((typep (domain-of arg) 'general-expressions)
		  (setq domain (domain-of arg)))					                 (setq domain (domain-of arg)))
		 (t (setq domain *general*)						                (t (setq domain *general*)
		    (setq arg (coerce arg domain))))					                   (setq arg (coerce arg domain))))
	 (simplify (,maker-name domain arg))))						          (simplify (,maker-name domain arg))))
       (defmethod ,name ((,arg general-expression))					      (defmethod ,name ((,arg general-expression))
	 (simplify (,maker-name (domain-of ,arg) ,arg)))				        (simplify (,maker-name (domain-of ,arg) ,arg)))
       )))										      )))

(defmacro defsimplify-funct (name args &body body)					(defmacro defsimplify-funct (name args &body body)
  (let ((simp-name (intern (format nil "SIMPF-~A" name))))				  (let ((simp-name (intern (format nil "SIMPF-~A" name))))
    `(progn										    `(progn
       (defun ,simp-name ,args ,@body)							      (defun ,simp-name ,args ,@body)
       (setf (getf (make-function nil ',name) 'simplify) ',simp-name))))		      (setf (getf (make-function nil ',name) 'simplify) ',simp-name))))

(defmacro defderiv-funct (name &body body)						(defmacro defderiv-funct (name &body body)
  (let ((fun-name (intern (format nil ".~A-deriv." name))))				  (let ((fun-name (intern (format nil ".~A-deriv." name))))
    `(progn										    `(progn
       (defun ,fun-name ()								      (defun ,fun-name ()
	 (setf (getf (make-function nil ',name) 'deriv) 				        (setf (getf (make-function nil ',name) 'deriv) 
	       (list ,@body)))								              (list ,@body)))
       (pushnew ',fun-name *initialize-contexts-funs*))))				      (pushnew ',fun-name *initialize-contexts-funs*))))

										    >	;;; FIXME : Track down the def-ge-1oper macro and generic function
										    >	;;; definition.
(def-ge-1oper ABS (x))									(def-ge-1oper ABS (x))
(def-ge-1oper REALPART (x))								(def-ge-1oper REALPART (x))
										    >	(def-ge-1oper IMAGPART (x))
										    >
(defsimplify-funct realpart (domain whole exp)						(defsimplify-funct realpart (domain whole exp)
  (declare (ignore domain))								  (declare (ignore domain))
  (cond ((or (ge-abs? exp) 								  (cond ((or (ge-abs? exp) 
             (ge-realpart? exp)								             (ge-realpart? exp)
             (ge-imagpart? exp))							             (ge-imagpart? exp))
         exp)										         exp)
        (t whole)))									        (t whole)))

(def-ge-1oper IMAGPART (x))							    <
(defsimplify-funct imagpart (domain whole exp)						(defsimplify-funct imagpart (domain whole exp)
  (cond ((or (ge-abs? exp) 								  (cond ((or (ge-abs? exp) 
             (ge-realpart? exp)								             (ge-realpart? exp)
             (ge-imagpart? exp))							             (ge-imagpart? exp))
         (zero domain))									         (zero domain))
        (t whole)))									        (t whole)))

(def-ge-1oper LOG (x))									(def-ge-1oper LOG (x))
(defsimplify-funct log (domain whole exp)
  (cond ((cl:floatp exp)								(defsimplify-funct log (domain whole exp)
         (make-element domain (cl:log exp)))						  (cond ((cl:floatp exp)
        ((ge-expt? exp)									         (make-element domain (cl:log exp)))
         (simplify									        ((ge-expt? exp)
          (make-ge-times domain								         (simplify
                         `(,(exponent-of exp)						          (make-ge-times domain
                           ,(make-ge-log (domain-of exp) (base-of exp))))))		                         `(,(exponent-of exp)
        (t whole)))									                           ,(make-ge-log (domain-of exp) (base-of exp))))))
											        (t whole)))
(defderiv-funct log
  (make-app-function '(x) (expt 'x -1)))						(defderiv-funct log
											  (make-app-function '(x) (expt 'x -1)))
(def-ge-1oper SIN (x))
(defsimplify-funct sin (domain whole exp)						(def-ge-1oper SIN (x))
  (cond ((cl:floatp exp)
         (make-element domain (cl:sin exp)))						(defsimplify-funct sin (domain whole exp)
        ((and (number? exp) (0? exp))							  (cond ((cl:floatp exp)
         (make-element domain 0))							         (make-element domain (cl:sin exp)))
        ((ge-minus? exp)								        ((and (number? exp) (0? exp))
         (- (make-ge-sin domain (- exp))))						         (make-element domain 0))
        (t whole)))									        ((ge-minus? exp)
											         (- (make-ge-sin domain (- exp))))
(defderiv-funct sin									        (t whole)))
  (make-app-function  '(x) (cos 'x)))
											(defderiv-funct sin
(def-ge-1oper COS (x))									  (make-app-function  '(x) (cos 'x)))
(defsimplify-funct cos (domain whole exp)
  (cond ((cl:floatp exp)								(def-ge-1oper COS (x))
         (make-element domain (cl:cos exp)))
        ((and (number? exp) (0? exp))							(defsimplify-funct cos (domain whole exp)
         (make-element domain 1))							  (cond ((cl:floatp exp)
        ((ge-minus? exp)								         (make-element domain (cl:cos exp)))
         (make-ge-cos domain (- exp)))							        ((and (number? exp) (0? exp))
        (t whole)))									         (make-element domain 1))
											        ((ge-minus? exp)
(defderiv-funct cos									         (make-ge-cos domain (- exp)))
    (make-app-function '(x) (- (sin 'x))))						        (t whole)))

(def-ge-1oper TAN (x))									(defderiv-funct cos
(defsimplify-funct tan (domain whole exp)						  (make-app-function '(x) (- (sin 'x))))
    (cond ((cl:floatp exp)
	   (make-element domain (cl:tan exp)))						(def-ge-1oper TAN (x))
	  ((and (number? exp) (0? exp))
	   (make-element domain 0))							(defsimplify-funct tan (domain whole exp)
	  ((ge-minus? exp)								  (cond ((cl:floatp exp)
	   (- (make-ge-tan domain (- exp))))						         (make-element domain (cl:tan exp)))
	  (t whole)))									        ((and (number? exp) (0? exp))
											         (make-element domain 0))
(defderiv-funct tan									        ((ge-minus? exp)
  (make-app-function '(x) (- (expt (cos 'x) -2))))					         (- (make-ge-tan domain (- exp))))
											        (t whole)))
(def-ge-1oper ASIN (x))
(defsimplify-funct asin (domain whole exp)						(defderiv-funct tan
  (cond ((cl:floatp exp)								  (make-app-function '(x) (- (expt (cos 'x) -2))))
         (make-element domain (cl:asin exp)))
        ((and (number? exp) (0? exp))							(def-ge-1oper ASIN (x))
         (make-element domain 0))
        ((ge-minus? exp)								(defsimplify-funct asin (domain whole exp)
         (- (make-ge-asin domain (- exp))))						  (cond ((cl:floatp exp)
        (t whole)))									         (make-element domain (cl:asin exp)))
											        ((and (number? exp) (0? exp))
(defderiv-funct asin									         (make-element domain 0))
  (make-app-function '(x) (- (expt (- 1 (expt 'x 2)) -1/2))))				        ((ge-minus? exp)
											         (- (make-ge-asin domain (- exp))))
(def-ge-1oper ACOS (x))									        (t whole)))
(defsimplify-funct acos (domain whole exp)
  (cond ((cl:floatp exp)								(defderiv-funct asin
         (make-element domain (cl:acos exp)))						  (make-app-function '(x) (- (expt (- 1 (expt 'x 2)) -1/2))))
        (t whole)))
											(def-ge-1oper ACOS (x))
(defderiv-funct acos
  (make-app-function '(x) (expt (- 1 (expt 'x 2)) -1/2)))				(defsimplify-funct acos (domain whole exp)
											  (cond ((cl:floatp exp)
										    )	         (make-element domain (cl:acos exp)))
										    )	        (t whole)))
										    )
										    )	(defderiv-funct acos
										    )	  (make-app-function '(x) (expt (- 1 (expt 'x 2)) -1/2)))
										    )
										    >	;;; FIXME : Correct the custom version of ATAN to account for 2
										    >	;;; arguments.
;; These are conditionalized out since, we might want to have a two			;; These are conditionalized out since, we might want to have a two
;; argument version of atan!.								;; argument version of atan!.
#+FIXTHIS										#+FIXTHIS
(def-ge-1oper ATAN (x))									(def-ge-1oper ATAN (x))
#+FIXTHIS										#+FIXTHIS
(defsimplify-funct atan (domain whole exp)						(defsimplify-funct atan (domain whole exp)
  (cond ((cl:floatp exp) (cl:atan exp))							  (cond ((cl:floatp exp) (cl:atan exp))
	  (t `(atan ,exp))))									  (t `(atan ,exp))))

#+FIXTHIS										#+FIXTHIS
(defderiv-funct atan									(defderiv-funct atan
  (make-app-function '(x) (/ (+ 1 (expt 'x 2)))))					  (make-app-function '(x) (/ (+ 1 (expt 'x 2)))))

(def-ge-1oper SINH (x))									(def-ge-1oper SINH (x))
(defsimplify-funct sinh (domain whole exp)
  (cond ((cl:floatp exp)								(defsimplify-funct sinh (domain whole exp)
         (make-element domain (cl:sinh exp)))						  (cond ((cl:floatp exp)
        ((and (number? exp) (0? exp))							         (make-element domain (cl:sinh exp)))
         (make-element domain 0))							        ((and (number? exp) (0? exp))
        ((ge-minus? exp)								         (make-element domain 0))
         (- (make-ge-sinh domain (- exp))))						        ((ge-minus? exp)
        (t whole)))									         (- (make-ge-sinh domain (- exp))))
											        (t whole)))
(defderiv-funct sinh 
  (make-app-function '(x) (cosh 'x)))							(defderiv-funct sinh 
											  (make-app-function '(x) (cosh 'x)))
(def-ge-1oper COSH (x))
(defsimplify-funct cosh (domain whole exp)						(def-ge-1oper COSH (x))
  (cond ((cl:floatp exp)
         (make-element domain (cl:cosh exp)))						(defsimplify-funct cosh (domain whole exp)
        ((and (number? exp) (0? exp))							  (cond ((cl:floatp exp)
         (make-element domain 1))							         (make-element domain (cl:cosh exp)))
        ((ge-minus? exp)								        ((and (number? exp) (0? exp))
         (make-ge-cosh domain (- exp)))							         (make-element domain 1))
        (t whole)))									        ((ge-minus? exp)
											         (make-ge-cosh domain (- exp)))
(defderiv-funct cosh									        (t whole)))
  (make-app-function '(x) (sinh 'x)))
											(defderiv-funct cosh
(def-ge-1oper TANH (x))									  (make-app-function '(x) (sinh 'x)))
(defsimplify-funct tanh (domain whole exp)
  (cond ((cl:floatp exp)								(def-ge-1oper TANH (x))
         (make-element domain (cl:tanh exp)))
        ((and (number? exp) (0? exp))							(defsimplify-funct tanh (domain whole exp)
         (make-element domain 0))							  (cond ((cl:floatp exp)
        ((ge-minus? exp)								         (make-element domain (cl:tanh exp)))
         (- (make-ge-tanh domain (- exp))))						        ((and (number? exp) (0? exp))
        (t whole)))									         (make-element domain 0))
											        ((ge-minus? exp)
(defderiv-funct tanh									         (- (make-ge-tanh domain (- exp))))
  (make-app-function '(x) (expt (cosh 'x) -2)))						        (t whole)))

(def-ge-1oper ASINH (x))								(defderiv-funct tanh
(defsimplify-funct asinh (domain whole exp)						  (make-app-function '(x) (expt (cosh 'x) -2)))
  (cond ((cl:floatp exp)
         (make-element domain (cl:asinh exp)))						(def-ge-1oper ASINH (x))
        ((and (number? exp) (0? exp))
         (make-element domain 0))							(defsimplify-funct asinh (domain whole exp)
        ((ge-minus? exp)								  (cond ((cl:floatp exp)
         (- (make-ge-asinh domain (- exp))))						         (make-element domain (cl:asinh exp)))
        (t whole)))									        ((and (number? exp) (0? exp))
											         (make-element domain 0))
(defderiv-funct asinh 									        ((ge-minus? exp)
  (make-app-function '(x) (expt (+ 1 (expt 'x 2)) -1/2)))				         (- (make-ge-asinh domain (- exp))))
											        (t whole)))
(def-ge-1oper ACOSH (x))
(defsimplify-funct acosh (domain whole exp)						(defderiv-funct asinh 
  (cond ((cl:floatp exp)								  (make-app-function '(x) (expt (+ 1 (expt 'x 2)) -1/2)))
         (make-element domain (cl:acosh exp)))
        (t whole)))									(def-ge-1oper ACOSH (x))

(defderiv-funct acosh 									(defsimplify-funct acosh (domain whole exp)
  (make-app-function '(x) (expt (+ 1 (expt 'x 2)) -1/2)))				  (cond ((cl:floatp exp)
											         (make-element domain (cl:acosh exp)))
#+FIXTHIS										        (t whole)))
(def-ge-1oper ATANH (x))
#+FIXTHIS										(defderiv-funct acosh 
(defsimplify atanh (domain whole exp)							  (make-app-function '(x) (expt (+ 1 (expt 'x 2)) -1/2)))
  (cond ((cl:floatp exp) (cl:atanh exp))
	  (t `(atanh ,exp))))								#+FIXTHIS
											(def-ge-1oper ATANH (x))
#+FIXTHIS										#+FIXTHIS
(defderiv-funct atanh									(defsimplify atanh (domain whole exp)
  (make-app-funciton '(x) (expt (- 1 (expt 'x 2)) -1)))					  (cond ((cl:floatp exp) (cl:atanh exp))
										    )		  (t `(atanh ,exp))))
										    )
										    )	#+FIXTHIS
										    )	(defderiv-funct atanh
										    )	  (make-app-funciton '(x) (expt (- 1 (expt 'x 2)) -1)))
;;; -*- Mode:Lisp; Package:WEYLI; Base:10; Lowercase:T; Syntax:Common-Lisp -*-		;;; -*- Mode:Lisp; Package:WEYLI; Base:10; Lowercase:T; Syntax:Common-Lisp -*-
;;; ===========================================================================		;;; ===========================================================================
;;;			   Function Spaces						;;;			   Function Spaces
;;; ===========================================================================		;;; ===========================================================================
;;; (c) Copyright 1993 Cornell University						;;; (c) Copyright 1993 Cornell University

;;; funct-spaces.lisp,v 1.7 1994/10/21 18:16:36 rz Exp					;;; funct-spaces.lisp,v 1.7 1994/10/21 18:16:36 rz Exp

(in-package "WEYLI")								    |	(in-package :weyli)

(make::adjust-version-numbers Weyl "1.7")					    |	;;; DELETE (make::adjust-version-numbers Weyl "1.7")

#|  Classes used in this file but defined elsewhere |				    |	(eval-when (:compile-toplevel :load-toplevel)
										    |	  (define-domain-creator function-space ((domain domain) (range field))
(defclass function-space (vector-space dimensional-space ring)			    <
     ((funct-domain :initarg :domain :reader funct-domain-of)			    <
      (funct-range :initarg :range :reader funct-range-of)))			    <
										    <
(defclass function-space-element (domain-element)				    <
     ())									    <
										    <
;; The domain and range for a Banach space should both be geometric domains	    <
(defclass Banach-space (function-space)						    <
     ())									    <
										    <
;;Both Banach and Hilbert spaces are supposed to be complete under the		    <
;;norm.  I wonder how that is defined.						    <
										    <
(define-operations Banach-space							    <
  (norm (element self)) -> REAL-NUMBERS)					    <
										    <
(defclass Hilbert-space (Banach-space)						    <
     ())									    <
										    <
(define-operations Hilbert-space						    <
  (inner-product (element self) (element self)) -> REAL-NUMBERS)		    <
										    <
(defclass hilbert-space-element (function-space-element)			    <
     ())									    <
||#										    <
										    <
										    <
(define-domain-creator function-space ((domain domain) (range field))		    <
  (make-instance 'function-space :domain domain :range range				    (make-instance 'function-space :domain domain :range range
		 :coefficient-domain range)						                   :coefficient-domain range)
  :predicate #'(lambda (d)								    :predicate #'(lambda (d)
	         (and (eql (class-name (class-of d)) 'function-space)			                   (and (eql (class-name (class-of d)) 'function-space)
		      (eql (funct-domain-of d) domain)					                        (eql (funct-domain-of d) domain)
		      (eql (funct-range-of d) range))))				    |	                        (eql (funct-range-of d) range)))))

;; The points of a function space are the functions themselves.  (i.e.			;; The points of a function space are the functions themselves.  (i.e.
;; function-space-element's)								;; function-space-element's)

(def-binary-coercion inner-product							(def-binary-coercion inner-product
  "No way to compute the inner-product of ~S and ~S"					  "No way to compute the inner-product of ~S and ~S"
  "Ambiguous coercion for inner-product (~S, ~S)")					  "Ambiguous coercion for inner-product (~S, ~S)")

;; FIXTHIS:: I'm leaving this here for now, but being a Hilbert space			;; FIXTHIS:: I'm leaving this here for now, but being a Hilbert space
;; should bea property, not a class.  That way, function spaces AND			;; should bea property, not a class.  That way, function spaces AND
;; vector space could both be Hilbert Spaces.						;; vector space could both be Hilbert Spaces.

;; Default norm for a Hilbert space							;; Default norm for a Hilbert space
(defmethod norm ((x hilbert-space-element))						(defmethod norm ((x hilbert-space-element))
  (inner-product x x))									  (inner-product x x))

(define-domain-creator hilbert-space ((domain dimensional-space)		    |	(eval-when (:compile-toplevel :load-toplevel)
										    >	  (define-domain-creator hilbert-space ((domain dimensional-space)
				      (range dimensional-space))			                                        (range dimensional-space))
  (make-instance 'hilbert-space :domain domain :range range)				    (make-instance 'hilbert-space :domain domain :range range)
  :predicate #'(lambda (d)								    :predicate #'(lambda (d)
	         (and (eql (class-name (class-of d)) 'free-module)			                   (and (eql (class-name (class-of d)) 'free-module)
		      (eql (funct-domain-of d) domain)					                        (eql (funct-domain-of d) domain)
		      (eql (funct-range-of d) range))))				    |	                        (eql (funct-range-of d) range)))))


;; The following routines maintain a cache of abscissa vectors.				;; The following routines maintain a cache of abscissa vectors.

(defvar *maximum-number-of-cached-vectors* 12)						(defvar *maximum-number-of-cached-vectors* 12)
(defvar *cached-vectors* ())								(defvar *cached-vectors* ())

(defun check-cached-vector (vector)							(defun check-cached-vector (vector)
  (let ((len (length vector)))								  (let ((len (length vector)))
    (flet ((equal-vector (vect)								    (flet ((equal-vector (vect)
	     (when (and vect (eql (length vect) len))						     (when (and vect (eql (length vect) len))
	       (loop for i below len								       (loop for i below len
		     do (unless (= (aref vector i) (aref vect i))					     do (unless (= (aref vector i) (aref vect i))
			  (return nil))										  (return nil))
		     finally (return t)))))								     finally (return t)))))
      (cond ((null *cached-vectors*)							      (cond ((null *cached-vectors*)
	     (setq *cached-vectors*								     (setq *cached-vectors*
		   (make-array *maximum-number-of-cached-vectors*))					   (make-array *maximum-number-of-cached-vectors*))
	     (setf (svref *cached-vectors* 0) vector)						     (setf (svref *cached-vectors* 0) vector)
	     vector)										     vector)
	    (t (loop for i below *maximum-number-of-cached-vectors*				    (t (loop for i below *maximum-number-of-cached-vectors*
		     for vect = (svref *cached-vectors* i)						     for vect = (svref *cached-vectors* i)
		     do (cond ((null vect)								     do (cond ((null vect)
			       (setf (svref *cached-vectors* i) vector)						       (setf (svref *cached-vectors* i) vector)
			       (return vector))									       (return vector))
			      ((equal-vector vect)								      ((equal-vector vect)
			       (unless (zerop i)								       (unless (zerop i)
				 (rotatef (svref *cached-vectors* (1- i))						 (rotatef (svref *cached-vectors* (1- i))
					  (svref *cached-vectors* i)))								  (svref *cached-vectors* i)))
			       (return vect)))									       (return vect)))
		     finally										     finally
		  (setf (svref *cached-vectors*								  (setf (svref *cached-vectors*
			       (1- *maximum-number-of-cached-vectors*))						       (1- *maximum-number-of-cached-vectors*))
			vector)											vector)
		  (return vector)))))))									  (return vector)))))))

(defclass sampled-function (function-space-element)					(defclass sampled-function (function-space-element)
  ((x :initarg :x									  ((x :initarg :x
      :reader function-x)								      :reader function-x)
   (y :initarg :y									   (y :initarg :y
      :reader function-y)))								      :reader function-y)))

(defmethod print-object ((obj sampled-function) stream)					(defmethod print-object ((obj sampled-function) stream)
  (let* ((x-coords (function-x obj))							  (let* ((x-coords (function-x obj))
	 (npts (array-dimension x-coords 0)))							 (npts (array-dimension x-coords 0)))
    (format stream "#<SFun: [~S, ~S] (~D pts)>"						    (format stream "#<SFun: [~S, ~S] (~D pts)>"
	    (aref x-coords 0) (aref x-coords (- npts 1))					    (aref x-coords 0) (aref x-coords (- npts 1))
	    npts)))										    npts)))

										    >	(defgeneric make-sampled-function (domain x y)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
;; Include domain here since eventually we'll need it.  For now we			;; Include domain here since eventually we'll need it.  For now we
;; use the global *FUNCTION-SPACE-RING*							;; use the global *FUNCTION-SPACE-RING*
(defmethod make-sampled-function ((domain function-space) x y)				(defmethod make-sampled-function ((domain function-space) x y)
  (make-instance 'sampled-function :domain domain					  (make-instance 'sampled-function :domain domain
		 :x (check-cached-vector x) :y y))							 :x (check-cached-vector x) :y y))

(defmethod print-table									(defmethod print-table
    ((func sampled-function) &optional (stream *standard-output*))			    ((func sampled-function) &optional (stream *standard-output*))
  (let ((x-array (function-x func))							  (let ((x-array (function-x func))
	(y-array (function-y func)))								(y-array (function-y func)))
    (loop for i below (length x-array)							    (loop for i below (length x-array)
	  do (format stream "~D: ~D~%" (aref x-array i) (aref y-array i)))))			  do (format stream "~D: ~D~%" (aref x-array i) (aref y-array i)))))

										    >	(defgeneric make-sampled-function-1 (domain x-list function)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
;; Creates a sampled function, by sampling the argument function at			;; Creates a sampled function, by sampling the argument function at
;; the points given in x-list.								;; the points given in x-list.
(defmethod make-sampled-function-1 ((domain function-space) x-list function)		(defmethod make-sampled-function-1 ((domain function-space) x-list function)
  (let* ((num-pts (length x-list))							  (let* ((num-pts (length x-list))
	 (y-array (make-array (list num-pts)))							 (y-array (make-array (list num-pts)))
	 (x-array										 (x-array
	  (if (listp x-list)									  (if (listp x-list)
	      (make-array (list num-pts)							      (make-array (list num-pts)
			  :initial-contents (mapcar #'float x-list))						  :initial-contents (mapcar #'float x-list))
	      x-list)))										      x-list)))
    (loop for i below num-pts								    (loop for i below num-pts
	  do (setf (aref y-array i) (funcall function (aref x-array i))))			  do (setf (aref y-array i) (funcall function (aref x-array i))))
    (make-sampled-function domain x-array y-array)))					    (make-sampled-function domain x-array y-array)))

(defmethod make-sampled-function-1 ((domain (eql nil)) x-list function)			(defmethod make-sampled-function-1 ((domain (eql nil)) x-list function)
  (let* ((num-pts (length x-list))							  (let* ((num-pts (length x-list))
	 (y-array (make-array (list num-pts)))							 (y-array (make-array (list num-pts)))
	 (x-array										 (x-array
	  (if (listp x-list)									  (if (listp x-list)
	      (make-array (list num-pts)							      (make-array (list num-pts)
			  :initial-contents (mapcar #'float x-list))						  :initial-contents (mapcar #'float x-list))
	      x-list))										      x-list))
	 domain range)										 domain range)
    (loop for i below num-pts								    (loop for i below num-pts
	  do (setf (aref y-array i) (funcall function (aref x-array i))))			  do (setf (aref y-array i) (funcall function (aref x-array i))))
    (setq domain (if (typep (aref x-array 0) 'domain-element)				    (setq domain (if (typep (aref x-array 0) 'domain-element)
		     (domain-of (aref x-array 0))							     (domain-of (aref x-array 0))
		   (domain-of (canonicalize-number (aref x-array 0)))))					   (domain-of (canonicalize-number (aref x-array 0)))))
    (setq range (if (typep (aref y-array 0) 'domain-element)				    (setq range (if (typep (aref y-array 0) 'domain-element)
		    (domain-of (aref y-array 0))							    (domain-of (aref y-array 0))
		  (domain-of (canonicalize-number (aref y-array 0)))))					  (domain-of (canonicalize-number (aref y-array 0)))))
    (make-sampled-function (get-function-space domain range)				    (make-sampled-function (get-function-space domain range)
			   x-array y-array)))									   x-array y-array)))

;; Takes a sampled-function and re-samples it at n evenly spaced			;; Takes a sampled-function and re-samples it at n evenly spaced
;; points.										;; points.

(defmethod resample ((func sampled-function) n)						(defmethod resample ((func sampled-function) n)
  (let* ((x (make-array n))								  (let* ((x (make-array n))
	 (f-x (function-x func))								 (f-x (function-x func))
	 (x0 (aref f-x 0))									 (x0 (aref f-x 0))
	 (step (/ (- (aref f-x (1- (length f-x))) x0) (1- n))))					 (step (/ (- (aref f-x (1- (length f-x))) x0) (1- n))))

    ;; Divide the domain of func into n-1 evenly spaced intervals.			    ;; Divide the domain of func into n-1 evenly spaced intervals.
    (loop for i below n									    (loop for i below n
	  do (setf (aref x i) x0								  do (setf (aref x i) x0
		   x0 (+ x0 step)))									   x0 (+ x0 step)))
    (smooth2 func x)))									    (smooth2 func x)))

										    >	(defgeneric smooth2 (function x)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
;; Given sampled function, resample it at each point of new-x,				;; Given sampled function, resample it at each point of new-x,
;; interpolating from func.								;; interpolating from func.
(defmethod smooth2 ((func sampled-function) new-x)					(defmethod smooth2 ((func sampled-function) new-x)
  (let ((new-y (make-array (length new-x)))						  (let ((new-y (make-array (length new-x)))
	(x (function-x func))									(x (function-x func))
	(y (function-y func)))	  								(y (function-y func)))	  
    (loop for i below (length new-x)							    (loop for i below (length new-x)
	  for xval = (aref new-x i)								  for xval = (aref new-x i)
	  do (setf (aref new-y i) (polynomial-interpolate x y xval 4)))				  do (setf (aref new-y i) (polynomial-interpolate x y xval 4)))
    (make-sampled-function (domain-of func) new-x new-y)))				    (make-sampled-function (domain-of func) new-x new-y)))
	  											  
(defmethod evaluate-at ((func sampled-function) pt)					(defmethod evaluate-at ((func sampled-function) pt)
  (polynomial-interpolate (function-x func) (function-y func) pt 4))			  (polynomial-interpolate (function-x func) (function-y func) pt 4))

;; Intepolate the function that passes through x-vector/y-vector at			;; Intepolate the function that passes through x-vector/y-vector at
;; point x using a polynomial interpolate of degree n.					;; point x using a polynomial interpolate of degree n.
(defun polynomial-interpolate (x-vector y-vector x &optional (n 4))			(defun polynomial-interpolate (x-vector y-vector x &optional (n 4))
  (let* ((dif (abs (- x (aref x-vector 0))))						  (let* ((dif (abs (- x (aref x-vector 0))))
	 (ns 0)											 (ns 0)
	 (vector-length (array-dimension x-vector 0))						 (vector-length (array-dimension x-vector 0))
	 p offset)										 p offset)
    ;; If the number of points is smaller than the desired order,			    ;; If the number of points is smaller than the desired order,
    ;; reduce the order.								    ;; reduce the order.
    (setq n (min n vector-length))							    (setq n (min n vector-length))
    (setq p (make-array (list n)))							    (setq p (make-array (list n)))
    (loop for i below vector-length							    (loop for i below vector-length
	  for dift = (abs (- x (aref x-vector i)))						  for dift = (abs (- x (aref x-vector i)))
	  do (when (< dift dif)									  do (when (< dift dif)
	       (setq ns i)									       (setq ns i)
	       (setq dif dift)))  								       (setq dif dift)))  
    (setq offset (max 0 (floor (+ ns (- (/ n 2))					    (setq offset (max 0 (floor (+ ns (- (/ n 2))
				  (if (minusp (- x (aref x-vector ns)))							  (if (minusp (- x (aref x-vector ns)))
				      0 1)))))										      0 1)))))
    (when (> (+ offset n) (1- vector-length))						    (when (> (+ offset n) (1- vector-length))
      (setq offset (max 0 (- vector-length n)))) 					      (setq offset (max 0 (- vector-length n)))) 
    (loop for i below n do								    (loop for i below n do
      (setf (aref p i) (aref y-vector (+ i offset))))					      (setf (aref p i) (aref y-vector (+ i offset))))
    (loop for m upfrom 1 below n do 							    (loop for m upfrom 1 below n do 
      (loop for i below (- n m) do							      (loop for i below (- n m) do
	(setf (aref p i)									(setf (aref p i)
	      (/ (+ (* (- x (aref x-vector (+ offset i m))) (aref p i))				      (/ (+ (* (- x (aref x-vector (+ offset i m))) (aref p i))
		    (* (- (aref x-vector (+ offset i)) x) (aref p (1+ i))))				    (* (- (aref x-vector (+ offset i)) x) (aref p (1+ i))))
		 (- (aref x-vector (+ offset i))							 (- (aref x-vector (+ offset i))
		    (aref x-vector (+ offset i m)))))))							    (aref x-vector (+ offset i m)))))))
    (aref p 0)))									    (aref p 0)))
	    											    
(defmethod-sd plus ((func1 sampled-function) (func2 sampled-function))			(defmethod-sd plus ((func1 sampled-function) (func2 sampled-function))
  (let ((x-array (function-x func1)))							  (let ((x-array (function-x func1)))
    (unless (eql x-array (function-x func2))						    (unless (eql x-array (function-x func2))
      (error "Different supports PLUS, ~A, ~A" func1 func2))				      (error "Different supports PLUS, ~A, ~A" func1 func2))
  (let* ((num-pts (length x-array))							  (let* ((num-pts (length x-array))
	 (y1 (function-y func1))								 (y1 (function-y func1))
	 (y2 (function-y func2))								 (y2 (function-y func2))
	 (sum (make-array (list num-pts))))							 (sum (make-array (list num-pts))))
      (dotimes (i num-pts)								      (dotimes (i num-pts)
	(setf (aref sum i) (cl:+ (aref y1 i) (aref y2 i))))					(setf (aref sum i) (cl:+ (aref y1 i) (aref y2 i))))
      (make-sampled-function domain x-array sum))))					      (make-sampled-function domain x-array sum))))

(defmethod-sd difference ((func1 sampled-function) (func2 sampled-function))		(defmethod-sd difference ((func1 sampled-function) (func2 sampled-function))
  (let ((x-array (function-x func1)))							  (let ((x-array (function-x func1)))
    (unless (eql x-array (function-x func2))						    (unless (eql x-array (function-x func2))
      (error "Different supports DIFFERENCE, ~A, ~A" func1 func2))			      (error "Different supports DIFFERENCE, ~A, ~A" func1 func2))
  (let* ((num-pts (length x-array))							  (let* ((num-pts (length x-array))
	 (y1 (function-y func1))								 (y1 (function-y func1))
	 (y2 (function-y func2))								 (y2 (function-y func2))
	 (sum (make-array (list num-pts))))							 (sum (make-array (list num-pts))))
      (dotimes (i num-pts)								      (dotimes (i num-pts)
	(setf (aref sum i) (cl:- (aref y1 i) (aref y2 i))))					(setf (aref sum i) (cl:- (aref y1 i) (aref y2 i))))
      (make-sampled-function domain x-array sum))))					      (make-sampled-function domain x-array sum))))

(defmethod-sd times ((func1 sampled-function) (func2 sampled-function))			(defmethod-sd times ((func1 sampled-function) (func2 sampled-function))
  (let ((x-array (function-x func1)))							  (let ((x-array (function-x func1)))
    (unless (eql x-array (function-x func2))						    (unless (eql x-array (function-x func2))
      (error "Different supports PLUS, ~A, ~A" func1 func2))				      (error "Different supports PLUS, ~A, ~A" func1 func2))
  (let* ((num-pts (length x-array))							  (let* ((num-pts (length x-array))
	 (y1 (function-y func1))								 (y1 (function-y func1))
	 (y2 (function-y func2))								 (y2 (function-y func2))
	 (prod (make-array (list num-pts))))							 (prod (make-array (list num-pts))))
      (dotimes (i num-pts)								      (dotimes (i num-pts)
	(setf (aref prod i) (cl:* (aref y1 i) (aref y2 i))))					(setf (aref prod i) (cl:* (aref y1 i) (aref y2 i))))
      (make-sampled-function domain x-array prod))))					      (make-sampled-function domain x-array prod))))

(defmethod map										(defmethod map
    ((result-type (eql 'sampled-function)) oper (func sampled-function)			    ((result-type (eql 'sampled-function)) oper (func sampled-function)
     &rest ignore)									     &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (let* ((y (function-y func))								  (let* ((y (function-y func))
	 (new-y (make-array (list (length y)))))						 (new-y (make-array (list (length y)))))
    (dotimes (i (length y))								    (dotimes (i (length y))
      (setf (aref new-y i) (funcall oper (aref y i))))					      (setf (aref new-y i) (funcall oper (aref y i))))
    (make-sampled-function (domain-of func) (function-x func) new-y)))			    (make-sampled-function (domain-of func) (function-x func) new-y)))

(defmethod minus ((func sampled-function))						(defmethod minus ((func sampled-function))
  (map 'sampled-function #'cl:- func))							  (map 'sampled-function #'cl:- func))

(defmethod times ((num (or number numeric)) (func sampled-function))		    |	(defmethod times ((num number) (func sampled-function))
										    >	  (map 'sampled-function #'(lambda (x) (* x num)) func))
										    >
										    >	(defmethod times ((num numeric) (func sampled-function))
  (map 'sampled-function #'(lambda (x) (* x num)) func))				  (map 'sampled-function #'(lambda (x) (* x num)) func))

(defmethod times ((func sampled-function) (num (or number numeric)))		    |	(defmethod times ((func sampled-function) (num number))
  (map 'sampled-function #'(lambda (x) (* x num)) func))				  (map 'sampled-function #'(lambda (x) (* x num)) func))

(defmethod quotient ((func sampled-function) (num (or number numeric)))		    |	(defmethod times ((func sampled-function) (num numeric))
										    >	  (map 'sampled-function #'(lambda (x) (* x num)) func))
										    >
										    >	(defmethod quotient ((func sampled-function) (num number))
										    >	  (map 'sampled-function #'(lambda (x) (/ x num)) func))
										    >
										    >	(defmethod quotient ((func sampled-function) (num numeric))
  (map 'sampled-function #'(lambda (x) (/ x num)) func))				  (map 'sampled-function #'(lambda (x) (/ x num)) func))

(defmethod conjugate ((func sampled-function))						(defmethod conjugate ((func sampled-function))
  (map 'sampled-function #'cl:conjugate func))						  (map 'sampled-function #'cl:conjugate func))

(defmethod realpart ((func sampled-function))						(defmethod realpart ((func sampled-function))
  (map 'sampled-function #'cl:realpart func))						  (map 'sampled-function #'cl:realpart func))

(defmethod imagpart ((func sampled-function))						(defmethod imagpart ((func sampled-function))
  (map 'sampled-function #'cl:imagpart func))						  (map 'sampled-function #'cl:imagpart func))

(defmacro deriv-2point (x y index1 index2)						(defmacro deriv-2point (x y index1 index2)
  `(/ (- (aref ,y ,index2) (aref ,y ,index1))						  `(/ (- (aref ,y ,index2) (aref ,y ,index1))
      (- (aref ,x ,index2) (aref ,x ,index1))))						      (- (aref ,x ,index2) (aref ,x ,index1))))

(defmethod deriv ((func sampled-function) &rest vars)					(defmethod deriv ((func sampled-function) &rest vars)
  (declare (ignore vars))								  (declare (ignore vars))
  (let* ((x-array (function-x func))							  (let* ((x-array (function-x func))
	 (y-array (function-y func))								 (y-array (function-y func))
	 (num-pts (length x-array))								 (num-pts (length x-array))
	 (y-prime (make-array (list num-pts))))							 (y-prime (make-array (list num-pts))))
    (setf (aref y-prime 0) (deriv-2point x-array y-array 1 0))				    (setf (aref y-prime 0) (deriv-2point x-array y-array 1 0))
    (do ((i 1 (+ i 1)))									    (do ((i 1 (+ i 1)))
	((= i (1- num-pts))									((= i (1- num-pts))
	 (setf (aref y-prime i) (deriv-2point x-array y-array (- i 1) i)))			 (setf (aref y-prime i) (deriv-2point x-array y-array (- i 1) i)))
      (setf (aref y-prime i)								      (setf (aref y-prime i)
	    (/ (+ (deriv-2point x-array y-array (- i 1) i)					    (/ (+ (deriv-2point x-array y-array (- i 1) i)
		  (deriv-2point x-array y-array  i (+ i 1))) 2)))					  (deriv-2point x-array y-array  i (+ i 1))) 2)))
    (make-sampled-function (domain-of func) x-array y-prime)))				    (make-sampled-function (domain-of func) x-array y-prime)))

(defmacro trapezoidal (x y i1 i2)							(defmacro trapezoidal (x y i1 i2)
  `(/ (* (- (aref ,x ,i2) (aref ,x ,i1))						  `(/ (* (- (aref ,x ,i2) (aref ,x ,i1))
	  (+ (aref ,y ,i1) (aref ,y ,i2))) 2))							  (+ (aref ,y ,i1) (aref ,y ,i2))) 2))
										    >
										    >	(defgeneric integral (function &key lower upper &allow-other-keys)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))

(defmethod integral ((func sampled-function)						(defmethod integral ((func sampled-function)
		     &key lower upper &allow-other-keys)						     &key lower upper &allow-other-keys)
  (cond ((and (null lower) (null upper))						  (cond ((and (null lower) (null upper))
	 (indef-integral func))									 (indef-integral func))
	(t (let* ((x (function-x func))								(t (let* ((x (function-x func))
		  (y (function-y func))									  (y (function-y func))
		  (num-pts (length x))									  (num-pts (length x))
		  (sum 0.0))										  (sum 0.0))
	     ;; FIXTHIS: The trapezoidal rule is used here because it				     ;; FIXTHIS: The trapezoidal rule is used here because it
	     ;; seems a bit more accurate.  But its really stupid.				     ;; seems a bit more accurate.  But its really stupid.
	     ;; Since we know how we are interpolating the interval				     ;; Since we know how we are interpolating the interval
	     ;; between any pair of points we should use an exact				     ;; between any pair of points we should use an exact
	     ;; integration scheme.								     ;; integration scheme.
	     (do ((i1 0 i2)									     (do ((i1 0 i2)
		  (i2 1 (cl:1+ i2)))									  (i2 1 (cl:1+ i2)))
		 ((or (cl:>= i2 num-pts) (cl:<= upper (aref x i1)))					 ((or (cl:>= i2 num-pts) (cl:<= upper (aref x i1)))
		  sum)											  sum)
		 (setq sum (+ sum (trapezoidal x y i1 i2))))						 (setq sum (+ sum (trapezoidal x y i1 i2))))
	     #+ignore 										     #+ignore 
	     (do ((i1 0 (+ 2 i1))								     (do ((i1 0 (+ 2 i1))
		  (i2 1 (+ 2 i2))									  (i2 1 (+ 2 i2))
		  (i3 2 (+ 2 i3)))									  (i3 2 (+ 2 i3)))
		 ((or (cl:>= i3 num-pts) (cl:<= upper (aref x i1)))					 ((or (cl:>= i3 num-pts) (cl:<= upper (aref x i1)))
		  sum)											  sum)
	       (multiple-value-bind (w1 w2) (simpson x y i1 i2 i3)				       (multiple-value-bind (w1 w2) (simpson x y i1 i2 i3)
		 (setq sum (+ sum w1 w2))))))))								 (setq sum (+ sum w1 w2))))))))

;; FIXTHIS:  I don't trust this routine. 						;; FIXTHIS:  I don't trust this routine. 
(defun simpson (x y i1 i2 i3)								(defun simpson (x y i1 i2 i3)
  (let* ((x1 (svref x i1))								  (let* ((x1 (svref x i1))
	 (x2 (svref x i2))									 (x2 (svref x i2))
	 (x3 (svref x i3))									 (x3 (svref x i3))
	 (h (- x2 x1))										 (h (- x2 x1))
	 (k (- x3 x2))										 (k (- x3 x2))
	 (range (- x2 x1))									 (range (- x2 x1))
	 (denom (* h k range))									 (denom (* h k range))
	 (ksq (* k k))										 (ksq (* k k))
	 (hsq (* h h))										 (hsq (* h h))

	 (y1 (svref y i1))									 (y1 (svref y i1))
	 (y2 (svref y i2))									 (y2 (svref y i2))
	 (y3 (svref y i3))									 (y3 (svref y i3))

	 (a (/ (- (+ (* k y1) (* h y3)) (* range y2)) (* 3 denom)))				 (a (/ (- (+ (* k y1) (* h y3)) (* range y2)) (* 3 denom)))
	 (b (/ (+ (* hsq (- y3 y2)) (* ksq (- y2 y1))) (* 2 denom)))				 (b (/ (+ (* hsq (- y3 y2)) (* ksq (- y2 y1))) (* 2 denom)))
	 (c y2))										 (c y2))
    (values (+ (- (* a hsq h) (* b hsq)) (* c h))					    (values (+ (- (* a hsq h) (* b hsq)) (* c h))
	    (+ (* a ksq k) (* b ksq) (* c k)))))						    (+ (* a ksq k) (* b ksq) (* c k)))))

(defun indef-integral (func)								(defun indef-integral (func)
  (let* ((x (function-x func))								  (let* ((x (function-x func))
	 (y (function-y func))									 (y (function-y func))
	 (num-pts (length x))									 (num-pts (length x))
	 (int-y (make-array (list num-pts)))							 (int-y (make-array (list num-pts)))
	 (sum 0.0))										 (sum 0.0))
    (setf (aref int-y 0) 0.0)								    (setf (aref int-y 0) 0.0)
    (do ((i1 0 (+ 2 i1))								    (do ((i1 0 (+ 2 i1))
	 (i2 1 (+ 2 i2))									 (i2 1 (+ 2 i2))
	 (i3 2 (+ 2 i3)))									 (i3 2 (+ 2 i3)))
	((cl:>= i3 num-pts)									((cl:>= i3 num-pts)
	 (if (= i2 (1- num-pts))								 (if (= i2 (1- num-pts))
	     (setf (aref int-y i2) (+ sum (trapezoidal x y i1 i2))))				     (setf (aref int-y i2) (+ sum (trapezoidal x y i1 i2))))
	 (make-sampled-function (domain-of func) x int-y))					 (make-sampled-function (domain-of func) x int-y))
      (multiple-value-bind (w1 w2) (simpson x y i1 i2 i3)				      (multiple-value-bind (w1 w2) (simpson x y i1 i2 i3)
	(setq sum (+ sum w1))									(setq sum (+ sum w1))
	(setf (aref int-y i2) sum)								(setf (aref int-y i2) sum)
	(setq sum (+ sum w2))									(setq sum (+ sum w2))
	(setf (aref int-y i3) sum)))))								(setf (aref int-y i3) sum)))))

(defmethod-sd inner-product ((x sampled-function) (y sampled-function))			(defmethod-sd inner-product ((x sampled-function) (y sampled-function))
  (let* ((fun (* x (conjugate y)))							  (let* ((fun (* x (conjugate y)))
	 (abscissa (function-x x))								 (abscissa (function-x x))
	 (dim (array-dimension abscissa 0)))							 (dim (array-dimension abscissa 0)))
    (integral fun :lower (aref abscissa 0)						    (integral fun :lower (aref abscissa 0)
	      :upper (aref abscissa (1- dim)))))						      :upper (aref abscissa (1- dim)))))
	    											    

#| Test programs |									#| Test programs |

(defun sine-waves (n-pts n)								(defun sine-waves (n-pts n)
  (let ((abscissa (loop for x below 1 by (cl:/ n-pts)					  (let ((abscissa (loop for x below 1 by (cl:/ n-pts)
			collect x)))										collect x)))
    (loop for i below n									    (loop for i below n
	  collect (make-sampled-function-1							  collect (make-sampled-function-1
		       abscissa										       abscissa
		       #'(lambda (x) (sin (* 2 pi (1+ i) x)))))))					       #'(lambda (x) (sin (* 2 pi (1+ i) x)))))))

;; The following should generate Legendre polynomials!					;; The following should generate Legendre polynomials!
(defun polys (n-pts n)									(defun polys (n-pts n)
  (let ((abscissa (loop for x upfrom -1 below 1 by (cl:/ 2.0 n-pts)			  (let ((abscissa (loop for x upfrom -1 below 1 by (cl:/ 2.0 n-pts)
			collect x)))										collect x)))
    (loop for i below n									    (loop for i below n
	  collect (make-sampled-function-1							  collect (make-sampled-function-1
		       abscissa										       abscissa
		       #'(lambda (x) (cl:expt x i))))))							       #'(lambda (x) (cl:expt x i))))))

;; This uses randomly selected points.							;; This uses randomly selected points.
(defun rpolys (n-pts n)									(defun rpolys (n-pts n)
  (let ((abscissa (sort									  (let ((abscissa (sort
		   (append (list 1.0 -1.0)								   (append (list 1.0 -1.0)
			   (loop for i below (- n-pts 2)							   (loop for i below (- n-pts 2)
				 collect (/ (float (- (cl:random 20000) 10000))						 collect (/ (float (- (cl:random 20000) 10000))
					    10000)))										    10000)))
		   #'cl:<)))										   #'cl:<)))
    (loop for i below n									    (loop for i below n
	  collect (make-sampled-function-1 abscissa						  collect (make-sampled-function-1 abscissa
					   #'(lambda (x) (cl:expt x i))))))							   #'(lambda (x) (cl:expt x i))))))

;; Each argument is supposed to be a vector.  The vectors are are			;; Each argument is supposed to be a vector.  The vectors are are
;; normalized and an orthorgonal basis is returned.					;; normalized and an orthorgonal basis is returned.
(defun gram-schmidt (&rest vects)							(defun gram-schmidt (&rest vects)
  (let* ((dim (length vects))								  (let* ((dim (length vects))
	 (space (apply #'vector vects)))							 (space (apply #'vector vects)))
    (loop for k below dim								    (loop for k below dim
	  for vect = (aref space k)								  for vect = (aref space k)
	  do ;; Normalize vector								  do ;; Normalize vector
	     (setq vect (/ vect (sqrt (abs (inner-product vect vect)))))			     (setq vect (/ vect (sqrt (abs (inner-product vect vect)))))
	     (setf (aref space k) vect)								     (setf (aref space k) vect)
	     (loop for j upfrom (+ k 1) below dim						     (loop for j upfrom (+ k 1) below dim
		   for vect2 = (aref space j)								   for vect2 = (aref space j)
		   do (setf (aref space j)								   do (setf (aref space j)
			    (- vect2 (* (inner-product vect vect2) vect)))))					    (- vect2 (* (inner-product vect vect2) vect)))))
    space))										    space))

(defmethod print-Mathematica								(defmethod print-Mathematica
    ((func sampled-function) &key (smooth 4) (stream *standard-output*)) 		    ((func sampled-function) &key (smooth 4) (stream *standard-output*)) 
  (let* ((x-array (function-x func))							  (let* ((x-array (function-x func))
	 (y-array (function-y func)))								 (y-array (function-y func)))

    (when (and (not (null smooth))							    (when (and (not (null smooth))
	       (not (cl:numberp smooth)))							       (not (cl:numberp smooth)))
      (setq smooth 4))									      (setq smooth 4))

    (format stream "Graphics[{GrayLevel[0.0]")						    (format stream "Graphics[{GrayLevel[0.0]")
    (loop for i upfrom 1 below (length x-array)						    (loop for i upfrom 1 below (length x-array)
	  for x0 = (aref x-array 0) then x1							  for x0 = (aref x-array 0) then x1
	  and y0 = (aref y-array 0) then y1							  and y0 = (aref y-array 0) then y1
	  and x1 = (aref x-array i)								  and x1 = (aref x-array i)
	  and y1 = (aref y-array i)								  and y1 = (aref y-array i)
	  do  (if (null smooth)									  do  (if (null smooth)
		 (format stream ",~%Line[{{~10F, ~10F}, {~10F, ~10F}}]"					 (format stream ",~%Line[{{~10F, ~10F}, {~10F, ~10F}}]"
			 x0 y0 x1 y1)										 x0 y0 x1 y1)
	       (loop for j below smooth								       (loop for j below smooth
		     with delta = (cl:/ (cl:- x1 x0) smooth)						     with delta = (cl:/ (cl:- x1 x0) smooth)
		     and xp = x0 and yp = y0 and xn and yn						     and xp = x0 and yp = y0 and xn and yn
		     do (setq xn (cl:+ xp delta)							     do (setq xn (cl:+ xp delta)
			      yn (evaluate-at func xn))								      yn (evaluate-at func xn))
		     (format stream ",~%Line[{{~10F, ~10F}, {~10F, ~10F}}]"				     (format stream ",~%Line[{{~10F, ~10F}, {~10F, ~10F}}]"
			     xp yp xn yn)									     xp yp xn yn)
		     (setq xp xn yp yn))))								     (setq xp xn yp yn))))
    (format stream "}]")))								    (format stream "}]")))

||#											||#

;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-		;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-
;;; ===========================================================================		;;; ===========================================================================
;;;		    General Representation Classes					;;;		    General Representation Classes
;;; ===========================================================================		;;; ===========================================================================
;;; (c) Copyright 1989, 1993 Cornell University						;;; (c) Copyright 1989, 1993 Cornell University

;;; general-classes.lisp,v 1.5 1995/05/24 17:42:00 rz Exp				;;; general-classes.lisp,v 1.5 1995/05/24 17:42:00 rz Exp

(in-package "WEYLI")								    |	(in-package :weyli)

(make::adjust-version-numbers Weyl "1.5")					    |	;;; DELETE (make::adjust-version-numbers Weyl "1.5")

(defclass has-memoization ()								(defclass has-memoization ()
     ((memos :initform (make-hash-table :test #'equal))))				  ((memos :initform (make-hash-table :test #'equal))))

;;; Classes for General expressions							;;; Classes for General expressions

(defvar *global-functions* ()								(defvar *global-functions* ()
  "These are the functions known by everyone")						  "These are the functions known by everyone")

(defclass general-expressions (has-memoization non-strict-domain domain)		(defclass general-expressions (has-memoization non-strict-domain domain)
     ((variables :initform ()							    |	  ((variables
										    >	    :initform ()
		 :accessor ge-variables)						    :accessor ge-variables)
      (functions :initform nil							    |	   (functions
										    >	    :initform nil
                 :accessor ge-functions)						    :accessor ge-functions)
      (context :initform ()							    |	   (context
										    >	    :initform ()
	       :accessor ge-context)))							    :accessor ge-context)))

(defclass general-expression (ge-or-numeric)						(defclass general-expression (ge-or-numeric)
     ((simplified? :initform nil						    |	  ((simplified?
										    >	    :initform nil
		   :accessor simplified?)))						    :accessor simplified?)))

;; This class is used to define those general expressions that are			;; This class is used to define those general expressions that are
;; indivisible.										;; indivisible.
(defclass ge-atom () ())								(defclass ge-atom () ())

(defsubst ge-atom? (x) (typep x 'ge-atom))						(defsubst ge-atom? (x) (typep x 'ge-atom))

(defclass ge-variable (general-expression has-property-list ge-atom)			(defclass ge-variable (general-expression has-property-list ge-atom)
     ((symbol :initarg :symbol							    |	  ((symbol
										    >	    :initarg :symbol
	      :accessor symbol-of)							    :accessor symbol-of)
      (string :initarg :string							    |	   (string
										    >	    :initarg :string
	      :accessor string-of)))							    :accessor string-of)))

;; N-ary operators are built from this class 						;; N-ary operators are built from this class 
(defclass ge-nary (general-expression)							(defclass ge-nary (general-expression)
     ((terms :initform nil							    |	  ((terms
										    >	    :initform nil
	     :initarg :terms								    :initarg :terms
	     :accessor terms-of)))							    :accessor terms-of)))

(defsubst ge-nary? (x) (typep x 'ge-nary))						(defsubst ge-nary? (x) (typep x 'ge-nary))

(defclass ge-plus (ge-nary)								(defclass ge-plus (ge-nary)
     ())										  ())

(defsubst ge-plus? (x) (typep x 'ge-plus))						(defsubst ge-plus? (x) (typep x 'ge-plus))

(defclass ge-times (ge-nary)								(defclass ge-times (ge-nary)
     ())										  ())

(defsubst ge-times? (x) (typep x 'ge-times))						(defsubst ge-times? (x) (typep x 'ge-times))

(defclass ge-expt (general-expression)							(defclass ge-expt (general-expression)
     ((base :initarg :base							    |	  ((base
										    >	    :initarg :base
	    :accessor base-of)								    :accessor base-of)
      (exp :initarg :exp							    |	   (exp
										    >	    :initarg :exp
	   :accessor exponent-of)))							    :accessor exponent-of)))

(defsubst ge-expt? (x) (typep x 'ge-expt))						(defsubst ge-expt? (x) (typep x 'ge-expt))

;; FUNCTIONS										;; FUNCTIONS

;; Functions themselves are first class objects.  So we need a representation 		;; Functions themselves are first class objects.  So we need a representation 
;; for a function, and a second representation for a functional application. 		;; for a function, and a second representation for a functional application. 
;; These functions should be cached just the way variables are cached. 			;; These functions should be cached just the way variables are cached. 

;; ABSTRACT-FUNCTION is the base class for all functions.  At a minimum 		;; ABSTRACT-FUNCTION is the base class for all functions.  At a minimum 
;; all functions have a specified number of arguments, and a property-list 		;; all functions have a specified number of arguments, and a property-list 
;; in which additional information can be stored. 					;; in which additional information can be stored. 
(defclass abstract-function (domain-element has-property-list)				(defclass abstract-function (domain-element has-property-list)
  ((nargs :initarg :nargs               ; The number of arguments		    |	  ((nargs
										    >	    :initarg :nargs                     ; The number of arguments
          :accessor nargs-of)))								    :accessor nargs-of)))

;; This separated out so that we can implemented existential as well			;; This separated out so that we can implemented existential as well
;; universal quantifiers.								;; universal quantifiers.
(defclass has-bound-variables ()							(defclass has-bound-variables ()
     ((bound-vars :initarg :bound-vars						    |	  ((bound-vars
										    >	    :initarg :bound-vars
		  :accessor bound-vars-of)))						    :accessor bound-vars-of)))

;; APPLICABLE-FUNCTION indicates that this object is a symbolic 			;; APPLICABLE-FUNCTION indicates that this object is a symbolic 
;; lambda expression									;; lambda expression
(defclass applicable-function (abstract-function has-bound-variables)			(defclass applicable-function (abstract-function has-bound-variables)
  ((body :initarg :body								    |	  ((body
										    >	    :initarg :body
         :reader body-of)))								    :reader body-of)))

(defsubst applicable-function? (x) (typep x 'applicable-function))			(defsubst applicable-function? (x) (typep x 'applicable-function))

;; GE-FUNCTION is the class of named functions, 					;; GE-FUNCTION is the class of named functions, 
(defclass ge-function (abstract-function has-name)					(defclass ge-function (abstract-function has-name)
     ())										  ())

(defsubst ge-function? (x) (typep x 'ge-function))					(defsubst ge-function? (x) (typep x 'ge-function))

;; GE-FUNCTION-DERIV is used to represent the derivative of a function. 		;; GE-FUNCTION-DERIV is used to represent the derivative of a function. 
;; The DERIVS slot is used to hold an order list of the derivatives.  Each 		;; The DERIVS slot is used to hold an order list of the derivatives.  Each 
;; element of the list is a number from 0 to nars - 1 indicating a derivative 		;; element of the list is a number from 0 to nars - 1 indicating a derivative 
;; in that position.  Numbers can appear more than once and are sorted.			;; in that position.  Numbers can appear more than once and are sorted.

(defclass ge-function-deriv (ge-function)						(defclass ge-function-deriv (ge-function)
  ((derivs :initform ()								    |	  ((derivs
										    >	    :initform ()
           :initarg :derivs								    :initarg :derivs
           :accessor derivs-of)))							    :accessor derivs-of)))

;; Notice that a GE-FUNCTION-DERIV is also a GE-FUNCTION				;; Notice that a GE-FUNCTION-DERIV is also a GE-FUNCTION
(defsubst ge-function-deriv? (x) (typep x 'ge-function-deriv))				(defsubst ge-function-deriv? (x) (typep x 'ge-function-deriv))

(defclass ge-application (general-expression)						(defclass ge-application (general-expression)
  ((funct :initarg :funct               ; The function being applied		    |	  ((funct
										    >	    :initarg :funct                     ; The function being applied
          :accessor funct-of)								    :accessor funct-of)
   (args :initarg :args                 ; Arguments to the function		    |	   (args
										    >	    :initarg :args                      ; Arguments to the function
         :accessor args-of)))								    :accessor args-of)))

(defsubst ge-application? (x) (typep x 'ge-application))				(defsubst ge-application? (x) (typep x 'ge-application))

(defclass ge-equation (general-expression)						(defclass ge-equation (general-expression)
     ((lhs :initarg :lhs							    |	  ((lhs
										    >	    :initarg :lhs
	   :accessor lhs-of)								    :accessor lhs-of)
      (rhs :initarg :rhs							    |	   (rhs
										    >	    :initarg :rhs
	   :accessor rhs-of)))								    :accessor rhs-of)))

(defclass ge-eqn= (ge-equation)								(defclass ge-eqn= (ge-equation)
     ())										  ())

(defsubst ge-eqn=? (exp)								(defsubst ge-eqn=? (exp)
  (typep exp 'ge-eqn=))									  (typep exp 'ge-eqn=))

(defclass ge-eqn> (ge-equation)								(defclass ge-eqn> (ge-equation)
     ())										  ())

(defsubst ge-eqn>? (exp)								(defsubst ge-eqn>? (exp)
  (typep exp 'ge-eqn>))									  (typep exp 'ge-eqn>))

(defclass ge-eqn>= (ge-equation)							(defclass ge-eqn>= (ge-equation)
     ())										  ())

(defsubst ge-eqn>=? (exp)								(defsubst ge-eqn>=? (exp)
  (typep exp 'ge-eqn>=))								  (typep exp 'ge-eqn>=))

;; The expression must be general-expression, so I am also make a univerally 		;; The expression must be general-expression, so I am also make a univerally 
;; quantified set a domain-element							;; quantified set a domain-element
(defclass universal-quantified-set (has-bound-variables set general-expression)		(defclass universal-quantified-set (has-bound-variables set general-expression)
     ((exprs :initarg :expressions  						    |	  ((exprs
										    >	    :initarg :expressions  
	     :accessor exprs-of)))							    :accessor exprs-of)))

;; Fourier transforms 									;; Fourier transforms 

(defclass ge-fourier (general-expression)						(defclass ge-fourier (general-expression)
     ((argument :initarg :argument						    |	  ((argument
										    >	    :initarg :argument
		:accessor argument-of)							    :accessor argument-of)
      (space-var :initarg :space-var						    |	   (space-var
										    >	    :initarg :space-var
		 :accessor space-var-of)						    :accessor space-var-of)
      (freq-var :initarg :freq-var						    |	   (freq-var
										    >	    :initarg :freq-var
		:accessor freq-var-of)))						    :accessor freq-var-of)))

(defsubst ge-fourier? (x) (typep x 'ge-fourier))					(defsubst ge-fourier? (x) (typep x 'ge-fourier))

(defclass ge-ifourier (general-expression)						(defclass ge-ifourier (general-expression)
     ((argument :initarg :argument						    |	  ((argument
										    >	    :initarg :argument
		:accessor argument-of)							    :accessor argument-of)
      (space-var :initarg :space-var						    |	   (space-var
										    >	    :initarg :space-var
		 :accessor space-var-of)						    :accessor space-var-of)
      (freq-var :initarg :freq-var						    |	   (freq-var
										    >	    :initarg :freq-var
		:accessor freq-var-of)))						    :accessor freq-var-of)))

(defsubst ge-ifourier? (x) (typep x 'ge-ifourier))					(defsubst ge-ifourier? (x) (typep x 'ge-ifourier))
;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-		;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-
;;; ===========================================================================		;;; ===========================================================================
;;;			      General Representation					;;;			      General Representation
;;; ===========================================================================		;;; ===========================================================================
;;; (c) Copyright 1989, 1993 Cornell University						;;; (c) Copyright 1989, 1993 Cornell University

;;; general.lisp,v 1.14 1995/05/24 17:42:01 rz Exp					;;; general.lisp,v 1.14 1995/05/24 17:42:01 rz Exp

(in-package "WEYLI")								    |	;;; 06-FEB-2025/kfp : implementation of D(p^f(q),q) in method ge-deriv
										    |	;;;                 : fix bug in 'simp-times-terms' if exponent not a number
(make::adjust-version-numbers Weyl "1.14")					    |	;;; 24-FEB-2025/kfp : Docstrings added.
										    >	;;; 15-MAR-2025/kfp : Fix bug in expand[ge-expt]: exponent must be in Z
										    >	;;;                 : and at least non-negative (reasonably >=2). 
										    >	;;; 16-MAR-2025/kfp : method added since (expt 2 p) --> error, no method so far 
										    >	;;;                 : defmethod-sd expt [ge-or-numeric,general-expression] 
										    >
										    >	(defparameter +version+ "cl-weyl: 16-MAR-2025 13:23")
										    >
										    >	(in-package :weyli)
										    >
										    >
										    >	(defgeneric set-memoization (domain key value)
										    >	  (:documentation
										    >	   "Set memoization. See chapter 3.2 in the manual."))

(defmethod set-memoization ((domain has-memoization) key value)				(defmethod set-memoization ((domain has-memoization) key value)
  (with-slots (memos) domain								  (with-slots (memos) domain
    (setf (gethash key memos) value)							    (setf (gethash key memos) value)
    value))										    value))

										    >	;;; FIXME : Merge this into a single setf function.
										    >	(defgeneric get-memoization (domain key)
										    >	  (:documentation
										    >	   "Get memoization."))
										    >
(defmethod get-memoization ((domain has-memoization) key)				(defmethod get-memoization ((domain has-memoization) key)
  (with-slots (memos) domain								  (with-slots (memos) domain
    (gethash key memos)))								    (gethash key memos)))

(defsetf get-memoization set-memoization)						(defsetf get-memoization set-memoization)

(defmacro %memoize (domain expression &body body)					(defmacro %memoize (domain expression &body body)
										    >	"Each time this form is executed, it checks to see if expression is cached 
										    >	in domain's memoization cache. If so, the value in the cache is returned 
										    >	without executing the body. If expression is not found in the cache, then 
										    >	the forms in body are evaluated, and the value of the last form is both 
										    >	returned and saved in domain's memoization cache.
										    >	It is usually much more convenient to use the memoize control structure."
  `(let ((.expr. ,expression))								  `(let ((.expr. ,expression))
    (with-slots (memos) ,domain								    (with-slots (memos) ,domain
       (multiple-value-bind (value found?) (gethash .expr. memos)			      (multiple-value-bind (value found?) (gethash .expr. memos)
	 (if found? value								        (if found? value
	     (setf (get-memoization ,domain .expr.) (progn ,@body)))))))		            (setf (get-memoization ,domain .expr.) (progn ,@body)))))))

(defmacro memoize (expression &body body)						(defmacro memoize (expression &body body)
										    >	"Performs the same functions as weyli::%memoize except that the domain
										    >	used is *general*."
  `(%memoize *general* ,expression ,@body))						  `(%memoize *general* ,expression ,@body))

#+ignore										#+ignore
(defun fib-memo (n)									(defun fib-memo (n)
  (memoize `(fib ,n)									  (memoize `(fib ,n)
    (if (< n 2) 1									    (if (< n 2) 1
	(+ (fib-memo (- n 1)) (fib-memo (- n 2))))))						(+ (fib-memo (- n 1)) (fib-memo (- n 2))))))

(defmethod display ((ge general-expression) &optional stream &rest ignore)	    |	(defgeneric display (expression &optional stream &rest ignore)
										    >	  (:documentation
										    >	   "Prints the expression expr onto stream. If stream a graphics stream 
										    >	then a two dimension display will be used (not yet implemented), otherwise 
										    >	some textual display will be used.")
										    >	  (:method ((express general-expression) &optional stream &rest ignore)
  (declare (ignore ignore))								    (declare (ignore ignore))
  (princ ge stream))								    |	    (princ express stream)))

(defmethod simplify ((ge general-expression))					    |	(defgeneric simplify (expression)
  ge)										    |	  (:documentation
										    |	   "Simplify the expression.")
(defmethod ge-equal (x y)							    |	  (:method ((expression general-expression)) expression))
  (declare (ignore x y))							    |
  nil)										    |	(defgeneric ge-equal (expression1 expression2)
										    >	  (:documentation
										    >	   "Returns T for syntactically identical general expressions.")
										    >	  (:method (expression1 expression2)
										    >	    (declare (ignore expression1 expression2))
										    >	    nil))

(defmethod ge-equal ((x general-expression) (y general-expression))			(defmethod ge-equal ((x general-expression) (y general-expression))
										    >	  "Returns T if x and y are syntactically identical general expressions."
  (eql x y))										  (eql x y))

(defmethod ge-great ((x general-expression) (y general-expression))		    |	(defgeneric ge-great (expression1 expression2)
  nil)										    |	  (:documentation
										    |	   "To speed up operations like simplification of expressions, an order is 
										    >	placed on all expressions in the general representation. This ordering 
										    >	is provided by the function ge-great.")
										    >	  (:method ((x general-expression) (y general-expression))
										    >	    (declare (ignore x y))
										    >	    nil))

;; Numbers and Variables								;; Numbers and Variables

(defmethod make-quotient-element							(defmethod make-quotient-element
    ((domain general-expressions) (x integer) (y integer))				    ((domain general-expressions) (x integer) (y integer))
  (make-instance 'rational-number :domain domain					  (make-instance 'rational-number :domain domain
		 :numerator x :denominator y))								 :numerator x :denominator y))

(defmethod make-element ((domain general-expressions) (x integer) &rest args)		(defmethod make-element ((domain general-expressions) (x integer) &rest args)
  (cond ((or (null args) (0? (first args)))						  (cond ((or (null args) (0? (first args)))
	 (make-instance 'rational-integer :domain domain :value x))				 (make-instance 'rational-integer :domain domain :value x))
	((number? (first args))									((number? (first args))
	 (make-instance 'complex-number :domain domain						 (make-instance 'complex-number :domain domain
			:realpart x :imagpart (first args)))							:realpart x :imagpart (first args)))
	(t (error "Can't deal with this yet: ~A" args))))					(t (error "Can't deal with this yet: ~A" args))))

(defmethod make-element ((domain general-expressions) (x ratio) &rest args)		(defmethod make-element ((domain general-expressions) (x ratio) &rest args)
  (cond ((or (null args) (0? (first args)))						  (cond ((or (null args) (0? (first args)))
	 (make-instance 'rational-number :domain domain						 (make-instance 'rational-number :domain domain
			:numerator (cl:numerator x)								:numerator (cl:numerator x)
			:denominator (cl:denominator x)))							:denominator (cl:denominator x)))
	((number? (first args))									((number? (first args))
	 (make-instance 'complex-number :domain domain						 (make-instance 'complex-number :domain domain
			:realpart x :imagpart (first args)))							:realpart x :imagpart (first args)))
	(t (error "Can't deal with this yet: ~A" args))))					(t (error "Can't deal with this yet: ~A" args))))

(defmethod make-element ((domain general-expressions) (x float) &rest args)		(defmethod make-element ((domain general-expressions) (x float) &rest args)
  (cond ((or (null args) (0? (first args)))						  (cond ((or (null args) (0? (first args)))
	 (make-instance 'floating-point-number :domain domain					 (make-instance 'floating-point-number :domain domain
			:value x))										:value x))
	((number? (first args))									((number? (first args))
	 (make-instance 'complex-number :domain domain						 (make-instance 'complex-number :domain domain
			:realpart x :imagpart (first args)))							:realpart x :imagpart (first args)))
	(t (error "Can't deal with this yet: ~A" args))))					(t (error "Can't deal with this yet: ~A" args))))

(defmethod make-element ((domain general-expressions) (x cl:complex)			(defmethod make-element ((domain general-expressions) (x cl:complex)
			 &rest ignore)										 &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (make-instance 'complex-number :domain domain						  (make-instance 'complex-number :domain domain
		 :realpart (cl:realpart x)								 :realpart (cl:realpart x)
		 :imagpart (cl:imagpart x)))								 :imagpart (cl:imagpart x)))

(defmethod coerce ((num number) (domain general-expressions))				(defmethod coerce ((num number) (domain general-expressions))
										    >	"Coerce finds an element of domain that corresponds with element. This is 
										    >	done using one of two methods. First, there may be a canonical coercion, 
										    >	which is one that is defined via explicit coerce methods. These methods 
										    >	take care of mapping Lisp expressions, like numbers and atoms, into Weyl 
										    >	domains. If there are no canonical coercion methods then coerce checks to 
										    >	see if there is a unique morphism between element's domain and domain. 
										    >	If so, this morphism is used to map element to domain. If there is more 
										    >	than one morphism then an error is signaled."
  (make-element domain num))								  (make-element domain num))

(defmethod coerce ((num rational-integer) (domain general-expressions))			(defmethod coerce ((num rational-integer) (domain general-expressions))
  (if (eql (domain-of num) domain) num							  (if (eql (domain-of num) domain) num
      (make-element domain (integer-value num))))					      (make-element domain (integer-value num))))

(defmethod coerce ((num rational-number) (domain general-expressions))			(defmethod coerce ((num rational-number) (domain general-expressions))
  (if (eql (domain-of num) domain) num							  (if (eql (domain-of num) domain) num
      (make-instance 'rational-number :domain domain 					      (make-instance 'rational-number :domain domain 
                     :numerator (qo-numerator num)					                     :numerator (qo-numerator num)
                     :denominator (qo-denominator num))))				                     :denominator (qo-denominator num))))

(defmethod coerce ((num floating-point-number) (domain general-expressions))		(defmethod coerce ((num floating-point-number) (domain general-expressions))
  (if (eql (domain-of num) domain) num							  (if (eql (domain-of num) domain) num
      (make-element domain (fp-value num))))						      (make-element domain (fp-value num))))

(defmethod coerce ((num bigfloat) (domain general-expressions))				(defmethod coerce ((num bigfloat) (domain general-expressions))
  (if (eql (domain-of num) domain) num							  (if (eql (domain-of num) domain) num
      (make-bigfloat domain (bigfloat-mantissa num) (bigfloat-exponent num))))		      (make-bigfloat domain (bigfloat-mantissa num) (bigfloat-exponent num))))

(defmethod coerce ((num cl:complex) (domain general-expressions))			(defmethod coerce ((num cl:complex) (domain general-expressions))
  (make-instance 'complex-number :domain domain						  (make-instance 'complex-number :domain domain
		 :realpart (realpart num)								 :realpart (realpart num)
		 :imagpart (imagpart num)))								 :imagpart (imagpart num)))

(defmethod coerce ((num complex-number) (domain general-expressions))			(defmethod coerce ((num complex-number) (domain general-expressions))
  (if (eql (domain-of num) domain) num							  (if (eql (domain-of num) domain) num
      (make-instance 'complex-number :domain domain					      (make-instance 'complex-number :domain domain
		     :realpart (cn-realpart num)							     :realpart (cn-realpart num)
		     :imagpart (cn-imagpart num))))							     :imagpart (cn-imagpart num))))

(defmethod simplify ((x number))							(defmethod simplify ((x number))
  (make-element *general* x))								  (make-element *general* x))

(defmethod simplify ((x numeric))						    |	(defmethod simplify ((x numeric)) x)
  x)										    |
										    >	;;; AUDIT : These methods were defined as a single method using an OR
										    >	;;; specializer. Might be useful to revisit that extension.
										    >	(defmethod ge-equal ((x number)  (y number))  (= x y))
										    >	(defmethod ge-equal ((x numeric) (y number))  (= x y))
										    >	(defmethod ge-equal ((x number)  (y numeric)) (= x y))
										    >	(defmethod ge-equal ((x numeric) (y numeric)) (= x y))

(defmethod ge-equal ((x (or number numeric)) (y (or number numeric)))		    |	(defmethod ge-equal ((x number) y)
  (= x y))									    |	  (declare (ignore y))
										    >	  nil)

(defmethod ge-equal ((x (or number numeric)) y)					    |	(defmethod ge-equal ((x numeric) y)
  (declare (ignore y))									  (declare (ignore y))
  nil)											  nil)

(defmethod ge-equal (x (y (or number numeric)))					    |	(defmethod ge-equal (x (y number))
										    >	  (declare (ignore x))
										    >	  nil)
										    >
										    >	(defmethod ge-equal (x (y numeric))
  (declare (ignore x))									  (declare (ignore x))
  nil)											  nil)

(defmethod ge-great ((x (or number numeric)) (y (or number numeric)))		    |	(defmethod ge-great ((x number)  (y number))  (> x y))
  (> x y))									    |	(defmethod ge-great ((x numeric) (y number))  (> x y))
										    >	(defmethod ge-great ((x number)  (y numeric)) (> x y))
										    >	(defmethod ge-great ((x numeric) (y numeric)) (> x y))
										    >
										    >	(defmethod ge-great ((x number) y)
										    >	  (declare (ignore y))
										    >	  nil)

(defmethod ge-great ((x (or number numeric)) y)					    |	(defmethod ge-great ((x numeric) y)
  (declare (ignore y))									  (declare (ignore y))
  nil)											  nil)

(defmethod ge-great (x (y (or number numeric)))					    |	(defmethod ge-great (x (y number))
										    >	  (declare (ignore x))
										    >	  t)
										    >
										    >	(defmethod ge-great (x (y numeric))
  (declare (ignore x))									  (declare (ignore x))
  t)											  t)

;; Variables										;; Variables

(defmethod initialize-instance :after ((var ge-variable) &rest ignore)		    |	(defgeneric reparse-print-string (variable)
  (declare (ignore ignore))							    |	  (:documentation
  (reparse-print-string var))							    |	   "The class ge-variable has a slot for the symbol and one for
										    >	a string represenation. If subscripts are added, the string
										    >	represenation will be updated"))

(defmethod reparse-print-string ((var ge-variable))					(defmethod reparse-print-string ((var ge-variable))
  (let ((string (cond ((atom (symbol-of var))						  (let ((string (cond ((atom (symbol-of var))
		       (string-downcase (symbol-of var)))						       (string-downcase (symbol-of var)))
		      (t (format nil "[~A]" (symbol-of var)))))						      (t (format nil "[~A]" (symbol-of var)))))
	temp)											temp)
    (when (setq temp (getf var :subscripts))						    (when (setq temp (getf var :subscripts))
      (setq string 									      (setq string 
	    (format nil "~A(~S~{,~S~})"								    (format nil "~A(~S~{,~S~})"
		    string (first temp) (rest temp))))							    string (first temp) (rest temp))))
    (setf (string-of var) string)))							    (setf (string-of var) string)))

(defmethod coerce ((var symbol) (domain general-expressions))			    |	(defmethod initialize-instance :after ((var ge-variable) &rest ignore)
  (make-ge-variable domain var))						    |	  (declare (ignore ignore))
										    >	  (reparse-print-string var))
										    >
										    >	(defgeneric make-ge-variable (domain variable)
										    >	  (:documentation
										    >	   "Create a variable in a domain."))

(defmethod make-ge-variable ((domain general-expressions) var)				(defmethod make-ge-variable ((domain general-expressions) var)
										    >	  "Create a variable var in the general-expressions domain. The new
										    >	variable will be pushed into the list (ge-variables domain)."
  (loop for v in (ge-variables domain)							  (loop for v in (ge-variables domain)
	do (when (equal (symbol-of v) var)							do (when (equal (symbol-of v) var)
	     (return v))									     (return v))
	finally											finally
         (setq var (make-instance 'ge-variable :domain domain :symbol var))		         (setq var (make-instance 'ge-variable :domain domain :symbol var))
	 (push var (ge-variables domain))							 (push var (ge-variables domain))
	 (return var)))										 (return var)))

										    >	(defmethod coerce ((var symbol) (domain general-expressions))
										    >	  (make-ge-variable domain var))
										    >
(defmethod print-object ((var ge-variable) stream)					(defmethod print-object ((var ge-variable) stream)
										    >	  "This method is provided for all CLOS instances. It is used whenever an 
										    >	object is printed using princ or a related function. In Weyl, a 
										    >	print-object method is provided for classes of objects to make the objects 
										    >	more readable when debugging or when doing simple computations. The printed 
										    >	form produced by print-object cannot be read to produce the object again 
										    >	(as can be done with lists and some other Lisp expressions."
  (let ((sym (string-of var)))								  (let ((sym (string-of var)))
    (cond ((and (not (null sym)) (atom sym))						    (cond ((and (not (null sym)) (atom sym))
	   #+Genera										   #+Genera
	   (format stream "~'i~A~" sym)								   (format stream "~'i~A~" sym)
	   #-Genera										   #-Genera
	   (princ sym stream))									   (princ sym stream))
	  (t (princ (symbol-of var) stream)))))							  (t (princ (symbol-of var) stream)))))

;; This function is only to be applied to general expressions. 				;; This function is only to be applied to general expressions. 
(defsubst ge-variable? (x)								(defsubst ge-variable? (x)
  (typep x 'ge-variable))								  (typep x 'ge-variable))

(defmethod add-subscripts ((var symbol) &rest subscripts)			    |	(defgeneric add-subscripts (variable &rest subscripts)
  (%apply #'add-subscripts (coerce var *general*) subscripts))			    |	  (:documentation
										    >	   "Creates a new variable, which has the subscripts indicated. If the 
										    >	variable already has subscripts, then the new subscripts are appended to 
										    >	the ones already present."))

(defmethod add-subscripts ((var ge-variable) &rest subscripts)				(defmethod add-subscripts ((var ge-variable) &rest subscripts)
  (setq var (coerce var *general*))							  (setq var (coerce var *general*))
  (let* ((symbol (symbol-of var))							  (let* ((symbol (symbol-of var))
	 (subscripts (append (getf var :subscripts) (copy-list subscripts)))			 (subscripts (append (getf var :subscripts) (copy-list subscripts)))
	 (canonical-var 									 (canonical-var 
	  (member symbol (ge-variables *general*)						  (member symbol (ge-variables *general*)
		  :test #'(lambda (a b)									  :test #'(lambda (a b)
			    (and (equal a (symbol-of b))							    (and (equal a (symbol-of b))
				 (equal subscripts (getf b :subscripts)))))))						 (equal subscripts (getf b :subscripts)))))))
    (cond (canonical-var								    (cond (canonical-var
	   (first canonical-var))								   (first canonical-var))
	  (t (setq var (make-instance 'ge-variable :domain (domain-of var)			  (t (setq var (make-instance 'ge-variable :domain (domain-of var)
				      :symbol symbol))									      :symbol symbol))
	     (setf (getf var :subscripts) subscripts)						     (setf (getf var :subscripts) subscripts)
	     (reparse-print-string var)								     (reparse-print-string var)
	     (push var (ge-variables *general*))						     (push var (ge-variables *general*))
	     var))))										     var))))

										    >	(defmethod add-subscripts ((var symbol) &rest subscripts)
										    >	  (%apply #'add-subscripts (coerce var *general*) subscripts))
										    >
(defmethod ge-equal ((x ge-variable) (y ge-variable))					(defmethod ge-equal ((x ge-variable) (y ge-variable))
  (eql x y))										  (eql x y))

(defmethod ge-great ((x ge-variable) (y ge-variable))					(defmethod ge-great ((x ge-variable) (y ge-variable))
  (string-greaterp (string-of x) (string-of y)))					  (string-greaterp (string-of x) (string-of y)))

(defmethod ge-great ((x ge-variable) (y (or ge-plus ge-times)))  		    |	(defmethod ge-great ((x ge-variable) (y  ge-plus))  
										    >	  (loop for w in (terms-of y)
										    >		unless (ge-great x w)
										    >	        do (return nil)
										    >		finally (return t)))
										    >
										    >	(defmethod ge-great ((x ge-variable) (y ge-times))  
  (loop for w in (terms-of y)								  (loop for w in (terms-of y)
	unless (ge-great x w)									unless (ge-great x w)
	  do (return nil)								        do (return nil)
	finally (return t)))									finally (return t)))

(defmethod ge-great ((x (or ge-plus ge-times)) (y ge-variable))  		    |	(defmethod ge-great ((x ge-plus) (y ge-variable))  
										    >	  (loop for w in (terms-of x)
										    >		unless (ge-great w y)
										    >	        do (return t)
										    >		finally (return nil)))
										    >
										    >	(defmethod ge-great ((x ge-times) (y ge-variable))  
  (loop for w in (terms-of x)								  (loop for w in (terms-of x)
	unless (ge-great w y)									unless (ge-great w y)
	  do (return t)									        do (return t)
	finally (return nil)))									finally (return nil)))

;; Functions										;; Functions

(defun search-for-function (list name nargs)						(defun search-for-function (list name nargs)
  (loop for f in list									  (loop for f in list
        do (when (and (not (typep f 'ge-function-deriv))				        do (when (and (not (typep f 'ge-function-deriv))
                      (string= name (name-of f)))					                      (string= name (name-of f)))
             (when (and nargs (not (cl:= nargs (nargs-of f))))				             (when (and nargs (not (cl:= nargs (nargs-of f))))
               (error "Wrong number of arguments specified for function ~A"		               (error "Wrong number of arguments specified for function ~A"
                      name))								                      name))
             (return f))))  								             (return f))))  

										    >	(defgeneric get-function (domain name &optional args)
										    >	  (:documentation
										    >	   "Looks for a function with given name."))
										    >
(defmethod get-function ((domain general-expressions) name &optional nargs)		(defmethod get-function ((domain general-expressions) name &optional nargs)
  (setq name (string-downcase (string name)))						  (setq name (string-downcase (string name)))
  (or (search-for-function (ge-functions domain) name nargs)				  (or (search-for-function (ge-functions domain) name nargs)
      (search-for-function *global-functions* name nargs)))				      (search-for-function *global-functions* name nargs)))

(defmethod get-function ((domain (eql nil)) name &optional nargs)			(defmethod get-function ((domain (eql nil)) name &optional nargs)
  (setq name (string-downcase (string name)))						  (setq name (string-downcase (string name)))
  (search-for-function *global-functions* name nargs))					  (search-for-function *global-functions* name nargs))

										    >	(defgeneric make-function (domain name &optional nargs)
										    >	  (:documentation
										    >	   "Create a funtion in a domain with name given."))
										    >
(defmethod make-function ((domain general-expressions) name &optional nargs)		(defmethod make-function ((domain general-expressions) name &optional nargs)
  (setq name (string-downcase (string name)))						  (setq name (string-downcase (string name)))
  (let ((fun (or (search-for-function (ge-functions domain) name nargs)			  (let ((fun (or (search-for-function (ge-functions domain) name nargs)
                 (search-for-function *global-functions* name nargs))))			                 (search-for-function *global-functions* name nargs))))
    (unless fun										    (unless fun
      (when (null nargs)								      (when (null nargs)
        (error "Number of arguments to ~A must be specified" name))			        (error "Number of arguments to ~A must be specified" name))
      (setq fun (make-instance 'ge-function :domain domain				      (setq fun (make-instance 'ge-function :domain domain
                               :name name :nargs nargs))				                               :name name :nargs nargs))
      (push fun (ge-functions domain)))							      (push fun (ge-functions domain)))
    fun))										    fun))

(defmethod make-function ((domain (eql nil)) name &optional nargs)			(defmethod make-function ((domain (eql nil)) name &optional nargs)
  (setq name (string-downcase (string name)))						  (setq name (string-downcase (string name)))
  (let ((fun (search-for-function *global-functions* name nargs)))			  (let ((fun (search-for-function *global-functions* name nargs)))
    (unless fun										    (unless fun
      (when (null nargs)								      (when (null nargs)
        (error "Number of arguments to ~A must be specified" name))			        (error "Number of arguments to ~A must be specified" name))
      (setq fun (make-instance 'ge-function :domain domain				      (setq fun (make-instance 'ge-function :domain domain
                               :name name :nargs nargs))				                               :name name :nargs nargs))
      (push fun *global-functions*))							      (push fun *global-functions*))
    fun))										    fun))

(defmethod derivs-of ((f ge-function))						    |	(defmethod derivs-of ((f ge-function)) nil)
  nil)										    <

(defun add-function-to-domain (domain name nargs &optional derivs)			(defun add-function-to-domain (domain name nargs &optional derivs)
										    >	  "Add a function to a domain."
  (let ((function-class (if derivs 'ge-function-deriv 'ge-function))			  (let ((function-class (if derivs 'ge-function-deriv 'ge-function))
        deriv)										        deriv)
    (loop for f in (ge-functions domain)						    (loop for f in (ge-functions domain)
          do (when (and (typep f function-class)					          do (when (and (typep f function-class)
                        (eql (name-of f) name)						                        (eql (name-of f) name)
                        (equal (derivs-of f) derivs))					                        (equal (derivs-of f) derivs))
               (setq deriv f)								               (setq deriv f)
               (return t)))								               (return t)))
    (unless deriv									    (unless deriv
      (setq deriv (make-instance function-class :domain domain				      (setq deriv (make-instance function-class :domain domain
                                 :name name :nargs nargs				                                 :name name :nargs nargs
                                 :derivs derivs))					                                 :derivs derivs))
      (push deriv (ge-functions domain)))						      (push deriv (ge-functions domain)))
    deriv))										    deriv))

										    >	;;; FIXME : This needs to be merged into the generic function.
										    >	(defmethod minus? ((x t))
										    >	  (declare (ignore x))
										    >	  nil)
										    >
										    >	;; For compatibility with Common Lisp
										    >	(defun minusp (x)
										    >	    "For compatibility with Common Lisp: same as (minus? x)"
										    >	   (minus? x))
										    >	(defun plusp (x) 
										    >	    "For compatibility with Common Lisp: same as (plus? x)"
										    >	    (plus? x))
										    >	(defun zerop (x) 
										    >	    "For compatibility with Common Lisp: same as (0? x)"
										    >	    (0? x))
										    >
										    >	(defgeneric make-function-deriv (function derivative)
										    >	  (:documentation
										    >	   "Create a function derivative."))
										    >
;; The copy-list's in the following functions is necessary because			;; The copy-list's in the following functions is necessary because
;; sort destructively modifies its argument.  --RZ					;; sort destructively modifies its argument.  --RZ
(defmethod make-function-deriv ((fun ge-function) (i integer))				(defmethod make-function-deriv ((fun ge-function) (i integer))
  (when (or (minusp i)									  (when (or (minusp i)
            (not (< i (nargs-of fun))))							            (not (< i (nargs-of fun))))
    (error "Illegal derivative of ~S in position ~D" fun i))				    (error "Illegal derivative of ~S in position ~D" fun i))
  (add-function-to-domain (domain-of fun)						  (add-function-to-domain (domain-of fun)
                          (name-of fun)							                          (name-of fun)
                          (nargs-of fun)						                          (nargs-of fun)
                          (if (typep fun 'ge-function-deriv)				                          (if (typep fun 'ge-function-deriv)
                            (sort (cons i (copy-list (derivs-of fun)))			                              (sort (cons i (copy-list (derivs-of fun)))
                                  #'cl:<)						                                    #'cl:<)
                            (list i))))							                              (list i))))

(defmethod make-function-deriv ((fun ge-function) (derivs list))			(defmethod make-function-deriv ((fun ge-function) (derivs list))
  (add-function-to-domain (domain-of fun)						  (add-function-to-domain (domain-of fun)
                          (name-of fun)							                          (name-of fun)
                          (nargs-of fun)						                          (nargs-of fun)
			  (sort (if (typep fun 'ge-function-deriv)						  (sort (if (typep fun 'ge-function-deriv)
				    (append derivs (copy-list (derivs-of fun)))						    (append derivs (copy-list (derivs-of fun)))
				    derivs)										    derivs)
				#'cl:<)))										#'cl:<)))

										    >	(defgeneric make-function-integrate (function integrand)
										    >	  (:documentation
										    >	   "Create the integral of a function."))
										    >
(defmethod make-function-integrate ((fun ge-function) (i integer))			(defmethod make-function-integrate ((fun ge-function) (i integer))
  (when (or (minusp i)									  (when (or (minusp i)
            (not (< i (nargs-of fun))))							            (not (< i (nargs-of fun))))
    (error "Illegal derivative of ~S in position ~D" fun i))				    (error "Illegal derivative of ~S in position ~D" fun i))
  (let ((derivs (if (typep fun 'ge-function-deriv)					  (let ((derivs (if (typep fun 'ge-function-deriv)
                  (derivs-of fun) nil)))						                    (derivs-of fun) nil)))
    (cond ((member i derivs)								    (cond ((member i derivs)
           (setq derivs (remove i derivs :count 1)))					           (setq derivs (remove i derivs :count 1)))
          (t (error "Don't have representation for integrals yet")))			          (t (error "Don't have representation for integrals yet")))
    (add-function-to-domain (domain-of fun) (name-of fun) (nargs-of fun)		    (add-function-to-domain (domain-of fun) (name-of fun) (nargs-of fun)
                            derivs)))							                            derivs)))

(defmethod print-object ((fun ge-function) stream)					(defmethod print-object ((fun ge-function) stream)
  #+Genera										  #+Genera
  (format stream "~'i~A~" (name-of fun))						  (format stream "~'i~A~" (name-of fun))
  #-Genera										  #-Genera
  (princ (name-of fun) stream))								  (princ (name-of fun) stream))

(defmethod print-object ((fun ge-function-deriv) stream)				(defmethod print-object ((fun ge-function-deriv) stream)
  #+Genera										  #+Genera
  (format stream "~'i~A~" (name-of fun))						  (format stream "~'i~A~" (name-of fun))
  #-Genera										  #-Genera
  (princ (name-of fun) stream)								  (princ (name-of fun) stream)
  (princ "_{" stream)									  (princ "_{" stream)
  (loop for n in (derivs-of fun)							  (loop for n in (derivs-of fun)
        do (princ n stream))								        do (princ n stream))
  (princ "}" stream))									  (princ "}" stream))

										    >	(defgeneric make-ge-funct (domain function &rest args)
										    >	  (:documentation
										    >	   "Create a function in the general expression domain."))
										    >
(defmethod make-ge-funct ((domain general-expressions) funct &rest args)		(defmethod make-ge-funct ((domain general-expressions) funct &rest args)
  (make-instance 'ge-application :domain domain						  (make-instance 'ge-application :domain domain
		 :funct (if (ge-function? funct) funct							 :funct (if (ge-function? funct) funct
                            (make-function domain funct (length args)))			                            (make-function domain funct (length args)))
                 :args (copy-list args)))						                 :args (copy-list args)))

(defmethod apply ((fun ge-function) &rest args)						(defmethod apply ((fun ge-function) &rest args)
										    >	  "Apply fun to the k arguments specified and the elements of list. If the 
										    >	number of arguments of the function di er from k plus the length of list 
										    >	then an error is signaled."
  (let ((domain (domain-of fun)))							  (let ((domain (domain-of fun)))
    (flet ((check-domain (dom)								    (flet ((check-domain (dom)
             (cond ((null domain)							             (cond ((null domain)
                    (if (typep dom 'general-expressions)				                    (if (typep dom 'general-expressions)
                      (setq domain dom)							                        (setq domain dom)
                      (error "GE function of ~D" dom)))					                        (error "GE function of ~D" dom)))
                   ((not (eql domain dom))						                   ((not (eql domain dom))
                    (error "Incompatible domains apply ~S to ~S" fun args)))))		                    (error "Incompatible domains apply ~S to ~S" fun args)))))
      (setq args (accum-apply-args args))						      (setq args (accum-apply-args args))
      (loop for arg in args								      (loop for arg in args
            do (when (or (typep arg 'general-expression)				            do (when (or (typep arg 'general-expression)
                         (typep arg 'numeric))						                         (typep arg 'numeric))
                 (check-domain (domain-of arg))))					                 (check-domain (domain-of arg))))
      (when (null domain)								      (when (null domain)
        (setq domain *general*))							        (setq domain *general*))
      (simplify										      (simplify
       (make-instance 'ge-application :domain domain					       (make-instance 'ge-application :domain domain
                      :funct fun							                      :funct fun
                      :args (loop for arg in args					                      :args (loop for arg in args
                                  collect (coerce arg domain)))))))			                                  collect (coerce arg domain)))))))

(defmacro funct (function &rest args)							(defmacro funct (function &rest args)
  `(make-ge-funct *general* ',function							  `(make-ge-funct *general* ',function
      ,@(mapcar #'(lambda (q) `(coerce ,q *general*))					    ,@(mapcar #'(lambda (q) `(coerce ,q *general*))
		args)))									              args)))

										    >	(defgeneric display-list (objects &optional stream)
										    >	  (:documentation "Display a list of objects, paying attention to
										    >	*print-length*.  No surrounding delimiters.  This is a method so that
										    >	we can define similar functions for sets of objects embedded in
										    >	arrays."))
										    >
										    >	(defmethod display-list
										    >	    ((objects list) &optional (stream *standard-output*))
										    >	  (when objects
										    >	    (let ((cnt (or *print-length* -1)))
										    >	      (declare (fixnum cnt))
										    >	      (print-object (first objects) stream)
										    >	      (cl:decf cnt)
										    >	      (loop for var in (rest objects)
										    >		    do (princ ", " stream)
										    >		       (when (cl:zerop cnt)
										    >			 (princ "..." stream)
										    >			 (return))
										    >		       (print-object var stream)
										    >		       (cl:decf cnt)))))
										    >
(defmethod print-object ((x ge-application) stream)					(defmethod print-object ((x ge-application) stream)
  (print-object (funct-of x) stream)							  (print-object (funct-of x) stream)
  (write-char #\( stream)								  (write-char #\( stream)
  (display-list (args-of x) stream)							  (display-list (args-of x) stream)
  (write-char #\) stream))								  (write-char #\) stream))

(defmethod simplify ((x ge-application))						(defmethod simplify ((x ge-application))
										    >	  "Performs simple simplifications of expr, 0 + x = x and so on."
  (let ((args (mapcar #'simplify (args-of x)))						  (let ((args (mapcar #'simplify (args-of x)))
        (simplifier (getf (funct-of x) 'simplify))					        (simplifier (getf (funct-of x) 'simplify))
	new-x)											new-x)
    ;; This is the function application with the simplified arguments.			    ;; This is the function application with the simplified arguments.
    (setq new-x (apply #'make-ge-funct (domain-of x) (funct-of x) args))		    (setq new-x (apply #'make-ge-funct (domain-of x) (funct-of x) args))
    (if simplifier									    (if simplifier
      (apply simplifier (domain-of x) new-x args)					        (apply simplifier (domain-of x) new-x args)
      new-x)))										        new-x)))

;; Contexts										;; Contexts

(defvar *initialize-contexts-funs* ())							(defvar *initialize-contexts-funs* ())

(defun initialize-contexts ()								(defun initialize-contexts ()
  (setq *general* (make-instance 'general-expressions))					  (setq *general* (make-instance 'general-expressions))
  (loop for fun in *initialize-contexts-funs*						  (loop for fun in *initialize-contexts-funs*
	do (funcall fun)))									do (funcall fun)))

(defmacro with-new-context (&body body)							(defmacro with-new-context (&body body)
  `(let ((*general* (make-instance 'general-expressions)))				  `(let ((*general* (make-instance 'general-expressions)))
     ,@body))										    ,@body))

(defmacro check-point-context (&body body)						(defmacro check-point-context (&body body)
  `(let ((.old-variables. (ge-variables *general*))					  `(let ((.old-variables. (ge-variables *general*))
	 (.old-context. (ge-context *general*)))						 (.old-context. (ge-context *general*)))
     (unwind-protect (progn ,@body)							    (unwind-protect (progn ,@body)
       (setf .old-variables. (ge-variables *general*))					      (setf .old-variables. (ge-variables *general*))
       (setf .old-context. (ge-context *general*)))))					      (setf .old-context. (ge-context *general*)))))

										    >	(defgeneric make-ge-plus (domain terms)
										    >	  (:documentation
										    >	   "Create ge-plus instances."))
										    >
										    >	(defmethod make-ge-plus ((domain general-expressions) terms)
										    >	  (make-instance 'ge-plus :domain domain :terms terms))
										    >
										    >	(defgeneric make-ge-times (domain terms)
										    >	  (:documentation
										    >	   "Create ge-times instances."))
										    >
										    >	(defmethod make-ge-times ((domain general-expressions) terms)
										    >	  (make-instance 'ge-times :domain domain :terms terms))
										    >
										    >	(defgeneric make-ge-expt (domain base exp)
										    >	  (:documentation
										    >	   "Create ge-expt instances."))
										    >
										    >	(defmethod make-ge-expt ((domain general-expressions) base exp)
										    >	  (make-instance 'ge-expt :domain domain :base base :exp exp))
										    >
(defmethod coerce ((exp list) (domain general-expressions))				(defmethod coerce ((exp list) (domain general-expressions))
  (flet ((coerce-obj (x)								  (flet ((coerce-obj (x)
	   (coerce x domain)))									   (coerce x domain)))
    (cond ((eql (first exp) '+)								    (cond ((eql (first exp) '+)
	   (make-ge-plus domain									   (make-ge-plus domain
			 (mapcar #'coerce-obj (rest exp))))							 (mapcar #'coerce-obj (rest exp))))
	  ((eql (first exp) '*)									  ((eql (first exp) '*)
	   (make-ge-times domain								   (make-ge-times domain
			 (mapcar #'coerce-obj (rest exp))))				                          (mapcar #'coerce-obj (rest exp))))
	  ((eql (first exp) '-)									  ((eql (first exp) '-)
	   (if (null (rest (rest exp)))								   (if (null (rest (rest exp)))
	       (make-ge-times domain (list -1 (coerce-obj (second exp))))			       (make-ge-times domain (list -1 (coerce-obj (second exp))))
	       (make-ge-plus domain								       (make-ge-plus domain
		 (list (coerce-obj (second exp))					                             (list (coerce-obj (second exp))
		       (make-ge-times domain						                                   (make-ge-times domain
			 (cons (make-element domain -1)					                                                  (cons (make-element domain -1)
			       (mapcar #'coerce-obj (rest (rest exp)))))))))		                                                        (mapcar #'coerce-obj (rest
	  ((eql (first exp) '/)									  ((eql (first exp) '/)
	   (make-ge-times domain								   (make-ge-times domain
	     (list (coerce-obj (second exp))						                          (list (coerce-obj (second exp))
		   (make-ge-expt domain							                                (make-ge-expt domain
		     (make-ge-times domain						                                              (make-ge-times domain
		       (mapcar #'coerce-obj (rest (rest exp))))				                                                             (mapcar #'coerce-obj 
		     (make-element domain -1)))))					                                              (make-element domain -1)))))
	  (t (error "Don't know how to coerce ~S into ~S"					  (t (error "Don't know how to coerce ~S into ~S"
		    exp domain)))))			     						    exp domain)))))			     
			     
(defmethod get-variable-property ((domain domain) (var ge-variable) key)	    <
  (loop for var-prop in (ge-context domain)					    <
	do (when (eql (first var-prop) var)					    <
	     (return (%getf (rest var-prop) key)))				    <
	finally (progn 								    <
		  (push (list var) (ge-context domain))				    <
		  (return nil))))						    <
										    <
(defmethod set-variable-property (domain (var ge-variable) key value)		    <
  (loop for var-prop in (ge-context domain)					    <
	do (when (eql (first var-prop) var)					    <
	     (setf (%getf (rest var-prop) key) value)				    <
	     (return value))							    <
	finally (progn 								    <
		  (push (list var key value) (ge-context domain))		    <
		  (return value))))						    <
										    <
(defsetf get-variable-property set-variable-property)				    <
										    <
(defun parenthesized-display (expr stream)						(defun parenthesized-display (expr stream)
										    >	  "Decorate the expr with parens ()."
  (princ "(" stream)									  (princ "(" stream)
  (print-object expr stream)								  (print-object expr stream)
  (princ ")" stream))									  (princ ")" stream))

(defun safe-display (expr stream)							(defun safe-display (expr stream)
										    >	  "Use parens if necessary."
  (if (or (and (number? expr) (not (typep expr 'complex-number)))			  (if (or (and (number? expr) (not (typep expr 'complex-number)))
	  (and (typep expr 'complex-number)							  (and (typep expr 'complex-number)
	       (0? (realpart expr)))								       (0? (realpart expr)))
	  (ge-variable? expr)									  (ge-variable? expr)
	  (ge-expt? expr))									  (ge-expt? expr))
      (print-object expr stream)      							      (print-object expr stream)      
      (parenthesized-display expr stream)))						      (parenthesized-display expr stream)))

;; Display a list of objects, paying attention to *print-length*.  No		    <
;; surrounding delimiters.   This is a method so that we can define		    <
;; similar functions for sets of objects embedded in arrays.			    <
(defmethod display-list								    <
    ((objects list) &optional (stream *standard-output*))			    <
  (when objects									    <
    (let ((cnt (or *print-length* -1)))						    <
      (declare (fixnum cnt))							    <
      (print-object (first objects) stream)					    <
      (cl:decf cnt)								    <
      (loop for var in (rest objects)						    <
	    do (princ ", " stream)						    <
	       (when (cl:zerop cnt)						    <
		 (princ "..." stream)						    <
		 (return))							    <
	       (print-object var stream)					    <
	       (cl:decf cnt)))))						    <
										    <
										    <
;; Ordering functions for general expressions						;; Ordering functions for general expressions

;; Some operators may choose to ignore various parameters here.				;; Some operators may choose to ignore various parameters here.

(defun ge-lequal (x y)									(defun ge-lequal (x y)
  (loop											  (loop
    (when (and (null x) (null y))							   (when (and (null x) (null y))
      (return-from ge-lequal t))							     (return-from ge-lequal t))
    (when (or (null x) (null y)								   (when (or (null x) (null y)
	      (not (ge-equal (first x) (first y))))					             (not (ge-equal (first x) (first y))))
      (return-from ge-lequal nil))							     (return-from ge-lequal nil))
    (pop x) (pop y)))									   (pop x) (pop y)))

(defun ge-lgreat (x y)									(defun ge-lgreat (x y)
  (loop 										  (loop 
    (cond ((null x)									   (cond ((null x)
	   (return nil))								          (return nil))
	  ((null y)									         ((null y)
	   (return t))									          (return t))
	  ((ge-equal (first x) (first y)))						         ((ge-equal (first x) (first y)))
	  ((ge-great (first x) (first y))						         ((ge-great (first x) (first y))
	   (return t))									          (return t))
	  (t (return nil)))								         (t (return nil)))
    (pop x) (pop y)))									   (pop x) (pop y)))

										    |	(defgeneric real? (object)
;; x is assumed to be a variable						    |	  (:documentation
										    |	   "Return true if the object is real valued.")
										    |	  (:method ((object number))
(defmethod real? ((x number))							    |	    (not (cl:complexp object)))
  (not (cl:complexp x)))							    |	  (:method ((object bigfloat))
										    |	    (declare (ignore object))
(defmethod real? ((x bigfloat))							    <
  t)											    t)
										    |	  (:method ((object numeric))
(defmethod real? ((x numeric))							    |	    (not (typep object 'complex-number))))
  (not (typep x 'complex-number)))						    <
										    <
(defmethod minus? ((x t))							    <
  nil)										    <
										    <
;; For compatibility with Common Lisp						    <
(defun minusp (x) (minus? x))							    <
(defun plusp (x) (plus? x))							    <
(defun zerop (x) (0? x))							    <

(defun ge-minus? (x)									(defun ge-minus? (x)
  (cond ((and (number? x) (real? x)) (minus? x))					  (cond ((and (number? x) (real? x)) (minus? x))
	((ge-times? x)										((ge-times? x)
	 (let ((lead-term (first (terms-of x))))						 (let ((lead-term (first (terms-of x))))
	   (and (and (number? lead-term)							   (and (and (number? lead-term)
		     (real? lead-term)									     (real? lead-term)
		     (minus? lead-term)))))								     (minus? lead-term)))))
	(t nil)))										(t nil)))

;; This works by converting the sum into a list of dotted pairs.  The			;; This works by converting the sum into a list of dotted pairs.  The
;; first element of the list is a number, while the second is a list			;; first element of the list is a number, while the second is a list
;; of product terms.  This makes combining new elements quite easy.			;; of product terms.  This makes combining new elements quite easy.
;; After the combination, everything is converted back to the standard			;; After the combination, everything is converted back to the standard
;; representation. 									;; representation. 
											(defmacro merge-terms-in-sum (terms &body body)
(defmacro merge-terms-in-sum (terms &body body)					    (
										    >	  "This works by converting the sum into a list of dotted pairs.  The
										    >	first element of the list is a number, while the second is a list
										    >	of product terms.  This makes combining new elements quite easy.
										    >	After the combination, everything is converted back to the standard
										    >	representation." 
  `(let ((,terms (list nil)))								  `(let ((,terms (list nil)))
     (labels ((add-term (base order) 							    (labels ((add-term (base order) 
		(loop with terms = ,terms do						               (loop with terms = ,terms do
		  (cond ((or (null (rest terms))					                     (cond ((or (null (rest terms))
			     (ge-lgreat base (rest (second terms))))			                                (ge-lgreat base (rest (second terms))))
			 (push (cons order base) (rest terms))				                            (push (cons order base) (rest terms))
			 (return t))							                            (return t))
			((ge-lequal base (rest (second terms)))				                           ((ge-lequal base (rest (second terms)))
			 (setf (first (second terms))					                            (setf (first (second terms))
			       (+ (first (second terms)) order))			                                  (+ (first (second terms)) order))
			 (when (0? (first (second terms)))				                            (when (0? (first (second terms)))
			   (setf (rest terms) (rest (rest terms))))			                              (setf (rest terms) (rest (rest terms))))
			 (return t)))							                            (return t)))
		  (pop terms))))							                     (pop terms))))
       ,@body)))									      ,@body)))

										    <
(defmethod make-ge-plus ((domain general-expressions) terms)			    <
  (make-instance 'ge-plus :domain domain :terms terms))				    <
										    <
(defmethod print-object ((sum ge-plus) stream)					    <
  (let ((terms (terms-of sum)))							    <
    (print-object (first terms) stream)						    <
    (loop for x in (rest terms)							    <
	  do (cond ((and (number? x) (real? x))					    <
		    (if (plus? x)						    <
			(format stream " + ~S" x)				    <
			(format stream " - ~S" (minus x))))			    <
		   ((ge-minus? x)						    <
		    (princ " - " stream)					    <
		    (safe-display 						    <
		     (simp-times-terms (domain-of sum) (list -1 x))		    <
		     stream))							    <
		   (t (princ " + " stream)					    <
		      (print-object x stream))))))				    <
										    <
(defmethod simplify ((x ge-plus))						    <
  (simp-plus-terms (domain-of x) (terms-of x)))					    <
  										    <
(defun simp-plus-terms (domain old-terms)						(defun simp-plus-terms (domain old-terms)
										    >	  "Simplify ge-plus terms."
  (merge-terms-in-sum terms								  (merge-terms-in-sum terms
    (let ((const 0))									    (let ((const 0))
      (labels ((loop-over-terms (terms)							      (labels ((loop-over-terms (terms)
		 (loop for term in terms								 (loop for term in terms
		       do (setq term (simplify term))							       do (setq term (simplify term))
			  (cond ((number? term) 					                       (cond ((number? term) 
				 (setq const (+ const term)))				                              (setq const (+ const term)))
				((ge-plus? term)					                             ((ge-plus? term)
				 (loop-over-terms (terms-of term)))			                              (loop-over-terms (terms-of term)))
				((ge-times? term)					                             ((ge-times? term)
				 (setq term (terms-of term))				                              (setq term (terms-of term))
				 (cond ((number? (first term))				                              (cond ((number? (first term))
					(add-term (rest term) (first term)))		                                     (add-term (rest term) (first term)))
				       (t (add-term term 1))))				                                    (t (add-term term 1))))
				(t (add-term (list term) 1))))))			                             (t (add-term (list term) 1))))))
	(loop-over-terms old-terms)								(loop-over-terms old-terms)
	(setq terms (loop for (c . term-l) in (rest terms)					(setq terms (loop for (c . term-l) in (rest terms)
			  collect										  collect
			  (if (or (eql c 1) (eql c 1.0))							  (if (or (eql c 1) (eql c 1.0))
			      (if (null (rest term-l))								      (if (null (rest term-l))
				  (first term-l)									  (first term-l)
				  (simplify										  (simplify
				   (make-ge-times domain term-l)))							   (make-ge-times domain term-l)))
			      (simplify										      (simplify
			       (make-ge-times domain (cons c term-l)))))) 					       (make-ge-times domain (cons c term-l)))))) 
	(cond ((not (0? const))									(cond ((not (0? const))
	       (if (null terms) const								       (if (null terms) const
		   (make-ge-plus domain (cons const terms))))						   (make-ge-plus domain (cons const terms))))
	      ((null terms)									      ((null terms)
	       (make-element domain 0))								       (make-element domain 0))
	      ((null (rest terms))								      ((null (rest terms))
	       (first terms))									       (first terms))
	      (t (make-ge-plus domain terms)))))))						      (t (make-ge-plus domain terms)))))))

(defmethod ge-equal ((x ge-plus) (y ge-plus))					    <
  (ge-lequal (terms-of x) (terms-of y)))					    <
										    <
(defmethod ge-great ((x ge-plus) (y ge-plus))					    <
  (ge-lgreat (terms-of x) (terms-of y)))					    <
										    <
										    <
(defmethod make-ge-times ((domain general-expressions) terms)			    <
  (make-instance 'ge-times :domain domain :terms terms))			    <
										    <
(defmethod print-object ((x ge-times) stream)					    <
  (let ((terms (terms-of x)))							    <
    (safe-display (first terms) stream)						    <
    (loop for x in (rest terms)							    <
	  do (princ " " stream)							    <
	     (safe-display x stream))))						    <
										    <
(defmethod simplify ((x ge-times)) 						    <
  (simp-times-terms (domain-of x) (terms-of x)))				    <
										    <
(defun simp-times-terms (domain old-terms)						(defun simp-times-terms (domain old-terms)
										    >	  "Simplify ge-times terms"
  (merge-terms-in-sum terms 								  (merge-terms-in-sum terms 
    (let ((const 1))									    (let ((const 1))
      (labels ((loop-over-terms (terms) 						      (labels ((loop-over-terms (terms) 
		 (loop for term in terms do								 (loop for term in terms do
		   (setq term (simplify term))								   (setq term (simplify term))
		   (cond ((number? term)								   (cond ((number? term)
			  (when (0? term)									  (when (0? term)
			    (return-from simp-times-terms							    (return-from simp-times-terms
			      (make-element domain 0)))								      (make-element domain 0)))
			  (setq const (* const term)))								  (setq const (* const term)))
			 ((ge-times? term)									 ((ge-times? term)
			  (loop-over-terms (terms-of term)))							  (loop-over-terms (terms-of term)))
			 ((ge-expt? term)									 ((ge-expt? term)
			  (let ((exp (exponent-of term))							  (let ((exp (exponent-of term))
				(base (base-of term)))									(base (base-of term)))
			    (cond ((number? (exponent-of term))							    (cond ((number? (exponent-of term))
				   (add-term (list base) exp))								   (add-term (list base) exp))
				  (t (add-term (list base)								  (t (add-term (list base)
					       (make-element domain 1))))))	    |						 ;;; *kfp* -- (make-element domain 1) 
										    >						 (simplify exp))))))
			 (t (add-term (list term) 1))))))							 (t (add-term (list term) 1))))))
	(loop-over-terms old-terms)								(loop-over-terms old-terms)
	(setq terms (loop for (exp base) in (rest terms)					(setq terms (loop for (exp base) in (rest terms)
			  collect										  collect
			  (if (1? exp) base									  (if (1? exp) base
			      (make-ge-expt domain base exp))))							      (make-ge-expt domain base exp))))
	(cond ((not (1? const))									(cond ((not (1? const))
	       (if (null terms)									       (if (null terms)
		   const										   const
		   (make-ge-times domain (cons const terms))))						   (make-ge-times domain (cons const terms))))
	      ((null terms)									      ((null terms)
	       (make-element domain 1))								       (make-element domain 1))
	      ((null (rest terms))								      ((null (rest terms))
	       (first terms))									       (first terms))
	      (t (make-ge-times domain terms)))))))						      (t (make-ge-times domain terms)))))))

(defmethod ge-equal ((x ge-times) (y ge-times))					    |	(defmethod print-object ((sum ge-plus) stream)
										    >	  (let ((terms (terms-of sum)))
										    >	    (print-object (first terms) stream)
										    >	    (loop for x in (rest terms)
										    >		  do (cond ((and (number? x) (real? x))
										    >			    (if (plus? x)
										    >				(format stream " + ~S" x)
										    >				(format stream " - ~S" (minus x))))
										    >			   ((ge-minus? x)
										    >			    (princ " - " stream)
										    >			    (safe-display 
										    >			     (simp-times-terms (domain-of sum) (list -1 x))
										    >			     stream))
										    >			   (t (princ " + " stream)
										    >			      (print-object x stream))))))
										    >
										    >	(defmethod simplify ((x ge-plus))
										    >	  (simp-plus-terms (domain-of x) (terms-of x)))
										    >
										    >	(defmethod ge-equal ((x ge-plus) (y ge-plus))
  (ge-lequal (terms-of x) (terms-of y)))						  (ge-lequal (terms-of x) (terms-of y)))

(defmethod ge-great ((x ge-times) (y ge-times))					    |	(defmethod ge-great ((x ge-plus) (y ge-plus))
  (ge-lgreat (terms-of x) (terms-of y)))						  (ge-lgreat (terms-of x) (terms-of y)))

										    >	(defmethod print-object ((x ge-times) stream)
										    >	  (let ((terms (terms-of x)))
										    >	    (safe-display (first terms) stream)
										    >	    (loop for x in (rest terms)
										    >		  do (princ " " stream)
										    >		     (safe-display x stream))))

(defmethod make-ge-expt ((domain general-expressions) base exp)			    |	(defmethod simplify ((x ge-times)) 
  (make-instance 'ge-expt :domain domain :base base :exp exp))			    |	  (simp-times-terms (domain-of x) (terms-of x)))
										    >
										    >	(defmethod ge-equal ((x ge-times) (y ge-times))
										    >	  (ge-lequal (terms-of x) (terms-of y)))
										    >
										    >	(defmethod ge-great ((x ge-times) (y ge-times))
										    >	  (ge-lgreat (terms-of x) (terms-of y)))

(defmethod simplify ((x ge-expt))							(defmethod simplify ((x ge-expt))
										    >	  "Simplify ge-expt (base exponent)."
  (let ((exp (simplify (exponent-of x)))						  (let ((exp (simplify (exponent-of x)))
	(base (base-of x)))									(base (base-of x)))
    (cond ((0? exp) 1)									    (cond ((0? exp) 1)
	  ((1? exp) (simplify base))								  ((1? exp) (simplify base))
	  ((and (number? (setq base (simplify base)))						  ((and (number? (setq base (simplify base)))
		(number? exp))										(number? exp))
	   (expt base exp))									   (expt base exp))
	  ((ge-expt? base)									  ((ge-expt? base)
	   (simplify 										   (simplify 
	    (make-ge-expt (domain-of x) (base-of base)						    (make-ge-expt (domain-of x) (base-of base)
			  (* (exponent-of base) exp))))								  (* (exponent-of base) exp))))
	  (t (make-ge-expt (domain-of x) (simplify (base-of x)) exp)))))			  (t (make-ge-expt (domain-of x) (simplify (base-of x)) exp)))))

(defmethod print-object ((expr ge-expt) stream)						(defmethod print-object ((expr ge-expt) stream)
  (safe-display (base-of expr) stream)							  (safe-display (base-of expr) stream)
  (princ "^" stream)									  (princ "^" stream)
  (safe-display (exponent-of expr) stream))						  (safe-display (exponent-of expr) stream))

(defmethod ge-equal ((x ge-expt) (y ge-expt))						(defmethod ge-equal ((x ge-expt) (y ge-expt))
  (and (ge-equal (base-of x) (base-of y))						  (and (ge-equal (base-of x) (base-of y))
       (ge-equal (exponent-of x) (exponent-of y))))					       (ge-equal (exponent-of x) (exponent-of y))))

(defmethod ge-great ((x ge-expt) (y ge-expt))						(defmethod ge-great ((x ge-expt) (y ge-expt))
  (cond ((ge-great (base-of x) (base-of y))						  (cond ((ge-great (base-of x) (base-of y))
	 t)											 t)
	((ge-equal (base-of x) (base-of y))							((ge-equal (base-of x) (base-of y))
	 (ge-great (exponent-of x) (exponent-of y)))						 (ge-great (exponent-of x) (exponent-of y)))
	(t nil)))										(t nil)))

(defmethod ge-equal ((x ge-application) (y ge-application))				(defmethod ge-equal ((x ge-application) (y ge-application))
  (and (eql (funct-of x) (funct-of y))							  (and (eql (funct-of x) (funct-of y))
       (ge-lequal (args-of x) (args-of y))))						       (ge-lequal (args-of x) (args-of y))))

(defmethod ge-equal ((x ge-function) (y ge-function))					(defmethod ge-equal ((x ge-function) (y ge-function))
  (eql x y))										  (eql x y))

										    >	(defgeneric get-variable-property (domain variable key)
										    >	  (:documentation
										    >	   "There is a property list associated with each variable in a polynomial 
										    >	ring. This property list is ring specific and not global. The ring 
										    >	property list is accessed using the generic function get-variable-property. 
										    >	Properties can modified using setf, as with normal property lists."))
										    >
										    >	(defmethod get-variable-property ((domain domain) (var ge-variable) key)
										    >	  "Returns a property property of variable."
										    >	  (loop for var-prop in (ge-context domain)
										    >		do (when (eql (first var-prop) var)
										    >		     (return (%getf (rest var-prop) key)))
										    >		finally (progn 
										    >			  (push (list var) (ge-context domain))
										    >			  (return nil))))
										    >
										    >	(defgeneric set-variable-property (domain variable key value)
										    >	  (:documentation
										    >	   "There is a property list associated with each variable in a polynomial 
										    >	ring. This property list is ring specific and not global. The ring 
										    >	property list is accessed using the generic function get-variable-property. 
										    >	Properties can modified using setf, as with normal property lists."))
										    >
										    >	(defmethod set-variable-property (domain (var ge-variable) key value)
										    >	  "Set a variable property."
										    >	  (loop for var-prop in (ge-context domain)
										    >		do (when (eql (first var-prop) var)
										    >		     (setf (%getf (rest var-prop) key) value)
										    >		     (return value))	
										    >		finally (progn 
										    >			  (push (list var key value) (ge-context domain))
										    >			  (return value))))
										    >
										    >	(defsetf get-variable-property set-variable-property)
										    >
										    >	;; Variable dependencies and DEPENDS-ON? 
										    >
										    >	(defgeneric declare-dependencies (variable &rest variables)
										    >	  (:documentation
										    >	   "Dependencies of one variable on another can be declared using 
										    >	declare-dependencies."))
										    >
										    >	(defmethod declare-dependencies ((var ge-variable) &rest vars)
										    >	  "This indicates that kernel depends upon each of the variables in vars."
										    >	  (let ((depends (get-variable-property (domain-of var) var :dependencies))
										    >		(domain (domain-of var)))
										    >	    (loop for v in vars
										    >		  do (setq v (coerce v domain))
										    >	          (unless (member v depends :test #'ge-equal)
										    >	            (push v depends)))
										    >	    (setf (get-variable-property (domain-of var) var :dependencies) depends)))
										    >
										    >	(defgeneric depends-on? (expression &rest variables)
										    >	  (:documentation
										    >	   "Return true if the expression depends on any of the variables"))
										    >
										    >	(defmethod depends-on? ((exp list) &rest vars)
										    >	  "This predicate can be applied to any expression, not just to variables. 
										    >	It returns t if the exp depends on all of the variables in vars, otherwise 
										    >	it returns nil. The expression can also be a list, in which case nil is 
										    >	returned only if every element of exp is free of vars."
										    >	  (loop for arg in exp
										    >		do (when (apply #'depends-on? arg vars)
										    >		     (return t))
										    >		finally (return nil)))
										    >
										    >	(defmethod depends-on? ((exp number) &rest vars)
										    >	  (declare (ignore vars))
										    >	  nil)
										    >
										    >	(defmethod depends-on? ((exp numeric) &rest vars)
										    >	  (declare (ignore vars))
										    >	  nil)
										    >
										    >	(defmethod depends-on? ((exp ge-variable) &rest vars)
										    >	  (or (member exp vars :test #'ge-equal)
										    >	      (loop
										    >	       for var in (get-variable-property
										    >	                   (domain-of exp) exp :dependencies)
										    >	       do (when (member var vars :test #'ge-equal)
										    >	            (return t))
										    >	       finally (return nil))))
										    >
										    >	(defmethod depends-on? ((exp ge-function) &rest vars)
										    >	  (loop for var in vars
										    >		do (when (and (typep var 'ge-function)
										    >			      (eql (name-of exp) (name-of var)))
										    >		     (return t))
										    >		finally (return nil)))
										    >
										    >	(defmethod depends-on? ((exp ge-application) &rest vars)
										    >	  (or (apply #'depends-on? (funct-of exp) vars)
										    >	      (apply #'depends-on? (args-of exp) vars)))		     
										    >
										    >	(defmethod depends-on? ((exp ge-plus) &rest vars)
										    >	  (apply #'depends-on? (terms-of exp) vars))
										    >
										    >	(defmethod depends-on? ((exp ge-times) &rest vars)
										    >	  (apply #'depends-on? (terms-of exp) vars))
										    >
										    >	(defmethod depends-on? ((exp ge-expt) &rest vars)
										    >	  (or (apply #'depends-on? (base-of exp) vars)
										    >	      (apply #'depends-on? (exponent-of exp) vars)))
										    >
;; Derivatives										;; Derivatives

(defmethod ge-deriv (exp var)							    |	(defgeneric ge-deriv (expression variable)
  (error "Don't know how to take the derivative of ~S wrt ~S"			    |	  (:documentation
	 exp var))								    |	   "Return the derivate of the expression with respect to variable.")
										    >	  (:method (expression variable)
										    >	    (error "Don't know how to take the derivative of ~S wrt ~S."
										    >	           expression variable)))
										    >
										    >	(defgeneric deriv (expression &rest variables)
										    >	  (:documentation
										    >	   "Derivative of expression with respect to variables."))

(defmethod deriv ((exp number) &rest vars)						(defmethod deriv ((exp number) &rest vars)
  (if (null vars)									  (if (null vars)
      (make-element *general* exp)							      (make-element *general* exp)
      (make-element *general* 0)))							      (make-element *general* 0)))

(defmethod deriv ((exp numeric) &rest vars)						(defmethod deriv ((exp numeric) &rest vars)
  (if (null vars) exp									  (if (null vars) exp
      (make-element (domain-of exp) 0)))						      (make-element (domain-of exp) 0)))

(defmethod deriv ((exp (or symbol general-expression)) &rest vars)		    |	(defmethod deriv ((exp symbol) &rest vars)
										    >	  (setq exp (coerce exp *general*))
										    >	  (loop for v in vars
										    >		do (setq exp (ge-deriv exp (coerce v *general*))))
										    >	  exp)
										    >
										    >	(defmethod deriv ((exp general-expression) &rest vars)
  (setq exp (coerce exp *general*))							  (setq exp (coerce exp *general*))
  (loop for v in vars									  (loop for v in vars
	do (setq exp (ge-deriv exp (coerce v *general*))))					do (setq exp (ge-deriv exp (coerce v *general*))))
  exp)											  exp)

(defmethod deriv ((fun ge-function) &rest args)						(defmethod deriv ((fun ge-function) &rest args)
  (loop for i in args									  (loop for i in args
	with nargs = (nargs-of fun)								with nargs = (nargs-of fun)
	do (when (or (minusp i) (not (< i nargs)))						do (when (or (minusp i) (not (< i nargs)))
	     (error "Illegal derivative of ~S in position ~D" fun i)))				     (error "Illegal derivative of ~S in position ~D" fun i)))
  (cond ((null args)									  (cond ((null args)
	 fun)											 fun)
	((getf fun 'deriv)									((getf fun 'deriv)
	 (apply #'deriv (nth (first args) (getf fun 'deriv))					 (apply #'deriv (nth (first args) (getf fun 'deriv))
		(rest args)))										(rest args)))
	(t (make-function-deriv fun (copy-list args)))))					(t (make-function-deriv fun (copy-list args)))))

(defmethod ge-deriv ((exp general-expression) (var symbol))				(defmethod ge-deriv ((exp general-expression) (var symbol))
										    >	  "Derivative of expression w.r.t symbol which will be coerced
										    >	to the domain where expression lives."
  (ge-deriv exp (coerce var (domain-of exp))))						  (ge-deriv exp (coerce var (domain-of exp))))

(defmethod-sd ge-deriv ((exp numeric) (var ge-atom))					(defmethod-sd ge-deriv ((exp numeric) (var ge-atom))
  (make-element domain 0))								  (make-element domain 0))

(defmethod-sd ge-deriv ((exp ge-atom) (var ge-atom))					(defmethod-sd ge-deriv ((exp ge-atom) (var ge-atom))
  (cond ((ge-equal exp var) (make-element domain 1))					  (cond ((ge-equal exp var) (make-element domain 1))
        #+ignore									        #+ignore
	((depends-on? exp var)									((depends-on? exp var)
	 (make-ge-deriv domain exp `((,var 1))))						 (make-ge-deriv domain exp `((,var 1))))
	(t (make-element domain 0))))								(t (make-element domain 0))))

(defmethod-sd ge-deriv ((exp ge-plus) (var ge-atom))					(defmethod-sd ge-deriv ((exp ge-plus) (var ge-atom))
  (simplify										  (simplify
   (make-ge-plus domain (loop for x in (terms-of exp)					   (make-ge-plus domain (loop for x in (terms-of exp)
			      collect (ge-deriv x var)))))							      collect (ge-deriv x var)))))

(defmethod-sd ge-deriv ((exp ge-times) (var ge-atom))					(defmethod-sd ge-deriv ((exp ge-times) (var ge-atom))
  (let ((terms (terms-of exp)))								  (let ((terms (terms-of exp)))
    (simplify										    (simplify
     (make-ge-plus domain							    |	     (make-ge-plus
										    >	      domain
       (loop for x in terms								      (loop for x in terms
	     collect									            collect
	     (simplify									            (simplify
	       (make-ge-times domain							             (make-ge-times domain
		 (cons (ge-deriv x var) (remove x terms)))))))))			                            (cons (ge-deriv x var) (remove x terms)))))))))

(defmethod-sd ge-deriv ((exp ge-expt) (var ge-atom))					(defmethod-sd ge-deriv ((exp ge-expt) (var ge-atom))
  (let ((base (base-of exp))								  (let ((base (base-of exp))
	(power (exponent-of exp)))								(power (exponent-of exp)))
    (cond ((depends-on? power var)						    |	      (+ (* (log base) (expt base power) (ge-deriv power var))
	   (error "Not yet implemented"))					    |	      (* power (expt base (- power 1)) (ge-deriv base var)))))
	  ((and (number? power) (= power 2))					    <
	   (* 2 base (ge-deriv base var)))					    <
	  (t (* power (expt base (- power 1)))))))				    <

(defmethod-sd ge-deriv ((exp ge-application) (var ge-atom))				(defmethod-sd ge-deriv ((exp ge-application) (var ge-atom))
  (let* ((args (args-of exp))								  (let* ((args (args-of exp))
         (fun (funct-of exp))								         (fun (funct-of exp))
         (dargs (loop for arg in args							         (dargs (loop for arg in args
                     collect (ge-deriv arg var)))					                      collect (ge-deriv arg var)))
         (derivs (getf fun 'deriv))							         (derivs (getf fun 'deriv))
         ans)										         ans)
    (when (null derivs)									    (when (null derivs)
      (setq derivs (loop for i below (nargs-of fun)					      (setq derivs (loop for i below (nargs-of fun)
                         collect (make-function-deriv fun i)))				                         collect (make-function-deriv fun i)))
      (setf (getf fun 'deriv) derivs))							      (setf (getf fun 'deriv) derivs))
    (loop for darg in dargs								    (loop for darg in dargs
          for deriv in derivs								          for deriv in derivs
          do  (unless (0? darg)								          do  (unless (0? darg)
               (push (if (1? darg)							                (push (if (1? darg)
                       (apply deriv args)						                          (apply deriv args)
                       (* darg (apply deriv args)))					                          (* darg (apply deriv args)))
                     ans)))								                      ans)))
    (cond ((null ans)									    (cond ((null ans)
	   (zero domain))									   (zero domain))
	  ((rest ans) (make-ge-plus domain ans))						  ((rest ans) (make-ge-plus domain ans))
	  (t (first ans)))))									  (t (first ans)))))

										    >	(defgeneric make-ge-eqn= (domain lhs rhs)
										    >	  (:documentation
										    >	   "Create an equation of the form lhs = rhs in domain."))
										    >
(defmethod make-ge-eqn= ((domain general-expressions) lhs rhs)				(defmethod make-ge-eqn= ((domain general-expressions) lhs rhs)
  (make-instance 'ge-eqn= :domain domain :rhs rhs :lhs lhs))				  (make-instance 'ge-eqn= :domain domain :rhs rhs :lhs lhs))

(defmethod print-object ((eqn ge-eqn=) stream)						(defmethod print-object ((eqn ge-eqn=) stream)
  (print-object (lhs-of eqn) stream)							  (print-object (lhs-of eqn) stream)
  (princ " = " stream)									  (princ " = " stream)
  (print-object (rhs-of eqn) stream))							  (print-object (rhs-of eqn) stream))

										    >	(defgeneric eqn= (lhs rhs)
										    >	  (:documentation
										    >	   "The purpose of this method is unknown."))
										    >
(defmethod eqn= (lhs rhs)								(defmethod eqn= (lhs rhs)
										    >	  "Create an equation of the form lhs = rhs in domain *general*"
  (make-ge-eqn= *general*								  (make-ge-eqn= *general*
		(simplify (coerce lhs *general*))							(simplify (coerce lhs *general*))
		(simplify (coerce rhs *general*))))							(simplify (coerce rhs *general*))))

(defmethod simplify ((eqn ge-eqn=))							(defmethod simplify ((eqn ge-eqn=))
  (make-ge-eqn= (domain-of eqn)								  (make-ge-eqn= (domain-of eqn)
		(simplify (lhs-of eqn))									(simplify (lhs-of eqn))
		(simplify (rhs-of eqn))))								(simplify (rhs-of eqn))))

(defmethod-sd ge-deriv ((eqn ge-eqn=) (var ge-atom))					(defmethod-sd ge-deriv ((eqn ge-eqn=) (var ge-atom))
  (make-ge-eqn= domain									  (make-ge-eqn= domain
		(ge-deriv (lhs-of eqn) var)								(ge-deriv (lhs-of eqn) var)
		(ge-deriv (rhs-of eqn) var)))								(ge-deriv (rhs-of eqn) var)))

										    >	(defgeneric make-ge-eqn> (domain lhs rhs)
										    >	  (:documentation
										    >	   "Create an inequality of the form lhs > rhs in domain"))
										    >
(defmethod make-ge-eqn> ((domain general-expressions) lhs rhs)				(defmethod make-ge-eqn> ((domain general-expressions) lhs rhs)
  (make-instance 'ge-eqn> :domain domain :rhs rhs :lhs lhs))				  (make-instance 'ge-eqn> :domain domain :rhs rhs :lhs lhs))

(defmethod print-object ((eqn ge-eqn>) stream)						(defmethod print-object ((eqn ge-eqn>) stream)
  (print-object (lhs-of eqn) stream)							  (print-object (lhs-of eqn) stream)
  (princ " > " stream)									  (princ " > " stream)
  (print-object (rhs-of eqn) stream))							  (print-object (rhs-of eqn) stream))

										    >	(defgeneric eqn> (lhs rhs)
										    >	  (:documentation
										    >	   "Create an inequality of the form lhs > rhs in domain *general*"))
										    >
(defmethod eqn> (lhs rhs)								(defmethod eqn> (lhs rhs)
  (make-ge-eqn> *general*								  (make-ge-eqn> *general*
		(simplify (coerce lhs *general*))							(simplify (coerce lhs *general*))
		(simplify (coerce rhs *general*))))							(simplify (coerce rhs *general*))))

(defmethod simplify ((eqn ge-eqn>))							(defmethod simplify ((eqn ge-eqn>))
  (make-ge-eqn> (domain-of eqn)								  (make-ge-eqn> (domain-of eqn)
		(simplify (lhs-of eqn))									(simplify (lhs-of eqn))
		(simplify (rhs-of eqn))))								(simplify (rhs-of eqn))))

(defmethod-sd ge-deriv ((eqn ge-eqn>) (var ge-atom))					(defmethod-sd ge-deriv ((eqn ge-eqn>) (var ge-atom))
  (make-ge-eqn> domain									  (make-ge-eqn> domain
		(ge-deriv (lhs-of eqn) var)								(ge-deriv (lhs-of eqn) var)
		(ge-deriv (rhs-of eqn) var)))								(ge-deriv (rhs-of eqn) var)))

										    >	(defgeneric make-ge-eqn>= (domain lhs rhs)
										    >	  (:documentation
										    >	   "Create an inequality of the form lhs >= rhs in domain"))
										    >
(defmethod make-ge-eqn>= ((domain general-expressions) lhs rhs)				(defmethod make-ge-eqn>= ((domain general-expressions) lhs rhs)
  (make-instance 'ge-eqn>= :domain domain :rhs rhs :lhs lhs))				  (make-instance 'ge-eqn>= :domain domain :rhs rhs :lhs lhs))

(defmethod print-object ((eqn ge-eqn>=) stream)						(defmethod print-object ((eqn ge-eqn>=) stream)
  (print-object (lhs-of eqn) stream)							  (print-object (lhs-of eqn) stream)
  (princ " >= " stream)									  (princ " >= " stream)
  (print-object (rhs-of eqn) stream))							  (print-object (rhs-of eqn) stream))

										    >	(defgeneric eqn>= (lhs rhs)
										    >	  (:documentation
										    >	   "Create an inequality of the form lhs >= rhs in domain *general*"))
										    >
(defmethod eqn>= (lhs rhs)								(defmethod eqn>= (lhs rhs)
  (make-ge-eqn>= *general*								  (make-ge-eqn>= *general*
		 (simplify (coerce lhs *general*))							 (simplify (coerce lhs *general*))
		 (simplify (coerce rhs *general*))))							 (simplify (coerce rhs *general*))))

(defmethod simplify ((eqn ge-eqn>=))							(defmethod simplify ((eqn ge-eqn>=))
  (make-ge-eqn>= (domain-of eqn)							  (make-ge-eqn>= (domain-of eqn)
		 (simplify (lhs-of eqn))								 (simplify (lhs-of eqn))
		 (simplify (rhs-of eqn))))								 (simplify (rhs-of eqn))))

(defmethod-sd ge-deriv ((eqn ge-eqn>=) (var ge-atom))					(defmethod-sd ge-deriv ((eqn ge-eqn>=) (var ge-atom))
  (make-ge-eqn>= domain									  (make-ge-eqn>= domain
		 (ge-deriv (lhs-of eqn) var)								 (ge-deriv (lhs-of eqn) var)
		 (ge-deriv (rhs-of eqn) var)))								 (ge-deriv (rhs-of eqn) var)))

;; Scalar versus scalar is covered by numbers.lisp				    |	;;; Scalar versus scalar is covered by numbers.lisp
;; These are just supposed to be the other cases.  				    |	;;; These are just supposed to be the other cases.  
										    |	;;; FIXME : Expand this macro.
(defmacro define-ge2-standard-methods (op)						(defmacro define-ge2-standard-methods (op)
  `(progn										  `(progn
     (defmethod ,op ((x (or number symbol)) (y symbol))				    |	    (defmethod ,op ((x number) (y symbol))
										    >	      (,op (coerce x *general*) (coerce y *general*)))
										    >	    (defmethod ,op ((x symbol) (y symbol))
       (,op (coerce x *general*) (coerce y *general*)))					      (,op (coerce x *general*) (coerce y *general*)))
											    (defmethod ,op ((x symbol) (y number))
     (defmethod ,op ((x symbol) (y number))						      (,op (coerce x *general*) (coerce y *general*)))
       (,op (coerce x *general*) (coerce y *general*)))					    (defmethod ,op ((x general-expression) (y symbol))
											      (,op x (coerce y (domain-of x))))
     (defmethod ,op ((x general-expression) (y symbol))					    (defmethod ,op ((x symbol) (y general-expression))
       (,op x (coerce y (domain-of x))))						      (,op (coerce x (domain-of y)) y))))

     (defmethod ,op ((x symbol) (y general-expression))				    (
       (,op (coerce x (domain-of y)) y))))					    (
										    (
;; When a numeric from a different domain is added to a general			    |	;;; When a numeric from a different domain is added to a general
;; expression, the code in morphisms.lisp will coerce the numeric to		    |	;;; expression, the code in morphisms.lisp will coerce the numeric to
;; the *general* (a non-strict-domain) and then come back here.			    |	;;; the *general* (a non-strict-domain) and then come back here.

(define-ge2-standard-methods plus)							(define-ge2-standard-methods plus)

(defmethod-sd plus ((x ge-or-numeric) (y ge-or-numeric))				(defmethod-sd plus ((x ge-or-numeric) (y ge-or-numeric))
  (simplify (make-ge-plus domain (list x y))))						  (simplify (make-ge-plus domain (list x y))))

(defmethod-sd plus ((eq1 ge-eqn=) (eq2 ge-eqn=))					(defmethod-sd plus ((eq1 ge-eqn=) (eq2 ge-eqn=))
  (make-ge-eqn= domain									  (make-ge-eqn= domain
		(+ (lhs-of eq1) (lhs-of eq2))								(+ (lhs-of eq1) (lhs-of eq2))
		(+ (rhs-of eq1) (rhs-of eq2))))								(+ (rhs-of eq1) (rhs-of eq2))))

(defmethod-sd plus ((eq1 ge-eqn=) (exp ge-or-numeric))					(defmethod-sd plus ((eq1 ge-eqn=) (exp ge-or-numeric))
  (make-ge-eqn= domain (+ (lhs-of eq1) exp) (+ (rhs-of eq1) exp)))			  (make-ge-eqn= domain (+ (lhs-of eq1) exp) (+ (rhs-of eq1) exp)))

(defmethod-sd plus ((exp ge-or-numeric) (eq1 ge-eqn=))					(defmethod-sd plus ((exp ge-or-numeric) (eq1 ge-eqn=))
  (make-ge-eqn= domain (+ (lhs-of eq1) exp) (+ (rhs-of eq1) exp)))			  (make-ge-eqn= domain (+ (lhs-of eq1) exp) (+ (rhs-of eq1) exp)))

											(define-ge2-standard-methods difference)
(define-ge2-standard-methods difference)
											(defmethod-sd difference ((x ge-or-numeric) (y ge-or-numeric))
(defmethod-sd difference ((x ge-or-numeric) (y ge-or-numeric))			    (
  (simplify (make-ge-plus domain						    |	  (simplify (make-ge-plus
	      (list x (make-ge-times domain					    |	             domain
										    >	             (list x (make-ge-times
										    >	                      domain
				     (list (make-element domain -1) y))))))		                      (list (make-element domain -1) y))))))

(defmethod-sd difference ((eq1 ge-eqn=) (eq2 ge-eqn=))					(defmethod-sd difference ((eq1 ge-eqn=) (eq2 ge-eqn=))
  (make-ge-eqn= domain									  (make-ge-eqn= domain
		(- (lhs-of eq1) (lhs-of eq2))								(- (lhs-of eq1) (lhs-of eq2))
		(- (rhs-of eq1) (rhs-of eq2))))								(- (rhs-of eq1) (rhs-of eq2))))

(defmethod-sd difference ((eq1 ge-eqn=) (exp ge-or-numeric))				(defmethod-sd difference ((eq1 ge-eqn=) (exp ge-or-numeric))
  (make-ge-eqn= domain (- (lhs-of eq1) exp) (- (rhs-of eq1) exp)))			  (make-ge-eqn= domain (- (lhs-of eq1) exp) (- (rhs-of eq1) exp)))

(defmethod-sd difference ((exp ge-or-numeric) (eq1 ge-eqn=))				(defmethod-sd difference ((exp ge-or-numeric) (eq1 ge-eqn=))
  (make-ge-eqn= domain (- exp (lhs-of eq1)) (- exp (rhs-of eq1))))			  (make-ge-eqn= domain (- exp (lhs-of eq1)) (- exp (rhs-of eq1))))

											(defmethod minus ((x symbol))
(defmethod minus ((x symbol))								  (- (coerce x *general*)))
  (- (coerce x *general*)))
											(defmethod minus ((x general-expression))
(defmethod minus ((x general-expression))						  (let ((domain (domain-of x)))
  (let ((domain (domain-of x)))								    (simplify
    (simplify										     (make-ge-times domain (list (make-element domain -1) x)))))
     (make-ge-times domain (list (make-element domain -1) x)))))
											(defmethod minus ((eq1 ge-eqn=))
(defmethod minus ((eq1 ge-eqn=))							  (make-ge-eqn= (domain-of eq1) (- (lhs-of eq1)) (- (rhs-of eq1))))
  (make-ge-eqn= (domain-of eq1) (- (lhs-of eq1)) (- (rhs-of eq1))))
							  				(define-ge2-standard-methods times)

(define-ge2-standard-methods times)							(defmethod-sd times ((x ge-or-numeric) (y ge-or-numeric))
											  (simplify (make-ge-times domain (list x y))))
(defmethod-sd times ((x ge-or-numeric) (y ge-or-numeric))
  (simplify (make-ge-times domain (list x y))))						(defmethod-sd times ((eq1 ge-eqn=) (eq2 ge-eqn=))
											  (error "Can't multiply two equations"))
(defmethod-sd times ((eq1 ge-eqn=) (eq2 ge-eqn=))
  (error "Can't multiply two equations"))						(defmethod-sd times ((eq1 ge-eqn=) (exp ge-or-numeric))
											  (make-ge-eqn= domain (* (lhs-of eq1) exp) (* (rhs-of eq1) exp)))
(defmethod-sd times ((eq1 ge-eqn=) (exp ge-or-numeric))
  (make-ge-eqn= domain (* (lhs-of eq1) exp) (* (rhs-of eq1) exp)))			(defmethod-sd times ((exp ge-or-numeric) (eq1 ge-eqn=))
											  (make-ge-eqn= domain (* (lhs-of eq1) exp) (* (rhs-of eq1) exp)))
(defmethod-sd times ((exp ge-or-numeric) (eq1 ge-eqn=))
  (make-ge-eqn= domain (* (lhs-of eq1) exp) (* (rhs-of eq1) exp)))			(define-ge2-standard-methods quotient)

											(defmethod-sd quotient ((x ge-or-numeric) (y ge-or-numeric))
(define-ge2-standard-methods quotient)						    (
										    (
(defmethod-sd quotient ((x ge-or-numeric) (y ge-or-numeric))			    (
  (simplify (make-ge-times domain						    |	  (simplify (make-ge-times
										    >	             domain
	      (list x (make-ge-expt domain y (make-element domain -1))))))		             (list x (make-ge-expt domain y (make-element domain -1))))))

(defmethod-sd quotient ((eq1 ge-eqn=) (eq2 ge-eqn=))					(defmethod-sd quotient ((eq1 ge-eqn=) (eq2 ge-eqn=))
  (error "Can't divide two equations"))							  (error "Can't divide two equations"))

(defmethod-sd quotient ((eq1 ge-eqn=) (exp ge-or-numeric))				(defmethod-sd quotient ((eq1 ge-eqn=) (exp ge-or-numeric))
  (make-ge-eqn= domain (/ (lhs-of eq1) exp) (/ (rhs-of eq1) exp)))			  (make-ge-eqn= domain (/ (lhs-of eq1) exp) (/ (rhs-of eq1) exp)))

(defmethod-sd quotient ((exp domain-element) (eq1 ge-eqn=))				(defmethod-sd quotient ((exp domain-element) (eq1 ge-eqn=))
  (error "Can't divide by an equation"))						  (error "Can't divide by an equation"))

											(defmethod recip ((x symbol))
(defmethod recip ((x symbol))								  (recip (coerce x *general*)))
  (recip (coerce x *general*)))
											(defmethod recip ((x general-expression))
(defmethod recip ((x general-expression))						  (let ((domain (domain-of x)))
  (let ((domain (domain-of x)))								    (simplify (make-ge-expt domain x (make-element domain -1)))))
    (simplify (make-ge-expt domain x (make-element domain -1)))))
											(defmethod recip ((eq1 ge-eqn=))
(defmethod recip ((eq1 ge-eqn=))							  (make-ge-eqn= (domain-of eq1) (/ (lhs-of eq1)) (/ (rhs-of eq1))))
  (make-ge-eqn= (domain-of eq1) (/ (lhs-of eq1)) (/ (rhs-of eq1))))
											(define-ge2-standard-methods expt)

(define-ge2-standard-methods expt)							(defmethod-sd expt ((x general-expression) (y ge-or-numeric))
											  (simplify (make-ge-expt domain x y)))
(defmethod-sd expt ((x general-expression) (y ge-or-numeric))				  
  (simplify (make-ge-expt domain x y)))						    (
										    (
										    >	;;+kfp (since (expt 2 p) --> error, no method so far) 
										    >	(defmethod-sd expt ((x ge-or-numeric) (y general-expression))
										    >	  (simplify (make-ge-expt domain x y)))
										    >
(defmethod-sd expt ((eq1 ge-eqn=) (eq2 ge-eqn=))					(defmethod-sd expt ((eq1 ge-eqn=) (eq2 ge-eqn=))
  (error "Can't exponentiate two equations"))						  (error "Can't exponentiate two equations"))

(defmethod-sd expt ((eq1 ge-eqn=) (exp ge-or-numeric))					(defmethod-sd expt ((eq1 ge-eqn=) (exp ge-or-numeric))
  (make-ge-eqn= domain (expt (lhs-of eq1) exp) (expt (rhs-of eq1) exp)))		  (make-ge-eqn= domain (expt (lhs-of eq1) exp) (expt (rhs-of eq1) exp)))

(defmethod-sd expt ((exp ge-or-numeric) (eq1 ge-eqn=))					(defmethod-sd expt ((exp ge-or-numeric) (eq1 ge-eqn=))
  (error "Can't put an equation in an exponent"))					  (error "Can't put an equation in an exponent"))

										    >	(defgeneric make-union (variable set expression &rest expressions)
										    >	  (:documentation
										    >	   "The purpose of this method is unknown."))
										    >
(defmethod make-union ((var symbol) (set set) (expr general-expression)			(defmethod make-union ((var symbol) (set set) (expr general-expression)
		       &rest rest-exprs)								       &rest rest-exprs)
  (apply #'make-union (coerce var (domain-of expr)) set expr rest-exprs))		  (apply #'make-union (coerce var (domain-of expr)) set expr rest-exprs))

(defun make-universal-quantified-set (domain bound-vars expressions)			(defun make-universal-quantified-set (domain bound-vars expressions)
  (make-instance 'universal-quantified-set						  (make-instance 'universal-quantified-set
		 :domain domain										 :domain domain
		 :bound-vars bound-vars									 :bound-vars bound-vars
		 :expressions expressions								 :expressions expressions
		 :print-function 'uq-set-print-object))							 :print-function 'uq-set-print-object))

(defun uq-set-print-object (set stream)							(defun uq-set-print-object (set stream)
  (let ((bound-vars (bound-vars-of set)))						  (let ((bound-vars (bound-vars-of set)))
    (format stream "{ForAll ~S in ~S~:{, ~S in ~S~} . ~S~{, ~S~}}" 			    (format stream "{ForAll ~S in ~S~:{, ~S in ~S~} . ~S~{, ~S~}}" 
	    (first (first bound-vars)) (second (first bound-vars))				    (first (first bound-vars)) (second (first bound-vars))
	    (rest bound-vars)									    (rest bound-vars)
	    (first (exprs-of set)) (rest (exprs-of set)))))					    (first (exprs-of set)) (rest (exprs-of set)))))

;; This used to be just variables, but it makes more sense for one to be		;; This used to be just variables, but it makes more sense for one to be
;; able to use quantifiers over any atomic object.					;; able to use quantifiers over any atomic object.
(defmethod make-union (var set (expr general-expression)				(defmethod make-union (var set (expr general-expression)
		       &rest rest-exprs)								       &rest rest-exprs)
  (let ((domain (domain-of expr)))							  (let ((domain (domain-of expr)))
    ;;; Make sure that the union is sensible.						    ;;; Make sure that the union is sensible.
    (dolist (x rest-exprs)								    (dolist (x rest-exprs)
      (if (not (eq domain (domain-of x)))						      (if (not (eq domain (domain-of x)))
	  (error "Can't union incompatible domains.")))						  (error "Can't union incompatible domains.")))
    (simplify										    (simplify
      (make-universal-quantified-set domain (list (list var set))			     (make-universal-quantified-set domain (list (list var set))
				     (cons expr rest-exprs)))))				                                    (cons expr rest-exprs)))))

;; The following function examines each element of EXPRS to see if			;; The following function examines each element of EXPRS to see if
;; they contain any bound variables.  If so, its bound variables are			;; they contain any bound variables.  If so, its bound variables are
;; merged with BOUND-VARS.  Two values are returned the list of bound			;; merged with BOUND-VARS.  Two values are returned the list of bound
;; variables and expressions.  The variable TYPE indicates the type of			;; variables and expressions.  The variable TYPE indicates the type of
;; quantification.									;; quantification.
(defun merge-bound-vars (type bound-vars exprs)						(defun merge-bound-vars (type bound-vars exprs)
  (let ((new-exprs nil))								  (let ((new-exprs nil))
    (flet ((merge-new-bv (var set)							    (flet ((merge-new-bv (var set)
	     (loop for (v) in bound-vars							     (loop for (v) in bound-vars
		   do (when (ge-equal var v)								   do (when (ge-equal var v)
			(error "Don't know how deal with scoping"))						(error "Don't know how deal with scoping"))
		   finally (push (list var set) bound-vars))))						   finally (push (list var set) bound-vars))))
      (loop for expr in exprs								      (loop for expr in exprs
	    do (setq expr (simplify expr))							    do (setq expr (simplify expr))
	       (cond ((not (typep expr type))						            (cond ((not (typep expr type))
		      (push expr new-exprs))						                   (push expr new-exprs))
		     (t (loop for (var set) in (bound-vars-of expr)			                  (t (loop for (var set) in (bound-vars-of expr)
			      do (merge-new-bv var set))				                           do (merge-new-bv var set))
			(setq new-exprs (append new-exprs (exprs-of expr))))))		                     (setq new-exprs (append new-exprs (exprs-of expr))))))
      (values bound-vars new-exprs))))       						      (values bound-vars new-exprs))))       
  											  
(defmethod simplify ((set universal-quantified-set))					(defmethod simplify ((set universal-quantified-set))
  (multiple-value-bind (bv exprs) (merge-bound-vars 'universal-quantified-set	    |	  (multiple-value-bind (bv exprs)
										    >	      (merge-bound-vars 'universal-quantified-set
						    (bound-vars-of set)			                        (bound-vars-of set)
						    (exprs-of set))			                        (exprs-of set))

    (make-universal-quantified-set (domain-of set) bv exprs)))				    (make-universal-quantified-set (domain-of set) bv exprs)))

;; Variable dependencies and DEPENDS-ON? 					    <
										    <
(defmethod declare-dependencies ((var ge-variable) &rest vars)			    <
  (let ((depends (get-variable-property (domain-of var) var :dependencies))	    <
	(domain (domain-of var)))						    <
    (loop for v in vars								    <
	  do (setq v (coerce v domain))						    <
	     (unless (member v depends :test #'ge-equal)			    <
	       (push v depends)))						    <
    (setf (get-variable-property (domain-of var) var :dependencies) depends)))	    <
										    <
;; The following method allows one to check if any of several			    <
;; expressions depend on a variable easily.					    <
(defmethod depends-on? ((exp list) &rest vars)					    <
  (loop for arg in exp								    <
	do (when (apply #'depends-on? arg vars)					    <
	     (return t))							    <
	finally (return nil)))							    <
										    <
(defmethod depends-on? ((exp (or number numeric)) &rest vars)			    <
  (declare (ignore vars))							    <
  nil)										    <
										    <
(defmethod depends-on? ((exp ge-variable) &rest vars)				    <
  (or (member exp vars :test #'ge-equal)					    <
      (loop for var in (get-variable-property (domain-of exp)			    <
			   exp :dependencies)					    <
	    do (when (member var vars :test #'ge-equal)				    <
		 (return t))							    <
	    finally (return nil))))						    <
										    <
(defmethod depends-on? ((exp ge-function) &rest vars)				    <
  (loop for var in vars								    <
	do (when (and (typep var 'ge-function)					    <
		      (eql (name-of exp) (name-of var)))			    <
	     (return t))							    <
	finally (return nil)))							    <
										    <
(defmethod depends-on? ((exp ge-application) &rest vars)			    <
  (or (apply #'depends-on? (funct-of exp) vars)					    <
      (apply #'depends-on? (args-of exp) vars)))		     		    <
										    <
(defmethod depends-on? ((exp ge-plus) &rest vars)				    <
  (depends-on? (terms-of exp) vars))						    <
										    <
(defmethod depends-on? ((exp ge-times) &rest vars)				    <
  (depends-on? (terms-of exp) vars))						    <
										    <
(defmethod depends-on? ((exp ge-expt) &rest vars)				    <
  (or (apply #'depends-on? (base-of exp) vars)					    <
      (apply #'depends-on? (exponent-of exp) vars)))				    <
										    <
;; Different kernels									;; Different kernels

(defmethod different-kernels ((exp numeric) (kernels list))			    |	(defgeneric different-kernels (expression kernels)
  kernels)									    |	  (:documentation
										    >	   "Returns a list of the kernels in exp that are different from those in 
										    >	   ``list-of-kernels``.")
										    >	  (:method ((expression numeric) (kernels list))
										    >	    (declare (ignore expression))
										    >	    kernels))

;; If we don't know anything about the object, then its a kernel.			;; If we don't know anything about the object, then its a kernel.
(defmethod different-kernels (exp (kernels list))					(defmethod different-kernels (exp (kernels list))
  (if  (member exp kernels :test #'ge-equal)						  (if (member exp kernels :test #'ge-equal)
       kernels										      kernels
       (cons exp kernels)))								      (cons exp kernels)))

(defmethod different-kernels ((exp ge-plus) (kernels list))				(defmethod different-kernels ((exp ge-plus) (kernels list))
  (loop for term in (terms-of exp)							  (loop for term in (terms-of exp)
	do (setq kernels (different-kernels term kernels)))					do (setq kernels (different-kernels term kernels)))
  kernels)										  kernels)

(defmethod different-kernels ((exp ge-times) (kernels list))				(defmethod different-kernels ((exp ge-times) (kernels list))
  (loop for term in (terms-of exp)							  (loop for term in (terms-of exp)
	do (setq kernels (different-kernels term kernels)))					do (setq kernels (different-kernels term kernels)))
  kernels)										  kernels)

(defmethod different-kernels ((exp ge-expt) (kernels list))				(defmethod different-kernels ((exp ge-expt) (kernels list))
  (if (or (cl:integerp (exponent-of exp))						  (if (or (cl:integerp (exponent-of exp))
	  (typep (exponent-of exp) 'rational-integer))						  (typep (exponent-of exp) 'rational-integer))
      (different-kernels (base-of exp) kernels)						      (different-kernels (base-of exp) kernels)
      (call-next-method)))								      (call-next-method)))

(defmethod different-kernels ((exp ge-equation) (kernels list))				(defmethod different-kernels ((exp ge-equation) (kernels list))
  (different-kernels (lhs-of exp)							  (different-kernels (lhs-of exp)
		     (different-kernels (rhs-of exp) kernels)))						     (different-kernels (rhs-of exp) kernels)))

(defmethod different-kernels ((exp list) (kernels list))				(defmethod different-kernels ((exp list) (kernels list))
  (loop for e in exp									  (loop for e in exp
	do (setq kernels (different-kernels e kernels)))					do (setq kernels (different-kernels e kernels)))
  kernels)										  kernels)

											(defmethod substitute (value var expr &rest ignore)
(defmethod substitute (value var expr &rest ignore)				    (
										    >	  "Substitutes value for each occurrence of var in polynomial . If value 
										    >	is a list, it is interpreted as a set of values to be substituted in 
										    >	parallel for the variables in var. The values being substituted must 
										    >	be either elements of the domain of polynomial or its coefficient domain."
  (declare (ignore value var ignore))							  (declare (ignore value var ignore))
  expr)											  expr)

(defmethod substitute (value (var symbol) expr &rest ignore)				(defmethod substitute (value (var symbol) expr &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (substitute value (coerce var (domain-of expr)) expr))				  (substitute value (coerce var (domain-of expr)) expr))

(defmethod substitute (value (var ge-variable) (expr (or number numeric))	    |	(defmethod substitute (value (var ge-variable) (expr number)
										    >	                       &rest ignore)
										    >	  (declare (ignore value ignore))
										    >	  expr)
										    >
										    >	(defmethod substitute (value (var ge-variable) (expr numeric)
     &rest ignore)									                       &rest ignore)
  (declare (ignore value ignore))							  (declare (ignore value ignore))
  expr)											  expr)

(defmethod substitute (value (var ge-variable) (expr ge-variable) &rest ignore)		(defmethod substitute (value (var ge-variable) (expr ge-variable) &rest ignore)
  (declare (ignore ignore)) 								  (declare (ignore ignore)) 
  (if (eql var expr) (coerce value (domain-of expr)) expr))				  (if (eql var expr) (coerce value (domain-of expr)) expr))

(defmethod substitute									(defmethod substitute
    (value (var ge-function) (expr ge-function) &rest ignore)				    (value (var ge-function) (expr ge-function) &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (if (eql var expr) value expr))							  (if (eql var expr) value expr))

(defmethod substitute (value var (expr ge-plus) &rest ignore)				(defmethod substitute (value var (expr ge-plus) &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (apply #'%plus (mapcar #'(lambda (q) (substitute value var q))			  (apply #'%plus (mapcar #'(lambda (q) (substitute value var q))
			 (terms-of expr))))									 (terms-of expr))))

(defmethod substitute (value var (expr ge-times) &rest ignore)				(defmethod substitute (value var (expr ge-times) &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (apply #'%times (mapcar #'(lambda (q) (substitute value var q))			  (apply #'%times (mapcar #'(lambda (q) (substitute value var q))
			 (terms-of expr))))						                          (terms-of expr))))

(defmethod substitute (value var (expr ge-expt) &rest ignore)				(defmethod substitute (value var (expr ge-expt) &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (expt (substitute value var (base-of expr))						  (expt (substitute value var (base-of expr))
	(substitute value var (exponent-of expr))))						(substitute value var (exponent-of expr))))

(defmethod substitute (value (var ge-variable) (expr ge-application)			(defmethod substitute (value (var ge-variable) (expr ge-application)
			     &rest ignore)						                       &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (apply (funct-of expr)								  (apply (funct-of expr)
	  (mapcar #'(lambda (q) (substitute value var q))				         (mapcar #'(lambda (q) (substitute value var q))
		  (args-of expr))))							                 (args-of expr))))

;; FIXTHIS Bummed to make finite element work......					;; FIXTHIS Bummed to make finite element work......
(defvar *fem-kludge* nil)								(defvar *fem-kludge* nil)

(defmethod substitute (value (var ge-function) (expr ge-application)			(defmethod substitute (value (var ge-function) (expr ge-application)
			     &rest ignore)						                       &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (let ((name (name-of var))								  (let ((name (name-of var))
	(funct (funct-of expr)))								(funct (funct-of expr)))
    (if *fem-kludge*									    (if *fem-kludge*
	(cond ((string= name (name-of funct))							(cond ((string= name (name-of funct))
	       (if (typep funct 'ge-function-deriv)						       (if (typep funct 'ge-function-deriv)
		   (apply #'deriv value (derivs-of funct))						   (apply #'deriv value (derivs-of funct))
		   value))										   value))
	      (t (funct-of expr)))								      (t (funct-of expr)))
	(apply (cond ((string= name (name-of funct))						(apply (cond ((string= name (name-of funct))
		      (if (typep funct 'ge-function-deriv)						      (if (typep funct 'ge-function-deriv)
			  (apply #'deriv value (derivs-of funct))						  (apply #'deriv value (derivs-of funct))
			  value))										  value))
		     (t (funct-of expr)))								     (t (funct-of expr)))
	       (mapcar #'(lambda (q) (substitute value var q))					       (mapcar #'(lambda (q) (substitute value var q))
		       (args-of expr))))))								       (args-of expr))))))

(defmethod substitute (value var (expr ge-equation) &rest ignore)			(defmethod substitute (value var (expr ge-equation) &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (make-instance (class-of expr)							  (make-instance (class-of expr)
		 :domain (domain-of expr)								 :domain (domain-of expr)
		 :lhs (substitute value var (lhs-of expr))						 :lhs (substitute value var (lhs-of expr))
		 :rhs (substitute value var (rhs-of expr))))						 :rhs (substitute value var (rhs-of expr))))

										    |	(defgeneric expand (expression)
(defmethod expand ((exp t))							    |	  (:documentation
  exp)										    |	   "Replaces all products of sums in exp by sums of products.")
										    |	  (:method ((expression t)) expression))
(defmethod expand ((exp ge-times))						    <
  (let ((forms (expand-product exp)))						    <
    (if (null (rest forms))							    <
	(first forms)								    <
	(simp-plus-terms (domain-of exp) forms))))				    <
										    <
(defun expand-product (exp)							    <
  (loop for list in (expand-product1 (terms-of exp))				    <
	collect (simp-times-terms (domain-of exp) list)))			    <

(defun expand-product1 (terms)								(defun expand-product1 (terms)
  (flet ((expand-plus (term rest)							  (flet ((expand-plus (term rest)
	   (loop with expanded-terms = (expand-product1 rest)					   (loop with expanded-terms = (expand-product1 rest)
		 for x in (terms-of term)								 for x in (terms-of term)
		 append (loop for et in expanded-terms							 append (loop for et in expanded-terms
			      collect (cons x et))))								      collect (cons x et))))
	 (expand-other (term rest)								 (expand-other (term rest)
	   (loop for et in (expand-product1 rest)						   (loop for et in (expand-product1 rest)
		 collect (cons term et))))								 collect (cons term et))))
    (cond ((null terms)									    (cond ((null terms)
	   (list ()))										   (list ()))
	  ((ge-plus? (first terms))								  ((ge-plus? (first terms))
	   (expand-plus (first terms) (rest terms)))						   (expand-plus (first terms) (rest terms)))
	  ((ge-expt? (first terms))								  ((ge-expt? (first terms))
	   (let ((temp (expand (first terms))))							   (let ((temp (expand (first terms))))
		(cond ((ge-plus? temp)									(cond ((ge-plus? temp)
		       (expand-plus temp (rest terms)))							       (expand-plus temp (rest terms)))
		      (t (expand-other temp (rest terms))))))						      (t (expand-other temp (rest terms))))))
	  (t (expand-other (first terms) (rest terms))))))					  (t (expand-other (first terms) (rest terms))))))
	       
										    >	(defun expand-product (exp)
										    >	  (loop for list in (expand-product1 (terms-of exp))
										    >		collect (simp-times-terms (domain-of exp) list)))
										    >
										    >	(defmethod expand ((exp ge-times))
										    >	  (let ((forms (expand-product exp)))
										    >	    (if (null (rest forms))
										    >		(first forms)
										    >		(simp-plus-terms (domain-of exp) forms))))
										    >
(defmethod expand ((exp ge-plus))							(defmethod expand ((exp ge-plus))
  (let ((expanded-terms nil)								  (let ((expanded-terms nil)
	(terms (terms-of exp))									(terms (terms-of exp))
	term)											term)
    (loop while terms do								    (loop while terms do
      (setq term (expand (pop terms)))							          (setq term (expand (pop terms)))
      (if (ge-plus? term)								          (if (ge-plus? term)
	  (setq terms (append terms (terms-of term)))					              (setq terms (append terms (terms-of term)))
	  (push term expanded-terms)))							              (push term expanded-terms)))
    (simp-plus-terms (domain-of exp) expanded-terms)))					    (simp-plus-terms (domain-of exp) expanded-terms)))

										    >	(defun expand-binomial-form (terms n)
										    >	  (cond ((null (rest terms))
										    >		 (list (expt (first terms) n)))
										    >		(t (let ((sum ())
										    >			 (a (first terms))
										    >			 (b (rest terms)))
										    >		     (loop for i below (1+ n)
										    >			   for coef = (combinations n i)
										    >			   do (loop for term in (expand-binomial-form b i)
										    >				    do (push (* coef (expt a (- n i)) term) sum)))
										    >		     sum))))
										    >
										    >
										    >	;;+kfp
										    >	;; [-] (typep exponent 'rational-integer)
										    >	;; [+] (if (typep exponent 'rational-integer) (>= exponent 2) nil)
										    >	  
										    >
(defmethod expand ((exp ge-expt))							(defmethod expand ((exp ge-expt))
  (let ((base (base-of exp))								  (let ((base (base-of exp))
	(exponent (exponent-of exp)))								(exponent (exponent-of exp)))
    (cond ((and (ge-plus? base)								    (cond ((and (ge-plus? base)
		(typep exponent 'rational-integer))				    |			(if (typep exponent 'rational-integer) (>= exponent 2) nil))
	   (simp-plus-terms (domain-of exp)							   (simp-plus-terms (domain-of exp)
			     (expand-binomial-form (terms-of base)			                            (expand-binomial-form (terms-of base)
						   (integer-value exponent))))		                                                  (integer-value exponent))))
	  ((ge-times? base)									  ((ge-times? base)
	   (expand (simp-times-terms (domain-of exp)						   (expand (simp-times-terms (domain-of exp)
		     (loop for term in (terms-of base)					                                     (loop for term in (terms-of base)
			   collect (expand (expt term exponent))))))			                                           collect (expand (expt term exponent))))
	  (t exp))))										  (t exp))))
										    <
(defun expand-binomial-form (terms n)						    <
  (cond ((null (rest terms))							    <
	 (list (expt (first terms) n)))						    <
	(t (let ((sum ())							    <
		 (a (first terms))						    <
		 (b (rest terms)))						    <
	     (loop for i below (1+ n)						    <
		   for coef = (combinations n i)				    <
		   do (loop for term in (expand-binomial-form b i)		    <
			    do (push (* coef (expt a (- n i)) term) sum)))	    <
	     sum))))								    <
;;; -*- Mode:Lisp; Package:Weyli; Syntax:Common-Lisp; Base:10; Lowercase:T -*-		;;; -*- Mode:Lisp; Package:Weyli; Syntax:Common-Lisp; Base:10; Lowercase:T -*-
;;; ===========================================================================		;;; ===========================================================================
;;;				  GF(p)							;;;				  GF(p)
;;; ===========================================================================		;;; ===========================================================================
;;; (c) Copyright 1989, 1993 Cornell University						;;; (c) Copyright 1989, 1993 Cornell University

;;; gfp.lisp,v 1.8 1995/05/24 17:42:01 rz Exp						;;; gfp.lisp,v 1.8 1995/05/24 17:42:01 rz Exp

(in-package "WEYLI")								    |	(in-package :weyli)

(make::adjust-version-numbers Weyl "1.8")					    |	;;; DELETE (make::adjust-version-numbers Weyl "1.8")

(define-domain-element-classes GFp GFp-element)						(define-domain-element-classes GFp GFp-element)

										    >	(defgeneric number-of-elements (domain)
										    >	  (:documentation
										    >	   "The purpose of this method is unknown."))
										    >
(defmethod number-of-elements ((domain GFp))						(defmethod number-of-elements ((domain GFp))
  (characteristic domain))								  (characteristic domain))

(defmethod number-of-elements ((domain GFq))						(defmethod number-of-elements ((domain GFq))
  (expt (characteristic domain) (field-degree domain)))					  (expt (characteristic domain) (field-degree domain)))

										    >	(defgeneric make-GFp-domain (number number~)
										    >	  (:documentation
										    >	   "The purpose of this method is unknown."))
										    >
(defmethod make-GFp-domain ((characteristic integer) (degree integer))			(defmethod make-GFp-domain ((characteristic integer) (degree integer))
  (cond ((= degree 1)									  (cond ((= degree 1)
	 (let ((domain (make-instance 'gfp :characteristic characteristic			 (let ((domain (make-instance 'gfp :characteristic characteristic
				      :print-function 'GFp-print-object))						      :print-function 'GFp-print-object))
	       (Z (get-rational-integers)))							       (Z (get-rational-integers)))
	   (make-homomorphism Z							    |		   (make-homomorphism
			      #'(lambda (x)					    |	            Z
										    >	            (lambda (x)
				  (make-element domain					              (make-element domain
				    (if (cl:integerp x) x				                            (if (cl:integerp x) x
					(integer-value x))))				                                (integer-value x))))
			      domain)							            domain)
	   domain))										   domain))
 	(t (error "Can't do GF(~D^~D) yet" characteristic degree)			 	(t (error "Can't do GF(~D^~D) yet" characteristic degree)
	   ;; This is where GFq domains are to be defined.					   ;; This is where GFq domains are to be defined.
	   )))											   )))

(defun GFp-print-object (d stream)							(defun GFp-print-object (d stream)
  #+Genera										  #+Genera
  (format stream "~'bGF~(~D)" (characteristic d))					  (format stream "~'bGF~(~D)" (characteristic d))
  #-Genera										  #-Genera
  (format stream "GF(~D)" (characteristic d)))						  (format stream "GF(~D)" (characteristic d)))

(defmethod make-element ((domain GFp) (value integer) &rest ignore)			(defmethod make-element ((domain GFp) (value integer) &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (let ((modulus (characteristic domain)))						  (let ((modulus (characteristic domain)))
    (make-instance 'GFp-element								    (make-instance 'GFp-element
		   :domain domain									   :domain domain
		   :value (reduce-modulo-integer value modulus))))					   :value (reduce-modulo-integer value modulus))))

;; Could have more error checking							;; Could have more error checking
(defmethod weyl::make-element ((domain GFp) (value integer) &rest ignore)		(defmethod weyl::make-element ((domain GFp) (value integer) &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (make-element domain value))								  (make-element domain value))

(defvar *print-modulus* t)								(defvar *print-modulus* t)

(defmethod print-object ((x GFp-element) stream)					(defmethod print-object ((x GFp-element) stream)
  (with-slots (value domain) x								  (with-slots (value domain) x
    (if *print-modulus*									    (if *print-modulus*
	(format stream "~D(~D)" value (characteristic domain))					(format stream "~D(~D)" value (characteristic domain))	
	(format stream "~D" value))))								(format stream "~D" value))))

										    >	(defun compute-inverse (value modulus)
										    >	  (let ((a1 modulus)
										    >		(a2 (if (cl:< value 0) (cl:+ value modulus) value))
										    >		(y1 0)
										    >		(y2 1)
										    >		q)
										    >	    (loop
										    >	     (if (eql a2 1) (return (values y2 y1)))
										    >	     (if (cl:zerop a2)
										    >	         (error "Inverse of zero divisor -- ~d modulo ~d"
										    >	                value modulus))
										    >	     (setq q (truncate a1 a2))
										    >	     (psetq a1 a2 a2 (cl:- a1 (cl:* a2 q)))
										    >	     (psetq y1 y2 y2 (cl:- y1 (cl:* y2 q))))))
										    >
(defmethod coerce ((value ratio) (domain GFp))						(defmethod coerce ((value ratio) (domain GFp))
  (make-element domain (cl:* (cl:numerator value)				    |	  (make-element
										    >	   domain
										    >	   (cl:* (cl:numerator value)
			     (compute-inverse (cl:denominator value)			         (compute-inverse (cl:denominator value)
					      (characteristic domain)))))		                          (characteristic domain)))))

(defmethod coerce ((value rational-integer) (domain GFp))				(defmethod coerce ((value rational-integer) (domain GFp))
  (make-element domain (integer-value value)))						  (make-element domain (integer-value value)))

(defmethod coerce ((value integer) (domain GFp))					(defmethod coerce ((value integer) (domain GFp))
  (make-element domain value))								  (make-element domain value))

(defmethod coerce ((element gfp-element) (domain general-expressions))			(defmethod coerce ((element gfp-element) (domain general-expressions))
  (coerce (gfp-value element) domain))							  (coerce (gfp-value element) domain))

(defmethod-sd binary= ((x GFp-element) (y GFp-element))					(defmethod-sd binary= ((x GFp-element) (y GFp-element))
  (with-slots ((v1 value) (d1 domain)) x						  (with-slots ((v1 value) (d1 domain)) x
    (with-slots ((v2 value) (d2 domain)) y						    (with-slots ((v2 value) (d2 domain)) y
      (and (eq d1 d2) (eql v1 v2)))))							      (and (eq d1 d2) (eql v1 v2)))))

(defmethod 0? ((x GFp-element))								(defmethod 0? ((x GFp-element))
  (with-slots (value) x									  (with-slots (value) x
    (cl:zerop value)))									    (cl:zerop value)))

(defmethod 1? ((x GFp-element))								(defmethod 1? ((x GFp-element))
  (with-slots (value) x									  (with-slots (value) x
    (eql value 1)))									    (eql value 1)))

;; The following three methods make finite fields behave like quotient fields		;; The following three methods make finite fields behave like quotient fields

(defmethod make-quotient-element ((domain GFp) (a GFp-element) (b GFp-element))		(defmethod make-quotient-element ((domain GFp) (a GFp-element) (b GFp-element))
  (unless (eql domain (domain-of a))							  (unless (eql domain (domain-of a))
    (error "~S should be an element of ~S" a domain))					    (error "~S should be an element of ~S" a domain))
  (unless (eql domain (domain-of b))							  (unless (eql domain (domain-of b))
    (error "~S should be an element of ~S" b domain))					    (error "~S should be an element of ~S" b domain))
  (with-slots ((v1 value)) a								  (with-slots ((v1 value)) a
    (with-slots ((v2 value)) b								    (with-slots ((v2 value)) b
      (with-slots (characteristic) domain						      (with-slots (characteristic) domain
	(make-element domain									(make-element domain
	  (cl:* v1 (compute-inverse v2 characteristic)))))))				                      (cl:* v1 (compute-inverse v2 characteristic)))))))

(defmethod numerator ((a GFp-element))							(defmethod numerator ((a GFp-element))
  a)											  a)

(defmethod denominator ((a GFp-element))						(defmethod denominator ((a GFp-element))
  (make-element (domain-of a) 1))							  (make-element (domain-of a) 1))

(defmethod minus ((x GFp-element))							(defmethod minus ((x GFp-element))
  (with-slots (value domain) x								  (with-slots (value domain) x
    (with-slots (characteristic) domain							    (with-slots (characteristic) domain
      (if (eql 2 characteristic) x							      (if (eql 2 characteristic) x
	  (make-element domain (cl:- characteristic value))))))					  (make-element domain (cl:- characteristic value))))))

;;; There is no such thing as a negative number in finite fields.			;;; There is no such thing as a negative number in finite fields.
(defmethod minus? ((x GFp-element))							(defmethod minus? ((x GFp-element))
  nil)											  nil)

(defmethod plus? ((x GFp-element))							(defmethod plus? ((x GFp-element))
  (not (0? x)))										  (not (0? x)))

(defmethod-sd plus ((a GFp-element) (b GFp-element))					(defmethod-sd plus ((a GFp-element) (b GFp-element))
  (make-element domain (cl:+ (gfp-value a) (gfp-value b))))				  (make-element domain (cl:+ (gfp-value a) (gfp-value b))))

(defmethod-sd difference ((a GFp-element) (b GFp-element))				(defmethod-sd difference ((a GFp-element) (b GFp-element))
  (make-element domain (cl:- (gfp-value a) (gfp-value b))))				  (make-element domain (cl:- (gfp-value a) (gfp-value b))))

(defmethod-sd times ((a GFp-element) (b GFp-element))					(defmethod-sd times ((a GFp-element) (b GFp-element))
  (make-element domain (cl:* (gfp-value a) (gfp-value b))))				  (make-element domain (cl:* (gfp-value a) (gfp-value b))))

											;; Takes the inverse of an integer N mod P.  Solve N*X + P*Y = 1.  N
;; Takes the inverse of an integer N mod P.  Solve N*X + P*Y = 1.  N			;; is guaranteed to be less than P, since in the case where P is a
;; is guaranteed to be less than P, since in the case where P is a			;; fixnum, N is also assumed to be one.
;; fixnum, N is also assumed to be one.
											(defmethod recip ((x GFp-element))
(defmethod recip ((x GFp-element))							  (with-slots (value domain) x
  (with-slots (value domain) x								    (with-slots (characteristic) domain
    (with-slots (characteristic) domain							      (make-element domain (reduce-modulo-integer
      (make-element domain (reduce-modulo-integer								    (compute-inverse value characteristic)
			    (compute-inverse value characteristic)						    characteristic)))))
			    characteristic)))))
										    (
(defun compute-inverse (value modulus)						    <
  (let ((a1 modulus)								    <
	(a2 (if (cl:< value 0) (cl:+ value modulus) value))			    <
	(y1 0)									    <
	(y2 1)									    <
	q)									    <
    (loop									    <
      (if (eql a2 1) (return (values y2 y1)))					    <
      (if (cl:zerop a2)								    <
	  (error "Inverse of zero divisor -- ~d modulo ~d"			    <
		 value modulus))						    <
      (setq q (truncate a1 a2))							    <
      (psetq a1 a2 a2 (cl:- a1 (cl:* a2 q)))					    <
      (psetq y1 y2 y2 (cl:- y1 (cl:* y2 q))))))					    <
										    <
(defmethod expt ((x GFp-element) (e integer))						(defmethod expt ((x GFp-element) (e integer))
  (with-slots (value domain) x								  (with-slots (value domain) x
    (cond ((eql 1 value) x)								    (cond ((eql 1 value) x)
	  ((cl:minusp e)									  ((cl:minusp e)
	   (error "Raising ~D to a negative power ~D" x e))					   (error "Raising ~D to a negative power ~D" x e))
	  (t (make-element domain								  (t (make-element domain
	       (expt-modulo-integer value e (characteristic domain)))))))			       (expt-modulo-integer value e (characteristic domain)))))))

(defmethod quotient ((a GFp-element) (b GFp-element)) 					(defmethod quotient ((a GFp-element) (b GFp-element)) 
  (with-slots ((v1 value) (d1 domain)) a						  (with-slots ((v1 value) (d1 domain)) a
    (with-slots ((v2 value) (d2 domain)) b						    (with-slots ((v2 value) (d2 domain)) b
      (cond ((eq d1 d2)									      (cond ((eq d1 d2)
	     (with-slots (characteristic) d1							     (with-slots (characteristic) d1
	       (make-element d1									       (make-element d1
		 (cl:* v1 (compute-inverse v2 characteristic)))))					 (cl:* v1 (compute-inverse v2 characteristic)))))
	    (t (error "Taking the quotient of elements of ~					    (t (error "Taking the quotient of elements of ~
		       different fields: ~S, ~S"							       different fields: ~S, ~S"
		      a b))))))										      a b))))))

(defmethod remainder ((a GFp-element) (b GFp-element))					(defmethod remainder ((a GFp-element) (b GFp-element))
  (error "Computing the remainder of ~D by ~D"						  (error "Computing the remainder of ~D by ~D"
	 a b))											 a b))

(defmethod binary-gcd ((a GFp-element) (b GFp-element))					(defmethod binary-gcd ((a GFp-element) (b GFp-element))
  (with-slots ((d1 domain)) a								  (with-slots ((d1 domain)) a
    (with-slots ((d2 domain)) b								    (with-slots ((d2 domain)) b
      (cond ((eq d1 d2) (make-element d1 1))						      (cond ((eq d1 d2) (make-element d1 1))
	    (t (error "Taking the GCD of elements of different fields: ~S, ~S"			    (t (error "Taking the GCD of elements of different fields: ~S, ~S"
		      a b))))))										      a b))))))

(defmethod binary-lcm ((a GFp-element) (b GFp-element))					(defmethod binary-lcm ((a GFp-element) (b GFp-element))
  (with-slots ((d1 domain)) a								  (with-slots ((d1 domain)) a
    (with-slots ((d2 domain)) b								    (with-slots ((d2 domain)) b
      (cond ((eq d1 d2) (make-element d1 1))						      (cond ((eq d1 d2) (make-element d1 1))
	    (t (error "Taking the LCM of elements of different fields: ~S, ~S"			    (t (error "Taking the LCM of elements of different fields: ~S, ~S"
		      a b))))))										      a b))))))

(defmethod random ((domain GFp) &optional height)					(defmethod random ((domain GFp) &optional height)
  (declare (ignore height))								  (declare (ignore height))
  (make-element domain (cl:random (characteristic domain))))				  (make-element domain (cl:random (characteristic domain))))

(defmethod height ((x GFp-element))							(defmethod height ((x GFp-element))
  (make-element (get-real-numbers) (characteristic (domain-of x))))			  (make-element (get-real-numbers) (characteristic (domain-of x))))

										    >	(defgeneric multiplicative-order (element)
										    >	  (:documentation
										    >	   "The purpose of this method is unknown."))
										    >
(defmethod multiplicative-order ((a GFp-element))					(defmethod multiplicative-order ((a GFp-element))
  (with-slots (value domain) a								  (with-slots (value domain) a
    (with-slots ((p  characteristic)) domain						    (with-slots ((p  characteristic)) domain
      (cond ((not (eql 1 (cl:gcd value p)))						      (cond ((not (eql 1 (cl:gcd value p)))
	     *positive-infinity*)								     *positive-infinity*)
	    ((let ((group-order (totient p)))							    ((let ((group-order (totient p)))
	       (do ((factors (factor group-order)						       (do ((factors (factor group-order)
			     (rest factors))									     (rest factors))
		    (order group-order))								    (order group-order))
		   ((null factors)									   ((null factors)
		    order)										    order)
		 (do ((i 0 (cl:1+ i)))									 (do ((i 0 (cl:1+ i)))
		     ((cl:= i (cdar factors)))								     ((cl:= i (cdar factors)))
		   (setq order (cl:/ order (caar factors)))						   (setq order (cl:/ order (caar factors)))
		   (when (not (eql 1 (expt-modulo-integer value order p)))				   (when (not (eql 1 (expt-modulo-integer value order p)))
		     (setq order (cl:* order (caar factors)))						     (setq order (cl:* order (caar factors)))
		     (return t))))))))))								     (return t))))))))))

;; GF(2^n)										;; GF(2^n)
(defvar *GF2-irreducible-polynomials*							(defvar *GF2-irreducible-polynomials*
	'(#O7 #O13 #O23 #O45 #O103 #O211 #O435 #O1021 #O2011 #O4005 #O10123		  '(#O7 #O13 #O23 #O45 #O103 #O211 #O435 #O1021 #O2011 #O4005 #O10123
	  #O20033 #O42103 #O100003 #O210013))						    #O20033 #O42103 #O100003 #O210013))

(defmethod make-GFp-domain ((characteristic (eql 2)) (degree integer))			(defmethod make-GFp-domain ((characteristic (eql 2)) (degree integer))
  (cond ((= degree 1)									  (cond ((= degree 1)
	 (make-instance 'gfp :characteristic characteristic))					 (make-instance 'gfp :characteristic characteristic))
	((< degree (+ (length *GF2-irreducible-polynomials*) 2))				((< degree (+ (length *GF2-irreducible-polynomials*) 2))
	 (let* ((mask (ash 1 degree))								 (let* ((mask (ash 1 degree))
		(field (1- mask))									(field (1- mask))
		(min-poly (logand (nth (- degree 2) *GF2-irreducible-polynomials*)			(min-poly (logand (nth (- degree 2) *GF2-irreducible-polynomials*)
				  field))										  field))
                domain Z)								                domain Z)
           (setq domain									           (setq domain
                 (make-instance 'GF2^n 							                 (make-instance 'GF2^n 
                                :degree degree						                                :degree degree
                                :reduction-table					                                :reduction-table
                                (loop for i below degree				                                (loop for i below degree
                                      for x^n = min-poly then (ash x^n 1)		                                      for x^n = min-poly then (ash x^n 1)
                                      collect						                                      collect
                                      (if (cl:zerop (logand mask x^n)) x^n		                                      (if (cl:zerop (logand mask x^n)) x^n
                                          (setq x^n (logxor (logand field x^n) min	                                          (setq x^n (logxor (logand field x^n) min
                                :characteristic characteristic				                                :characteristic characteristic
				:print-function 'GF2^n-print-object))							:print-function 'GF2^n-print-object))
           (setq Z (get-rational-integers))						           (setq Z (get-rational-integers))
           (make-homomorphism Z #'(lambda (x)						           (make-homomorphism Z #'(lambda (x)
                                    (coerce (integer-value x) domain))			                                    (coerce (integer-value x) domain))
                              domain)							                              domain)
           domain))									           domain))
	(t (error "Table doesn't go far enough: 2^~D" degree))))				(t (error "Table doesn't go far enough: 2^~D" degree))))

(defun GF2^n-print-object (domain stream)						(defun GF2^n-print-object (domain stream)
  #+Genera										  #+Genera
  (format stream "~'bGF~(2^~D)" (field-degree domain))					  (format stream "~'bGF~(2^~D)" (field-degree domain))
  #-Genera										  #-Genera
  (format stream "GF(2^~D)" (field-degree domain)))					  (format stream "GF(2^~D)" (field-degree domain)))

(defclass GF2^n-element (GFp-element) 							(defclass GF2^n-element (GFp-element) 
     ())										  ())

(defmethod print-object ((elt GF2^n-element) stream)					(defmethod print-object ((elt GF2^n-element) stream)
  (format stream "~V,'0B(2^~D)"								  (format stream "~V,'0B(2^~D)"
	  (field-degree (domain-of elt)) (GFp-value elt)					  (field-degree (domain-of elt)) (GFp-value elt)
	(field-degree (domain-of elt))))						          (field-degree (domain-of elt))))

(defmethod make-element ((domain GF2^n) (value integer) &rest ignore)			(defmethod make-element ((domain GF2^n) (value integer) &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (make-instance 'GF2^N-element								  (make-instance 'GF2^N-element
		 :domain domain										 :domain domain
		 :value (logand (1- (ash 1 (field-degree domain))) value)))				 :value (logand (1- (ash 1 (field-degree domain))) value)))

;; Could have more error checking							;; Could have more error checking
(defmethod weyl::make-element ((domain GF2^n) (value integer) &rest ignore)		(defmethod weyl::make-element ((domain GF2^n) (value integer) &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (make-element domain value))								  (make-element domain value))

(defmethod coerce ((value (or integer ratio)) (domain GF2^n))			    |	(defmethod coerce ((value integer) (domain GF2^n))
										    >	  (make-element domain (if (zerop value) 0 1)))
										    >
										    >	(defmethod coerce ((value ratio) (domain GF2^n))
  (make-element domain (if (zerop value) 0 1)))						  (make-element domain (if (zerop value) 0 1)))

(defmethod multiplicative-order ((a GF2^n-element))					(defmethod multiplicative-order ((a GF2^n-element))
  (let ((group-size (1- (number-of-elements (domain-of a)))))				  (let ((group-size (1- (number-of-elements (domain-of a)))))
    (loop for order in (all-divisors group-size)					    (loop for order in (all-divisors group-size)
	  do (when (1? (expt a order))								  do (when (1? (expt a order))
	       (return order)))))								       (return order)))))

(defmethod-sd plus ((a GF2^n-element) (b GF2^n-element))				(defmethod-sd plus ((a GF2^n-element) (b GF2^n-element))
  (make-element domain (logxor (gfp-value a) (gfp-value b))))				  (make-element domain (logxor (gfp-value a) (gfp-value b))))

(defmethod-sd times ((a GF2^n-element) (b GF2^n-element))				(defmethod-sd times ((a GF2^n-element) (b GF2^n-element))
  (let ((x (Gfp-value a))								  (let ((x (Gfp-value a))
	(y (GFp-value b))									(y (GFp-value b))
	(degree (field-degree domain))								(degree (field-degree domain))
	(acc 0) answer)										(acc 0) answer)
    (loop while (not (cl:zerop y)) do							    (loop while (not (cl:zerop y)) do
      (when (not (cl:zerop (cl:logand 1 y)))						          (when (not (cl:zerop (cl:logand 1 y)))
	(setq acc (cl:logxor acc x)))							            (setq acc (cl:logxor acc x)))
      (setq x (cl:ash x 1))								          (setq x (cl:ash x 1))
      (setq y (cl:ash y -1)))								          (setq y (cl:ash y -1)))
    (setq answer (cl:logand (cl:1- (cl:ash 1 degree)) acc))				    (setq answer (cl:logand (cl:1- (cl:ash 1 degree)) acc))
    (loop for hi-bits = (cl:ash acc (cl:- degree))					    (loop for hi-bits = (cl:ash acc (cl:- degree))
	    then (cl:ash hi-bits -1)							          then (cl:ash hi-bits -1)
	  for poly in (GFp-reduction-table domain)						  for poly in (GFp-reduction-table domain)
	  while (not (cl:zerop hi-bits))							  while (not (cl:zerop hi-bits))
	  do (unless (cl:zerop (cl:logand 1 hi-bits))						  do (unless (cl:zerop (cl:logand 1 hi-bits))
	       (setq answer (cl:logxor answer poly))))						       (setq answer (cl:logxor answer poly))))
    (make-instance 'GF2^N-element :domain domain :value answer)))    			    (make-instance 'GF2^N-element :domain domain :value answer)))    

(defmethod expt ((base GF2^n-element) (expt integer))					(defmethod expt ((base GF2^n-element) (expt integer))
  (%funcall (repeated-squaring #'times (make-element (domain-of base) 1))		  (%funcall (repeated-squaring #'times (make-element (domain-of base) 1))
		base expt))								            base expt))

(defmethod recip ((x GF2^n-element))							(defmethod recip ((x GF2^n-element))
  (let ((domain (domain-of x)))								  (let ((domain (domain-of x)))
    (expt x (cl:- (cl:expt 2 (field-degree domain)) 2))))				    (expt x (cl:- (cl:expt 2 (field-degree domain)) 2))))

(defmethod-sd quotient ((x GF2^n-element) (y GF2^n-element))				(defmethod-sd quotient ((x GF2^n-element) (y GF2^n-element))
  (* x (recip y)))									  (* x (recip y)))

;; GF(m)										;; GF(m)

;; This domain is the union of all Z/mZ for all m.					;; This domain is the union of all Z/mZ for all m.

(define-domain-element-classes GFm GFm-element)						(define-domain-element-classes GFm GFm-element)

(defun make-gfm-domain ()								(defun make-gfm-domain ()
  (let ((domain (make-instance 'gfm))							  (let ((domain (make-instance 'gfm))
	(Z (get-rational-integers)))								(Z (get-rational-integers)))
    (make-homomorphism Z #'(lambda (x)							    (make-homomorphism Z #'(lambda (x)
			     (make-element domain (integer-value x) 0))						     (make-element domain (integer-value x) 0))
		       domain)										       domain)
    domain))										    domain))

(defmethod make-element ((domain GFm) value &rest rest)					(defmethod make-element ((domain GFm) value &rest rest)
  (let ((modulus (first rest)))								  (let ((modulus (first rest)))
    (make-instance 'GFm-element								    (make-instance 'GFm-element
		   :domain domain									   :domain domain
		   :value (reduce-modulo-integer value modulus)						   :value (reduce-modulo-integer value modulus)
		   :modulus modulus)))									   :modulus modulus)))

;; Could have more error checking							;; Could have more error checking
(defmethod weyl::make-element ((domain GFm) value &rest rest)				(defmethod weyl::make-element ((domain GFm) value &rest rest)
  (%apply #'make-element domain value rest))						  (%apply #'make-element domain value rest))

(defmethod print-object ((x GFm-element) stream)					(defmethod print-object ((x GFm-element) stream)
  (with-slots (value modulus) x								  (with-slots (value modulus) x
    (format stream "~D(~D)" value modulus)))						    (format stream "~D(~D)" value modulus)))

(defmethod coerce ((value integer) (domain GFm))					(defmethod coerce ((value integer) (domain GFm))
  (make-element domain value 0))							  (make-element domain value 0))

(defmethod coerce ((elt GFp-element) (domain GFm))					(defmethod coerce ((elt GFp-element) (domain GFm))
  (with-slots ((v1 value) (d1 domain)) elt						  (with-slots ((v1 value) (d1 domain)) elt
    (make-element domain v1 (characteristic d1))))					    (make-element domain v1 (characteristic d1))))

											(defmethod-sd binary= ((x GFm-element) (y GFm-element))
(defmethod-sd binary= ((x GFm-element) (y GFm-element))					  (with-slots ((v1 value) (m1 modulus) (d1 domain)) x
  (with-slots ((v1 value) (m1 modulus) (d1 domain)) x					    (with-slots ((v2 value) (m2 modulus) (d2 domain)) y
    (with-slots ((v2 value) (m2 modulus) (d2 domain)) y					      (and (eq d1 d2) (eql v1 v2) (eql m1 m2)))))
      (and (eq d1 d2) (eql v1 v2) (eql m1 m2)))))
											(defmethod 0? ((x GFm-element))
(defmethod 0? ((x GFm-element))								  (with-slots (value) x
  (with-slots (value) x									    (cl:zerop value)))
    (cl:zerop value)))
											(defmethod 1? ((x GFm-element))
(defmethod 1? ((x GFm-element))								  (with-slots (value) x
  (with-slots (value) x									    (eql value 1)))
    (eql value 1)))
											(defmethod minus ((x GFm-element))
(defmethod minus ((x GFm-element))							  (with-slots (value modulus domain) x
  (with-slots (value modulus domain) x							    (if (eql 2 modulus) x
    (if (eql 2 modulus) x									(make-element domain (cl:- modulus value) modulus))))
	(make-element domain (cl:- modulus value) modulus))))
											;;; There is no such thing as a negative number in finite fields.
;;; There is no such thing as a negative number in finite fields.			(defmethod minus? ((x GFm-element))
(defmethod minus? ((x GFm-element))							  nil)
  nil)
											(defmethod plus? ((x GFm-element))
(defmethod plus? ((x GFm-element))							  (not (0? x)))
  (not (0? x)))
											(defmethod-sd plus ((a GFm-element) (b GFm-element))
(defmethod-sd plus ((a GFm-element) (b GFm-element))					  (with-slots ((v1 value) (m1 modulus) (d1 domain)) a
  (with-slots ((v1 value) (m1 modulus) (d1 domain)) a					    (with-slots ((v2 value) (m2 modulus) (d2 domain)) b
    (with-slots ((v2 value) (m2 modulus) (d2 domain)) b					      (cond ((not (eql d1 d2))
      (cond ((not (eql d1 d2))									     (error "~S and ~S are not from the same domain" a b))
	     (error "~S and ~S are not from the same domain" a b))				    ((eql m1 m2)
	    ((eql m1 m2)									     (make-element d1 (cl:+ v1 v2) m1))
	     (make-element d1 (cl:+ v1 v2) m1))							    (t (make-element d1 (cl:+ v1 v2) (cl:lcm m1 m2)))))))
	    (t (make-element d1 (cl:+ v1 v2) (cl:lcm m1 m2)))))))
											(defmethod-sd difference ((a GFm-element) (b GFm-element))
(defmethod-sd difference ((a GFm-element) (b GFm-element))				  (with-slots ((v1 value) (m1 modulus) (d1 domain)) a
  (with-slots ((v1 value) (m1 modulus) (d1 domain)) a					    (with-slots ((v2 value) (m2 modulus) (d2 domain)) b
    (with-slots ((v2 value) (m2 modulus) (d2 domain)) b					      (cond ((not (eql d1 d2))
      (cond ((not (eql d1 d2))									     (error "~S and ~S are not from the same domain" a b))
	     (error "~S and ~S are not from the same domain" a b))				    ((eql m1 m2)
	    ((eql m1 m2)									     (make-element d1 (cl:- v1 v2) m1))
	     (make-element d1 (cl:- v1 v2) m1))							    (t (make-element d1 (cl:- v1 v2) (cl:lcm m1 m2)))))))
	    (t (make-element d1 (cl:- v1 v2) (cl:lcm m1 m2)))))))
											(defmethod-sd times ((a GFm-element) (b GFm-element))
(defmethod-sd times ((a GFm-element) (b GFm-element))					  (with-slots ((v1 value) (m1 modulus) (d1 domain)) a
  (with-slots ((v1 value) (m1 modulus) (d1 domain)) a					    (with-slots ((v2 value) (m2 modulus) (d2 domain)) b
    (with-slots ((v2 value) (m2 modulus) (d2 domain)) b					      (cond ((not (eql d1 d2))
      (cond ((not (eql d1 d2))									     (error "~S and ~S are not from the same domain" a b))
	     (error "~S and ~S are not from the same domain" a b))				    ((eql m1 m2)
	    ((eql m1 m2)									     (make-element d1 (cl:* v1 v2) m1))
	     (make-element d1 (cl:* v1 v2) m1))							    (t (make-element d1 (cl:* v1 v2) (cl:lcm m1 m2)))))))
	    (t (make-element d1 (cl:* v1 v2) (cl:lcm m1 m2)))))))
											(defmethod plus ((a GFm-element) (b integer))
(defmethod plus ((a GFm-element) (b integer))						  (with-slots ((v1 value) (m1 modulus) (d1 domain)) a
  (with-slots ((v1 value) (m1 modulus) (d1 domain)) a					    (make-element d1 (cl:+ v1 (reduce-modulo-integer b m1)) m1)))
    (make-element d1 (cl:+ v1 (reduce-modulo-integer b m1)) m1)))
											(defmethod plus ((a integer) (b GFm-element))
(defmethod plus ((a integer) (b GFm-element))						  (with-slots ((v1 value) (m1 modulus) (d1 domain)) b
  (with-slots ((v1 value) (m1 modulus) (d1 domain)) b					    (make-element d1 (cl:+ (reduce-modulo-integer a m1) v1) m1)))
    (make-element d1 (cl:+ (reduce-modulo-integer a m1) v1) m1)))
											(defmethod difference ((a GFm-element) (b integer))
(defmethod difference ((a GFm-element) (b integer))					  (with-slots ((v1 value) (m1 modulus) (d1 domain)) a
  (with-slots ((v1 value) (m1 modulus) (d1 domain)) a					    (make-element d1 (cl:- v1 (reduce-modulo-integer b m1)) m1)))
    (make-element d1 (cl:- v1 (reduce-modulo-integer b m1)) m1)))
											(defmethod difference ((a integer) (b GFm-element))
(defmethod difference ((a integer) (b GFm-element))					  (with-slots ((v1 value) (m1 modulus) (d1 domain)) b
  (with-slots ((v1 value) (m1 modulus) (d1 domain)) b					    (make-element d1 (cl:- (reduce-modulo-integer a m1) v1) m1)))
    (make-element d1 (cl:- (reduce-modulo-integer a m1) v1) m1)))
											(defmethod times ((a GFm-element) (b integer))
(defmethod times ((a GFm-element) (b integer))						  (with-slots ((v1 value) (m1 modulus) (d1 domain)) a
  (with-slots ((v1 value) (m1 modulus) (d1 domain)) a					    (make-element d1 (cl:* v1 (reduce-modulo-integer b m1)) m1)))
    (make-element d1 (cl:* v1 (reduce-modulo-integer b m1)) m1)))
											(defmethod times ((a integer) (b GFm-element))
(defmethod times ((a integer) (b GFm-element))						  (with-slots ((v1 value) (m1 modulus) (d1 domain)) b
  (with-slots ((v1 value) (m1 modulus) (d1 domain)) b					    (make-element d1 (cl:* (reduce-modulo-integer a m1) v1) m1)))
    (make-element d1 (cl:* (reduce-modulo-integer a m1) v1) m1)))
											;;; Takes the inverse of an integer N mod P.  Solve N*X + P*Y = 1.  N
											;;; is guaranteed to be less than P, since in the case where P is a
;;; Takes the inverse of an integer N mod P.  Solve N*X + P*Y = 1.  N			;;; fixnum, N is also assumed to be one.
;;; is guaranteed to be less than P, since in the case where P is a
;;; fixnum, N is also assumed to be one.						(defmethod recip ((x GFm-element))
											  (with-slots (value modulus domain) x
(defmethod recip ((x GFm-element))							    (make-element domain (reduce-modulo-integer (compute-inverse value modulus)
  (with-slots (value modulus domain) x													modulus)
    (make-element domain (reduce-modulo-integer (compute-inverse value modulus)				  modulus)))
						modulus)
		  modulus)))								(defmethod expt ((x GFm-element) (e integer))
											  (with-slots (value modulus domain) x
(defmethod expt ((x GFm-element) (e integer))						    (cond ((eql 1 value) x)
  (with-slots (value modulus domain) x								  ((cl:minusp e)
    (cond ((eql 1 value) x)									   (error "Raising ~D to a negative power ~D" x e))
	  ((cl:minusp e)									  (t (make-element domain (expt-modulo-integer value e modulus)
	   (error "Raising ~D to a negative power ~D" x e))							   modulus)))))
	  (t (make-element domain (expt-modulo-integer value e modulus)
			   modulus)))))							(defmethod-sd  quotient ((a GFm-element) (b GFm-element)) 
											  (with-slots ((v1 value) (m1 modulus)) a
(defmethod-sd  quotient ((a GFm-element) (b GFm-element)) 				    (with-slots ((v2 value) (m2 modulus)) b
  (with-slots ((v1 value) (m1 modulus)) a						      (make-element domain (cl:* v1 (compute-inverse v2 m2)) m1))))
    (with-slots ((v2 value) (m2 modulus)) b						  
      (make-element domain (cl:* v1 (compute-inverse v2 m2)) m1))))			(defmethod remainder ((a GFm-element) (b GFm-element))
  										    (
(defmethod remainder ((a GFm-element) (b GFm-element))				    (
  (error "Computing the remainder of ~D by ~D"					    |	  (error "Computing the remainder of ~D by ~D" a b))
	 a b))									    <

(defmethod binary-gcd ((a GFm-element) (b GFm-element))					(defmethod binary-gcd ((a GFm-element) (b GFm-element))
  (declare (ignore b))									  (declare (ignore b))
  (with-slots ((m1 modulus) (d1 domain)) a						  (with-slots ((m1 modulus) (d1 domain)) a
    (make-element d1 1 m1)))								    (make-element d1 1 m1)))

(defmethod-sd binary-lcm ((a GFm-element) (b GFm-element))				(defmethod-sd binary-lcm ((a GFm-element) (b GFm-element))
  (with-slots ((m1 modulus)) a								  (with-slots ((m1 modulus)) a
    (make-element domain 1 m1)))							    (make-element domain 1 m1)))

(defmethod multiplicative-order ((a GFm-element))					(defmethod multiplicative-order ((a GFm-element))
  (with-slots (value modulus) a								  (with-slots (value modulus) a
    (cond ((not (eql 1 (cl:gcd value modulus)))						    (cond ((not (eql 1 (cl:gcd value modulus)))
	   *positive-infinity*)									   *positive-infinity*)
	  ((let ((group-order (totient modulus)))						  ((let ((group-order (totient modulus)))
	     (do ((factors (factor group-order)							     (do ((factors (factor group-order)
			   (rest factors))									   (rest factors))
		  (order group-order))									  (order group-order))
		 ((null factors)									 ((null factors)
		  order)										  order)
	       (do ((i 0 (cl:1+ i)))								       (do ((i 0 (cl:1+ i)))
		   ((cl:= i (cdar factors)))								   ((cl:= i (cdar factors)))
		 (setq order (cl:/ order (caar factors)))						 (setq order (cl:/ order (caar factors)))
		 (when (not (eql 1 (expt-modulo-integer value order modulus)))				 (when (not (eql 1 (expt-modulo-integer value order modulus)))
		   (setq order (cl:* order (caar factors)))						   (setq order (cl:* order (caar factors)))
		   (return t)))))))))									   (return t)))))))))

;; These are the guys that actually create the finite fields.				;; These are the guys that actually create the finite fields.
(defun make-finite-field* (size)							(defun make-finite-field* (size)
  (cond ((null size)									  (cond ((null size)
	 (make-gfm-domain))									 (make-gfm-domain))
	((prime? size)										((prime? size)
	 (make-GFp-domain size 1))								 (make-GFp-domain size 1))
	(t (let* ((s (factor size))								(t (let* ((s (factor size))
		  (char (first (first s)))								  (char (first (first s)))
		  (degree (rest (first s))))								  (degree (rest (first s))))
	     (if (null (rest s))								     (if (null (rest s))
		 (make-Gfp-domain char degree)								 (make-Gfp-domain char degree)
		 (error "Finite fields of size ~S=~S don't exist" size s))))))				 (error "Finite fields of size ~S=~S don't exist" size s))))))

											(defun make-finite-field (&optional size)
(defun make-finite-field (&optional size)						  (add-domain #'false (make-finite-field* size)))
  (add-domain #'false (make-finite-field* size)))
											;; This is slightly inefficient, but who cares...  I want to localize
;; This is slightly inefficient, but who cares...  I want to localize			;; the knowledge of how to create domains in the MAKE-...* functions.
;; the knowledge of how to create domains in the MAKE-...* functions.			(defun get-finite-field (&optional size)
(defun get-finite-field (&optional size)						  (cond ((null size)
  (cond ((null size)										 (add-domain #'(lambda (d) (eql (class-name (class-of d)) 'GFm))
	 (add-domain #'(lambda (d) (eql (class-name (class-of d)) 'GFm))			   (make-finite-field* size)))
	   (make-finite-field* size)))								((prime? size)
	((prime? size)										 (add-domain #'(lambda (d)
	 (add-domain #'(lambda (d)									         (and (eql (class-name (class-of d)) 'GFp)
		         (and (eql (class-name (class-of d)) 'GFp)						      (eql (characteristic d) size)))
			      (eql (characteristic d) size)))					   (make-finite-field* size)))
	   (make-finite-field* size)))							        ((null (rest (factor size)))
	 ((null (rest (factor size)))							         (add-domain #'(lambda (d)
	  (add-domain #'(lambda (d)							                         (and (eql (class-name (class-of d)) 'GF2^n)
			  (and (eql (class-name (class-of d)) 'GF2^n)			                              (eql (cl:expt (characteristic d)
			       (eql (cl:expt (characteristic d)				                                            (field-degree d))
					     (field-degree d))				                                   size)))
				    size)))							   (make-finite-field* size)))
	   (make-finite-field* size)))								(t (error "Can't do algebraic extensions yet"))))
	(t (error "Can't do algebraic extensions yet"))))
										    (
										    >	(defgeneric get-factor-ring (ring ideal)
										    >	  (:documentation
										    >	   "The purpose of this method is unknown."))
										    >
(defmethod get-factor-ring ((ring rational-integers) (ideal ideal))			(defmethod get-factor-ring ((ring rational-integers) (ideal ideal))
  (cond ((eql (ring-of ideal) ring)							  (cond ((eql (ring-of ideal) ring)
	 (get-finite-field (first (generators-of ideal))))					 (get-finite-field (first (generators-of ideal))))
	(t (error "Don't know how to compute ~S/~S" ring ideal))))				(t (error "Don't know how to compute ~S/~S" ring ideal))))

										    >	(defgeneric use-chinese-remainder (remainders)
										    >	  (:documentation
										    >	   "The purpose of this method is unknown."))
										    >
;; Use Chinese remainder theorem to compute the result given a list			;; Use Chinese remainder theorem to compute the result given a list
;; of remainders which are GFp elements.						;; of remainders which are GFp elements.
(defmethod use-chinese-remainder ((remainders list))					(defmethod use-chinese-remainder ((remainders list))
  (let* ((gfm (get-finite-field '()))							  (let* ((gfm (get-finite-field '()))
	 (x (car remainders))									 (x (car remainders))
	 (remainders (cdr remainders))								 (remainders (cdr remainders))
	 (p1 (if (typep (domain-of x) 'GFp)							 (p1 (if (typep (domain-of x) 'GFp)
		 (coerce (characteristic (domain-of x)) gfm)						 (coerce (characteristic (domain-of x)) gfm)
		 (coerce (modulus x) gfm)))								 (coerce (modulus x) gfm)))
	 p1inv p2)										 p1inv p2)
    (setq x (coerce x gfm))								    (setq x (coerce x gfm))
    (loop for k2 in remainders do							    (loop for k2 in remainders do
      (setq p1inv (recip (with-slots ((v value)) p1					          (setq p1inv (recip (with-slots ((v value)) p1
			   (coerce (coerce v (domain-of k2)) gfm))))			                               (coerce (coerce v (domain-of k2)) gfm))))
      (setq p2 (if (typep (domain-of k2) 'GFp)						          (setq p2 (if (typep (domain-of k2) 'GFp)
		   (coerce (characteristic (domain-of k2)) gfm)				                       (coerce (characteristic (domain-of k2)) gfm)
		   (coerce (modulus k2) gfm)))						                       (coerce (modulus k2) gfm)))
      (setq k2 (coerce k2 gfm))								          (setq k2 (coerce k2 gfm))
      (setq x (make-element gfm								          (setq x (make-element gfm
		(value (+ x (* (* p1inv (- k2 x)) p1)))					                                (value (+ x (* (* p1inv (- k2 x)) p1)))
		(value (* p1 p2))))							                                (value (* p1 p2))))
      (setq p1 (* p1 p2)))								          (setq p1 (* p1 p2)))
	x))										    x))
										    >
										    >	(defgeneric compute-result (result)
										    >	  (:documentation
										    >	   "The purpose of this method is unknown."))

(defmethod compute-result ((result GFm-element))					(defmethod compute-result ((result GFm-element))
  (with-slots ((v value) (modulus modulus)) result					  (with-slots ((v value) (modulus modulus)) result
    (if (> v (floor modulus 2)) (- v modulus) v)))					    (if (> v (floor modulus 2)) (- v modulus) v)))
;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-		;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-
;;; ===========================================================================		;;; ===========================================================================
;;;			      Expanded Polynomials					;;;			      Expanded Polynomials
;;; ===========================================================================		;;; ===========================================================================
;;; (c) Copyright 1989, 1993 Cornell University						;;; (c) Copyright 1989, 1993 Cornell University

;;; grobner.lisp,v 1.8 1995/05/24 17:42:02 rz Exp					;;; grobner.lisp,v 1.8 1995/05/24 17:42:02 rz Exp

(in-package "WEYLI")								    |	(in-package :weyli)

(make::adjust-version-numbers Weyl "1.8")					    |	;;; DELETE (make::adjust-version-numbers Weyl "1.8")

(defmethod initialize-instance :after ((id ideal) &rest ignore)				(defmethod initialize-instance :after ((id ideal) &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (let ((ring (ring-of id)))								  (let ((ring (ring-of id)))
    (with-slots (coefficient-domain print-function) id					    (with-slots (coefficient-domain print-function) id
      (unless coefficient-domain							      (unless coefficient-domain
	(setf coefficient-domain (ring-of id)))							(setf coefficient-domain (ring-of id)))

      (setf print-function 'ideal-print-object))					      (setf print-function 'ideal-print-object))
    (unless (super-domains-of id)							    (unless (super-domains-of id)
      (setf (super-domains-of id) (cons ring (super-domains-of ring))))))		      (setf (super-domains-of id) (cons ring (super-domains-of ring))))))

(defun ideal-print-object (id stream)							(defun ideal-print-object (id stream)
  (let ((gens (generators-of id)))							  (let ((gens (generators-of id)))
    (format stream "#Id(~S~{, ~S~})" (first gens) (rest gens))))			    (format stream "#Id(~S~{, ~S~})" (first gens) (rest gens))))

										    >	(defgeneric make-ideal (ring &rest generators)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod make-ideal ((ring ring) &rest generators)					(defmethod make-ideal ((ring ring) &rest generators)
  (make-instance 'ideal									  (make-instance 'ideal
		 :ring ring										 :ring ring
		 :generators (loop for g in generators							 :generators (loop for g in generators
				   collect (coerce g ring))))								   collect (coerce g ring))))

(defmethod make-ideal ((ring field) &rest generators)					(defmethod make-ideal ((ring field) &rest generators)
  (declare (ignore generators))								  (declare (ignore generators))
  (make-instance 'ideal :ring ring :generators (list (one ring))))			  (make-instance 'ideal :ring ring :generators (list (one ring))))

;;FIXTHIS:  The following assumes that PID are GCD domains, which isn't true. 		;;FIXTHIS:  The following assumes that PID are GCD domains, which isn't true. 
(defmethod make-ideal ((ring rational-integers) &rest generators)			(defmethod make-ideal ((ring rational-integers) &rest generators)
  (make-instance 'PID-ideal :ring ring							  (make-instance 'PID-ideal :ring ring
		 :generators (list									 :generators (list
			       (loop with g = (coerce (first generators) ring)					       (loop with g = (coerce (first generators) ring)
				     for e in (rest generators)								     for e in (rest generators)
				     do (setq g (gcd g (coerce e ring)))						     do (setq g (gcd g (coerce e ring)))
					finally (return g)))))									finally (return g)))))

(defmethod reduce-basis ((id PID-ideal))						(defmethod reduce-basis ((id PID-ideal))
  id)											  id)

(defmethod plus ((id1 ideal) (id2 ideal))						(defmethod plus ((id1 ideal) (id2 ideal))
  (cond ((and (eql (ring-of id1) (ring-of id2))						  (cond ((and (eql (ring-of id1) (ring-of id2))
	      (eql (coefficient-domain-of id1) (coefficient-domain-of id2)))			      (eql (coefficient-domain-of id1) (coefficient-domain-of id2)))
	 (apply #'make-ideal (ring-of id1)							 (apply #'make-ideal (ring-of id1)
		(append (generators-of id1) (generators-of id2))))					(append (generators-of id1) (generators-of id2))))
	(t (call-next-method))))								(t (call-next-method))))

(defmethod times ((id1 ideal) (id2 ideal))						(defmethod times ((id1 ideal) (id2 ideal))
  (cond ((and (eql (ring-of id1) (ring-of id2))						  (cond ((and (eql (ring-of id1) (ring-of id2))
	      (eql (coefficient-domain-of id1) (coefficient-domain-of id2)))			      (eql (coefficient-domain-of id1) (coefficient-domain-of id2)))
	 (apply #'make-ideal (ring-of id1)							 (apply #'make-ideal (ring-of id1)
		(loop for e1 in (generators-of id1)							(loop for e1 in (generators-of id1)
		      append (loop for e2 in (generators-of id2)					      append (loop for e2 in (generators-of id2)
				   collect (* e1 e2)))))								   collect (* e1 e2)))))
	(t (call-next-method))))								(t (call-next-method))))

(defmethod binary= ((id1 ideal) (id2 ideal))						(defmethod binary= ((id1 ideal) (id2 ideal))
  (or (eql id1 id2)									  (or (eql id1 id2)
      (loop with id2-gen = (generators-of id2)						      (loop with id2-gen = (generators-of id2)
	    for p in (generators-of id1)							    for p in (generators-of id1)
	    do (unless (member p id2-gen :test #'binary=)					    do (unless (member p id2-gen :test #'binary=)
		 (return nil))										 (return nil))
	    finally (return t))))								    finally (return t))))
		     											     

(defmacro with-grobner-operations (grobner-basis &body body)				(defmacro with-grobner-operations (grobner-basis &body body)
  `(with-slots (greater-function ring generators undones reducibles possibles)		  `(with-slots (greater-function ring generators undones reducibles possibles)
	       ,grobner-basis									       ,grobner-basis
     (let ((dim (cl:1+ (length (ring-variables ring)))))				     (let ((dim (cl:1+ (length (ring-variables ring)))))
       (macrolet ((e> (a b) `(%funcall greater-function ,a ,b))				       (macrolet ((e> (a b) `(%funcall greater-function ,a ,b))
		  (e< (a b) `(%funcall greater-function ,b ,a)))					  (e< (a b) `(%funcall greater-function ,b ,a)))
	 ,@body))))										 ,@body))))

;; Grobner calculations are done within the context of an instance of			;; Grobner calculations are done within the context of an instance of
;; the Grobner-Basis flavor.  Each instance has its own variable list			;; the Grobner-Basis flavor.  Each instance has its own variable list
;; and flags sets.  At any time the user can add polynomials or				;; and flags sets.  At any time the user can add polynomials or
;; extract information from the structure.						;; extract information from the structure.

#|  ;; The following is actually in algebraic-domains.lisp |				#|  ;; The following is actually in algebraic-domains.lisp |
(defclass grobner-basis (ideal has-comparison)						(defclass grobner-basis (ideal has-comparison)
  (;; The exponent comparison function is managed by HAS-COMPARISON			  (;; The exponent comparison function is managed by HAS-COMPARISON

   (undones :initform ())								   (undones :initform ())
   ;; A list of triples pairs (lt f g), lt(f)<=lt(g), of elements of			   ;; A list of triples pairs (lt f g), lt(f)<=lt(g), of elements of
   ;; GENERATORS such that if any pair is not in the list, its s-poly			   ;; GENERATORS such that if any pair is not in the list, its s-poly
   ;; is guaranteed to be writable as a linear combination of				   ;; is guaranteed to be writable as a linear combination of
   ;; GENERATORS, with smaller s-degs							   ;; GENERATORS, with smaller s-degs
   											   
   (reducibles :initform nil :accessor reducibles-of)					   (reducibles :initform nil :accessor reducibles-of)
   (possibles :initform nil)								   (possibles :initform nil)	
   ))											   ))
||#											||#

(defmethod initialize-instance :after ((gb grobner-basis) &rest ignore)			(defmethod initialize-instance :after ((gb grobner-basis) &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (with-slots (greater-function ring) gb						  (with-slots (greater-function ring) gb
    (setq greater-function 								    (setq greater-function 
	  (get-comparison-fun (length (ring-variables ring))					  (get-comparison-fun (length (ring-variables ring))
			      greater-function))))								      greater-function))))

(defun check-same-domain (exprs)							(defun check-same-domain (exprs)
  (let ((domain (domain-of (first exprs))))						  (let ((domain (domain-of (first exprs))))
    (loop for exp in (rest exprs)							    (loop for exp in (rest exprs)
	  do (unless (eql domain (domain-of exp))						  do (unless (eql domain (domain-of exp))
	       (return nil))									       (return nil))
	  finally (return domain))))								  finally (return domain))))


(defmethod make-ideal ((ring polynomial-ring) &rest polys)				(defmethod make-ideal ((ring polynomial-ring) &rest polys)
  (let (ideal)										  (let (ideal)
    (cond ((field? (coefficient-domain-of ring))					    (cond ((field? (coefficient-domain-of ring))
	   (setq ideal (make-instance 'grobner-basis :ring ring					   (setq ideal (make-instance 'grobner-basis :ring ring
				      :greater-function :lexical)))							      :greater-function :lexical)))
	  (t (error "Can't deal with polynomials not over fields: ~S"				  (t (error "Can't deal with polynomials not over fields: ~S"
		    ring))) 										    ring))) 
    (loop for p in polys								    (loop for p in polys
	  do (add-relation ideal (coerce p ring)))						  do (add-relation ideal (coerce p ring)))
    ideal))										    ideal))

(defmethod (setf greater-function) (new-function (grob grobner-basis))			(defmethod (setf greater-function) (new-function (grob grobner-basis))
  (with-slots (ring greater-function generators reducibles possibles) grob		  (with-slots (ring greater-function generators reducibles possibles) grob
    (unless (eql greater-function new-function) 					    (unless (eql greater-function new-function) 
      (flet ((convert-list (list) 							      (flet ((convert-list (list) 
	       (loop for poly in list 								       (loop for poly in list 
		     collect (sort poly new-function))))						     collect (sort poly new-function))))
	(unless (functionp new-function)							(unless (functionp new-function)
	  (setq new-function									  (setq new-function
		(get-comparison-fun (length (ring-variables ring))					(get-comparison-fun (length (ring-variables ring))
				    new-function)))									    new-function)))
	(setq generators (convert-list generators))						(setq generators (convert-list generators))
	(setq reducibles (convert-list reducibles))						(setq reducibles (convert-list reducibles))
	(setq possibles (convert-list possibles))						(setq possibles (convert-list possibles))
	(setq greater-function new-function)))							(setq greater-function new-function)))
    grob))										    grob))

(defmethod add-relation ((grob-struct grobner-basis)				    |	(defgeneric add-relation (basis poly)
			 (relation (or mpolynomial epolynomial)))		    |	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
										    >	(defmethod add-relation ((grob-struct grobner-basis) (relation mpolynomial))
										    >	  (let ((ring (ring-of grob-struct)))
										    >	    (if (not (eql ring (domain-of relation)))
										    >		(add-relation grob-struct (coerce relation ring)))
										    >	    (let ((poly (make-epolynomial ring (greater-function-of grob-struct)
										    >					  relation)))
										    >	      (push (poly-form poly) (reducibles-of grob-struct))
										    >	      poly)))
										    >
										    >	(defmethod add-relation ((grob-struct grobner-basis) (relation epolynomial))
  (let ((ring (ring-of grob-struct)))							  (let ((ring (ring-of grob-struct)))
    (if (not (eql ring (domain-of relation)))						    (if (not (eql ring (domain-of relation)))
	(add-relation grob-struct (coerce relation ring)))					(add-relation grob-struct (coerce relation ring)))
    (let ((poly (make-epolynomial ring (greater-function-of grob-struct)		    (let ((poly (make-epolynomial ring (greater-function-of grob-struct)
				  relation)))										  relation)))
      (push (poly-form poly) (reducibles-of grob-struct))				      (push (poly-form poly) (reducibles-of grob-struct))
      poly)))										      poly)))

(defmethod generators-of ((grob-struct grobner-basis))					(defmethod generators-of ((grob-struct grobner-basis))
  (with-slots (generators reducibles greater-function ring) grob-struct			  (with-slots (generators reducibles greater-function ring) grob-struct
    (append										    (append
      (loop for g in generators								      (loop for g in generators
	    collect (make-instance 'epolynomial							    collect (make-instance 'epolynomial
				   :domain ring										   :domain ring
				   :greater-function greater-function							   :greater-function greater-function
				   :form g))										   :form g))
      (loop for g in reducibles								      (loop for g in reducibles
	    collect (make-instance 'epolynomial							    collect (make-instance 'epolynomial
				   :domain ring										   :domain ring
				   :greater-function greater-function							   :greater-function greater-function
				   :form g)))))										   :form g)))))

(defmethod reset-grobner-basis ((grob-struct grobner-basis))				(defmethod reset-grobner-basis ((grob-struct grobner-basis))
  (with-slots (generators undones possibles reducibles) grob-struct			  (with-slots (generators undones possibles reducibles) grob-struct
    (setq generators nil undones nil							    (setq generators nil undones nil
	  possibles nil reducibles nil)))							  possibles nil reducibles nil)))

#+Ignore										#+Ignore
(defun terms-s-poly (greater-function terms1 terms2)					(defun terms-s-poly (greater-function terms1 terms2)
  (let ((m (max (le terms1) (le terms2))))						  (let ((m (max (le terms1) (le terms2))))
    (gterms-difference greater-function							    (gterms-difference greater-function
     (gterms-mon-times terms1 (- m (le terms1)) (lc terms2))				     (gterms-mon-times terms1 (- m (le terms1)) (lc terms2))
     (gterms-mon-times terms2 (- m (le terms2)) (lc terms1)))))				     (gterms-mon-times terms2 (- m (le terms2)) (lc terms1)))))

;; The following saves a bunch of consing, but not as much as I would expect		;; The following saves a bunch of consing, but not as much as I would expect
(defun terms-s-poly (greater-function terms1 terms2)					(defun terms-s-poly (greater-function terms1 terms2)
  #+Lucid										  #+Lucid
  (declare (optimize (safety 0)))							  (declare (optimize (safety 0)))
  (let* ((dim (length (first terms1))) 							  (let* ((dim (length (first terms1))) 
	 (m (gterm-lcm (lt terms1) (lt terms2) dim))						 (m (gterm-lcm (lt terms1) (lt terms2) dim))
	 (ans-terms (list nil))									 (ans-terms (list nil))
	 (terms ans-terms)									 (terms ans-terms)
	 (x (red terms1))									 (x (red terms1))
	 (y (red terms2))									 (y (red terms2))
	 (xe (gterm-quot m (lt terms1) dim))							 (xe (gterm-quot m (lt terms1) dim))
	 (xc (svref (lt terms2) 0))								 (xc (svref (lt terms2) 0))
	 (ye (gterm-quot m (lt terms2) dim))							 (ye (gterm-quot m (lt terms2) dim))
	 (yc (- (svref (lt terms1) 0)))								 (yc (- (svref (lt terms1) 0)))
	 temp sum new-xe new-ye)								 temp sum new-xe new-ye)
    (loop										    (loop
      (cond ((terms0? x)								      (cond ((terms0? x)
	     (cond ((terms0? y) (return (rest ans-terms)))					     (cond ((terms0? y) (return (rest ans-terms)))
		   (t (setq temp (gterm-times ye (lt y) dim))						   (t (setq temp (gterm-times ye (lt y) dim))
		      (setf (svref temp 0) (* yc (svref (lt y) 0)))					      (setf (svref temp 0) (* yc (svref (lt y) 0)))
		      (setf (rest terms) (list temp))							      (setf (rest terms) (list temp))
		      (setf terms (rest terms))								      (setf terms (rest terms))
		      (setq y (red y)))))								      (setq y (red y)))))
	    ((or (terms0? y)									    ((or (terms0? y)
		 (%funcall greater-function								 (%funcall greater-function
			   (setq new-xe (gterm-times xe (lt x) dim))						   (setq new-xe (gterm-times xe (lt x) dim))
			   (setq new-ye (gterm-times ye (lt y) dim))))						   (setq new-ye (gterm-times ye (lt y) dim))))
	     (setq temp (gterm-times xe (lt x) dim))						     (setq temp (gterm-times xe (lt x) dim))
	     (setf (svref temp 0) (* xc (svref (lt x) 0)))					     (setf (svref temp 0) (* xc (svref (lt x) 0)))
	     (setf (rest terms) (list temp))							     (setf (rest terms) (list temp))
	     (setf terms (rest terms))								     (setf terms (rest terms))
	     (setq x (red x)))									     (setq x (red x)))
	    ((%funcall greater-function new-ye new-xe)						    ((%funcall greater-function new-ye new-xe)
	     (setf (svref new-ye 0) (* yc (svref (lt y) 0)))					     (setf (svref new-ye 0) (* yc (svref (lt y) 0)))
	     (setf (rest terms) (list new-ye))							     (setf (rest terms) (list new-ye))
	     (setf terms (rest terms))								     (setf terms (rest terms))
	     (setq y (red y)))									     (setq y (red y)))
	    (t (setq sum (+ (* xc (svref (lt x) 0))						    (t (setq sum (+ (* xc (svref (lt x) 0))
			    (* yc (svref (lt y) 0))))								    (* yc (svref (lt y) 0))))
	       (unless (0? sum)									       (unless (0? sum)
		 (setf (svref new-xe 0) sum)								 (setf (svref new-xe 0) sum)
		 (setf (rest terms) (list new-xe))							 (setf (rest terms) (list new-xe))
		 (setf terms (rest terms)))								 (setf terms (rest terms)))
	       (setq x (red x) y (red y)))))))							       (setq x (red x) y (red y)))))))

(defmethod reduce-basis ((grob-struct grobner-basis))					(defmethod reduce-basis ((grob-struct grobner-basis))
  (with-grobner-operations grob-struct							  (with-grobner-operations grob-struct
    (flet ((criterion1 (degree f1 f2)							    (flet ((criterion1 (degree f1 f2)
	     (loop for p in generators do							     (loop for p in generators do
	       (when (and (not (eql p f1))							       (when (and (not (eql p f1))
			  (not (eql p f2))									  (not (eql p f2))
			  (gterm-dominates degree (lt p) dim))							  (gterm-dominates degree (lt p) dim))
		 (unless (member nil undones								 (unless (member nil undones
				 :test											 :test
				 #'(lambda (x prod)									 #'(lambda (x prod)
				     (declare (ignore x))								     (declare (ignore x))
				     (let ((b1 (second prod))								     (let ((b1 (second prod))
					   (b2 (third prod)))									   (b2 (third prod)))
					  (or (and (eql f1 b1) (eql p b2))							  (or (and (eql f1 b1) (eql p b2))
					      (and (eql f1 b2) (eql p b1))							      (and (eql f1 b2) (eql p b1))
					      (and (eql p b1) (eql f2 b2))							      (and (eql p b1) (eql f2 b2))
					      (and (eql p b2) (eql f2 b1))))))							      (and (eql p b2) (eql f2 b1))))))
		   (return-from criterion1 t))))))							   (return-from criterion1 t))))))
      (let (temp f1 f2 h)								      (let (temp f1 f2 h)
	(reduce-all grob-struct)								(reduce-all grob-struct)
	(new-basis grob-struct)									(new-basis grob-struct)
      	(loop while undones do								      	(loop while undones do
          (setq temp (pop undones))							          (setq temp (pop undones))
	  (setq f1 (second temp) f2 (third temp))						  (setq f1 (second temp) f2 (third temp))
	  (when (and (null (criterion1 (first temp) f1 f2))					  (when (and (null (criterion1 (first temp) f1 f2))
		     (not (gterm-disjoint (lt f1) (lt f2) dim)))					     (not (gterm-disjoint (lt f1) (lt f2) dim)))
	    (setq h (terms-reduce greater-function						    (setq h (terms-reduce greater-function
				  (gterms-prim*										  (gterms-prim*
				   (terms-s-poly greater-function f1 f2))						   (terms-s-poly greater-function f1 f2))
				  generators))										  generators))
	    (when (not (terms0? h))								    (when (not (terms0? h))
	      (setq reducibles nil)								      (setq reducibles nil)
	      (setq possibles (list h))								      (setq possibles (list h))
	      (setq generators									      (setq generators
		    (loop for g in generators								    (loop for g in generators
			  when (gterm-dominates (lt g) (lt h) dim)						  when (gterm-dominates (lt g) (lt h) dim)
			    do (push g reducibles)								    do (push g reducibles)
			  else collect g))									  else collect g))
	      (setq undones									      (setq undones
		    (loop for undone in undones								    (loop for undone in undones
			  unless (or (member (second undone) reducibles)					  unless (or (member (second undone) reducibles)
				     (member (third undone) reducibles))						     (member (third undone) reducibles))
			    collect undone)) 									    collect undone)) 
	      (reduce-all grob-struct)								      (reduce-all grob-struct)
	      (new-basis grob-struct)))))))							      (new-basis grob-struct)))))))
  grob-struct)										  grob-struct)

										    >	(defgeneric reduce-all (basis)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
;; This makes sure that all of the polynomials in generators and			;; This makes sure that all of the polynomials in generators and
;; possibles are AUTOREDUCED.								;; possibles are AUTOREDUCED.
(defmethod reduce-all ((grob-struct grobner-basis))					(defmethod reduce-all ((grob-struct grobner-basis))
  (with-grobner-operations grob-struct							  (with-grobner-operations grob-struct
    (let (h g0)										    (let (h g0)
      (loop while (not (null reducibles)) do						      (loop while (not (null reducibles)) do
        (setq h (terms-reduce greater-function						        (setq h (terms-reduce greater-function
			      (pop reducibles)									      (pop reducibles)
			      (append generators possibles)))							      (append generators possibles)))
	(unless (terms0? h)									(unless (terms0? h)
	  (setq generators (loop for elt in generators 						  (setq generators (loop for elt in generators 
				 when (gterm-dominates (lt elt) (lt h) dim)						 when (gterm-dominates (lt elt) (lt h) dim)
				   do (push elt reducibles)								   do (push elt reducibles)
				      (push elt g0)									      (push elt g0)
				 else collect elt))									 else collect elt))
	  (setq possibles (loop for elt in possibles						  (setq possibles (loop for elt in possibles
				when (gterm-dominates (lt elt) (lt h) dim)						when (gterm-dominates (lt elt) (lt h) dim)
				  do (push elt reducibles)								  do (push elt reducibles)
				else collect elt))									else collect elt))
	  (setq undones (loop for (nil f1 f2) in undones					  (setq undones (loop for (nil f1 f2) in undones
			      when (and (not (member f1 g0))							      when (and (not (member f1 g0))
					(not (member f2 g0)))									(not (member f2 g0)))
				collect (list (gterm-lcm (lt f1) (lt f2) dim)						collect (list (gterm-lcm (lt f1) (lt f2) dim)
					      f1 f2)))										      f1 f2)))
	  (push h possibles))))))								  (push h possibles))))))
										    >
										    >	(defgeneric new-basis (basis)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))

(defmethod new-basis ((grob-struct grobner-basis))					(defmethod new-basis ((grob-struct grobner-basis))
  (with-grobner-operations grob-struct							  (with-grobner-operations grob-struct
    (flet ((add-undone (f g)								    (flet ((add-undone (f g)
	     (when (e> (lt f) (lt g))								     (when (e> (lt f) (lt g))
	       (rotatef f g))									       (rotatef f g))
	     (loop for (nil ff gg) in undones							     (loop for (nil ff gg) in undones
		   do (when (and (eql ff f) (eq gg g))							   do (when (and (eql ff f) (eq gg g))
			(return t))										(return t))
		   finally (push (list (gterm-lcm (lt f) (lt g) dim) f g)				   finally (push (list (gterm-lcm (lt f) (lt g) dim) f g)
				 undones))))										 undones))))
      (setq generators (append generators possibles))					      (setq generators (append generators possibles))
      (loop for g in generators do							      (loop for g in generators do
	(loop for elt in possibles do								(loop for elt in possibles do
	  (when (not (eql elt g))								  (when (not (eql elt g))
	    (add-undone elt g))))								    (add-undone elt g))))
      (setq possibles nil)								      (setq possibles nil)
      (setq undones (sort undones #'(lambda (a b) (e< (first a) (first b)))))		      (setq undones (sort undones #'(lambda (a b) (e< (first a) (first b)))))
      #+ignore										      #+ignore
      (setq generators									      (setq generators
	    (loop for g in generators								    (loop for g in generators
		  for h = (terms-reduce greater-function g (remove g generators))			  for h = (terms-reduce greater-function g (remove g generators))
		  when (not (terms0? h))								  when (not (terms0? h))
		    collect h)))))									    collect h)))))

;; Reduce terms modulo the current basis						;; Reduce terms modulo the current basis
(defun terms-reduce (greater-function terms basis)					(defun terms-reduce (greater-function terms basis)
  (let ((dim (length (first terms))))							  (let ((dim (length (first terms))))
    #+ignore										    #+ignore
    (format t "~&~%Poly = ~S~%Basis: "							    (format t "~&~%Poly = ~S~%Basis: "
	    (le terms))										    (le terms))
    #+ignore										    #+ignore
    (princ (mapcar #'(lambda (f) (le f)) basis))					    (princ (mapcar #'(lambda (f) (le f)) basis))
    (let ((again t))									    (let ((again t))
      (loop while again do								      (loop while again do
	(when (terms0? terms)									(when (terms0? terms)
	  (return nil))										  (return nil))
	#+ignore										#+ignore
	(format t "~&Terms = ~S"								(format t "~&Terms = ~S"
		(make-instance 'epolynomial								(make-instance 'epolynomial
			       :domain (slot-value grob-struct 'ring)						       :domain (slot-value grob-struct 'ring)
			       :greater-function greater-function						       :greater-function greater-function
			       :form terms))									       :form terms))
	(loop for g in basis									(loop for g in basis
	      do (when (gterm-dominates (lt terms) (lt g) dim)					      do (when (gterm-dominates (lt terms) (lt g) dim)
		   (setq terms (gterms-prim*								   (setq terms (gterms-prim*
				 (terms-s-poly greater-function terms g)))						 (terms-s-poly greater-function terms g)))
		   (return t))										   (return t))
	      finally (setq again nil))))							      finally (setq again nil))))
    #+ignore										    #+ignore
    (format t "~&Result = ~S~%" (le terms))						    (format t "~&Result = ~S~%" (le terms))
    terms))										    terms))

;; Make poly primitive.  								;; Make poly primitive.  
;; This isn't really well defined since coefs are in a field.  Idea is			;; This isn't really well defined since coefs are in a field.  Idea is
;; to make the coefficients smaller.  Its really worth avoiding				;; to make the coefficients smaller.  Its really worth avoiding
;; dividing out a content of 1!!!							;; dividing out a content of 1!!!
#+ignore  ;; Use for integral domains							#+ignore  ;; Use for integral domains
(defun gterms-prim* (poly) 								(defun gterms-prim* (poly) 
  (unless (terms0? poly)								  (unless (terms0? poly)
    (let ((coef-domain (domain-of (lc poly)))						    (let ((coef-domain (domain-of (lc poly)))
	  (num-gcd (numerator (lc poly)))							  (num-gcd (numerator (lc poly)))
	  (den-gcd (denominator (lc poly)))							  (den-gcd (denominator (lc poly)))
	  1/content)										  1/content)
      ;; Should really use a probabilistic algorithm content algorithm			      ;; Should really use a probabilistic algorithm content algorithm
      ;; here										      ;; here
      (map-over-each-term (red poly) (nil c)						      (map-over-each-term (red poly) (nil c)
	(if (1? num-gcd)									(if (1? num-gcd)
	    (if (1? den-gcd) (return t)								    (if (1? den-gcd) (return t)
		(setq den-gcd (gcd den-gcd (denominator c))))						(setq den-gcd (gcd den-gcd (denominator c))))
	    (if (1? den-gcd)									    (if (1? den-gcd)
		(setq num-gcd (gcd num-gcd (numerator c)))						(setq num-gcd (gcd num-gcd (numerator c)))
		(setq num-gcd (gcd num-gcd (numerator c))						(setq num-gcd (gcd num-gcd (numerator c))
		      den-gcd (gcd den-gcd (denominator c))))))						      den-gcd (gcd den-gcd (denominator c))))))
      (unless (and (1? num-gcd) (1? den-gcd))						      (unless (and (1? num-gcd) (1? den-gcd))
	(setq 1/content (make-quotient-element coef-domain den-gcd num-gcd))			(setq 1/content (make-quotient-element coef-domain den-gcd num-gcd))
	(map-over-each-term poly (e c)								(map-over-each-term poly (e c)
	  (update-term e (* c 1/content))))))							  (update-term e (* c 1/content))))))
  poly)											  poly)

;; Use for fields									;; Use for fields
(defun gterms-prim* (poly)								(defun gterms-prim* (poly)
  (unless (terms0? poly)								  (unless (terms0? poly)
    (let ((1/lc (/ (svref (lt poly) 0))))						    (let ((1/lc (/ (svref (lt poly) 0))))
      (unless (1? 1/lc)									      (unless (1? 1/lc)
	(loop for term in poly									(loop for term in poly
	      do (setf (svref term 0) (* (svref term 0) 1/lc))))))				      do (setf (svref term 0) (* (svref term 0) 1/lc))))))
  poly)											  poly)
;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*- 		;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*- 
;;; ===========================================================================		;;; ===========================================================================
;;;				 Lisp Numbers 						;;;				 Lisp Numbers 
;;; ===========================================================================		;;; ===========================================================================
;;; (c) Copyright 1989, 1993 Cornell University						;;; (c) Copyright 1989, 1993 Cornell University

;;; lisp-numbers.lisp,v 1.6 1995/05/24 17:42:03 rz Exp					;;; lisp-numbers.lisp,v 1.6 1995/05/24 17:42:03 rz Exp

(in-package "WEYLI")								    |	(in-package :weyli)

(make::adjust-version-numbers Weyl "1.6")					    |	;;; DELETE (make::adjust-version-numbers Weyl "1.6")

;; Contains a bunch of routines that allow one to use the Weyl generic			;; Contains a bunch of routines that allow one to use the Weyl generic
;; functions on Lisp numbers.  There are a number of special				;; functions on Lisp numbers.  There are a number of special
;; arithmetic routines here also.  This is in not in LISP-SUPPORT			;; arithmetic routines here also.  This is in not in LISP-SUPPORT
;; because it is more convenient to put write this code in the WEYLI			;; because it is more convenient to put write this code in the WEYLI
;; package. 										;; package. 

;; The Lisp number domain is a special field whose elements are				;; The Lisp number domain is a special field whose elements are
;; represented as Lisp numbers.  This class is unique.					;; represented as Lisp numbers.  This class is unique.

(defmethod numerator ((r integer))						    |	(defgeneric numerator (number)
  r)										    |	  (:documentation
										    |	   "Return the numerator of the number.")
(defmethod denominator ((r integer))						    |	  (:method ((number integer)) number)
  1)										    |	  (:method ((number ratio)) (common-lisp:numerator number)))
										    |
(defmethod numerator ((r ratio))						    |	(defgeneric denominator (number)
  (cl:numerator r))								    |	  (:documentation
										    |	   "Return the denominator of the number.")
(defmethod denominator ((r ratio))						    |	  (:method ((number integer)) 1)
  (cl:denominator r))								    |	  (:method ((number ratio)) (common-lisp:denominator number)))
										    >
										    >	(defgeneric factorial (number)
										    >	  (:documentation
										    >	   "Return the factorial of the number."))

(defmethod factorial ((n integer))							(defmethod factorial ((n integer))
  (labels ((fact (n)									  (labels ((fact (n)
	     (if (cl:< n 2) 1									     (if (cl:< n 2) 1
		 (cl:* n (fact (cl:1- n))))))								 (cl:* n (fact (cl:1- n))))))
    (if (cl:minusp n)									    (if (cl:minusp n)
	(error "Illegal argument to factorial: ~D" n)						(error "Illegal argument to factorial: ~D" n)
	(fact n))))										(fact n))))

										    >	(defgeneric pochhammer (number1 number2)
										    >	  (:documentation
										    >	   "Return the falling, or lower, factorial."))
										    >
(defmethod pochhammer ((n integer) (k integer))						(defmethod pochhammer ((n integer) (k integer))
  (cond ((cl:minusp k)									  (cond ((cl:minusp k)
	 (error "Illegal arguments to Pochhammer: (~D, ~D)"					 (error "Illegal arguments to Pochhammer: (~D, ~D)"
		n k))											n k))
	((cl:zerop k) 1)									((cl:zerop k) 1)
	(t (let ((ans n))									(t (let ((ans n))
	     (loop for i upfrom 1 below k							     (loop for i upfrom 1 below k
		   do (setq ans (cl:* ans (cl:+ n i))))							   do (setq ans (cl:* ans (cl:+ n i))))
	     ans))))										     ans))))

(defmethod combinations ((n integer) (m integer))				    |	(defgeneric combinations (number1 number2)
  (cl:/ (pochhammer (+  n (- m) 1) m) (factorial m)))				    |	  (:documentation
  										    |	   "Return a combination of the upper and lower factorial.")
										    >	  (:method ((number1 integer) (number2 integer))
										    >	    (common-lisp:/ (pochhammer (+  number1 (- number2) 1) number2) (factorial numb

(defun faster-isqrt (n)									(defun faster-isqrt (n)
  (let (n-len-quarter n-half n-half-isqrt init-value q r iterated-value)	    <
    "argument n must be a non-negative integer"						  "Argument n must be a non-negative integer"
										    >	  (let (n-len-quarter n-half n-half-isqrt init-value q r iterated-value)
    (cond										    (cond
      ((> n 24)										      ((> n 24)
       ;; theoretically (> n 7) ,i.e., n-len-quarter > 0				       ;; theoretically (> n 7) ,i.e., n-len-quarter > 0
       (setq n-len-quarter (ash (integer-length n) -2))					       (setq n-len-quarter (ash (integer-length n) -2))
       (setq n-half (ash n (- (ash n-len-quarter 1))))					       (setq n-half (ash n (- (ash n-len-quarter 1))))
       (setq n-half-isqrt (faster-isqrt n-half))					       (setq n-half-isqrt (faster-isqrt n-half))
       (setq init-value (ash (1+ n-half-isqrt) n-len-quarter))				       (setq init-value (ash (1+ n-half-isqrt) n-len-quarter))
       (multiple-value-setq (q r) (cl:floor n init-value))				       (multiple-value-setq (q r) (cl:floor n init-value))
       (setq iterated-value (ash (+ init-value q) -1))					       (setq iterated-value (ash (+ init-value q) -1))
       (if (eq (logbitp 0 q) (logbitp 0 init-value)) ; same sign			       (if (eq (logbitp 0 q) (logbitp 0 init-value)) ; same sign
	   ;; average is exact and we need to test the result					   ;; average is exact and we need to test the result
	   (let ((m (- iterated-value init-value)))						   (let ((m (- iterated-value init-value)))
	     (if (> (* m m) r)									     (if (> (* m m) r)
		 (- iterated-value 1)									 (- iterated-value 1)
		 iterated-value))									 iterated-value))
	   ;; average was not exact, we take value						   ;; average was not exact, we take value
	   iterated-value))									   iterated-value))
      ((> n 15) 4)									      ((> n 15) 4)
      ((> n  8) 3)									      ((> n  8) 3)
      ((> n  3) 2)									      ((> n  3) 2)
      ((> n  0) 1)									      ((> n  0) 1)
      ((> n -1) 0)									      ((> n -1) 0)
      (t nil))))									      (t nil))))

(defun integer-nth-root (x n)								(defun integer-nth-root (x n)
  (cond ((cl:zerop x) x)								  (cond ((cl:zerop x) x)
	((cl:plusp x)										((cl:plusp x)
	 (let ((n-1 (cl:- n 1))									 (let ((n-1 (cl:- n 1))
	       (root (ash 1 (cl:truncate (integer-length x) n)))				       (root (ash 1 (cl:truncate (integer-length x) n)))
	       new-root)									       new-root)
	   (loop for root^n-1 = (cl:expt root n-1)						   (loop for root^n-1 = (cl:expt root n-1)
		 do (setq new-root									 do (setq new-root
			  (cl:round (cl:+ (cl:* n-1 root root^n-1) x)						  (cl:round (cl:+ (cl:* n-1 root root^n-1) x)
				      (* n root^n-1)))					                                    (* n root^n-1)))
		    (if (cl:= new-root root)						                 (if (cl:= new-root root)
			(return new-root)						                     (return new-root)
			(setq root new-root)))))					                     (setq root new-root)))))
	((oddp n)										((oddp n)
	 (- (integer-nth-root (cl:- x) n)))							 (- (integer-nth-root (cl:- x) n)))
	(t nil)))										(t nil)))

										    >	;;; FIXME : Move the prime number related routines to a separate file
										    >	;;; and implement recent algorithms.
										    >
(defvar *pointbound* 2147483629 							(defvar *pointbound* 2147483629 
  "Should be largest prime that fits in a word")					  "Should be largest prime that fits in a word")

(defvar *big-primes* ()									(defvar *big-primes* ()
  "List of large primes by decending size")						  "List of large primes by decending size")

;; Return the next prime less than its argument, and that fits into a		    |	;; These two really should be in GFP, but because of LUCID brain damage,
;; word.  									    |	;; they have to be here to avoid warnings.
(defun newprime (&optional p)							    |
  (if (null p) *pointbound*							    |	(defun reduce-modulo-integer (value modulus)
      (do ((pl *big-primes* (cdr pl)))						    |	  (unless (cl:zerop modulus)
          ((null pl) (setq p (find-smaller-prime p))				    |	    (setq value (cl:rem value modulus)))
           (setq *big-primes* (nconc *big-primes* (list p)))			    |	  (if (cl:< value 0) (cl:+ value modulus)
           p)									    |	      value))
        (if (cl:< (car pl) p) (return (car pl))))))				    |
										    >	(defun expt-modulo-integer (base expt modulus)  
										    >	  (%funcall (repeated-squaring
										    >	             #'(lambda (a b) (reduce-modulo-integer (cl:* a b) modulus))
										    >	             1)
										    >	            base expt)) 
										    >
										    >	(defgeneric prime? (number)
										    >	  (:documentation
										    >	   "Return true if the number is prime."))
										    >
										    >	(defmethod prime? ((p integer))
										    >	  (and (cl:> p 1)
										    >	       (or (cl:< p 14.)
										    >		   (and (cl:= 1 (expt-modulo-integer 13. (1- p) p))
										    >			(cl:= 1 (expt-modulo-integer 3 (1- p) p))))
										    >	       (null (cdr (setq p (factor p))))
										    >	       (cl:= 1 (cdar p))))

;; Rabin's probabilistic primality algorithm isn't used here because it			;; Rabin's probabilistic primality algorithm isn't used here because it
;; isn't much faster than the simple one for numbers about the size of a		;; isn't much faster than the simple one for numbers about the size of a
;; word.										;; word.
(defun find-smaller-prime (p)								(defun find-smaller-prime (p)
  "Finds biggest prime less than fixnum p"						  "Finds biggest prime less than fixnum p"
  (if (evenp p) (setq p (1- p)))							  (if (evenp p) (setq p (1- p)))
  (loop for pp = (cl:- p 2) then (cl:- pp 2) until (cl:< pp 0)				  (loop for pp = (cl:- p 2) then (cl:- pp 2) until (cl:< pp 0)
	when (prime? pp)									when (prime? pp)
	  do (return pp)))								        do (return pp)))

										    >	;; Return the next prime less than its argument, and that fits into a
										    >	;; word.  
										    >	(defun newprime (&optional p)
										    >	  (if (null p) *pointbound*
										    >	      (do ((pl *big-primes* (cdr pl)))
										    >	          ((null pl) (setq p (find-smaller-prime p))
										    >	           (setq *big-primes* (nconc *big-primes* (list p)))
										    >	           p)
										    >	        (if (cl:< (car pl) p) (return (car pl))))))
										    >
;; Computes a list of primes whose product is greater than the given limit.		;; Computes a list of primes whose product is greater than the given limit.
(defun choice-primes (limit &optional							(defun choice-primes (limit &optional
				(prime-list						                      (prime-list
				  (list (find-smaller-prime				                       (list (find-smaller-prime
					  most-positive-fixnum))))			                              most-positive-fixnum))))
  (let ((p (car prime-list)))								  (let ((p (car prime-list)))
       (if (< limit p)									    (if (< limit p)
	   prime-list									        prime-list
	   (choice-primes (ceiling limit p)						        (choice-primes (ceiling limit p)
			  (cons (newprime p) prime-list)))))				                       (cons (newprime p) prime-list)))))

;; Computes (mod a b) symmetric around 0.  a and b are assumed to be			;; Computes (mod a b) symmetric around 0.  a and b are assumed to be
;; lisp integers.									;; lisp integers.
(defun sym-mod (a b)									(defun sym-mod (a b)
  (let* ((b (cl:abs b))									  (let* ((b (cl:abs b))
	 (c (cl:mod a b)))									 (c (cl:mod a b)))
	(if (cl:> c (cl:floor (cl:/ b 2)))						    (if (cl:> c (cl:floor (cl:/ b 2)))
	    (cl:- c b)									        (cl:- c b)
	    c)))									        c)))

(defun repeated-squaring (mult one)							(defun repeated-squaring (mult one)
  #'(lambda (base exp)								    |	  (lambda (base exp)
      (if (cl:zerop exp) one								    (if (cl:zerop exp) one
	  (let ((prod one))								        (let ((prod one))
	    (loop									          (loop
	      (if (oddp exp)								           (if (oddp exp)
		  (setq prod (%funcall mult prod base)))				               (setq prod (%funcall mult prod base)))
	      (setq exp (cl:truncate exp 2))						           (setq exp (cl:truncate exp 2))
	      (if (cl:zerop exp)							           (if (cl:zerop exp)
		  (return prod))							               (return prod))
	      (setq base (%funcall mult base base)))))))				           (setq base (%funcall mult base base)))))))

										    >	(defgeneric power-of? (number &optional opt-number)
										    >	  (:documentation
										    >	   "Return true if number is a power of opt-number."))
										    >
(defmethod power-of? ((m integer) &optional n)						(defmethod power-of? ((m integer) &optional n)
  (cond ((typep n 'integer)								  (cond ((typep n 'integer)
	 (loop for test = n then (cl:* test n)							 (loop for test = n then (cl:* test n)
	       for i upfrom 1									       for i upfrom 1
	       do (cond ((cl:= test m)								       do (cond ((cl:= test m)
			 (return (values n i)))									 (return (values n i)))
			((cl:> test m)										((cl:> test m)
			 (return nil)))))									 (return nil)))))
	(t (error "Haven't implemented the rest of the cases"))))				(t (error "Haven't implemented the rest of the cases"))))

;; These two really should be in GFP, but because of LUCID brain damage,	    <
;; they have to be here to avoid warnings.					    <
										    <
(defun reduce-modulo-integer (value modulus)					    <
  (unless (cl:zerop modulus)							    <
    (setq value (cl:rem value modulus)))					    <
  (if (cl:< value 0) (cl:+ value modulus)					    <
      value))									    <
										    <
(defun expt-modulo-integer (base expt modulus)  				    <
  (%funcall (repeated-squaring							    <
		  #'(lambda (a b) (reduce-modulo-integer (cl:* a b) modulus))	    <
		  1)								    <
		base expt)) 							    <
										    <
(defmethod prime? ((p integer))							    <
  (and (cl:> p 1)								    <
       (or (cl:< p 14.)								    <
	   (and (cl:= 1 (expt-modulo-integer 13. (1- p) p))			    <
		(cl:= 1 (expt-modulo-integer 3 (1- p) p))))			    <
       (null (cdr (setq p (factor p))))						    <
       (cl:= 1 (cdar p))))							    <
										    <
(defun all-divisors (n)								    <
  (let ((factors (factor n)))							    <
    (loop with divisors = (list 1)						    <
	  for (prime . times) in factors					    <
	  do (loop for i from 1 to times					    <
		   appending (loop for divisor in divisors			    <
				   collect (* divisor (cl:expt prime i)))	    <
		     into temp							    <
		   finally (setq divisors (append temp divisors)))		    <
	     finally (return (sort divisors #'cl:<)))))				    <
										    <
(defvar *factor-method* 'simple-integer-factor)						(defvar *factor-method* 'simple-integer-factor)

(defmacro count-multiple-integer-factors (N divisor)					(defmacro count-multiple-integer-factors (N divisor)
  `(loop with i = 0									  `(loop with i = 0
	 do (multiple-value-bind (quo rem) (cl:truncate ,N ,divisor)			    do (multiple-value-bind (quo rem) (cl:truncate ,N ,divisor)
	      (when (not (cl:zerop rem))						         (when (not (cl:zerop rem))
		(if (not (cl:zerop i))							           (if (not (cl:zerop i))
		    (push (cons ,divisor i) ans))					               (push (cons ,divisor i) ans))
		(return t))								           (return t))
	      (setq ,N quo)								         (setq ,N quo)
	      (incf i))))								         (incf i))))

										    >	(defun uniformize-factor-list (ans)
										    >	  (loop for pairs on (sort ans #'(lambda (a b) (< (first a) (first b))))
										    >		when (or (null (rest pairs))
										    >			 (not (cl:= (first (first pairs))
										    >				    (first (second pairs)))))
										    >	        collect (first pairs)
										    >		else do (incf (rest (second pairs)))))
										    >
										    >	(defgeneric factor (number)
										    >	  (:documentation
										    >	   "Return the factors of the number."))
										    >
(defmethod factor ((N integer))								(defmethod factor ((N integer))
  (let ((*factor-method* *factor-method*)						  (let ((*factor-method* *factor-method*)
	ans factors)										ans factors)
    (when (cl:minusp N)									    (when (cl:minusp N)
      (push (cons -1 1) ans)								      (push (cons -1 1) ans)
      (setq N (cl:- N)))								      (setq N (cl:- N)))
    (count-multiple-integer-factors N 2)						    (count-multiple-integer-factors N 2)
    (count-multiple-integer-factors N 3)						    (count-multiple-integer-factors N 3)
    (count-multiple-integer-factors N 5)						    (count-multiple-integer-factors N 5)
    (unless (cl:= N 1)									    (unless (cl:= N 1)
      (loop										      (loop
	(multiple-value-setq (N factors) (%funcall *factor-method* N))				(multiple-value-setq (N factors) (%funcall *factor-method* N))
	(setq ans (append factors ans))								(setq ans (append factors ans))
	(if (cl:= N 1) (return t))))								(if (cl:= N 1) (return t))))
    (uniformize-factor-list ans)))							    (uniformize-factor-list ans)))

(defun uniformize-factor-list (ans)						    |	(defun all-divisors (n)
  (loop for pairs on (sort ans #'(lambda (a b) (< (first a) (first b))))	    |	  (let ((factors (factor n)))
	when (or (null (rest pairs))						    |	    (loop with divisors = (list 1)
		 (not (cl:= (first (first pairs))				    |		  for (prime . times) in factors
			    (first (second pairs)))))				    |		  do (loop for i from 1 to times
	  collect (first pairs)							    |			   appending (loop for divisor in divisors
	else do (incf (rest (second pairs)))))					    |					   collect (* divisor (cl:expt prime i)))
										    >	                   into temp
										    >			   finally (setq divisors (append temp divisors)))
										    >	          finally (return (sort divisors #'cl:<)))))

;; In general each factorization method should return just one factor.			;; In general each factorization method should return just one factor.

(defvar *skip-chain-for-3-and-5* (circular-list 4 2 4 2 4 6 2 6))			(defvar *skip-chain-for-3-and-5* (circular-list 4 2 4 2 4 6 2 6))

(defun simple-integer-factor (N)							(defun simple-integer-factor (N)
  (let ((increments *skip-chain-for-3-and-5*)						  (let ((increments *skip-chain-for-3-and-5*)
	(divisor 7)										(divisor 7)
	ans)											ans)
    (flet ((simple-integer-factor-internal (N)						    (flet ((simple-integer-factor-internal (N)
	     (let ((limit (cl:isqrt N)))							     (let ((limit (cl:isqrt N)))
	       (loop 										       (loop 
		 (cond ((cl:= N 1)							                (cond ((cl:= N 1)
			(return (values N ans)))					                       (return (values N ans)))
		       ((cl:> divisor limit)						                      ((cl:> divisor limit)
			(return (values 1 (cons (cons N 1) ans))))			                       (return (values 1 (cons (cons N 1) ans))))
		       (t (count-multiple-integer-factors N divisor)))			                      (t (count-multiple-integer-factors N divisor)))
		 (setq divisor (cl:+ divisor (pop increments)))))))      		                (setq divisor (cl:+ divisor (pop increments)))))))      
      (setq *factor-method* #'simple-integer-factor-internal)				      (setq *factor-method* #'simple-integer-factor-internal)
      (simple-integer-factor-internal N))))						      (simple-integer-factor-internal N))))

(defun fermat-integer-factor (N)							(defun fermat-integer-factor (N)
  (loop for x = (1+ (cl:isqrt N)) then (+ x 1)						  (loop for x = (1+ (cl:isqrt N)) then (+ x 1)
	for w = (cl:- (cl:* x x) N)								for w = (cl:- (cl:* x x) N)
	for y = (cl:isqrt w)									for y = (cl:isqrt w)
	do (when (cl:zerop (cl:- w (cl:* y y)))							do (when (cl:zerop (cl:- w (cl:* y y)))
	     (let ((u (cl:+ x y))								     (let ((u (cl:+ x y))
		   (v (cl:- x y)))									   (v (cl:- x y)))
	       (return (if (1? v)								       (return (if (1? v)
			   (values 1 (list (cons u 1)))								   (values 1 (list (cons u 1)))
			   (values u (factor v))))))))								   (values u (factor v))))))))
												
#| Knuth's addition-subtraction version of Fermat's algorithm |				#| Knuth's addition-subtraction version of Fermat's algorithm |

(defun fermat-integer-factor (N)							(defun fermat-integer-factor (N)
  (let* ((isqrt-N (cl:isqrt N))								  (let* ((isqrt-N (cl:isqrt N))
	 (x (1+ (* 2 isqrt-N)))									 (x (1+ (* 2 isqrt-N)))
	 (y 1)											 (y 1)
	 (r (- (* isqrt-N isqrt-N) N)))								 (r (- (* isqrt-N isqrt-N) N)))
    (loop										    (loop
      (cond ((= r 0)									      (cond ((= r 0)
	     (return 										     (return 
	       (let ((f (/ (+ x y -2) 2))							       (let ((f (/ (+ x y -2) 2))
		     (g (/ (- x y) 2)))									     (g (/ (- x y) 2)))
		 (if (= g 1)										 (if (= g 1)
		     (values 1 (list (cons f 1)))							     (values 1 (list (cons f 1)))
		     (values 1 (append (factor f) (factor g)))))))					     (values 1 (append (factor f) (factor g)))))))
	    ((< r 0)										    ((< r 0)
	     (incf r x)										     (incf r x)
	     (incf x 2)))									     (incf x 2)))
      (decf r y)									      (decf r y)
      (incf y 2))))									      (incf y 2))))

(defun list-of-primes (N)								(defun list-of-primes (N)
  (cons 2										  (cons 2
	(loop for p upfrom 3 by 2 below N							(loop for p upfrom 3 by 2 below N
	      when (prime? p) collect p)))							      when (prime? p) collect p)))

(defun make-integer-GCD-list (max-prime size-limit)					(defun make-integer-GCD-list (max-prime size-limit)
  (let ((GCD-list ()))									  (let ((GCD-list ()))
    (loop for p in (list-of-primes max-prime)						    (loop for p in (list-of-primes max-prime)
	  with prod = 1 and prime-list = ()							  with prod = 1 and prime-list = ()
	  do (setq prod (* prod p))								  do (setq prod (* prod p))
	     (cond ((> prod size-limit)								     (cond ((> prod size-limit)
		    (push (list (/ prod p) prime-list)							    (push (list (/ prod p) prime-list)
			  GCD-list)										  GCD-list)
		    (setq prod p)									    (setq prod p)
		    (setq prime-list (list p)))								    (setq prime-list (list p)))
		   (t (push p prime-list))))								   (t (push p prime-list))))
    GCD-list))										    GCD-list))

	    											    
||#											||#

(defun totient (x)									(defun totient (x)
  (do ((factors (factor x) (rest factors))						  (do ((factors (factor x) (rest factors))
       (totient 1 (cl:* totient								       (totient 1 (cl:* totient
			  (cl:- (cl:expt (caar factors) (cdar factors))			                        (cl:- (cl:expt (caar factors) (cdar factors))
				  (cl:expt (caar factors) (1- (cdar factors)))))))	                              (cl:expt (caar factors) (1- (cdar factors)))))))
      ((null factors)									      ((null factors)
       totient)))									       totient)))

(defmethod sin ((x number))							    |	(defgeneric sin (number)
  (cl:sin x))									    |	  (:documentation
										    |	   "Return the sine of the number.")
(defmethod cos ((x number))							    |	  (:method ((number number)) (common-lisp:sin number)))
  (cl:cos x))									    |
										    |	(defgeneric cos (number)
(defmethod tan ((x number))							    |	  (:documentation
  (cl:tan x))									    |	   "Return the cosine of the number.")
										    |	  (:method ((number number)) (common-lisp:cos number)))
(defmethod asin ((x number))							    |
  (cl:asin x))									    |	(defgeneric tan (number)
										    |	  (:documentation
(defmethod acos ((x number))							    |	   "Return the tangent of the number.")
  (cl:acos x))									    |	  (:method ((number number)) (common-lisp:tan number)))
										    |
(defmethod atan ((x number) &optional y)					    |	(defgeneric asin (number)
  (cond ((null y)								    |	  (:documentation
	 (cl:atan x))								    |	   "Return the arc-sine of the number.")
	((numberp y)								    |	  (:method ((number number)) (common-lisp:asin number)))
	 (cl:atan x y))								    |
	(t (atan (coerce x (domain-of y)) y))))					    |	(defgeneric acos (number)
										    |	  (:documentation
(defmethod sinh ((x number))							    |	   "Return the arc-cosine of the number.")
  (cl:sinh x))									    |	  (:method ((number number)) (common-lisp:acos number)))
										    |
(defmethod cosh ((x number))							    |	(defgeneric atan (number1 &optional number2)
  (cl:cosh x))									    |	  (:documentation
										    |	   "Return the arc-tangent of the number1 or optionally
(defmethod tanh ((x number))							    |	number1/number2."))
  (tanh x))									    |
										    |	;;; FIXME : This is a simple example of the motivation for predicate
(defmethod asinh ((x number))							    |	;;; dispatching as described in AITR-2001-006.
  (cl:asinh x))									    |	(defmethod atan ((number1 number) &optional number2)
										    |	  (cond
(defmethod acosh ((x number))							    |	    ((null number2)
  (cl:acosh x))									    |	     (common-lisp:atan number1))
										    |	    ((numberp number2)
(defmethod atanh ((x number))							    |	     (common-lisp:atan number1 number2))
  (cl:atanh x))									    |	    (t (atan (coerce number1 (domain-of number2)) number2))))
										    |
(defmethod exp ((x number))							    |	(defgeneric sinh (number)
  (cl:exp x))									    |	  (:documentation
										    |	   "Return the hyperbolic sine of the number.")
(defmethod log2 ((x number) (base number))					    |	  (:method ((number number)) (common-lisp:sinh number)))
  (cl:log x base))								    |
										    |	(defgeneric cosh (number)
(defmethod log ((x number))							    |	  (:documentation
  (cl:log x))									    |	   "Return the hyperbolic cosine of the number.")
										    |	  (:method ((number number)) (common-lisp:cosh number)))
(defmethod signum ((x number))							    |
  (cl:signum x))								    |	(defgeneric tanh (number)
										    >	  (:documentation
										    >	   "Return the hyperbolic tangent of the number.")
										    >	  (:method ((number number)) (common-lisp:tanh number)))
										    >
										    >	(defgeneric asinh (number)
										    >	  (:documentation
										    >	   "Return the hyperbolic arc sine of the number.")
										    >	  (:method ((number number)) (common-lisp:asinh number)))
										    >
										    >	(defgeneric acosh (number)
										    >	  (:documentation
										    >	   "Return the hyperbolic arc cosine of the number.")
										    >	  (:method ((number number)) (common-lisp:acosh number)))
										    >
										    >	(defgeneric atanh (number)
										    >	  (:documentation
										    >	   "Return the hyperbolic arc tangent of the number.")
										    >	  (:method ((number number)) (common-lisp:atanh number)))
										    >
										    >	(defgeneric exp (number)
										    >	  (:documentation
										    >	   "Return the exponential of the number.")
										    >	  (:method ((number number)) (common-lisp:exp number)))
										    >
										    >	;;; FIXME : The functions log2 and log need to be merged. This
										    >	;;; provides another simple example of the motivation for predicate
										    >	;;; dispatching as described in AITR-2001-006.
										    >	(defgeneric log2 (number base)
										    >	  (:documentation
										    >	   "Return the base logarithm of the number.")
										    >	  (:method ((number number) (base number)) (common-lisp:log number base)))
										    >
										    >	(defgeneric log (number)
										    >	  (:documentation
										    >	   "Return the natural logarithm of the number.")
										    >	  (:method ((number number)) (common-lisp:log number)))
										    >
										    >	(defgeneric signum (number)
										    >	  (:documentation
										    >	   "Returns a numerical value that indicates whether number is
										    >	negative, zero or positive.")
										    >	  (:method ((number number)) (common-lisp:signum number)))
;;; -*- Mode:Lisp; Package:User; Base:10; Lowercase:T; Syntax:Common-Lisp -*-		;;; -*- Mode:Lisp; Package:User; Base:10; Lowercase:T; Syntax:Common-Lisp -*-
;;; ===========================================================================		;;; ===========================================================================
;;;				  Lisp Support						;;;				  Lisp Support
;;; ===========================================================================		;;; ===========================================================================
;;; (c) Copyright 1989, 1993 Cornell University						;;; (c) Copyright 1989, 1993 Cornell University

;;; lisp-support.lisp,v 1.8 1994/10/21 18:16:43 rz Exp					;;; lisp-support.lisp,v 1.8 1994/10/21 18:16:43 rz Exp

(in-package #-ANSI-CL "USER" #+ANSI-CL "CL-USER")				    |	(in-package :common-lisp-user)

(make::adjust-version-numbers Weyl "1.8")					    |	;;Infinities...
										    >	(defvar weyli::*positive-infinity*
										    >	  #+Genera si:infinite-positive-double-float
										    >	  #+Lucid system:float-positive-infinity
										    >	  #-(or Lucid Genera) most-positive-double-float)

;; The following is done instead of importing defgeneric and			    |	(defvar weyli::*negative-infinity*
;; defmethod, to avoid muddying the user package.   				    |	  #+Genera si:infinite-negative-double-float
#+PCL										    |	  #+Lucid system:float-negative-infinity
(progn										    |	  #-(or Genera Lucid) most-negative-double-float)
  (defmacro clos-defgeneric (&rest args) `(pcl:defgeneric . ,args))		    <
  (defmacro clos-defmethod (&rest args) `(pcl:defmethod . ,args)))		    <
										    <
#+(and CLOS (not MCL))								    <
(progn										    <
  (defmacro clos-defgeneric (&rest args) `(clos::defgeneric . ,args))		    <
  (defmacro clos-defmethod (&rest args) `(clos::defmethod . ,args)))		    <
										    <
#+MCL										    <
(progn										    <
  (defmacro clos-defgeneric (&rest args) `(cl:defgeneric . ,args))		    <
  (defmacro clos-defmethod (&rest args) `(cl:defmethod . ,args)))		    <

;; Extend defmethod slightly							    |	#|

#+PCL										    |	 Extend defmethod slightly
										    >
										    >	 1. Allows the use of OR when defining the method specializer.
										    >
										    >	 DELETE : It is not clear how DEFMETHOD is being extended. Regardless,
										    >	 the code should be written to use the standard DEFMETHOD. When that is
										    >	 complete and verified, these macros should be deleted.
										    >
										    >	 This version is SBCL specific.
										    >	#+SB-PCL
(defmacro weyli::defmethod (&rest args &environment env)				(defmacro weyli::defmethod (&rest args &environment env)
  (declare (pcl:arglist name							    <
			{method-qualifier}*					    <
			specialized-lambda-list					    <
			&body body))						    <
  (labels ((duplicate-arglist (arglist)							  (labels ((duplicate-arglist (arglist)
	     (cond ((null arglist) (list nil))							     (cond ((null arglist) (list nil))
		   ((or (atom (first arglist))								   ((or (atom (first arglist))
			(null (rest (first arglist)))								(null (rest (first arglist)))
			(atom (second (first arglist)))								(atom (second (first arglist)))
			(not (eql 'or (first (second (first arglist))))))					(not (eql 'or (first (second (first arglist))))))
		    (mapcar (lambda (q) (cons (first arglist) q))					    (mapcar (lambda (q) (cons (first arglist) q))
			    (duplicate-arglist (rest arglist))))						    (duplicate-arglist (rest arglist))))
		   (t (loop for type in (rest (second (first arglist)))					   (t (loop for type in (rest (second (first arglist)))
			    with rest = (duplicate-arglist (rest arglist))					    with rest = (duplicate-arglist (rest arglist))
			    nconc (mapcar #'(lambda (q)								    nconc (mapcar #'(lambda (q)
					      (cons (list (first (first arglist)) 						      (cons (list (first (first arglist)) 
						  q))					                                                    q))
					  rest))))))										  rest))))))
    (multiple-value-bind (name qualifiers lambda-list body)				    (multiple-value-bind (name qualifiers lambda-list body)
	(pcl:parse-defmethod args)						    |		(sb-pcl::parse-defmethod args)
      (let ((proto-method (pcl:method-prototype-for-gf name)))			    |	      (multiple-value-bind (proto-gf proto-method)
										    >	          (sb-pcl::prototypes-for-make-method-lambda name)
	`(progn										        `(progn
	   ,@(loop for ll in (duplicate-arglist lambda-list)				          ,@(loop for ll in (duplicate-arglist lambda-list)
		   collect								                  collect
		     (pcl:expand-defmethod proto-method name qualifiers ll body en  |	                  (sb-pcl::expand-defmethod name proto-gf proto-method qualifiers 
										    >
										    >	#+(or MCL (and Genera CLOS))
										    >	(defun clos-parse-defmethod (form)
										    >	  (let ((name (pop form))
										    >		qualifiers)
										    >	    (loop while (and (atom (first form))
										    >			     (not (null (first form))))
										    >		  do (push (pop form) qualifiers))
										    >	    (values name (reverse qualifiers) (first form) (rest form))))

#+CLOS											#+CLOS
(defmacro weyli::defmethod (&rest args)							(defmacro weyli::defmethod (&rest args)
  #+Genera										  #+Genera
  (declare (arglist name {method-qualifier}* specialized-lambda-list			  (declare (arglist name {method-qualifier}* specialized-lambda-list
		    &body body)										    &body body)
	   (zwei:indentation . wei:indent-for-clos-defmethod))					   (zwei:indentation . wei:indent-for-clos-defmethod))
  (labels ((duplicate-arglist (arglist)							  (labels ((duplicate-arglist (arglist)
	     (cond ((null arglist) (list nil))							     (cond ((null arglist) (list nil))
		   ((or (atom (first arglist))								   ((or (atom (first arglist))
			(null (rest (first arglist)))								(null (rest (first arglist)))
			(atom (second (first arglist)))								(atom (second (first arglist)))
			(not (eql 'or (first (second (first arglist))))))					(not (eql 'or (first (second (first arglist))))))
		    (mapcar #'(lambda (q) (cons (first arglist) q))					    (mapcar #'(lambda (q) (cons (first arglist) q))
			    (duplicate-arglist (rest arglist))))						    (duplicate-arglist (rest arglist))))
		   (t (loop for type in (rest (second (first arglist)))					   (t (loop for type in (rest (second (first arglist)))
			    with rest = (duplicate-arglist (rest arglist))					    with rest = (duplicate-arglist (rest arglist))
			    nconc (mapcar #'(lambda (q)								    nconc (mapcar #'(lambda (q)
					      (cons (list (first (first arglist)) 						      (cons (list (first (first arglist)) 
						    q))											    q))
					  rest))))))										  rest))))))
    #-LispWorks										    #-LispWorks
    (multiple-value-bind (name qualifiers lambda-list body)				    (multiple-value-bind (name qualifiers lambda-list body)
          #+(or excl Lucid) (clos::parse-defmethod args)				        #+(or excl Lucid) (clos::parse-defmethod args)
	  #+(or MCL Genera) (clos-parse-defmethod args)					        #+(or MCL Genera) (clos-parse-defmethod args)
      `(progn										        `(progn
	,@(loop for ll in (duplicate-arglist lambda-list)				          ,@(loop for ll in (duplicate-arglist lambda-list)
		collect									                  collect
                #-MCL									                  #-MCL
		 `(clos::defmethod ,name ,@qualifiers ,ll ,@body)			                  `(clos::defmethod ,name ,@qualifiers ,ll ,@body)
                 #+MCL									                  #+MCL
                  `(,(if (or qualifiers ll) 'cl:defmethod 'defun) ,name ,@qualifie	                  `(,(if (or qualifiers ll) 'cl:defmethod 'defun) ,name ,@qualifie
                    ,ll ,@body))))							                    ,ll ,@body))))
    #+LispWorks										    #+LispWorks
    (let ((name (first args)))								    (let ((name (first args)))
      (multiple-value-bind (qualifiers lambda-list body)				      (multiple-value-bind (qualifiers lambda-list body)
            (clos::parse-defmethod nil name (rest args))				          (clos::parse-defmethod nil name (rest args))
        `(progn										        `(progn
	  ,@(loop for ll in (duplicate-arglist lambda-list)					  ,@(loop for ll in (duplicate-arglist lambda-list)
		  collect										  collect
  		   `(clos:defmethod ,name ,@qualifiers ,ll ,@body)))))))		                  `(clos:defmethod ,name ,@qualifiers ,ll ,@body)))))))
										    >	|#

(defmacro clos-class-direct-superclasses (c)					    |	;;; The following predicate determines if class is a subclass of super-class.
  `(#-MCL clos::class-direct-superclasses 					    |	;;; FIXME : Relies on the MOP and is SBCL specific.
    #+MCL class-direct-superclasses       ,c))					    <
										    <
;; The following predicate determines if class is a subclass of super-class.	    <
(defun weyli::subclass-of? (class super-class)						(defun weyli::subclass-of? (class super-class)
  (when (symbolp class)									  (when (symbolp class)
    (setq class (find-class class)))							    (setq class (find-class class)))
  (when (symbolp super-class)								  (when (symbolp super-class)
    (setq super-class (find-class super-class)))					    (setq super-class (find-class super-class)))
  (labels ((search-list (list)								  (labels ((search-list (list)
	     (or (member class list)								     (or (member class list)
		 (loop for c in list									 (loop for c in list
		       when (search-list (clos-class-direct-superclasses c))	    |			       when (search-list (closer-mop:class-direct-superclasses c))
			 return t))))							                       return t))))
    (or (eql class super-class)								    (or (eql class super-class)
	(search-list (clos-class-direct-superclasses super-class)))))		    |		(search-list (closer-mop:class-direct-superclasses super-class)))))
										    <
#+(or MCL (and Genera CLOS))							    <
(defun clos-parse-defmethod (form)						    <
  (let ((name (pop form))							    <
	qualifiers)								    <
    (loop while (and (atom (first form))					    <
		     (not (null (first form))))					    <
	  do (push (pop form) qualifiers))					    <
    (values name (reverse qualifiers) (first form) (rest form))))		    <
										    <
(defmacro weyli::%funcall (function &rest args)					    <
  `(cl:funcall ,function ,@args))						    <
										    <
(clos-defmethod weyli::funcall (function &rest args)				    <
  (weyli::apply function args))							    <

(defmacro weyli::%apply (function &rest args)						(defmacro weyli::%apply (function &rest args)
  `(cl:apply ,function ,@args))							    |	  `(common-lisp:apply ,function ,@args))

(defun weyli::accum-apply-args (args)							(defun weyli::accum-apply-args (args)
  (cond ((null (rest args))							    |	  (if (null (rest args))
         (first args))								    |	      (first args)
        (t (cons (first args) (weyli::accum-apply-args (rest args))))))		    |	      (cons (first args) (weyli::accum-apply-args (rest args)))))
										    |
(clos-defmethod weyli::apply (function &rest args)				    |	(defgeneric weyli::apply (function &rest args)
  (cond ((null args)								    |	  (:documentation
         (error "The function APPLY was called with too few arguments"))	    |	   "Extend the common lisp standard APPLY."))
        (t (cl:apply function (weyli::accum-apply-args args)))))		    |
										    |	(defmethod weyli::apply (function &rest args)
(defmacro weyli::%getf (place indicator &optional (default nil))		    |	  "Use the common lisp APPLY by default."
  (if default									    |	  (if (null args)
      `(cl:getf ,place ,indicator ,default)					    |	      (error "The function APPLY was called with too few arguments")
      `(cl:getf ,place ,indicator)))						    |	      (common-lisp:apply function (weyli::accum-apply-args args))))
										    <
(clos-defgeneric weyli::getf (place indicator &optional default)		    <
		 )								    <
										    <
(clos-defmethod weyli::getf (place indicator &optional (default nil))		    <
  (cl:getf place indicator default))						    <
										    <
(clos-defmethod weyli::putf (place indicator value)				    <
  (setf (cl:getf place indicator) value))					    <
										    <
(defsetf weyli::getf weyli::putf)						    <
										    <
(clos-defgeneric weyli::delete (item set &key &allow-other-keys)		    <
  )										    <
										    <
(clos-defmethod weyli::delete (item (sequence sequence) &rest args)		    <
  (apply #'cl:delete item sequence args))					    <
										    <
(clos-defgeneric weyli::member (item list &key &allow-other-keys)		    <
  )										    <

(clos-defmethod weyli::member (item (list list) &rest args)			    |	(defmacro weyli::%funcall (function &rest args)
  (apply #'cl:member item list args))						    |	  `(common-lisp:funcall ,function ,@args))
										    <
(clos-defgeneric weyli::replace (item list &key &allow-other-keys)		    <
  )										    <
										    <
(clos-defmethod weyli::replace ((item sequence) (list sequence) &rest args)	    <
  (apply #'cl:replace item list args))						    <
										    <
(clos-defgeneric weyli::substitute						    <
    (newitem olditem sequence &key &allow-other-keys)				    <
  )										    <
										    <
(clos-defmethod weyli::substitute (newitem olditem (seq sequence) &rest args)	    <
  (apply #'cl:substitute newitem olditem seq args))				    <
										    <
(clos-defgeneric weyli::map (result-type function sequence &rest sequences)	    <
  )										    <
										    <
(clos-defmethod weyli::map (result-type function sequence &rest sequences)	    <
  (apply #'cl:map result-type function sequence sequences))			    <
										    <
(clos-defgeneric weyli::reduce (function sequence &rest options)		    <
  )										    <

(clos-defmethod weyli::reduce (function (sequence sequence) &rest options)	    |	(defgeneric weyli::funcall (function &rest args)
  (apply #'cl:reduce function sequence options))				    |	  (:documentation
										    >	   "Extend the common lisp standard FUNCALL."))

(clos-defmethod weyli::union ((arg1 list) (arg2 list) &rest rest)		    |	(defmethod weyli::funcall (function &rest args)
  (apply #'cl:union arg1 arg2 rest))						    |	  "Rely on apply for performing the FUNCALL."
										    >	  (weyli::apply function args))

(clos-defmethod weyli::intersection ((arg1 list) (arg2 list) &rest rest)	    |	(defmacro weyli::%getf (place indicator &optional (default nil))
  (apply #'cl:intersection arg1 arg2 rest))					    |	  (if default
										    >	      `(common-lisp:getf ,place ,indicator ,default)
										    >	      `(common-lisp:getf ,place ,indicator)))

										    >	(defgeneric weyli::getf (place indicator &optional default)
										    >	  (:documentation
										    >	   "Extend the common lisp standard GETF."))
										    >
										    >	(defmethod weyli::getf (place indicator &optional (default nil))
										    >	  "Use the common lisp GETF by default."
										    >	  (common-lisp:getf place indicator default))
										    >
										    >	(defgeneric weyli::putf (place indicator value)
										    >	  (:documentation
										    >	   "Extend the common lisp standard PUTF."))
										    >
										    >	(defmethod weyli::putf (place indicator value)
										    >	  "Use SETF and the common list standard GETF by default."
										    >	  (setf (common-lisp:getf place indicator) value))
										    >
										    >	(defsetf weyli::getf weyli::putf
										    >	    "Define weyli::getf settable.")
										    >
										    >	(defgeneric weyli::delete (item set &key &allow-other-keys)
										    >	  (:documentation
										    >	   "Extend the common lisp standard DELETE."))
										    >
										    >	(defmethod weyli::delete (item (sequence sequence) &rest args)
										    >	  "Use the common lisp DELETE function by default."
										    >	  (apply #'common-lisp:delete item sequence args))
										    >
										    >	(defgeneric weyli::member (item list &key &allow-other-keys)
										    >	  (:documentation
										    >	   "Extend the common lisp standard member."))
										    >
										    >	(defmethod weyli::member (item (list list) &rest args)
										    >	  "Use the common lisp MEMBER function by default."
										    >	  (apply #'common-lisp:member item list args))
										    >
										    >	(defgeneric weyli::replace (item list &key &allow-other-keys)
										    >	  (:documentation
										    >	   "Extend the common lisp standard replace."))
										    >
										    >	(defmethod weyli::replace ((item sequence) (list sequence) &rest args)
										    >	  "Use the common lisp REPLACE function by default."
										    >	  (apply #'common-lisp:replace item list args))
										    >
										    >	(defgeneric weyli::substitute (newitem olditem sequence &key &allow-other-keys)
										    >	  (:documentation
										    >	   "Extend the common lisp SUBSTITUTE function."))
										    >
										    >	(defmethod weyli::substitute (newitem olditem (seq sequence) &rest args)
										    >	  "Use the common lisp SUBSTITUTE function by default."
										    >	  (apply #'common-lisp:substitute newitem olditem seq args))
										    >
										    >	(defgeneric weyli::map (result-type function sequence &rest sequences)
										    >	  (:documentation
										    >	   "Extend the common lisp MAP function."))
										    >
										    >	(defmethod weyli::map (result-type function sequence &rest sequences)
										    >	  "Use the common lisp MAP function by default."
										    >	  (apply #'common-lisp:map result-type function sequence sequences))
										    >
										    >	(defgeneric weyli::reduce (function sequence &rest options)
										    >	  (:documentation
										    >	   "Extend the common lisp REDUCE function."))
										    >
										    >	(defmethod weyli::reduce (function (sequence sequence) &rest options)
										    >	  "Use the common lisp REDUCE function for sequences."
										    >	  (apply #'common-lisp:reduce function sequence options))
										    >
										    >	(defgeneric weyli::union (arg1 arg2 &rest rest)
										    >	  (:documentation
										    >	   "Extend the common lisp UNION function."))
										    >
										    >	(defmethod weyli::union ((arg1 list) (arg2 list) &rest rest)
										    >	  "Use the common lisp UNION function for lists."
										    >	  (apply #'common-lisp:union arg1 arg2 rest))
										    >
										    >	(defgeneric weyli::intersection (arg1 arg2 &rest rest)
										    >	  (:documentation
										    >	   "Extend the common lisp INTERSECTION function."))
										    >
										    >	(defmethod weyli::intersection ((arg1 list) (arg2 list) &rest rest)
										    >	  "Use the common lisp INTERSECTION function for lists."
										    >	  (apply #'common-lisp:intersection arg1 arg2 rest))

#+Genera										#+Genera
(eval-when (compile load eval)								(eval-when (compile load eval)
  ;; Link the value cells of algebra:* and zl:*, etc.					  ;; Link the value cells of algebra:* and zl:*, etc.
  (unless (eq (locf (symbol-value 'weyli::*))						  (unless (eq (locf (symbol-value 'weyli::*))
	      (locf (symbol-value 'zl:*)))							      (locf (symbol-value 'zl:*)))
    (setq weyli::* zl:*)								    (setq weyli::* zl:*)
    (si:link-symbol-value-cells 'weyli::* 'zl:*))					    (si:link-symbol-value-cells 'weyli::* 'zl:*))
  (unless (eq (locf (symbol-value 'weyli::+))						  (unless (eq (locf (symbol-value 'weyli::+))
	      (locf (symbol-value 'zl:+)))							      (locf (symbol-value 'zl:+)))
    (setq weyli::+ zl:+)								    (setq weyli::+ zl:+)
    (si:link-symbol-value-cells 'weyli::+ 'zl:+))				    |	    (si:link-symbol-value-cells 'weyli::+ 'zl:+)))
  )										    <

#+Lucid											#+Lucid
(setf (symbol-function 'lucid-old-top-level-eval) #'lucid::top-level-eval)		(setf (symbol-function 'lucid-old-top-level-eval) #'lucid::top-level-eval)

#+Lucid											#+Lucid
(defun  lucid::top-level-eval (&rest arguments)						(defun  lucid::top-level-eval (&rest arguments)
  (declare (special weyli::* weyli::+ cl:* cl:+))					  (declare (special weyli::* weyli::+ cl:* cl:+))
  (multiple-value-prog1 (apply #'lucid-old-top-level-eval arguments)			  (multiple-value-prog1 (apply #'lucid-old-top-level-eval arguments)
    (setq weyli::* cl:*)								    (setq weyli::* cl:*)
    (setq weyli::+ cl:+)))								    (setq weyli::+ cl:+)))

										    >	;;; DELETE : defsubst is an archaic technique. It should be replaced
										    >	;;; with function definitions and, if justified, INLINE declarations.
(defmacro weyli::defsubst (function lambda-list &body body)				(defmacro weyli::defsubst (function lambda-list &body body)
  `(#+Genera scl:defsubst								  `(#+Genera scl:defsubst
    #+Lucid  lcl:defsubst								    #+Lucid  lcl:defsubst
    #-(or Genera Lucid) defun								    #-(or Genera Lucid) defun
    ,function ,lambda-list ,@body))							    ,function ,lambda-list ,@body))

;;Infinities...									    |	(defun weyli::%copy-array-contents* (from-array to-array)
										    |	  "Perform a shallow copy of the array contents."
(defvar weyli::*positive-infinity*						    |	  (if (equal (array-dimensions from-array) (array-dimensions to-array))
	#+Genera si:infinite-positive-double-float				    |	      (let ((from-flat (make-array
	#+Lucid system:float-positive-infinity					    |	                        (array-total-size from-array)
        #-(or Lucid Genera) (expt 2.0 1000))					    |	                        :element-type (array-element-type from-array)
										    |	                        :displaced-to from-array))
(defvar weyli::*negative-infinity*						    |	            (to-flat (make-array
	#+Genera si:infinite-negative-double-float				    |	                      (array-total-size to-array)
	#+Lucid system:float-negative-infinity					    |	                      :element-type (array-element-type to-array)
        #-(or Genera Lucid) (- (expt 2.0 1000)))				    |	                      :displaced-to to-array)))
										    >	        (dotimes (index (array-total-size from-array) to-array)
										    >	          (setf (aref to-flat index) (aref from-flat index))))
										    >	      (error "Array dimensions are not equal.")))

(defmacro weyli::copy-array-contents (from-array to-array)				(defmacro weyli::copy-array-contents (from-array to-array)
  #+Genera										  #+Genera
  `(scl:copy-array-contents ,from-array ,to-array)					  `(scl:copy-array-contents ,from-array ,to-array)
  #-Genera										  #-Genera
  `(copy-array-contents* ,from-array ,to-array))				    |	  `(weyli::%copy-array-contents* ,from-array ,to-array))
										    <
#+(not (or Genera Lucid MCL Lispworks Allegro))					    <
(error "Need to define COPY-ARRAY-CONTENTS*")					    <
										    <
#+Lucid										    <
(defmacro general-set-aref (value array indices)				    <
  `(apply #'lucid-runtime-support:set-aref ,value ,array ,indices))		    <
										    <
#+MCL										    <
(defmacro general-set-aref (value array indices)				    <
  `(apply #'ccl::aset ,value ,array ,indices))					    <
										    <
#+Lispworks									    <
(defmacro general-set-aref (value array indices)				    <
  `(apply #'system::set-aref ,array ,indices ,value))				    <
										    <
#+Allegro									    <
(defmacro general-set-aref (value array indices)				    <
  `(apply #'excl::.inv-s-aref ,value ,array ,indices))				    <
										    <
(defun copy-array-contents* (from-array to-array)				    <
  (let ((from-dims (array-dimensions from-array))				    <
	(to-dims (array-dimensions to-array)))					    <
    (unless (eql (length from-dims) (length to-dims))				    <
      (error "Incompatable array dimensions: ~A -> ~A"				    <
	     from-array to-array))						    <
    (labels ((worker (from-dims to-dims indices)				    <
	       (cond ((null from-dims)						    <
		      (general-set-aref (apply #'aref from-array indices)	    <
					to-array indices))			    <
		     (t (loop for i below (min (first from-dims)		    <
					       (first to-dims))			    <
			      do (worker (rest from-dims) (rest to-dims)	    <
					 (cons i indices)))))))			    <
      (worker (reverse from-dims) (reverse to-dims) nil))))			    <

(defun weyli::circular-list (&rest arguments)						(defun weyli::circular-list (&rest arguments)
  #+Genera (apply #'scl:circular-list arguments)					  #+Genera (apply #'scl:circular-list arguments)
  #-Genera (nconc arguments arguments))							  #-Genera (nconc arguments arguments))

(weyli::defsubst structure-of (x)							(weyli::defsubst structure-of (x)
  (cl:type-of x))								    |	  (common-lisp:type-of x))

;; The following macros deal with certain functions that should take an		    |	;;; The following macros deal with certain functions that should take an
;; arbitrary number of arguments.						    |	;;; arbitrary number of arguments.

										    >	;;; FIXME : This symbol should not be in CL-USER.
(defun associate-predicate (predicate values)						(defun associate-predicate (predicate values)
  (let ((forms 										  (let ((forms 
	 (loop for (x y) on values								 (loop for (x y) on values
	       when y										       when y
		 collect `(,predicate ,x ,y))))						               collect `(,predicate ,x ,y))))
    (if (null (rest forms)) (first forms)						    (if (null (rest forms)) (first forms)
	(cons 'and forms))))									(cons 'and forms))))

(defmacro weyli::< (&rest values)							(defmacro weyli::< (&rest values)
  (cond ((null values)									  (cond ((null values)
	 (error "Illegal number of arguments to <"))						 (error "Illegal number of arguments to <"))
	((null (rest values)) t)								((null (rest values)) t)
	(t (associate-predicate 'weyli::binary< values))))					(t (associate-predicate 'weyli::binary< values))))

(defmacro weyli::= (&rest values)							(defmacro weyli::= (&rest values)
  (cond ((null values)									  (cond ((null values)
	 (error "Illegal number of arguments to ="))						 (error "Illegal number of arguments to ="))
	((null (rest values)) t)								((null (rest values)) t)
	(t (associate-predicate 'weyli::binary= values))))					(t (associate-predicate 'weyli::binary= values))))

(defmacro weyli::> (&rest values)							(defmacro weyli::> (&rest values)
  (cond ((null values)									  (cond ((null values)
	 (error "Illegal number of arguments to >"))						 (error "Illegal number of arguments to >"))
	((null (rest values)) t)								((null (rest values)) t)
	(t (associate-predicate 'weyli::binary> values))))					(t (associate-predicate 'weyli::binary> values))))

(defmacro weyli::<= (&rest values)							(defmacro weyli::<= (&rest values)
  (cond ((null values)									  (cond ((null values)
	 (error "Illegal number of arguments to <="))						 (error "Illegal number of arguments to <="))
	((null (rest values)) t)								((null (rest values)) t)
	(t (associate-predicate 'weyli::binary<= values))))					(t (associate-predicate 'weyli::binary<= values))))

(defmacro weyli::>= (&rest values)							(defmacro weyli::>= (&rest values)
  (cond ((null values)									  (cond ((null values)
	 (error "Illegal number of arguments to >="))						 (error "Illegal number of arguments to >="))
	((null (rest values)) t)								((null (rest values)) t)
	(t (associate-predicate 'weyli::binary>= values))))					(t (associate-predicate 'weyli::binary>= values))))

										    >	;;; FIXME : This symbol should not be in CL-USER.
(defun associate-operation (operation values)						(defun associate-operation (operation values)
  (labels ((iterate (values result)							  (labels ((iterate (values result)
	     (cond ((null values)								     (cond ((null values)
		    result)										    result)
		   (t (iterate (rest values)								   (t (iterate (rest values)
			       `(,operation ,result ,(first values)))))))					       `(,operation ,result ,(first values)))))))
    (iterate (rest values) (first values))))						    (iterate (rest values) (first values))))

(defmacro weyli::max (&rest values)							(defmacro weyli::max (&rest values)
  (cond ((null values)									  (cond ((null values)
	 (error "Illegal number of arguments to max"))						 (error "Illegal number of arguments to max"))
	((null (rest values))									((null (rest values))
	 (first values))									 (first values))
	(t (associate-operation 'weyli::max-pair values))))					(t (associate-operation 'weyli::max-pair values))))

(defun weyli::%max (&rest values)							(defun weyli::%max (&rest values)
  (if (null values)									  (if (null values)
      (error "Illegal number of arguments to max")					      (error "Illegal number of arguments to max")
      (labels ((next-loop (vals)							      (labels ((next-loop (vals)
	         (if (null (rest vals))								         (if (null (rest vals))
		     (first vals)									     (first vals)
										    >	                     ;; FIXME : max-pair needs to be defined prior to this.
		     (weyli::max-pair (first vals) (next-loop (rest vals))))))				     (weyli::max-pair (first vals) (next-loop (rest vals))))))
	 (next-loop values))))  							        (next-loop values))))  

(defmacro weyli::min (&rest values)							(defmacro weyli::min (&rest values)
  (cond ((null values)									  (cond ((null values)
	 (error "Illegal number of arguments to min"))						 (error "Illegal number of arguments to min"))
	((null (rest values))									((null (rest values))
	 (first values))									 (first values))
	(t (associate-operation 'weyli::min-pair values))))					(t (associate-operation 'weyli::min-pair values))))

(defun weyli::%min (&rest values)							(defun weyli::%min (&rest values)
  (if (null values)									  (if (null values)
      (error "Illegal number of arguments to min")					      (error "Illegal number of arguments to min")
      (labels ((next-loop (vals)							      (labels ((next-loop (vals)
	         (if (null (rest vals))								         (if (null (rest vals))
		     (first vals)									     (first vals)
										    >	                     ;; FIXME : min-pair needs to be defined prior to this.
		     (weyli::min-pair (first vals) (next-loop (rest vals))))))				     (weyli::min-pair (first vals) (next-loop (rest vals))))))
	 (next-loop values))))								        (next-loop values))))

(defmacro weyli::+ (&rest values)							(defmacro weyli::+ (&rest values)
  (cond ((null values)									  (cond ((null values)
	 (error "Illegal number of arguments to +"))						 (error "Illegal number of arguments to +"))
	((null (rest values))									((null (rest values))
	 (first values))									 (first values))
	(t (associate-operation 'weyli::plus values))))						(t (associate-operation 'weyli::plus values))))

(defun weyli::%plus (&rest values)							(defun weyli::%plus (&rest values)
  (if (null values)									  (if (null values)
      (error "Illegal number of arguments to +")					      (error "Illegal number of arguments to +")
      (labels ((next-loop (vals)							      (labels ((next-loop (vals)
	         (if (null (rest vals))								         (if (null (rest vals))
		     (first vals)									     (first vals)
										    >	                     ;; FIXME : plus needs to be defined prior to this.
		     (weyli::plus (first vals) (next-loop (rest vals))))))				     (weyli::plus (first vals) (next-loop (rest vals))))))
	 (next-loop values))))								        (next-loop values))))

(defmacro weyli::- (&rest values)							(defmacro weyli::- (&rest values)
  (cond ((null values)									  (cond ((null values)
	 (error "Illegal number of arguments to -"))						 (error "Illegal number of arguments to -"))
	((null (rest values))									((null (rest values))
	 `(weyli::minus ,(first values)))							 `(weyli::minus ,(first values)))
	(t (associate-operation 'weyli::difference values))))					(t (associate-operation 'weyli::difference values))))

(defun weyli::%difference (&rest values)						(defun weyli::%difference (&rest values)
  (if (null values)									  (if (null values)
      (error "Illegal number of arguments to -")					      (error "Illegal number of arguments to -")
      (labels ((next-loop (vals)							      (labels ((next-loop (vals)
	         (if (null (rest vals))								         (if (null (rest vals))
		     (first vals)									     (first vals)
										    >	                     ;; FIXME : plus needs to be defined prior to this.
		     (weyli::plus (first vals) (next-loop (rest vals))))))				     (weyli::plus (first vals) (next-loop (rest vals))))))
	 (if (null (rest values))							        (if (null (rest values))
										    >	            ;; FIXME : minus needs to be defined prior to this.
	     (weyli::minus (first values))						            (weyli::minus (first values))
	     (next-loop values)))))							            (next-loop values)))))

(defmacro weyli::* (&rest values)							(defmacro weyli::* (&rest values)
  (cond ((null values)									  (cond ((null values)
	 (error "Illegal number of arguments to *"))						 (error "Illegal number of arguments to *"))
	((null (rest values))									((null (rest values))
	 (first values))									 (first values))
	(t (associate-operation 'weyli::times values))))					(t (associate-operation 'weyli::times values))))

(defun weyli::%times (&rest values)							(defun weyli::%times (&rest values)
  (if (null values)									  (if (null values)
      (error "Illegal number of arguments to *")					      (error "Illegal number of arguments to *")
      (labels ((next-loop (vals)							      (labels ((next-loop (vals)
	         (if (null (rest vals))								         (if (null (rest vals))
		     (first vals)									     (first vals)
										    >	                     ;; FIXME : times needs to be defined prior to this.
		     (weyli::times (first vals) (next-loop (rest vals))))))				     (weyli::times (first vals) (next-loop (rest vals))))))
	 (next-loop values))))								        (next-loop values))))

(defmacro weyli::/ (&rest values)							(defmacro weyli::/ (&rest values)
  (cond ((null values)									  (cond ((null values)
	 (error "Illegal number of arguments to /"))						 (error "Illegal number of arguments to /"))
	((null (rest values))									((null (rest values))
	 `(weyli::recip ,(first values)))							 `(weyli::recip ,(first values)))
	(t (associate-operation 'weyli::quotient values))))					(t (associate-operation 'weyli::quotient values))))

(defun weyli::%quotient (&rest values)							(defun weyli::%quotient (&rest values)
  (if (null values)									  (if (null values)
      (error "Illegal number of arguments to -")					      (error "Illegal number of arguments to -")
      (labels ((next-loop (vals)							      (labels ((next-loop (vals)
	         (if (null (rest vals))								         (if (null (rest vals))
		     (first vals)									     (first vals)
										    >	                     ;; FIXME : quotient needs to be defined prior to this.
		     (weyli::quotient (first vals) (next-loop (rest vals))))))				     (weyli::quotient (first vals) (next-loop (rest vals))))))
	 (if (null (rest values))							        (if (null (rest values))
										    >	            ;; FIXME : recip needs to be defined prior to this.
	     (weyli::recip (first values))						            (weyli::recip (first values))
	     (next-loop values)))))							            (next-loop values)))))

(defmacro weyli::gcd (&rest values)							(defmacro weyli::gcd (&rest values)
  (cond ((null values)									  (cond ((null values)
	 (error "Illegal number of arguments to GCD"))						 (error "Illegal number of arguments to GCD"))
	((null (rest values))									((null (rest values))
	 (first values))									 (first values))
	(t (associate-operation 'weyli::binary-gcd values))))					(t (associate-operation 'weyli::binary-gcd values))))

(defun weyli::%gcd (&rest values)							(defun weyli::%gcd (&rest values)
  (if (null values)									  (if (null values)
      (error "Illegal number of arguments to GCD")					      (error "Illegal number of arguments to GCD")
      (labels ((next-loop (vals)							      (labels ((next-loop (vals)
	         (if (null (rest vals))								         (if (null (rest vals))
		     (first vals)									     (first vals)
										    >	                     ;; FIXME : binary-gcd needs to be defined prior to this.
		     (weyli::binary-gcd (first vals)							     (weyli::binary-gcd (first vals)
					(next-loop (rest vals))))))								(next-loop (rest vals))))))
	 (next-loop values))))								        (next-loop values))))

(defmacro weyli::lcm (&rest values)							(defmacro weyli::lcm (&rest values)
  (cond ((null values)									  (cond ((null values)
	 (error "Illegal number of arguments to LCM"))						 (error "Illegal number of arguments to LCM"))
	((null (rest values))									((null (rest values))
	 (first values))									 (first values))
	(t (associate-operation 'weyli::binary-lcm values))))					(t (associate-operation 'weyli::binary-lcm values))))

(defun weyli::%lcm (&rest values)							(defun weyli::%lcm (&rest values)
  (if (null values)									  (if (null values)
      (error "Illegal number of arguments to LCM")					      (error "Illegal number of arguments to LCM")
      (labels ((next-loop (vals)							      (labels ((next-loop (vals)
	         (if (null (rest vals))								         (if (null (rest vals))
		     (first vals)									     (first vals)
										    >	                     ;; FIXME : binary-lcm needs to be defined prior to this.
		     (weyli::binary-lcm (first vals)							     (weyli::binary-lcm (first vals)
					(next-loop (rest vals))))))								(next-loop (rest vals))))))
	 (next-loop values))))								        (next-loop values))))

(defmacro weyli::floor (a &optional b)							(defmacro weyli::floor (a &optional b)
  (if b `(weyli::floor2 ,a ,b) `(weyli::floor1 ,a)))					  (if b `(weyli::floor2 ,a ,b) `(weyli::floor1 ,a)))

(defmacro weyli::ceiling (a &optional b)						(defmacro weyli::ceiling (a &optional b)
  (if b `(weyli::ceiling2 ,a ,b) `(weyli::ceiling1 ,a)))				  (if b `(weyli::ceiling2 ,a ,b) `(weyli::ceiling1 ,a)))

(defmacro weyli::round (a &optional b)							(defmacro weyli::round (a &optional b)
  (if b `(weyli::round2 ,a ,b) `(weyli::round1 ,a)))					  (if b `(weyli::round2 ,a ,b) `(weyli::round1 ,a)))

(defmacro weyli::truncate (a &optional b)						(defmacro weyli::truncate (a &optional b)
  (if b `(weyli::truncate2 ,a ,b) `(weyli::truncate1 ,a)))				  (if b `(weyli::truncate2 ,a ,b) `(weyli::truncate1 ,a)))

										    >	#|
										    >
										    >	DELETE : All of the following forms can probably be deleted.
										    >
#+PCL											#+PCL
(defvar pcl:*compile-class-hash* (make-hash-table :test #'eq))				(defvar pcl:*compile-class-hash* (make-hash-table :test #'eq))

#+PCL											#+PCL
(defun pcl:COMPILE-CLASS-METHODS-1 (classes)						(defun pcl:COMPILE-CLASS-METHODS-1 (classes)
  (clrhash pcl:*compile-class-hash*)							  (clrhash pcl:*compile-class-hash*)
  (dolist (class-spec classes)								  (dolist (class-spec classes)
    (let ((class (cond ((symbolp class-spec) (pcl:find-class class-spec nil))		    (let ((class (cond ((symbolp class-spec) (pcl:find-class class-spec nil))
		       ((pcl:classp class-spec) class-spec))))						       ((pcl:classp class-spec) class-spec))))
      (cond (class									      (cond (class
	     (dolist (gf (pcl:class-direct-generic-functions class))				     (dolist (gf (pcl:class-direct-generic-functions class))
	       (unless (gethash gf pcl:*compile-class-hash*)					       (unless (gethash gf pcl:*compile-class-hash*)
		 (setf (gethash gf pcl:*compile-class-hash*) T)						 (setf (gethash gf pcl:*compile-class-hash*) T)
		 (pcl:notice-methods-change-1 gf))))							 (pcl:notice-methods-change-1 gf))))
	    (t (warn "~A is neither a class nor the name of a class" class-spec)))		    (t (warn "~A is neither a class nor the name of a class" class-spec)))

#+PCL											#+PCL
(defmacro weyli::compile-class-methods (&rest classes)					(defmacro weyli::compile-class-methods (&rest classes)
  `(pcl:compile-class-methods-1 ',classes))						  `(pcl:compile-class-methods-1 ',classes))

#-PCL											#-PCL
(defmacro compile-class-methods (&rest classes)						(defmacro compile-class-methods (&rest classes)
  (declare (ignore classes))								  (declare (ignore classes))
  "Ignored")										  "Ignored")

#+PCL											#+PCL
(defun weyli::class-uncompiled-methods (class-spec &optional (function #'print))	(defun weyli::class-uncompiled-methods (class-spec &optional (function #'print))
  (let ((class (cond ((symbolp class-spec) (pcl:find-class class-spec nil))		  (let ((class (cond ((symbolp class-spec) (pcl:find-class class-spec nil))
		     ((pcl:classp class-spec) class-spec))))						     ((pcl:classp class-spec) class-spec))))
    (cond (class									    (cond (class
	   (dolist (gf (pcl:class-direct-generic-functions class))				   (dolist (gf (pcl:class-direct-generic-functions class))
	     (dolist (method (pcl:generic-function-methods gf))					     (dolist (method (pcl:generic-function-methods gf))
	       (unless (or (compiled-function-p (pcl:method-function method))			       (unless (or (compiled-function-p (pcl:method-function method))
			   #+Genera										   #+Genera
			   (typep (pcl:method-function method) 'sys:lexical-closur				   (typep (pcl:method-function method) 'sys:lexical-closur
		 (funcall function method)))))								 (funcall function method)))))
	  (t (warn "~A is neither a class nor the name of a class" class-spec)))))		  (t (warn "~A is neither a class nor the name of a class" class-spec)))))

#+PCL											#+PCL
(defun weyli::all-weyl-classes (&optional (function #'print))				(defun weyli::all-weyl-classes (&optional (function #'print))
  (let (list)										  (let (list)
    (labels ((find-sub-classes (class)							    (labels ((find-sub-classes (class)
	       (loop for class in (pcl:class-direct-subclasses class)				       (loop for class in (pcl:class-direct-subclasses class)
		     do (unless (member class list)							     do (unless (member class list)
			  (push class list)									  (push class list)
			  (funcall function class)								  (funcall function class)
			  (find-sub-classes class)))))								  (find-sub-classes class)))))
      (find-sub-classes (pcl:find-class 'weyli::domain))				      (find-sub-classes (pcl:find-class 'weyli::domain))
      (find-sub-classes (pcl:find-class 'weyli::domain-element))			      (find-sub-classes (pcl:find-class 'weyli::domain-element))
      (find-sub-classes (pcl:find-class 'weyli::morphism)))))				      (find-sub-classes (pcl:find-class 'weyli::morphism)))))

#+PCL											#+PCL
(defun weyli::all-uncompiled-weyl-methods (&optional (function #'print))		(defun weyli::all-uncompiled-weyl-methods (&optional (function #'print))
  (let (list generic)									  (let (list generic)
    (weyli::all-weyl-classes								    (weyli::all-weyl-classes
      #'(lambda (class)									      #'(lambda (class)
	  (weyli::class-uncompiled-methods class						  (weyli::class-uncompiled-methods class
	    #'(lambda (method)									    #'(lambda (method)
	        (setq generic (pcl:method-generic-function method))				        (setq generic (pcl:method-generic-function method))
		(unless (member generic list)								(unless (member generic list)
		  (push generic list)									  (push generic list)
		  (funcall function generic))))))))							  (funcall function generic))))))))

										    |	|#
;;; -*- Mode:Lisp; Package:CL-User; Base:10; Lowercase:T; Syntax:Common-Lisp -*-	;;; -*- Mode:Lisp; Package:CL-User; Base:10; Lowercase:T; Syntax:Common-Lisp -*-
;;; ===========================================================================		;;; ===========================================================================
;;;			    System Maintenance						;;;			    System Maintenance
;;; ===========================================================================		;;; ===========================================================================
;;; (c) Copyright 1989, 1993 Cornell University						;;; (c) Copyright 1989, 1993 Cornell University

;;; maintenance.lisp,v 1.2 1994/08/04 14:29:22 rz Exp					;;; maintenance.lisp,v 1.2 1994/08/04 14:29:22 rz Exp

(in-package #-ANSI-CL "USER" #+ANSI-CL "CL-USER")					(in-package #-ANSI-CL "USER" #+ANSI-CL "CL-USER")

(make::adjust-version-numbers Weyl "1.2")						(make::adjust-version-numbers Weyl "1.2")

#+Lucid											#+Lucid
(defun dump-weyl (&optional (name "weyl"))						(defun dump-weyl (&optional (name "weyl"))
  (load-system 'weyl)									  (load-system 'weyl)
  (multiple-value-bind (seconds minutes hour date month year d-o-w d-s-t t-z)		  (multiple-value-bind (seconds minutes hour date month year d-o-w d-s-t t-z)
      (decode-universal-time (get-universal-time))					      (decode-universal-time (get-universal-time))
    (declare (ignore seconds minutes hour d-o-w d-s-t t-z))				    (declare (ignore seconds minutes hour d-o-w d-s-t t-z))
    (let ((file (make-pathname								    (let ((file (make-pathname
		 :name (cond ((member :mips *features*) "weyl-mips")					 :name (cond ((member :mips *features*) "weyl-mips")
			     ((member :sparc *features*) "weyl-sparc")						     ((member :sparc *features*) "weyl-sparc")
			     (t "Weyl-Unknown"))								     (t "Weyl-Unknown"))
		 :directory (pathname-directory *weyl-directory*)))					 :directory (pathname-directory *weyl-directory*)))
	  (archive (format nil									  (archive (format nil
			   (cond ((member :mips *features*)							   (cond ((member :mips *features*)
				  "~A/~A-mips-~D-~D-~D-~D")								  "~A/~A-mips-~D-~D-~D-~D")
				 ((member :sparc *features*)								 ((member :sparc *features*)
				  "~A/~A-sparc-~D-~D-~D-~D")								  "~A/~A-sparc-~D-~D-~D-~D")
				 (t "~A/~A-unknown-~D-~D-~D-~D"))							 (t "~A/~A-unknown-~D-~D-~D-~D"))
			   *weyl-archive-directory*								   *weyl-archive-directory*
			   name month date year									   name month date year
			   (+ minutes (* 100 hour))))								   (+ minutes (* 100 hour))))
	  (banner (weyl-banner)))								  (banner (weyl-banner)))
      (declare (special system::*enter-top-level-hook*))				      (declare (special system::*enter-top-level-hook*))
      (when (probe-file file)								      (when (probe-file file)
	(delete-file file))									(delete-file file))
      ;; Comment the following line to store binaries in the source directory.		      ;; Comment the following line to store binaries in the source directory.
      (user::shell (format nil "ln -s ~A ~A" archive file))				      (user::shell (format nil "ln -s ~A ~A" archive file))
      (setq system::*enter-top-level-hook* 						      (setq system::*enter-top-level-hook* 
	    #'(lambda ()									    #'(lambda ()
		(format t ";;; ~A~2%"  banner)								(format t ";;; ~A~2%"  banner)
		(lucid::default-enter-top-level-hook)))							(lucid::default-enter-top-level-hook)))
      (disksave file :full-gc t)							      (disksave file :full-gc t)
      (format t ";;; Weyl ~D.~D successfully dumped into ~A~%~				      (format t ";;; Weyl ~D.~D successfully dumped into ~A~%~
                 ;;; and link was created to it from ~A"				                 ;;; and link was created to it from ~A"
	      make::*weyl-major-version* make::*weyl-minor-version*				      make::*weyl-major-version* make::*weyl-minor-version*
	      archive file))))									      archive file))))

#+Lucid											#+Lucid
(defun weyl-banner ()									(defun weyl-banner ()
  (multiple-value-bind (second minute hour date month year day-of-week)			  (multiple-value-bind (second minute hour date month year day-of-week)
      (decode-universal-time (get-universal-time))					      (decode-universal-time (get-universal-time))
    (declare (ignore second))								    (declare (ignore second))
    (format nil "Weyl Version ~D.~D, saved ~2D:~2D ~A, ~A ~D, ~D"			    (format nil "Weyl Version ~D.~D, saved ~2D:~2D ~A, ~A ~D, ~D"
	    make::*weyl-major-version* make::*weyl-minor-version*				    make::*weyl-major-version* make::*weyl-minor-version*
	    hour minute										    hour minute
	    (second (assoc day-of-week								    (second (assoc day-of-week
			   '((0 "Monday") (1 "Tuesday") (2 "Wednesday")						   '((0 "Monday") (1 "Tuesday") (2 "Wednesday")
			     (3 "Thursday") (4 "Friday") (5 "Saturday")						     (3 "Thursday") (4 "Friday") (5 "Saturday")
			     (6 "Sunday"))))									     (6 "Sunday"))))
	    (second (assoc month								    (second (assoc month
			   '((1 "January") (2 "February") (3 "March")						   '((1 "January") (2 "February") (3 "March")
			     (4 "April") (5 "May") (6 "June") (7 "July")					     (4 "April") (5 "May") (6 "June") (7 "July")
			     (8 "August") (9 "September") (10 "October")					     (8 "August") (9 "September") (10 "October")
			     (11 "November") (12 "December"))))							     (11 "November") (12 "December"))))
	    date										    date
	    year)))										    year)))

#+MCL											#+MCL
(defun dump-weyl (&optional (name "Weyl"))						(defun dump-weyl (&optional (name "Weyl"))
  (load-system 'weyl)									  (load-system 'weyl)
  (let ((file (make-pathname								  (let ((file (make-pathname
               :name (format nil "~A ~Db~D" 						               :name (format nil "~A ~Db~D" 
                             name							                             name
			     make::*weyl-major-version*								     make::*weyl-major-version*
			     make::*weyl-minor-version*)							     make::*weyl-minor-version*)
               :directory (pathname-directory (user-homedir-pathname)))))		               :directory (pathname-directory (user-homedir-pathname)))))
    (when (probe-file file)								    (when (probe-file file)
      (delete-file file))								      (delete-file file))
    (format t ";;; Weyl ~D.~D successfully being dumped into ~A.~%"			    (format t ";;; Weyl ~D.~D successfully being dumped into ~A.~%"
	      make::*weyl-major-version* make::*weyl-minor-version*				      make::*weyl-major-version* make::*weyl-minor-version*
	      file)										      file)
    (save-application  file :init-file "init")))					    (save-application  file :init-file "init")))


Files ../simlab/weyl/src/maintenance.lisp and ../weyl/maintenance.lisp are identical
;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-		;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-
;;; ===========================================================================		;;; ===========================================================================
;;;				    Matrices						;;;				    Matrices
;;; ===========================================================================		;;; ===========================================================================
;;; (c) Copyright 1989, 1993 Cornell University						;;; (c) Copyright 1989, 1993 Cornell University

;;; matrix.lisp,v 1.14 1995/05/24 17:49:23 rz Exp					;;; matrix.lisp,v 1.14 1995/05/24 17:49:23 rz Exp

(in-package "WEYLI")								    |	(in-package :weyli)

(make::adjust-version-numbers Weyl "1.14")					    |	;;; DELETE (make::adjust-version-numbers Weyl "1.14")

;; This is a very general matrix implementation.   At some point it will		;; This is a very general matrix implementation.   At some point it will
;; be worth while implementing some more specialized matrix spaces.			;; be worth while implementing some more specialized matrix spaces.

(define-domain-creator matrix-space ((ring ring))				    |	(eval-when (:compile-toplevel :load-toplevel)
										    >	  (define-domain-creator matrix-space ((ring ring))
  (make-instance 'matrix-space								    (make-instance 'matrix-space
		 :coefficient-domain ring						                   :coefficient-domain ring
		 :print-function 'make-space-print-object)				                   :print-function 'make-space-print-object)
  :predicate #'(lambda (d)								    :predicate #'(lambda (d)
	         (and (eql (class-name (class-of d)) 'matrix-space)			                   (and (eql (class-name (class-of d)) 'matrix-space)
		      (eql (coefficient-domain-of d) ring))))			    |	                        (eql (coefficient-domain-of d) ring)))))

(defun matrix-space-print-object (domain stream)					(defun matrix-space-print-object (domain stream)
  (format stream "Mat(~S)" (coefficient-domain-of domain)))				  (format stream "Mat(~S)" (coefficient-domain-of domain)))

(defmethod make-element ((domain matrix-space) (value array) &rest ignore)		(defmethod make-element ((domain matrix-space) (value array) &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (make-instance 'matrix-space-element							  (make-instance 'matrix-space-element
		 :domain domain										 :domain domain
		 :dimension1 (array-dimension value 0)							 :dimension1 (array-dimension value 0)
		 :dimension2 (array-dimension value 1)							 :dimension2 (array-dimension value 1)
		 :value value))										 :value value))

(defmethod weyl::make-element ((domain matrix-space) (value array)			(defmethod weyl::make-element ((domain matrix-space) (value array)
			       &rest ignore)									       &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (let* ((array-dims (array-dimensions value))						  (let* ((array-dims (array-dimensions value))
	 (x-dim (first array-dims))								 (x-dim (first array-dims))
	 (y-dim (second array-dims))								 (y-dim (second array-dims))
	 (coef-domain (coefficient-domain-of domain))						 (coef-domain (coefficient-domain-of domain))
	 (array (make-array (list x-dim y-dim))))						 (array (make-array (list x-dim y-dim))))
    (loop for i fixnum below x-dim do							    (loop for i fixnum below x-dim do
	  (loop for j fixnum below y-dim do							  (loop for j fixnum below y-dim do
		(setf (aref array i j) (coerce (aref value i j) coef-domain))))				(setf (aref array i j) (coerce (aref value i j) coef-domain))))
    (make-instance 'matrix-space-element						    (make-instance 'matrix-space-element
		   :domain domain									   :domain domain
		   :dimension1 x-dim 									   :dimension1 x-dim 
		   :dimension2 y-dim 									   :dimension2 y-dim 
		   :value array)))									   :value array)))

(defmethod make-element ((domain matrix-space) (value list) &rest values)		(defmethod make-element ((domain matrix-space) (value list) &rest values)
  (setq values (if (null values) value							  (setq values (if (null values) value
		   (cons value values)))								   (cons value values)))
  (unless (loop for row in (rest values)						  (unless (loop for row in (rest values)
		with n = (length (first values))							with n = (length (first values))
		do (unless (eql (length row) n)								do (unless (eql (length row) n)
		     (return nil))									     (return nil))
		finally (return t))									finally (return t))
    (error "All rows not the same length: ~S" values))					    (error "All rows not the same length: ~S" values))
  (make-element domain									  (make-element domain
		(make-array (list (length values) (length (first values)))				(make-array (list (length values) (length (first values)))
			    :initial-contents values)))								    :initial-contents values)))

(defmethod weyl::make-element ((domain matrix-space) (value list) &rest values)		(defmethod weyl::make-element ((domain matrix-space) (value list) &rest values)
  (setq values (if (null values) value							  (setq values (if (null values) value
		   (cons value values)))								   (cons value values)))
  (unless (loop for row in (rest values)						  (unless (loop for row in (rest values)
		with n = (length (first values))							with n = (length (first values))
		do (unless (eql (length row) n)								do (unless (eql (length row) n)
		     (return nil))									     (return nil))
		finally (return t))									finally (return t))
    (error "All rows not the same length: ~S" values))					    (error "All rows not the same length: ~S" values))
  (let* ((x-dim (length values))							  (let* ((x-dim (length values))
	 (y-dim (length (first values)))							 (y-dim (length (first values)))
	 (array (make-array (list x-dim y-dim))))						 (array (make-array (list x-dim y-dim))))
    (loop for i fixnum  below x-dim							    (loop for i fixnum  below x-dim
	  for row in values do									  for row in values do
	    (loop for j fixnum below y-dim							    (loop for j fixnum below y-dim
		  for val in row do									  for val in row do
		    (setf (aref array i j) val)))							    (setf (aref array i j) val)))
    (weyl::make-element domain array)))							    (weyl::make-element domain array)))

										    >	(defgeneric matrix-dimensions (matrix)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod matrix-dimensions ((m matrix-space-element))					(defmethod matrix-dimensions ((m matrix-space-element))
  (with-slots (dimension1 dimension2) m							  (with-slots (dimension1 dimension2) m
    (values dimension1 dimension2)))							    (values dimension1 dimension2)))

(defmethod dimensions ((m matrix-space-element))					(defmethod dimensions ((m matrix-space-element))
  (with-slots (dimension1 dimension2) m							  (with-slots (dimension1 dimension2) m
    (list dimension1 dimension2)))							    (list dimension1 dimension2)))

#+Genera										#+Genera
(defmacro with-matrix-dimensions ((dim1 dim2 &optional array) matrix &body body		(defmacro with-matrix-dimensions ((dim1 dim2 &optional array) matrix &body body
				  &environment env)									  &environment env)
  (scl:once-only (matrix &environment env)						  (scl:once-only (matrix &environment env)
    `(multiple-value-bind (,dim1 ,dim2) (matrix-dimensions ,matrix)			    `(multiple-value-bind (,dim1 ,dim2) (matrix-dimensions ,matrix)
       ,(if array `(let ((,array (matrix-value ,matrix)))				       ,(if array `(let ((,array (matrix-value ,matrix)))
		     ,@body)										     ,@body)
	    `(progn ,@body)))))									    `(progn ,@body)))))

#-Genera										#-Genera
(defmacro with-matrix-dimensions ((dim1 dim2 &optional array) matrix &body body)    |	(eval-when (:compile-toplevel :load-toplevel)
										    >	  (defmacro with-matrix-dimensions ((dim1 dim2 &optional array) matrix &body body)
  (let ((decls (list `(fixnum ,dim1 ,dim2))))						    (let ((decls (list `(fixnum ,dim1 ,dim2))))
    (loop while (and (not (atom (first body)))						      (loop while (and (not (atom (first body)))
		     (eql (first (first body)) 'declare))				                       (eql (first (first body)) 'declare))
	  do (setq decls (append (rest (pop body)) decls)))				            do (setq decls (append (rest (pop body)) decls)))
    `(multiple-value-bind (,dim1 ,dim2) (matrix-dimensions ,matrix)			      `(multiple-value-bind (,dim1 ,dim2) (matrix-dimensions ,matrix)
       (declare ,@decls)								        (declare ,@decls)
       ,(if array `(let ((,array (matrix-value ,matrix)))				        ,(if array `(let ((,array (matrix-value ,matrix)))
			,@body)								                     ,@body)
	    `(progn ,@body)))))							    |	             `(progn ,@body))))))

#-Genera										#-Genera
(defmethod print-object ((matrix matrix-space-element) stream)				(defmethod print-object ((matrix matrix-space-element) stream)
  (with-matrix-dimensions (dim1 dim2 array) matrix					  (with-matrix-dimensions (dim1 dim2 array) matrix
    (princ "Mat<" stream)								    (princ "Mat<" stream)
    (loop for i fixnum below dim1							    (loop for i fixnum below dim1
	  do (princ "<" stream)									  do (princ "<" stream)
	     (loop for j fixnum below dim2							     (loop for j fixnum below dim2
		   do (print-object (aref array i j) stream)						   do (print-object (aref array i j) stream)
		      (if (< (1+ j) dim2)								      (if (< (1+ j) dim2)
			  (princ ",  " stream)									  (princ ",  " stream)
			  (princ ">" stream)))	     								  (princ ">" stream)))	     
	     (if (< (1+ i) dim1)								     (if (< (1+ i) dim1)
		 (princ ",  " stream)									 (princ ",  " stream)
		 (princ ">" stream)))))									 (princ ">" stream)))))

#+Genera										#+Genera
(defmethod print-object ((matrix matrix-space-element) stream)				(defmethod print-object ((matrix matrix-space-element) stream)
  (with-matrix-dimensions (dim1 dim2 array) matrix					  (with-matrix-dimensions (dim1 dim2 array) matrix
    (dw:formatting-table (stream)							    (dw:formatting-table (stream)
      (loop for i below dim1 do								      (loop for i below dim1 do
	(dw:formatting-row (stream)								(dw:formatting-row (stream)
	  (loop for j below dim2 do								  (loop for j below dim2 do
	    (dw:formatting-cell (stream :align-x :center)					    (dw:formatting-cell (stream :align-x :center)
	      (princ (aref array i j) stream))))))))						      (princ (aref array i j) stream))))))))

(defmethod ref ((matrix matrix-element) &rest args)					(defmethod ref ((matrix matrix-element) &rest args)
  (let ((x (first args))								  (let ((x (first args))
	(y (second args)))									(y (second args)))
    (cond ((numberp x)									    (cond ((numberp x)
	   (cond ((numberp y)									   (cond ((numberp y)
		  (aref (matrix-value matrix) x y))							  (aref (matrix-value matrix) x y))
		 ((eql y :*)										 ((eql y :*)
		  (with-matrix-dimensions (rows cols array) matrix					  (with-matrix-dimensions (rows cols array) matrix
		    (declare (ignore rows))								    (declare (ignore rows))
		    (let ((new-array (make-array (list 1 cols))))					    (let ((new-array (make-array (list 1 cols))))
		      (loop for j fixnum below cols							      (loop for j fixnum below cols
			    do (setf (aref new-array 0 j) (aref array x j)))					    do (setf (aref new-array 0 j) (aref array x j)))
		      (make-element (domain-of matrix) new-array))))					      (make-element (domain-of matrix) new-array))))
		 (t (error "Unknown argument to REF(~S ~S)"						 (t (error "Unknown argument to REF(~S ~S)"
			   x y))))										   x y))))
	  ((eql x :*)										  ((eql x :*)
	   (cond ((numberp y)		  							   (cond ((numberp y)		  
		  (with-matrix-dimensions (rows cols array) matrix					  (with-matrix-dimensions (rows cols array) matrix
		    (declare (ignore cols))								    (declare (ignore cols))
		    (let ((new-array (make-array (list rows 1))))					    (let ((new-array (make-array (list rows 1))))
		      (loop for i fixnum below rows							      (loop for i fixnum below rows
			    do (setf (aref new-array i 0) (aref array i y)))					    do (setf (aref new-array i 0) (aref array i y)))
		      (make-element (domain-of matrix) new-array))))					      (make-element (domain-of matrix) new-array))))
		 (t (error "Unknown argument to REF(~S ~S)"						 (t (error "Unknown argument to REF(~S ~S)"
			   x y))))										   x y))))
	  (t (error "Unknown argument to REF(~S ~S)"						  (t (error "Unknown argument to REF(~S ~S)"
		    x y)))))										    x y)))))

(defmethod set-ref ((matrix matrix-element) new-value &rest args)			(defmethod set-ref ((matrix matrix-element) new-value &rest args)
  (setf (aref (matrix-value matrix) (first args) (second args)) new-value))		  (setf (aref (matrix-value matrix) (first args) (second args)) new-value))

(defmethod zero-matrix ((domain matrix-space) &optional rank)				(defmethod zero-matrix ((domain matrix-space) &optional rank)
  (unless (numberp rank)								  (unless (numberp rank)
    (error "Must specify rank to ZERO-MATRIX (~D)" domain))				    (error "Must specify rank to ZERO-MATRIX (~D)" domain))
  (make-element domain									  (make-element domain
	       (make-array (list rank rank)							       (make-array (list rank rank)
			   :initial-element (zero (coefficient-domain-of domain)))				   :initial-element (zero (coefficient-domain-of domain)))

										    >	(defgeneric one-matrix (domain &optional rank)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod one-matrix ((domain matrix-space) &optional rank)				(defmethod one-matrix ((domain matrix-space) &optional rank)
  (unless (numberp rank)								  (unless (numberp rank)
    (error "Must specify rank to ONE-MATRIX (~D)" domain))				    (error "Must specify rank to ONE-MATRIX (~D)" domain))
  (let* ((zero (zero (coefficient-domain-of domain)))					  (let* ((zero (zero (coefficient-domain-of domain)))
	 (one (one (coefficient-domain-of domain)))						 (one (one (coefficient-domain-of domain)))
	 (array (make-array (list rank rank) :initial-element zero)))				 (array (make-array (list rank rank) :initial-element zero)))
    (loop for i fixnum below rank							    (loop for i fixnum below rank
	  do (setf (aref array i i) one))							  do (setf (aref array i i) one))
    (make-element domain array)))							    (make-element domain array)))

(defmethod plus ((m1 matrix-space-element) (m2 matrix-space-element))			(defmethod plus ((m1 matrix-space-element) (m2 matrix-space-element))
  (let ((domain (domain-of m1)))							  (let ((domain (domain-of m1)))
    (cond ((eql domain (domain-of m2))							    (cond ((eql domain (domain-of m2))
	   (with-matrix-dimensions (1dim1 1dim2 1array) m1					   (with-matrix-dimensions (1dim1 1dim2 1array) m1
	     (with-matrix-dimensions (2dim1 2dim2 2array) m2					     (with-matrix-dimensions (2dim1 2dim2 2array) m2
	       (unless (and (eql 1dim1 2dim1) (eql 1dim2 2dim2))				       (unless (and (eql 1dim1 2dim1) (eql 1dim2 2dim2))
		 (error "Trying to add matrices of different dimensions: (~D ~D) a			 (error "Trying to add matrices of different dimensions: (~D ~D) a
			1dim1 1dim2 2dim1 2dim2))								1dim1 1dim2 2dim1 2dim2))
	       (let ((array (make-array (list 1dim1 1dim2))))					       (let ((array (make-array (list 1dim1 1dim2))))
		 (loop for i fixnum below 1dim1 do							 (loop for i fixnum below 1dim1 do
		   (loop for j fixnum below 1dim2 do							   (loop for j fixnum below 1dim2 do
		     (setf (aref array i j)								     (setf (aref array i j)
			   (+ (aref 1array i j) (aref 2array i j)))))						   (+ (aref 1array i j) (aref 2array i j)))))
		 (make-element domain array)))))							 (make-element domain array)))))
	  (t (error "Can't add these matrices")))))						  (t (error "Can't add these matrices")))))

(defmethod difference ((m1 matrix-space-element) (m2 matrix-space-element))		(defmethod difference ((m1 matrix-space-element) (m2 matrix-space-element))
  (let ((domain (domain-of m1)))							  (let ((domain (domain-of m1)))
    (cond ((eql domain (domain-of m2))							    (cond ((eql domain (domain-of m2))
	   (with-matrix-dimensions (1dim1 1dim2 1array) m1					   (with-matrix-dimensions (1dim1 1dim2 1array) m1
	     (with-matrix-dimensions (2dim1 2dim2 2array) m2					     (with-matrix-dimensions (2dim1 2dim2 2array) m2
	       (unless (and (eql 1dim1 2dim1) (eql 1dim2 2dim2))				       (unless (and (eql 1dim1 2dim1) (eql 1dim2 2dim2))
		 (error "Trying to subtract matrices of different dimensions: (~D 			 (error "Trying to subtract matrices of different dimensions: (~D 
			1dim1 1dim2 2dim1 2dim2))								1dim1 1dim2 2dim1 2dim2))
	       (let ((array (make-array (list 1dim1 1dim2))))					       (let ((array (make-array (list 1dim1 1dim2))))
		 (loop for i fixnum below 1dim1 do							 (loop for i fixnum below 1dim1 do
		   (loop for j fixnum below 1dim2 do							   (loop for j fixnum below 1dim2 do
		     (setf (aref array i j)								     (setf (aref array i j)
			   (- (aref 1array i j) (aref 2array i j)))))						   (- (aref 1array i j) (aref 2array i j)))))
		 (make-element domain array)))))							 (make-element domain array)))))
	  (t (error "Can't subtract these matrices")))))					  (t (error "Can't subtract these matrices")))))


(defmethod-sd times ((m1 matrix-element) (m2 matrix-element))				(defmethod-sd times ((m1 matrix-element) (m2 matrix-element))
  (with-matrix-dimensions (1dim1 1dim2 1array) m1					  (with-matrix-dimensions (1dim1 1dim2 1array) m1
    (with-matrix-dimensions (2dim1 2dim2 2array) m2					    (with-matrix-dimensions (2dim1 2dim2 2array) m2
      (unless (eql 1dim2 2dim1)								      (unless (eql 1dim2 2dim1)
	(error "Trying to multiply matrices of incompatible dimensions: (~D ~D) an		(error "Trying to multiply matrices of incompatible dimensions: (~D ~D) an
	       1dim1 1dim2 2dim1 2dim2))							       1dim1 1dim2 2dim1 2dim2))
      (make-element domain (times-array 1array 1dim1 1dim2 2array 2dim2)))))		      (make-element domain (times-array 1array 1dim1 1dim2 2array 2dim2)))))

(defun array-times (array1 array2)							(defun array-times (array1 array2)
  (let ((dims1 (array-dimensions array1))						  (let ((dims1 (array-dimensions array1))
	(dims2 (array-dimensions array2)))							(dims2 (array-dimensions array2)))
    (unless (and (eql (length dims1) 2)							    (unless (and (eql (length dims1) 2)
		 (eql (length dims2) 2)									 (eql (length dims2) 2)
		 (eql (second dims1) (first dims2)))							 (eql (second dims1) (first dims2)))
      (error "Incompatible array dimensions"))						      (error "Incompatible array dimensions"))
    (times-array array1 (first dims1) (second dims1) array2 (second dims2))))		    (times-array array1 (first dims1) (second dims1) array2 (second dims2))))


(defun times-array (1array 1dim1 1dim2 2array 2dim2)					(defun times-array (1array 1dim1 1dim2 2array 2dim2)
  (let ((array (make-array (list 1dim1 2dim2))))					  (let ((array (make-array (list 1dim1 2dim2))))
    (loop for i fixnum below 1dim1 do							    (loop for i fixnum below 1dim1 do
      (loop for j fixnum below 2dim2 do							      (loop for j fixnum below 2dim2 do
	(loop for k fixnum below 1dim2								(loop for k fixnum below 1dim2
	      for c = (* (aref 1array i k) (aref 2array k j))					      for c = (* (aref 1array i k) (aref 2array k j))
		then (+ c (* (aref 1array i k) (aref 2array k j)))					then (+ c (* (aref 1array i k) (aref 2array k j)))
	      finally (setf (aref array i j) c))))						      finally (setf (aref array i j) c))))
    array))										    array))

(defmethod times ((m matrix-space-element) (v free-module-element))			(defmethod times ((m matrix-space-element) (v free-module-element))
  (matrix-fme-times m v))								  (matrix-fme-times m v))

(defun matrix-fme-times (m v)  								(defun matrix-fme-times (m v)  
  (let ((elt-domain (coefficient-domain-of (domain-of m)))				  (let ((elt-domain (coefficient-domain-of (domain-of m)))
	(vector-space (domain-of v)))								(vector-space (domain-of v)))
    (cond ((eql elt-domain (coefficient-domain-of vector-space))			    (cond ((eql elt-domain (coefficient-domain-of vector-space))
	   (with-matrix-dimensions (dim1 dim2 array) m						   (with-matrix-dimensions (dim1 dim2 array) m
	     (unless (eql dim2 (dimension-of vector-space))					     (unless (eql dim2 (dimension-of vector-space))
	       (error "Trying to multiply a matrix and vector of incompatible dime		       (error "Trying to multiply a matrix and vector of incompatible dime
		      dim1 dim2 (dimension-of vector-space)))						      dim1 dim2 (dimension-of vector-space)))
	     (%apply #'make-element								     (%apply #'make-element
		     (if (cl:= dim1 dim2) vector-space							     (if (cl:= dim1 dim2) vector-space
			 (get-free-module elt-domain dim1))							 (get-free-module elt-domain dim1))
		     (loop for i fixnum below dim1							     (loop for i fixnum below dim1
			   collect										   collect
			   (loop for k fixnum below dim2 							   (loop for k fixnum below dim2 
				 for c = (* (aref array i k) (ref v k))							 for c = (* (aref array i k) (ref v k))
				   then (+ c (* (aref array i k) (ref v k)))						   then (+ c (* (aref array i k) (ref v k)))
				 finally (return c))))))								 finally (return c))))))
	  (t (error "Incompatible arguments: ~S and ~S" m v)))))				  (t (error "Incompatible arguments: ~S and ~S" m v)))))

(defmethod times ((v free-module-element) (m matrix-space-element))			(defmethod times ((v free-module-element) (m matrix-space-element))
  (fme-matrix-times v m))								  (fme-matrix-times v m))

(defun fme-matrix-times (v m)  								(defun fme-matrix-times (v m)  
  (let ((elt-domain (coefficient-domain-of (domain-of m)))				  (let ((elt-domain (coefficient-domain-of (domain-of m)))
	(vector-space (domain-of v)))								(vector-space (domain-of v)))
    (cond ((eql elt-domain (coefficient-domain-of vector-space))			    (cond ((eql elt-domain (coefficient-domain-of vector-space))
	   (with-matrix-dimensions (dim1 dim2 array) m						   (with-matrix-dimensions (dim1 dim2 array) m
	     (unless (eql (dimension-of vector-space) dim1)					     (unless (eql (dimension-of vector-space) dim1)
	       (error "Trying to multiply a vector and matrix of incompatible dime		       (error "Trying to multiply a vector and matrix of incompatible dime
		      (dimension-of vector-space) dim1 dim2))						      (dimension-of vector-space) dim1 dim2))
	     (%apply #'make-element								     (%apply #'make-element
		     (if (cl:= dim1 dim2) vector-space							     (if (cl:= dim1 dim2) vector-space
			 (get-free-module elt-domain dim2))							 (get-free-module elt-domain dim2))
		     (loop for i fixnum below dim2							     (loop for i fixnum below dim2
			   collect										   collect
			   (loop for k fixnum below dim1							   (loop for k fixnum below dim1
				 for c = (* (ref v k) (aref array k i))							 for c = (* (ref v k) (aref array k i))
				   then (+ c (* (ref v k) (aref array k i)))						   then (+ c (* (ref v k) (aref array k i)))
				 finally (return c))))))								 finally (return c))))))
	  (t (error "Incompatible arguments: ~S and ~S" v m)))))				  (t (error "Incompatible arguments: ~S and ~S" v m)))))

										    >	(defgeneric transpose (matrix)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod transpose ((m matrix-element))						(defmethod transpose ((m matrix-element))
  (let ((domain (domain-of m)))								  (let ((domain (domain-of m)))
    (with-matrix-dimensions (dim1 dim2 array) m						    (with-matrix-dimensions (dim1 dim2 array) m
      (let ((transpose (make-array (list dim2 dim1))))					      (let ((transpose (make-array (list dim2 dim1))))
	(loop for i fixnum below dim1 do							(loop for i fixnum below dim1 do
	  (loop for j fixnum below dim2 do							  (loop for j fixnum below dim2 do
	    (setf (aref transpose j i) (aref array i j))))					    (setf (aref transpose j i) (aref array i j))))
	(make-element domain transpose)))))							(make-element domain transpose)))))

(defmethod-sd direct-sum ((x matrix-element) (y matrix-element))			(defmethod-sd direct-sum ((x matrix-element) (y matrix-element))
  (with-matrix-dimensions (x-rows x-cols x-array) x					  (with-matrix-dimensions (x-rows x-cols x-array) x
    (with-matrix-dimensions (y-rows y-cols y-array) y					    (with-matrix-dimensions (y-rows y-cols y-array) y
      (cond ((eql x-rows y-rows)							      (cond ((eql x-rows y-rows)
	     (let ((array (make-array (list x-rows (cl:+ x-cols y-cols)))))			     (let ((array (make-array (list x-rows (cl:+ x-cols y-cols)))))
	       (loop for i fixnum below x-rows							       (loop for i fixnum below x-rows
		     for j fixnum = 0									     for j fixnum = 0
		     do (loop for k fixnum below x-cols							     do (loop for k fixnum below x-cols
			      do (setf (aref array i j) (aref x-array i k ))					      do (setf (aref array i j) (aref x-array i k ))
				 (incf j))										 (incf j))
			(loop for k fixnum below y-cols								(loop for k fixnum below y-cols
			      do (setf (aref array i j) (aref y-array i k))					      do (setf (aref array i j) (aref y-array i k))
				 (incf j)))										 (incf j)))
	       (make-element domain array)))							       (make-element domain array)))
	    (t (error "Incompatable dimensions (~D, ~D) and (~D, ~D)"				    (t (error "Incompatable dimensions (~D, ~D) and (~D, ~D)"
		      x-rows x-cols y-rows y-cols))))))							      x-rows x-cols y-rows y-cols))))))

(defmethod recip ((m matrix-element))							(defmethod recip ((m matrix-element))
  (let ((domain (domain-of m)))								  (let ((domain (domain-of m)))
    (with-matrix-dimensions (dim1 dim2 array) m						    (with-matrix-dimensions (dim1 dim2 array) m
      (unless (eql dim1 dim2)								      (unless (eql dim1 dim2)
	(error "Can't invert a non-square matrix"))						(error "Can't invert a non-square matrix"))
      (let* ((dims (array-dimensions array))						      (let* ((dims (array-dimensions array))
	     (new-array (make-array dims)))							     (new-array (make-array dims)))
	(loop for i below (first dims) do							(loop for i below (first dims) do
	  (loop for j below (second dims) do							  (loop for j below (second dims) do
	    (setf (aref new-array i j) (aref array i j))))					    (setf (aref new-array i j) (aref array i j))))
	(make-element domain									(make-element domain
	  (invert-array (coefficient-domain-of domain) new-array))))))				  (invert-array (coefficient-domain-of domain) new-array))))))

										    >	(defgeneric invert-array (domain array &optional into-array)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
;; Invert an array of elements of domain in an ordered or un-ordered			;; Invert an array of elements of domain in an ordered or un-ordered
;; ring. This operation destroys the first array.					;; ring. This operation destroys the first array.
(defmethod invert-array (domain array &optional into-array)				(defmethod invert-array (domain array &optional into-array)
  (let ((dimension (array-dimensions array)))						  (let ((dimension (array-dimensions array)))
    (unless (and (null (rest (rest dimension)))						    (unless (and (null (rest (rest dimension)))
		 (eql (first dimension) (second dimension)))						 (eql (first dimension) (second dimension)))
      (error "Wrong dimensions for recip: ~S" array))					      (error "Wrong dimensions for recip: ~S" array))
    (cond (into-array									    (cond (into-array
	   (unless (eql dimension (array-dimensions into-array))				   (unless (eql dimension (array-dimensions into-array))
	     (error "Wrong dimensions for ~S, expected ~S"					     (error "Wrong dimensions for ~S, expected ~S"
		    into-array dimension)))								    into-array dimension)))
	  (t (setq into-array (make-array dimension))						  (t (setq into-array (make-array dimension))
	     (loop for i fixnum below (first dimension) 					     (loop for i fixnum below (first dimension) 
		   with zero = (zero domain) and one = (one domain) do					   with zero = (zero domain) and one = (one domain) do
	       (loop for j fixnum below (second dimension) do					       (loop for j fixnum below (second dimension) do
		 (setf (aref into-array i j) (if (eql i j) one zero))))))				 (setf (aref into-array i j) (if (eql i j) one zero))))))
    (setq dimension (first dimension))							    (setq dimension (first dimension))
    (flet ((exchange-rows (j k)								    (flet ((exchange-rows (j k)
	     (loop for i fixnum below dimension do						     (loop for i fixnum below dimension do
	       (rotatef (aref array j i) (aref array k i))					       (rotatef (aref array j i) (aref array k i))
	       (rotatef (aref into-array j i) (aref into-array k i))))				       (rotatef (aref into-array j i) (aref into-array k i))))
	   (find-pivot-ordered (i) 								   (find-pivot-ordered (i) 
	     (loop for j fixnum upfrom (1+ i) below dimension					     (loop for j fixnum upfrom (1+ i) below dimension
		   for elt = (aref array j i)								   for elt = (aref array j i)
		   with max = (aref array i i) and row = i do						   with max = (aref array i i) and row = i do
	       (when (> (abs elt) (abs max))							       (when (> (abs elt) (abs max))
		 (setq max elt										 (setq max elt
		       row j))										       row j))
		   finally  (return (values row max))))							   finally  (return (values row max))))
	   (find-pivot-unordered (i)								   (find-pivot-unordered (i)
	     (loop for j fixnum upfrom (1+ i) below dimension					     (loop for j fixnum upfrom (1+ i) below dimension
		   for elt = (aref array j i)								   for elt = (aref array j i)
		   with max = (aref array i i) and row = i do						   with max = (aref array i i) and row = i do
	       (when (and (0? max) (not (0? elt)))						       (when (and (0? max) (not (0? elt)))
		 (setq max elt										 (setq max elt
		       row j))										       row j))
		   finally (if (0? max)									   finally (if (0? max)
			       (error "Matrix is singular")							       (error "Matrix is singular")
			       (return (values row max)))))							       (return (values row max)))))
	   (subtract-rows (row1 row2)								   (subtract-rows (row1 row2)
	     (unless (0? (aref array row2 row1))						     (unless (0? (aref array row2 row1))
	       (let ((mult (aref array row2 row1)))						       (let ((mult (aref array row2 row1)))
		 (loop for j fixnum upfrom row1 below dimension do					 (loop for j fixnum upfrom row1 below dimension do
		   (setf (aref array row2 j)								   (setf (aref array row2 j)
			 (- (aref array row2 j) (* mult (aref array row1 j)))))					 (- (aref array row2 j) (* mult (aref array row1 j)))))
		 (loop for j fixnum below dimension do							 (loop for j fixnum below dimension do
		   (setf (aref into-array row2 j)							   (setf (aref into-array row2 j)
			 (- (aref into-array row2 j) (* mult (aref into-array row1				 (- (aref into-array row2 j) (* mult (aref into-array row1
      ;; Triangulate									      ;; Triangulate
      (loop for i fixnum below dimension do 						      (loop for i fixnum below dimension do 
	(multiple-value-bind (row pivot)							(multiple-value-bind (row pivot)
			     (if (ordered-domain? domain)							     (if (ordered-domain? domain)
				 (find-pivot-ordered i)									 (find-pivot-ordered i)
			       (find-pivot-unordered i))							       (find-pivot-unordered i))
	  (unless (eql i row)									  (unless (eql i row)
	    (exchange-rows i row))								    (exchange-rows i row))
	  ;; Make the pivot 1									  ;; Make the pivot 1
	  (unless (1? pivot) 									  (unless (1? pivot) 
	    (loop for j fixnum upfrom i below dimension do 					    (loop for j fixnum upfrom i below dimension do 
	      (setf (aref array i j) (/ (aref array i j) pivot)))				      (setf (aref array i j) (/ (aref array i j) pivot)))
	    (loop for j below dimension do							    (loop for j below dimension do
	      (setf (aref into-array i j) (/ (aref into-array i j) pivot))))			      (setf (aref into-array i j) (/ (aref into-array i j) pivot))))
	  (loop for j fixnum upfrom (1+ i) below dimension do					  (loop for j fixnum upfrom (1+ i) below dimension do
	    (subtract-rows i j))))								    (subtract-rows i j))))

      ;; Backsolve									      ;; Backsolve
      (loop for i fixnum downfrom (1- dimension) above -1 do				      (loop for i fixnum downfrom (1- dimension) above -1 do
	(loop for j fixnum downfrom (1- i) above -1 do						(loop for j fixnum downfrom (1- i) above -1 do
	  (subtract-rows i j))))								  (subtract-rows i j))))
    into-array))									    into-array))

(defmethod substitute ((values list) (variables list) (m matrix-space-element)		(defmethod substitute ((values list) (variables list) (m matrix-space-element)
		       &rest ignore)									       &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (with-matrix-dimensions (dim1 dim2 array) m						  (with-matrix-dimensions (dim1 dim2 array) m
     (let ((new-array (make-array (list dim1 dim2))))					     (let ((new-array (make-array (list dim1 dim2))))
       (loop for i fixnum below dim1 do							       (loop for i fixnum below dim1 do
	 (loop for j fixnum below dim2 do							 (loop for j fixnum below dim2 do
	   (setf (aref new-array i j)								   (setf (aref new-array i j)
		 (substitute values variables (aref array i j)))))					 (substitute values variables (aref array i j)))))
       (make-element (get-matrix-space (domain-of (aref new-array 0 0)))		       (make-element (get-matrix-space (domain-of (aref new-array 0 0)))
		     new-array))))									     new-array))))

(defmethod jacobian ((function-list list) (var-list list))				(defmethod jacobian ((function-list list) (var-list list))
  (let* ((ring (domain-of (first function-list)))					  (let* ((ring (domain-of (first function-list)))
	 (dim-col (length var-list))								 (dim-col (length var-list))
	 (dim-row (length function-list))							 (dim-row (length function-list))
	 (array (make-array (list dim-row dim-col))))						 (array (make-array (list dim-row dim-col))))
    (loop for poly in function-list							    (loop for poly in function-list
	  for i fixnum below dim-row								  for i fixnum below dim-row
	  do (loop for var in var-list								  do (loop for var in var-list
		   for j fixnum  below dim-col								   for j fixnum  below dim-col
		   do (setf (aref array i j) (partial-deriv poly var))))				   do (setf (aref array i j) (partial-deriv poly var))))
    (make-element (get-matrix-space ring) array)))					    (make-element (get-matrix-space ring) array)))
											
;; Matrix Groups									;; Matrix Groups

;;; ==========================================================================		;;; ==========================================================================
;;; The Groups GL(n), SL(n), PSL(n), O(n), SO(n) with the following			;;; The Groups GL(n), SL(n), PSL(n), O(n), SO(n) with the following
;;; hierarchy:										;;; hierarchy:
;;;  											;;;  
;;;  det<>0  GL(n)									;;;  det<>0  GL(n)
;;;            |									;;;            |
;;;            |									;;;            |
;;;  det=+-1 PSL(n) -------------> O(n) M*M^t = In					;;;  det=+-1 PSL(n) -------------> O(n) M*M^t = In
;;;            |                    |							;;;            |                    |
;;;            V                    |							;;;            V                    |
;;;  det=1   SL(n)                  |							;;;  det=1   SL(n)                  |
;;;            \                   /							;;;            \                   /
;;;              \               /							;;;              \               /
;;;                \           /							;;;                \           /
;;;                  \       /								;;;                  \       /
;;;                    \   /								;;;                    \   /
;;;                    SO(n)								;;;                    SO(n)
;;;											;;;
;;;											;;;
;;; ==========================================================================		;;; ==========================================================================


;; The coefficient domain of GL-n must be a field otherwise, it will			;; The coefficient domain of GL-n must be a field otherwise, it will
;; not be a group.  This is not necessary for the other matrix groups			;; not be a group.  This is not necessary for the other matrix groups
;; because the determinants are required to be units.					;; because the determinants are required to be units.

(define-domain-creator GL-n ((domain field) dimension)				    |	(eval-when (:compile-toplevel :load-toplevel)
										    >	  (define-domain-creator GL-n ((domain field) dimension)
  (make-instance 'GL-n									    (make-instance 'GL-n
		 :coefficient-domain domain						                   :coefficient-domain domain
		 :dimension dimension							                   :dimension dimension
		 :print-function 'GL-n-print-object)					                   :print-function 'GL-n-print-object)
  :predicate #'(lambda (d)								    :predicate #'(lambda (d)
		 (and (eql (class-name (class-of d)) 'GL-n)				                   (and (eql (class-name (class-of d)) 'GL-n)
		      (eql (coefficient-domain-of d) domain)				                        (eql (coefficient-domain-of d) domain)
		      (eql (dimension-of d) dimension))))			    |	                        (eql (dimension-of d) dimension)))))

(defun GL-n-print-object (domain stream)						(defun GL-n-print-object (domain stream)
  (let ((n (dimension-of domain)))							  (let ((n (dimension-of domain)))
    (format stream "GL^~D(~S)" n (coefficient-domain-of domain))))			    (format stream "GL^~D(~S)" n (coefficient-domain-of domain))))

(defmethod print-object ((matrix GL-n-element) stream)					(defmethod print-object ((matrix GL-n-element) stream)
  (with-matrix-dimensions (dim1 dim2 array) matrix					  (with-matrix-dimensions (dim1 dim2 array) matrix
    (format stream "~A<" (class-name (class-of (domain-of matrix))))			    (format stream "~A<" (class-name (class-of (domain-of matrix))))
    (loop for i fixnum below dim1							    (loop for i fixnum below dim1
	  do (princ "<" stream)									  do (princ "<" stream)
	     (loop for j fixnum below dim2							     (loop for j fixnum below dim2
		   do (princ (aref array i j) stream)							   do (princ (aref array i j) stream)
		      (if (< (1+ j) dim2)								      (if (< (1+ j) dim2)
			  (princ ",  " stream)									  (princ ",  " stream)
			  (princ ">" stream)))	     								  (princ ">" stream)))	     
	     (if (< (1+ i) dim1)								     (if (< (1+ i) dim1)
		 (princ ",  " stream)									 (princ ",  " stream)
		 (princ ">" stream)))))									 (princ ">" stream)))))

(define-domain-element-classes GL-n GL-n-element)					(define-domain-element-classes GL-n GL-n-element)

(defmethod matrix-dimensions ((m GL-n-element))						(defmethod matrix-dimensions ((m GL-n-element))
  (let ((dim (dimension-of (domain-of m))))						  (let ((dim (dimension-of (domain-of m))))
    (values dim dim)))									    (values dim dim)))

(defmethod make-element ((domain GL-n) (value array) &rest ignore)			(defmethod make-element ((domain GL-n) (value array) &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (make-instance (first (domain-element-classes domain))				  (make-instance (first (domain-element-classes domain))
		 :domain domain :value value))								 :domain domain :value value))

(defmethod weyl::make-element ((domain GL-n) (value array)				(defmethod weyl::make-element ((domain GL-n) (value array)
			       &rest ignore)									       &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (multiple-value-bind (x-dim y-dim) (array-dimensions value)			    |	  (destructuring-bind (x-dim y-dim) (array-dimensions value)
    (let ((coef-domain (coefficient-domain-of domain))					    (let ((coef-domain (coefficient-domain-of domain))
	  (array (make-array (list x-dim y-dim))))						  (array (make-array (list x-dim y-dim))))
      (loop for i fixnum below x-dim do						    |	      (loop for i below x-dim do
	(loop for j fixnum below y-dim do					    |		(loop for j below y-dim do
	  (setf (aref array i j) (coerce (aref value i j) coef-domain))))			  (setf (aref array i j) (coerce (aref value i j) coef-domain))))
      (make-element domain value))))							      (make-element domain value))))

(defmethod make-element ((domain GL-n) (value list) &rest values)			(defmethod make-element ((domain GL-n) (value list) &rest values)
  (setq values (if (null values) value							  (setq values (if (null values) value
		   (cons value values)))								   (cons value values)))
  (unless (loop for row in (rest values)						  (unless (loop for row in (rest values)
		with n = (length (first values))							with n = (length (first values))
		do (unless (eql (length row) n)								do (unless (eql (length row) n)
		     (return nil))									     (return nil))
		finally (return t))									finally (return t))
    (error "All rows not the same length: ~S" values))					    (error "All rows not the same length: ~S" values))
  (make-element domain									  (make-element domain
		(make-array (list (length values) (length (first values)))				(make-array (list (length values) (length (first values)))
			    :initial-contents values)))								    :initial-contents values)))

(defmethod weyl::make-element ((domain GL-n) (value list) &rest values)			(defmethod weyl::make-element ((domain GL-n) (value list) &rest values)
  (setq values (if (null values) value							  (setq values (if (null values) value
		   (cons value values)))								   (cons value values)))
  (unless (loop for row in (rest values)						  (unless (loop for row in (rest values)
		with n = (length (first values))							with n = (length (first values))
		do (unless (eql (length row) n)								do (unless (eql (length row) n)
		     (return nil))									     (return nil))
		finally (return t))									finally (return t))
    (error "All rows not the same length: ~S" values))					    (error "All rows not the same length: ~S" values))
  (let* ((x-dim (length values))							  (let* ((x-dim (length values))
	 (y-dim (length (first values)))							 (y-dim (length (first values)))
	 (array (make-array (list x-dim y-dim))))						 (array (make-array (list x-dim y-dim))))
    (loop for i fixnum  below x-dim							    (loop for i fixnum  below x-dim
	  for row in values do									  for row in values do
	    (loop for j fixnum below y-dim							    (loop for j fixnum below y-dim
		  for val in row do									  for val in row do
		    (setf (aref array i j) val)))							    (setf (aref array i j) val)))
    (make-element domain array)))							    (make-element domain array)))

(defmethod one-matrix ((domain GL-n) &optional rank)					(defmethod one-matrix ((domain GL-n) &optional rank)
  (let ((computed-rank (dimension-of domain)))						  (let ((computed-rank (dimension-of domain)))
    (if rank										    (if rank
	(if (not (eq rank computed-rank))							(if (not (eq rank computed-rank))
	    (error "rank argument conflicts with domain dimension")))				    (error "rank argument conflicts with domain dimension")))
    (let* ((zero (zero (coefficient-domain-of domain)))					    (let* ((zero (zero (coefficient-domain-of domain)))
	   (one (one (coefficient-domain-of domain)))						   (one (one (coefficient-domain-of domain)))
	   (array (make-array (list computed-rank computed-rank)				   (array (make-array (list computed-rank computed-rank)
			      :initial-element zero)))								      :initial-element zero)))
      (loop for i fixnum below computed-rank do						      (loop for i fixnum below computed-rank do
	(setf (aref array i i) one))								(setf (aref array i i) one))
      (make-element domain array))))							      (make-element domain array))))

(defmethod one ((domain GL-n))								(defmethod one ((domain GL-n))
  (one-matrix domain))									  (one-matrix domain))

(defmethod times ((m GL-n-element) (v free-module-element))				(defmethod times ((m GL-n-element) (v free-module-element))
  (matrix-fme-times m v))								  (matrix-fme-times m v))

(defmethod times ((v free-module-element) (m GL-n-element))				(defmethod times ((v free-module-element) (m GL-n-element))
  (fme-matrix-times v m))								  (fme-matrix-times v m))

;;											;;
;; PSL(n) : group of matrices with determinant +1 or -1					;; PSL(n) : group of matrices with determinant +1 or -1
;;											;;

(defun PSL-n-print-object (domain stream)						(defun PSL-n-print-object (domain stream)
  (let ((n (dimension-of domain)))							  (let ((n (dimension-of domain)))
    (format stream "PSL^~D(~S)" n (coefficient-domain-of domain))))			    (format stream "PSL^~D(~S)" n (coefficient-domain-of domain))))

(define-domain-element-classes PSL-n PSL-n-element)					(define-domain-element-classes PSL-n PSL-n-element)

(define-domain-creator PSL-n ((domain field) dimension)				    |	(eval-when (:compile-toplevel :load-toplevel)
										    >	  (define-domain-creator PSL-n ((domain field) dimension)
  (make-instance 'PSL-n									    (make-instance 'PSL-n
		 :coefficient-domain domain						                   :coefficient-domain domain
		 :dimension dimension							                   :dimension dimension
		 :print-function 'PSL-n-print-object)					                   :print-function 'PSL-n-print-object)
  :predicate #'(lambda (d)								    :predicate #'(lambda (d)
		 (and (eql (class-name (class-of d)) 'PSL-n)				                   (and (eql (class-name (class-of d)) 'PSL-n)
		      (eql (coefficient-domain-of d) domain)				                        (eql (coefficient-domain-of d) domain)
		      (eql (dimension-of d) dimension))))			    |	                        (eql (dimension-of d) dimension)))))
;;											;;
;; SL(n) : group of matrices with determinant +1 					;; SL(n) : group of matrices with determinant +1 
;;											;;


(defun SL-n-print-object (domain stream)						(defun SL-n-print-object (domain stream)
  (let ((n (dimension-of domain)))							  (let ((n (dimension-of domain)))
    (format stream "SL^~D(~S)" n (coefficient-domain-of domain))))			    (format stream "SL^~D(~S)" n (coefficient-domain-of domain))))

(define-domain-element-classes SL-n SL-n-element)					(define-domain-element-classes SL-n SL-n-element)

(define-domain-creator SL-n ((domain field) dimension)				    |	(eval-when (:compile-toplevel :load-toplevel)
										    >	  (define-domain-creator SL-n ((domain field) dimension)
  (make-instance 'SL-n									    (make-instance 'SL-n
		 :coefficient-domain domain						                   :coefficient-domain domain
		 :dimension dimension							                   :dimension dimension
		 :print-function 'SL-n-print-object)					                   :print-function 'SL-n-print-object)
  :predicate #'(lambda (d)								    :predicate #'(lambda (d)
		 (and (eql (class-name (class-of d)) 'SL-n)				                   (and (eql (class-name (class-of d)) 'SL-n)
		      (eql (coefficient-domain-of d) domain)				                        (eql (coefficient-domain-of d) domain)
		      (eql (dimension-of d) dimension))))			    |	                        (eql (dimension-of d) dimension)))))

(defmethod determinant ((m SL-n-element))						(defmethod determinant ((m SL-n-element))
  (one (coefficient-domain-of (domain-of m))))						  (one (coefficient-domain-of (domain-of m))))

;;											;;
;; O(n) : group of orthogonal matrices							;; O(n) : group of orthogonal matrices
;;											;;


(defun O-n-print-object (domain stream)							(defun O-n-print-object (domain stream)
  (let ((n (dimension-of domain)))							  (let ((n (dimension-of domain)))
    (format stream "O^~D(~S)" n (coefficient-domain-of domain))))			    (format stream "O^~D(~S)" n (coefficient-domain-of domain))))

(define-domain-element-classes O-n O-n-element)						(define-domain-element-classes O-n O-n-element)

(define-domain-creator O-n ((domain field) dimension)				    |	(eval-when (:compile-toplevel :load-toplevel)
										    >	  (define-domain-creator O-n ((domain field) dimension)
  (make-instance 'O-n									    (make-instance 'O-n
		 :coefficient-domain domain						                   :coefficient-domain domain
		 :dimension dimension							                   :dimension dimension
		 :print-function 'O-n-print-object)					                   :print-function 'O-n-print-object)
  :predicate #'(lambda (d)								    :predicate #'(lambda (d)
		 (and (eql (class-name (class-of d)) 'O-n)				                   (and (eql (class-name (class-of d)) 'O-n)
		      (eql (coefficient-domain-of d) domain)				                        (eql (coefficient-domain-of d) domain)
		      (eql (dimension-of d) dimension))))			    |	                        (eql (dimension-of d) dimension)))))
;;											;;
;; SO(n) : orthogonal matrices with unit determinant					;; SO(n) : orthogonal matrices with unit determinant
;;											;;

(defun SO-n-print-object (domain stream)						(defun SO-n-print-object (domain stream)
  (let ((n (dimension-of domain)))							  (let ((n (dimension-of domain)))
    (format stream "SO^~D(~S)" n (coefficient-domain-of domain))))			    (format stream "SO^~D(~S)" n (coefficient-domain-of domain))))

(define-domain-element-classes SO-n SO-n-element)					(define-domain-element-classes SO-n SO-n-element)

(defmethod recip ((m SO-n-element))							(defmethod recip ((m SO-n-element))
  (transpose m))									  (transpose m))

(define-domain-creator SO-n ((domain field) dimension)				    |	(eval-when (:compile-toplevel :load-toplevel)
										    >	  (define-domain-creator SO-n ((domain field) dimension)
  (make-instance 'SO-n									    (make-instance 'SO-n
		 :coefficient-domain domain						                   :coefficient-domain domain
		 :dimension dimension							                   :dimension dimension
		 :print-function 'SO-n-print-object)					                   :print-function 'SO-n-print-object)
  :predicate #'(lambda (d)								    :predicate #'(lambda (d)
		 (and (eql (class-name (class-of d)) 'SO-n)				                   (and (eql (class-name (class-of d)) 'SO-n)
		      (eql (coefficient-domain-of d) domain)				                        (eql (coefficient-domain-of d) domain)
		      (eql (dimension-of d) dimension))))			    |	                        (eql (dimension-of d) dimension)))))



;;; ====================================================================		;;; ====================================================================
;;; Routines for obtaining determinants and subdeterminants of matrices			;;; Routines for obtaining determinants and subdeterminants of matrices
;;; ====================================================================		;;; ====================================================================

(defvar *work-array*)									(defvar *work-array*)

(defvar *work-matrix*)									(defvar *work-matrix*)

(defmacro with-open-modular-arith (p &body body)					(defmacro with-open-modular-arith (p &body body)
  `(let ((.prime. ,p)									  `(let ((.prime. ,p)
	 temp)											 temp)
	(declare (fixnum .prime. temp))						    <
	(macrolet ((c+ (x y)									(macrolet ((c+ (x y)
		     `(progn (setq temp (cl:+ (the fixnum ,x) (the fixnum ,y)))				     `(progn (setq temp (cl:+ (the fixnum ,x) (the fixnum ,y)))
			     (if (cl:> temp .prime.) (cl:- temp .prime.)					     (if (cl:> temp .prime.) (cl:- temp .prime.)
				 temp)))										 temp)))
		   (c- (x y)										   (c- (x y)
		     `(cl:mod (cl:- (the fixnum ,x) (the fixnum ,y))					     `(cl:mod (cl:- (the fixnum ,x) (the fixnum ,y))
			      .prime.))										      .prime.))
		   (c* (x y)										   (c* (x y)
		     `(the fixnum (cl:mod (cl:* (the fixnum ,x)						     `(the fixnum (cl:mod (cl:* (the fixnum ,x)
						(the fixnum ,y))									(the fixnum ,y))
					  .prime.))))										  .prime.))))
	  temp											  temp
	  ,@body)))										  ,@body)))

										    >	(defgeneric determinant (matrix)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
										    >	(defgeneric determinant* (domain matrix)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod determinant ((m matrix-element))						(defmethod determinant ((m matrix-element))
  (with-matrix-dimensions (dim1 dim2) m							  (with-matrix-dimensions (dim1 dim2) m
    (if (/= dim1 dim2)									    (if (/= dim1 dim2)
	(error "Matrix is not square: Can't compute the determinant"))				(error "Matrix is not square: Can't compute the determinant"))
    (setq *work-array* (make-array (list dim1 dim2)))					    (setq *work-array* (make-array (list dim1 dim2)))
    (determinant* (coefficient-domain-of (domain-of m)) m)))				    (determinant* (coefficient-domain-of (domain-of m)) m)))

(defmethod determinant* ((domain polynomial-ring) (m matrix-element))			(defmethod determinant* ((domain polynomial-ring) (m matrix-element))
  (setq *work-matrix* m)								  (setq *work-matrix* m)
  (interpolate domain 'Evaluate-matrix (degree-bounds m)))				  (interpolate domain 'Evaluate-matrix (degree-bounds m)))
	       
										    >	(defgeneric degree-bounds (matrix)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod degree-bounds ((m matrix-element))						(defmethod degree-bounds ((m matrix-element))
  (with-matrix-dimensions (dim1 dim2 array) m  						  (with-matrix-dimensions (dim1 dim2 array) m  
    (let ((vars (ring-variables (coefficient-domain-of (domain-of m))))			    (let ((vars (ring-variables (coefficient-domain-of (domain-of m))))
	  ring-var d)										  ring-var d)
	 (loop for var in vars do								 (loop for var in vars do
	   (setq ring-var (coerce var (coefficient-domain-of (domain-of m))))			   (setq ring-var (coerce var (coefficient-domain-of (domain-of m))))
	   (setq d (degree (aref array 0 0) ring-var))						   (setq d (degree (aref array 0 0) ring-var))
	   (loop for i below dim1 do								   (loop for i below dim1 do
	     (loop for j below dim2 do								     (loop for j below dim2 do
	       (if (> (degree (aref array i j) ring-var) d)					       (if (> (degree (aref array i j) ring-var) d)
		   (setq d (degree (aref array i j)ring-var)))))					   (setq d (degree (aref array i j)ring-var)))))
	   collect (* (min dim1 dim2) d)))))							   collect (* (min dim1 dim2) d)))))

(defmethod substitute ((values list) (variables list) (m matrix-element)		(defmethod substitute ((values list) (variables list) (m matrix-element)
		       &rest ignore)									       &rest ignore)
  (ignore (ignore ignore))							    |	  (declare (ignore ignore))
  (if (not (typep (coefficient-domain-of (domain-of m))					  (if (not (typep (coefficient-domain-of (domain-of m))
		  'multivariate-polynomial-ring))							  'multivariate-polynomial-ring))
      (error "Expected ~S to be over a multivariate-polynomial-ring"))		    |	      (error "Expected ~S to be over a multivariate-polynomial-ring" m))
  (with-matrix-dimensions (dim1 dim2 array) m						  (with-matrix-dimensions (dim1 dim2 array) m
    (let ((new-array (make-array (list dim1 dim2))))					    (let ((new-array (make-array (list dim1 dim2))))
	 (loop for i below dim1 do								 (loop for i below dim1 do
	   (loop for j below dim2 do								   (loop for j below dim2 do
	     (setf (aref new-array i j)								     (setf (aref new-array i j)
		   (substitute values variables (aref array i j)))))					   (substitute values variables (aref array i j)))))
	 (make-element (domain-of m) new-array))))						 (make-element (domain-of m) new-array))))

(defmethod coerce ((m matrix-element) (domain matrix-space))				(defmethod coerce ((m matrix-element) (domain matrix-space))
  (with-matrix-dimensions (dim1 dim2 array) m						  (with-matrix-dimensions (dim1 dim2 array) m
    (let ((new-array (make-array (list dim1 dim2))))					    (let ((new-array (make-array (list dim1 dim2))))
	 (loop for i below dim1 do								 (loop for i below dim1 do
	   (loop for j below dim2 do								   (loop for j below dim2 do
	     (setf (aref new-array i j)								     (setf (aref new-array i j)
		   (coerce (coerce (aref array i j) *general*)						   (coerce (coerce (aref array i j) *general*)
			   (coefficient-domain-of domain)))))							   (coefficient-domain-of domain)))))
	 (make-element domain new-array))))							 (make-element domain new-array))))

;; Used as a black box for sparse multivariate interpolation.				;; Used as a black box for sparse multivariate interpolation.
;; Note the use of *work-matrix*.							;; Note the use of *work-matrix*.
(defmethod evaluate-matrix ((vals list))						(defmethod evaluate-matrix ((vals list))
  (let ((poly-ring (coefficient-domain-of (domain-of *work-matrix*)))			  (let ((poly-ring (coefficient-domain-of (domain-of *work-matrix*)))
	(coef-domain (domain-of (first vals)))							(coef-domain (domain-of (first vals)))
	(domain (get-matrix-space (domain-of (first vals)))))					(domain (get-matrix-space (domain-of (first vals)))))
       (cond ((eql (coefficient-domain-of poly-ring) coef-domain)			       (cond ((eql (coefficient-domain-of poly-ring) coef-domain)
	      (determinant									      (determinant
		(coerce											(coerce
		  (substitute										  (substitute
		    (list-coerce vals poly-ring)							    (list-coerce vals poly-ring)
		    (list-coerce (ring-variables poly-ring) poly-ring)					    (list-coerce (ring-variables poly-ring) poly-ring)
		    *work-matrix*)									    *work-matrix*)
		  domain)))										  domain)))
	     (t (setq poly-ring (get-polynomial-ring						     (t (setq poly-ring (get-polynomial-ring
				  coef-domain										  coef-domain
				  (ring-variables poly-ring)))								  (ring-variables poly-ring)))
		(determinant										(determinant
		  (coerce										  (coerce
		    (substitute										    (substitute
		      (list-coerce vals poly-ring)							      (list-coerce vals poly-ring)
		      (list-coerce (ring-variables poly-ring) poly-ring)				      (list-coerce (ring-variables poly-ring) poly-ring)
		      (coerce *work-matrix* (get-matrix-space poly-ring)))				      (coerce *work-matrix* (get-matrix-space poly-ring)))
		    domain))))))									    domain))))))

(defmethod determinant* ((domain rational-integers) (m matrix-element))			(defmethod determinant* ((domain rational-integers) (m matrix-element))
  (loop for p in (choice-primes (hadamard-bound m))					  (loop for p in (choice-primes (hadamard-bound m))
	collect											collect
	(make-element (get-finite-field p) 							(make-element (get-finite-field p) 
	  (determinant (weyl:make-element							  (determinant (weyl:make-element
			   (get-matrix-space									   (get-matrix-space
			     (get-finite-field p)) (matrix-value m))))						     (get-finite-field p)) (matrix-value m))))
	  into remainders									  into remainders
	finally (return (compute-result (use-chinese-remainder remainders)))))			finally (return (compute-result (use-chinese-remainder remainders)))))

										    >	(defgeneric hadamard-bound (matrix)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod hadamard-bound ((m matrix-element))						(defmethod hadamard-bound ((m matrix-element))
  (with-matrix-dimensions (dim1 dim2 array) m  						  (with-matrix-dimensions (dim1 dim2 array) m  
    (let ((d (aref array 0 0))								    (let ((d (aref array 0 0))
	  (m (min dim1 dim2)))									  (m (min dim1 dim2)))
	 (loop for i below dim1 do								 (loop for i below dim1 do
	   (loop for j below dim2 do								   (loop for j below dim2 do
	     (if (> (aref array i j) d)								     (if (> (aref array i j) d)
		 (setq d (aref array i j)))))								 (setq d (aref array i j)))))
	 (* (expt m m) (expt d m)))))								 (* (expt m m) (expt d m)))))

(defmethod  determinant* ((domain GFp) (m matrix-element))				(defmethod  determinant* ((domain GFp) (m matrix-element))
  (with-matrix-dimensions (dimension dim2 old-array) m					  (with-matrix-dimensions (dimension dim2 old-array) m
    (declare (ignore dim2))								    (declare (ignore dim2))
    (let* ((determinant 1)								    (let* ((determinant 1)
	   (sign 1)										   (sign 1)
	   (modulus (characteristic domain)))							   (modulus (characteristic domain)))
    (flet ((exchange-rows (i j)								    (flet ((exchange-rows (i j)
	     (loop for l from j below dimension do						     (loop for l from j below dimension do
	       (rotatef (aref *work-array* i l) (aref *work-array* j l)))			       (rotatef (aref *work-array* i l) (aref *work-array* j l)))
	     (setq sign (* sign -1)))								     (setq sign (* sign -1)))
	   (find-pivot (j)									   (find-pivot (j)
	     (loop for i fixnum upfrom j below dimension do					     (loop for i fixnum upfrom j below dimension do
	       (if (not (= (aref *work-array* i j) 0))						       (if (not (= (aref *work-array* i j) 0))
		   (return i))										   (return i))
	       finally (return -1))))								       finally (return -1))))
    (loop for i fixnum below  dimension do						    (loop for i fixnum below  dimension do
      (loop for j fixnum below dimension do						      (loop for j fixnum below dimension do
	(setf (aref *work-array* i j) (gfp-value (aref old-array i j)))))			(setf (aref *work-array* i j) (gfp-value (aref old-array i j)))))
    (with-open-modular-arith modulus							    (with-open-modular-arith modulus
      (loop for j fixnum below (- dimension 1)					    |	      (loop for j below (- dimension 1)
	    with row fixnum and pivot fixnum and d do				    |		    with row of-type fixnum and pivot fixnum and d do
	      (setq row (find-pivot j))								      (setq row (find-pivot j))
	      (if (/= row -1)									      (if (/= row -1)
		  (setf determinant (c* determinant (aref *work-array* row j)))				  (setf determinant (c* determinant (aref *work-array* row j)))
		  (return (* sign determinant)))							  (return (* sign determinant)))
	      (setq pivot (aref *work-array* row j))						      (setq pivot (aref *work-array* row j))
	      (setq d (reduce-modulo-integer							      (setq d (reduce-modulo-integer
		       (compute-inverse pivot modulus)							       (compute-inverse pivot modulus)
			     modulus))										     modulus))
;	    (format t "pivot = ~D d = ~D~%" pivot d)					;	    (format t "pivot = ~D d = ~D~%" pivot d)
	      (if (> row j)									      (if (> row j)
		  (exchange-rows row j))								  (exchange-rows row j))
	      (loop for k fixnum upfrom (cl:+ j 1) below dimension		    |		      (loop for k upfrom (cl:+ j 1) below dimension
		    with ck do										    with ck do
		      (setq ck (c* d (aref *work-array* k j)))						      (setq ck (c* d (aref *work-array* k j)))
;		    (format t "ck = ~D~%" ck)						;		    (format t "ck = ~D~%" ck)
		      (loop for l fixnum upfrom j below dimension do		    |			      (loop for l of-type fixnum upfrom j below dimension do
			(setf (aref *work-array* k l)								(setf (aref *work-array* k l)
			      (c- (aref *work-array* k l)							      (c- (aref *work-array* k l)
				  (c* ck (aref *work-array* j l))))))							  (c* ck (aref *work-array* j l))))))
;	    (print *work-array*)							;	    (print *work-array*)
	    finally										    finally
	 (setq determinant (c* determinant (aref *work-array* j j))))))				 (setq determinant (c* determinant (aref *work-array* j j))))))
    (* sign determinant))))								    (* sign determinant))))

(defmethod determinant* ((domain field) (m matrix-element))				(defmethod determinant* ((domain field) (m matrix-element))
  (with-matrix-dimensions (dimension dim2 old-array) m					  (with-matrix-dimensions (dimension dim2 old-array) m
    (declare (ignore dim2))								    (declare (ignore dim2))
    (let* ((determinant (one domain))							    (let* ((determinant (one domain))
	   (sign (one domain)))									   (sign (one domain)))
	  (flet ((exchange-rows (i j)								  (flet ((exchange-rows (i j)
		   (loop for l from j below dimension do						   (loop for l from j below dimension do
		     (rotatef (aref *work-array* i l) (aref *work-array* j l)))				     (rotatef (aref *work-array* i l) (aref *work-array* j l)))
		   (setq sign (* sign (minus (one domain)))))						   (setq sign (* sign (minus (one domain)))))
		 (find-pivot (j)									 (find-pivot (j)
	           (loop for i fixnum upfrom j below dimension do				           (loop for i fixnum upfrom j below dimension do
		     (if (not (0? (aref *work-array* i j)))						     (if (not (0? (aref *work-array* i j)))
			 (return i))										 (return i))
			 finally										 finally
		      (return -1))))									      (return -1))))
          (loop for i fixnum below  dimension do					          (loop for i fixnum below  dimension do
	    (loop for j fixnum below dimension do						    (loop for j fixnum below dimension do
	      (setf (aref *work-array* i j) (aref old-array i j))))				      (setf (aref *work-array* i j) (aref old-array i j))))
		;; Triangulate										;; Triangulate
	   (loop for j fixnum below (- dimension 1)						   (loop for j fixnum below (- dimension 1)
		 with row and pivot and d do								 with row and pivot and d do
		   (setq row (find-pivot j))								   (setq row (find-pivot j))
		   (if (/= row -1)									   (if (/= row -1)
		       (setf determinant (* determinant							       (setf determinant (* determinant
					    (aref *work-array* row j)))								    (aref *work-array* row j)))
		       (return (zero domain)))								       (return (zero domain)))
		   (setq pivot (aref *work-array* row j))						   (setq pivot (aref *work-array* row j))
		   (setq d (recip pivot))								   (setq d (recip pivot))
		   ;; (print (format nil "pivot = ~D d = ~D" pivot d))					   ;; (print (format nil "pivot = ~D d = ~D" pivot d))
		   (if (> row j)									   (if (> row j)
		       (exchange-rows row j))								       (exchange-rows row j))
		   (loop for k fixnum upfrom (+ j 1) below dimension					   (loop for k fixnum upfrom (+ j 1) below dimension
			 with ck do										 with ck do
			   (setq ck (* d (aref *work-array* k j)))						   (setq ck (* d (aref *work-array* k j)))
			   ;; (print (format nil "ck = ~D" ck))							   ;; (print (format nil "ck = ~D" ck))
			   (loop for l fixnum upfrom j below dimension do					   (loop for l fixnum upfrom j below dimension do
			     (setf (aref *work-array* k l)							     (setf (aref *work-array* k l)
				   (- (aref *work-array* k l)								   (- (aref *work-array* k l)
				      (* ck (aref *work-array* j l))))))						      (* ck (aref *work-array* j l))))))
		   ;; (print *work-array*)								   ;; (print *work-array*)
		 finally										 finally
	      (return (* sign determinant (aref *work-array* j j))))))))			      (return (* sign determinant (aref *work-array* j j))))))))

;; Use this method to find determinant only if the matrix is very sparse.		;; Use this method to find determinant only if the matrix is very sparse.
;; It computes determinant by expansion of the minors, so it is very slow		;; It computes determinant by expansion of the minors, so it is very slow
;; unless the matrix is very sparse.							;; unless the matrix is very sparse.
(defmethod sparse-determinant ((m matrix-element))					(defmethod sparse-determinant ((m matrix-element))
  (with-matrix-dimensions (dim1 dim2 array) m						  (with-matrix-dimensions (dim1 dim2 array) m
    (if (/= dim1 dim2)									    (if (/= dim1 dim2)
	(error "Matrix is not square: Can't compute the determinant"))				(error "Matrix is not square: Can't compute the determinant"))

    (let* ((domain (domain-of m))							    (let* ((domain (domain-of m))
	   (coefficient-domain (coefficient-domain-of domain))					   (coefficient-domain (coefficient-domain-of domain))
	   (one (one coefficient-domain))	   						   (one (one coefficient-domain))	   
	   (zero (zero coefficient-domain)))							   (zero (zero coefficient-domain)))
      (labels ((sparse-det (row cols)							      (labels ((sparse-det (row cols)
		 #+ignore										 #+ignore
	         (format t "in minor: row = ~D, cols = ~S~%" row cols)				         (format t "in minor: row = ~D, cols = ~S~%" row cols)
		 (memoize `(sparse-det ,m ,row ,cols)							 (memoize `(sparse-det ,m ,row ,cols)
		   (if (null cols) one									   (if (null cols) one
		       (loop for col in cols								       (loop for col in cols
			     for positive-sign? = t then (not positive-sign?)					     for positive-sign? = t then (not positive-sign?)
			     with minor and det = zero								     with minor and det = zero
			     do (unless (0? (aref array row col))						     do (unless (0? (aref array row col))
				  (setq minor 										  (setq minor 
					(* (aref array row col)									(* (aref array row col)
					   (sparse-det (1+ row) (remove col cols))						   (sparse-det (1+ row) (remove col cols))
				  (setq det										  (setq det
					(if positive-sign?									(if positive-sign?
					    (+ det minor)									    (+ det minor)
					    (- det minor))))									    (- det minor))))
			     finally (return det))))))								     finally (return det))))))
    (sparse-det 0 (loop for i below dim1 collect i))))))				    (sparse-det 0 (loop for i below dim1 collect i))))))

										    >	(defgeneric independent-rows (array)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
;; Independent rows of a LISP array are obtained by transforming it			;; Independent rows of a LISP array are obtained by transforming it
;; into row echelon form.								;; into row echelon form.
(defmethod independent-rows (array)							(defmethod independent-rows (array)
  (let ((dim1 (first (array-dimensions array)))						  (let ((dim1 (first (array-dimensions array)))
	(dim2 (second (array-dimensions array))))						(dim2 (second (array-dimensions array))))
       (flet ((find-pivot (i)								       (flet ((find-pivot (i)
		     (loop for j fixnum below dim2							     (loop for j fixnum below dim2
		       do (if (not (0? (aref array i j)))						       do (if (not (0? (aref array i j)))
			      (return j))									      (return j))
			   finally										   finally
			(return -1))))										(return -1))))
	     (loop for i fixnum below dim1 with col and pivot					     (loop for i fixnum below dim1 with col and pivot
		   do (setq col (find-pivot i))								   do (setq col (find-pivot i))
		      (cond ((/= col -1)								      (cond ((/= col -1)
			     (setq pivot (recip (aref array i col)))						     (setq pivot (recip (aref array i col)))
			     (loop for k fixnum upfrom (+ i 1) below dim1					     (loop for k fixnum upfrom (+ i 1) below dim1
				   with ck										   with ck
				   do (setq ck (* pivot (aref array k col)))						   do (setq ck (* pivot (aref array k col)))
				      (loop for l fixnum upfrom col below dim2						      (loop for l fixnum upfrom col below dim2
					    do (setf (aref array k l)								    do (setf (aref array k l)
						     (- (aref array k l)								     (- (aref array k l)
							(* ck (aref array i l)))))								(* ck (aref array i l)))))
	     (loop for i below dim1								     (loop for i below dim1
		   if (/= (find-pivot i) -1)								   if (/= (find-pivot i) -1)
		     collect i))))									     collect i))))

										    >	(defgeneric independent-cols (array)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
;; independent columns of the array are abtained by transforming it into		;; independent columns of the array are abtained by transforming it into
;; column echelon form.									;; column echelon form.
(defmethod independent-cols (array)							(defmethod independent-cols (array)
  (let ((dim1 (first (array-dimensions array)))						  (let ((dim1 (first (array-dimensions array)))
	(dim2 (second (array-dimensions array))))						(dim2 (second (array-dimensions array))))
       (flet ((find-pivot (j)								       (flet ((find-pivot (j)
			  (loop for i fixnum below dim1								  (loop for i fixnum below dim1
			    do (if (not (0? (aref array i j)))							    do (if (not (0? (aref array i j)))
				   (return i))										   (return i))
				finally											finally
			     (return -1))))									     (return -1))))
	     (loop for j fixnum below dim2							     (loop for j fixnum below dim2
		   with row and pivot do								   with row and pivot do
		     (setq row (find-pivot j))								     (setq row (find-pivot j))
		     (cond ((/= row -1)									     (cond ((/= row -1)
			    (setq pivot (recip (aref array row j)))						    (setq pivot (recip (aref array row j)))
			    (loop for l fixnum upfrom (+ j 1) below dim2					    (loop for l fixnum upfrom (+ j 1) below dim2
				  with ck										  with ck
				  do (setq ck (* pivot (aref array row l)))						  do (setq ck (* pivot (aref array row l)))
				     (loop for k fixnum upfrom row below dim1						     (loop for k fixnum upfrom row below dim1
					   do (setf (aref array k l)								   do (setf (aref array k l)
						    (- (aref array k l)									    (- (aref array k l)
						       (* ck (aref array k j))))))							       (* ck (aref array k j))))))
	     (loop for j below dim2								     (loop for j below dim2
		   if (/= (find-pivot j) -1)								   if (/= (find-pivot j) -1)
		     collect j))))									     collect j))))

										    >	(defgeneric subdeterminant (matrix)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
										    >	(defgeneric subdeterminant* (domain matrix)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod subdeterminant ((m matrix-element))						(defmethod subdeterminant ((m matrix-element))
  (subdeterminant* (coefficient-domain-of (domain-of m)) m))				  (subdeterminant* (coefficient-domain-of (domain-of m)) m))

(defmethod subdeterminant* ((domain field) (m matrix-element))				(defmethod subdeterminant* ((domain field) (m matrix-element))
  (with-matrix-dimensions (dim1 dim2 array) m						  (with-matrix-dimensions (dim1 dim2 array) m
    (setq *work-array* (make-array (list dim1 dim2)))					    (setq *work-array* (make-array (list dim1 dim2)))
    (let ((rows '())									    (let ((rows '())
	  (cols '())										  (cols '())
	  (new-array nil))									  (new-array nil))
	 (loop for i fixnum below dim1						    |		 (loop for i below dim1
	       do (loop for j fixnum below dim2							       do (loop for j fixnum below dim2
			do (setf (aref *work-array* i j) (aref array i j))))					do (setf (aref *work-array* i j) (aref array i j))))
	 (setq rows (independent-rows *work-array*))						 (setq rows (independent-rows *work-array*))
	 (loop for i fixnum below dim1						    |		 (loop for i below dim1
	       do (loop for j fixnum below dim2					    |		       do (loop for j of-type fixnum below dim2
			do (setf (aref *work-array* i j) (aref array i j))))					do (setf (aref *work-array* i j) (aref array i j))))
	 (setq cols (independent-cols *work-array*))						 (setq cols (independent-cols *work-array*))
	 (if (/= (length rows) (length cols))							 (if (/= (length rows) (length cols))
	     (error "Internal error: row rank is not equal to column rank"))			     (error "Internal error: row rank is not equal to column rank"))
	 (setq new-array (make-array (list (length rows) (length cols))))			 (setq new-array (make-array (list (length rows) (length cols))))
	 (loop for i upfrom 0 as row in rows							 (loop for i upfrom 0 as row in rows
	       do (loop for j upfrom 0 as col in cols						       do (loop for j upfrom 0 as col in cols
			do (setf (aref new-array i j)								do (setf (aref new-array i j)
				 (aref array row col))))								 (aref array row col))))
	 (values (determinant* domain								 (values (determinant* domain
			       (weyl:make-element (domain-of m)							       (weyl:make-element (domain-of m)
				 new-array))										 new-array))
		 new-array										 new-array
		 rows))))										 rows))))

;; First, find a prime for which the rank of the matrix m is maximum.			;; First, find a prime for which the rank of the matrix m is maximum.
;; Then obtain independent rows and columns for that prime to obtain			;; Then obtain independent rows and columns for that prime to obtain
;; the largest nonsingular submatrix.							;; the largest nonsingular submatrix.
(defmethod subdeterminant* ((domain rational-integers) (m matrix-element))		(defmethod subdeterminant* ((domain rational-integers) (m matrix-element))
  (with-matrix-dimensions (dim1 dim2 array) m						  (with-matrix-dimensions (dim1 dim2 array) m
    (setq *work-array* (make-array (list dim1 dim2)))					    (setq *work-array* (make-array (list dim1 dim2)))
    (let ((primes (choice-primes (hadamard-bound m)))					    (let ((primes (choice-primes (hadamard-bound m)))
	  (gfp nil)										  (gfp nil)
	  (rows '())										  (rows '())
	  (temp-rows '())									  (temp-rows '())
	  (cols '())										  (cols '())
	  (prime-of-maxrank nil)								  (prime-of-maxrank nil)
	  (new-array nil))									  (new-array nil))
	 (loop for p in primes									 (loop for p in primes
	       do (setq gfp (get-finite-field p))						       do (setq gfp (get-finite-field p))
		  (loop for i fixnum below dim1					    |			  (loop for i below dim1
			do (loop for j fixnum below dim2							do (loop for j fixnum below dim2
				 do (setf (aref *work-array* i j)							 do (setf (aref *work-array* i j)
					  (coerce (aref array i j) gfp))))							  (coerce (aref array i j) gfp))))
		  (setq temp-rows (independent-rows *work-array*))					  (setq temp-rows (independent-rows *work-array*))
		  (cond ((> (length temp-rows) (length rows))						  (cond ((> (length temp-rows) (length rows))
			 (setq rows temp-rows)									 (setq rows temp-rows)
			 (setq prime-of-maxrank p))))								 (setq prime-of-maxrank p))))
	 (setq gfp (get-finite-field prime-of-maxrank))						 (setq gfp (get-finite-field prime-of-maxrank))
	 (loop for i fixnum below dim1						    |		 (loop for i below dim1
	       do (loop for j fixnum below dim2					    |		       do (loop for j below dim2
			do (setf (aref *work-array* i j)							do (setf (aref *work-array* i j)
				 (coerce (aref array i j) gfp))))							 (coerce (aref array i j) gfp))))
	 (setq cols (independent-cols *work-array*))						 (setq cols (independent-cols *work-array*))
	 (if (/= (length rows) (length cols))							 (if (/= (length rows) (length cols))
	     (error "Internal error: row rank is not equal to column rank"))			     (error "Internal error: row rank is not equal to column rank"))
	 (setq new-array (make-array (list (length rows) (length cols))))			 (setq new-array (make-array (list (length rows) (length cols))))
	 (loop for i upfrom 0 as row in rows							 (loop for i upfrom 0 as row in rows
	       do (loop for j upfrom 0 as col in cols						       do (loop for j upfrom 0 as col in cols
			do (setf (aref new-array i j)								do (setf (aref new-array i j)
				 (aref array row col))))								 (aref array row col))))
	 (values (determinant* domain								 (values (determinant* domain
			       (weyl:make-element (domain-of m)							       (weyl:make-element (domain-of m)
				 new-array))										 new-array))
		 new-array										 new-array
		 rows))))										 rows))))

;;; ====================================================================		;;; ====================================================================
;;; Routines for obtaining Hermite and Smith normal forms of matrices			;;; Routines for obtaining Hermite and Smith normal forms of matrices
;;; over the ring of integers.								;;; over the ring of integers.
;;; ====================================================================		;;; ====================================================================

										    >	(defgeneric hermite* (domain matrix)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod hermite ((m matrix-element))							(defmethod hermite ((m matrix-element))
  (with-matrix-dimensions (dim1 dim2) m							  (with-matrix-dimensions (dim1 dim2) m
    (if (> dim1 dim2)									    (if (> dim1 dim2)
	(setq m (transpose m)))									(setq m (transpose m)))
    (hermite* (coefficient-domain-of (domain-of m)) m)))				    (hermite* (coefficient-domain-of (domain-of m)) m)))

(defmethod hermite* ((domain rational-integers) (m matrix-element))			(defmethod hermite* ((domain rational-integers) (m matrix-element))
  (with-matrix-dimensions (dim1 dim2 array) m						  (with-matrix-dimensions (dim1 dim2 array) m
    (declare (ignore dim1))								    (declare (ignore dim1))
    (multiple-value-bind (R new-array rows) (subdeterminant m)				    (multiple-value-bind (R new-array rows) (subdeterminant m)
      (declare (ignore new-array))							      (declare (ignore new-array))
      (let ((A (make-array (list (length rows) dim2))))					      (let ((A (make-array (list (length rows) dim2))))
	   (loop for i upfrom 0 as row in rows							   (loop for i upfrom 0 as row in rows
		 do (loop for j below dim2								 do (loop for j below dim2
			  do (setf (aref A i j)									  do (setf (aref A i j)
				   (integer-value (aref array row j)))))						   (integer-value (aref array row j)))))
	   (weyl:make-element (domain-of m) (hermite-array A (abs R)))))))			   (weyl:make-element (domain-of m) (hermite-array A (abs R)))))))

;; Algorithm 2.4.8 on page 71 of the book by Cohen.					;; Algorithm 2.4.8 on page 71 of the book by Cohen.
(defun hermite-array (A R)								(defun hermite-array (A R)
  (let* ((m (first (array-dimensions A)))						  (let* ((m (first (array-dimensions A)))
	 (n (second (array-dimensions A)))							 (n (second (array-dimensions A)))
	 (B (make-array m))									 (B (make-array m))
	 (W (make-array (list m m)))								 (W (make-array (list m m)))
	 (j (- n 1))										 (j (- n 1))
	 (k j)											 (k j)
	 u v d q)										 u v d q)
	(loop for i downfrom (- m 1) downto 0 by 1 do						(loop for i downfrom (- m 1) downto 0 by 1 do
	  (loop while (> j 0) do								  (loop while (> j 0) do
	    (setf j (- j 1))									    (setf j (- j 1))
	    (cond										    (cond
	      ((/= (aref A i j) 0)								      ((/= (aref A i j) 0)
	       (if (= (aref A i k) 0)								       (if (= (aref A i k) 0)
		   (setf (aref A i k) R))								   (setf (aref A i k) R))
	       (multiple-value-setq								       (multiple-value-setq
		   (u v d) (extended-gcd (aref A i k) (aref A i j)))					   (u v d) (extended-gcd (aref A i k) (aref A i j)))
	       (loop for l below m do								       (loop for l below m do
		 (setf (aref B l)									 (setf (aref B l)
		       (cl:+ (cl:* u (aref A l k)) (cl:* v (aref A l j))))				       (cl:+ (cl:* u (aref A l k)) (cl:* v (aref A l j))))
		 (setf (aref A l j)									 (setf (aref A l j)
		       (sym-mod (cl:- (cl:* (cl:/ (aref A i k) d) (aref A l j))				       (sym-mod (cl:- (cl:* (cl:/ (aref A i k) d) (aref A l j))
				      (cl:* (cl:/ (aref A i j) d) (aref A l k)))					      (cl:* (cl:/ (aref A i j) d) (aref A l k)))
			   R))											   R))
		 (setf (aref A l k) (sym-mod (aref B l) R))))))						 (setf (aref A l k) (sym-mod (aref B l) R))))))
	  (multiple-value-setq (u v d) (extended-gcd (aref A i k) R))				  (multiple-value-setq (u v d) (extended-gcd (aref A i k) R))
	  (loop for l below m do								  (loop for l below m do
	    (setf (aref W l i) (mod (cl:* u (aref A l k)) R)))					    (setf (aref W l i) (mod (cl:* u (aref A l k)) R)))
	  (if (= (aref W i i) 0)								  (if (= (aref W i i) 0)
	      (setf (aref W i i) R))								      (setf (aref W i i) R))
	  (loop for j from (1+ i) below m do							  (loop for j from (1+ i) below m do
	    (setf q (floor (cl:/ (aref W i j) (aref W i i))))					    (setf q (floor (cl:/ (aref W i j) (aref W i i))))
	    (loop for l below m do								    (loop for l below m do
	      (setf (aref W l j) (cl:mod (cl:- (aref W l j)					      (setf (aref W l j) (cl:mod (cl:- (aref W l j)
					       (cl:* q (aref W l i)))								       (cl:* q (aref W l i)))
				      R))))										      R))))
	  (setf R (cl:/ R d))									  (setf R (cl:/ R d))
	  (decf k)										  (decf k)
	  (setf j k))										  (setf j k))
	W))											W))
										    >
										    >	(defgeneric smith (matrix)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
										    >	(defgeneric smith* (domain matrix)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))

(defmethod smith ((m matrix-element))							(defmethod smith ((m matrix-element))
  (with-matrix-dimensions (dim1 dim2) m							  (with-matrix-dimensions (dim1 dim2) m
    (if (> dim1 dim2)									    (if (> dim1 dim2)
	(setq m (transpose m)))									(setq m (transpose m)))
    (smith* (coefficient-domain-of (domain-of m)) m)))					    (smith* (coefficient-domain-of (domain-of m)) m)))

(defmethod smith* ((domain rational-integers) (m matrix-element))			(defmethod smith* ((domain rational-integers) (m matrix-element))
  (multiple-value-bind (R array) (subdeterminant m)					  (multiple-value-bind (R array) (subdeterminant m)
    (let ((A (make-array (array-dimensions array))))					    (let ((A (make-array (array-dimensions array))))
	 (loop for i below (first (array-dimensions array))					 (loop for i below (first (array-dimensions array))
	       do (loop for j below (second (array-dimensions array))				       do (loop for j below (second (array-dimensions array))
			do (setf (aref A i j)									do (setf (aref A i j)
				 (integer-value (aref array i j)))))							 (integer-value (aref array i j)))))
	 (smith-array A (abs R)))))								 (smith-array A (abs R)))))

;; Algorithm 2.4.14 on page 77 of the book by Cohen.					;; Algorithm 2.4.14 on page 77 of the book by Cohen.
(defun smith-array (A R)								(defun smith-array (A R)
  (let* ((n (first (array-dimensions A)))						  (let* ((n (first (array-dimensions A)))
	 (B (make-array n))									 (B (make-array n))
	 (Diagonal (make-array n))								 (Diagonal (make-array n))
	 (foundb '())										 (foundb '())
	 (failed '())										 (failed '())
	 u v d b1 k l)										 u v d b1 k l)
    (flet										    (flet
      ((processi (i)									      ((processi (i)
	 (let ((j i)										 (let ((j i)
	       (c 1))										       (c 1))
          (loop while (> c 0) do							          (loop while (> c 0) do
	    (setf c 0)										    (setf c 0)
	    (loop while (> j 0) do								    (loop while (> j 0) do
	      (setf j (- j 1))									      (setf j (- j 1))
	      (cond										      (cond
		((/= (aref A i j) 0)									((/= (aref A i j) 0)
		 (multiple-value-setq									 (multiple-value-setq
		     (u v d) (extended-gcd (aref A i i) (aref A i j)))					     (u v d) (extended-gcd (aref A i i) (aref A i j)))
		 (loop for l below n do									 (loop for l below n do
		   (setf (aref B l)									   (setf (aref B l)
			 (cl:+ (cl:* u (aref A l i)) (cl:* v (aref A l j))))					 (cl:+ (cl:* u (aref A l i)) (cl:* v (aref A l j))))
		   (setf (aref A l j)									   (setf (aref A l j)
			 (sym-mod										 (sym-mod
			  (cl:- (cl:* (cl:/ (aref A i i) d) (aref A l j))					  (cl:- (cl:* (cl:/ (aref A i i) d) (aref A l j))
				(cl:* (cl:/ (aref A i j) d) (aref A l i)))						(cl:* (cl:/ (aref A i j) d) (aref A l i)))
			     R))										     R))
		   (setf (aref A l i) (sym-mod (aref B l) R))))))					   (setf (aref A l i) (sym-mod (aref B l) R))))))
	    (setf j i)										    (setf j i)
	    (loop while (> j 0) do								    (loop while (> j 0) do
	      (setf j (- j 1))									      (setf j (- j 1))
	      (cond										      (cond
		((/= (aref A j i) 0)									((/= (aref A j i) 0)
		 (multiple-value-setq									 (multiple-value-setq
		     (u v d) (extended-gcd (aref A i i) (aref A j i)))					     (u v d) (extended-gcd (aref A i i) (aref A j i)))
		 (loop for l below n do									 (loop for l below n do
		   (setf (aref B l)									   (setf (aref B l)
			 (cl:+ (cl:* u (aref A i l)) (cl:* v (aref A j l))))					 (cl:+ (cl:* u (aref A i l)) (cl:* v (aref A j l))))
		   (setf (aref A j l)									   (setf (aref A j l)
			 (sym-mod (cl:- (cl:* (cl:/ (aref A i i) d)						 (sym-mod (cl:- (cl:* (cl:/ (aref A i i) d)
					      (aref A j l))									      (aref A j l))
				     (cl:* (cl:/ (aref A j i) d) (aref A i l)))						     (cl:* (cl:/ (aref A j i) d) (aref A i l)))
			     R))										     R))
		   (setf (aref A i l) (sym-mod (aref B l) R)))						   (setf (aref A i l) (sym-mod (aref B l) R)))
		 (incf c))))))))									 (incf c))))))))
    (if (= n 1)										    (if (= n 1)
	(setf (aref Diagonal 0) R))								(setf (aref Diagonal 0) R))
    (loop for i downfrom (- n 1) above 0 by 1 do					    (loop for i downfrom (- n 1) above 0 by 1 do
      (setf foundb '())									      (setf foundb '())
      (loop while (not foundb) do							      (loop while (not foundb) do
	(processi i)										(processi i)
	(setf b1 (if (= (aref A i i) 0) R (aref A i i)))					(setf b1 (if (= (aref A i i) 0) R (aref A i i)))
	(setf k (- i 1))									(setf k (- i 1))
	(setf l (- i 1))									(setf l (- i 1))
	(setf failed '())									(setf failed '())
	(loop while (and (>= k 0) (not failed)) do						(loop while (and (>= k 0) (not failed)) do
	  (loop while (and (>= l 0) (not failed)) do						  (loop while (and (>= l 0) (not failed)) do
	    (cond ((/= (rem (aref A k l) b1) 0)							    (cond ((/= (rem (aref A k l) b1) 0)
		   (setf failed 1)									   (setf failed 1)
		   (loop for m below n do								   (loop for m below n do
		     (setf (aref A i m) (cl:+ (aref A i m) (aref A k m))))))				     (setf (aref A i m) (cl:+ (aref A i m) (aref A k m))))))
	    (decf l))										    (decf l))
	  (setf l (- i 1))									  (setf l (- i 1))
	  (decf k))										  (decf k))
	(if (not failed)									(if (not failed)
	    (setf foundb 1)))									    (setf foundb 1)))
      (setf (aref Diagonal i) (gcd (aref A i i) R))					      (setf (aref Diagonal i) (gcd (aref A i i) R))
      (setf R (cl:/ R (aref Diagonal i))))						      (setf R (cl:/ R (aref Diagonal i))))
    (setf (aref Diagonal 0) (gcd (aref A 0 0) R))					    (setf (aref Diagonal 0) (gcd (aref A 0 0) R))
    Diagonal)))										    Diagonal)))
;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-		;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-
;;; ===========================================================================		;;; ===========================================================================
;;;			         Flat Meshing						;;;			         Flat Meshing
;;; ===========================================================================		;;; ===========================================================================
;;; (c) Copyright 1995 Cornell University						;;; (c) Copyright 1995 Cornell University

;;; mesh.lisp,v 1.11 1995/06/09 14:21:32 chew Exp					;;; mesh.lisp,v 1.11 1995/06/09 14:21:32 chew Exp

;;  Everything needed for flat meshing.							;;  Everything needed for flat meshing.

(in-package "WEYLI")								    |	(in-package :weyli)

(make::adjust-version-numbers Weyl "1.11")					    |	;;; DELETE (make::adjust-version-numbers Weyl "1.11")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Control Variables.									;;  Control Variables.

(defvar *delaunay* T)			; Each new triangle is checked.			(defvar *delaunay* T)			; Each new triangle is checked.
(defvar *cross-edges* nil)              ; Can't cross constraint edges.			(defvar *cross-edges* nil)              ; Can't cross constraint edges.

(defvar *mesh* nil)			; Holds the current mesh.			(defvar *mesh* nil)			; Holds the current mesh.
(defvar *space* nil)			; Holds the current mesh space.			(defvar *space* nil)			; Holds the current mesh space.
(defvar *too-close-factor* 0.75)        ; Affects what gets deleted when edges		(defvar *too-close-factor* 0.75)        ; Affects what gets deleted when edges
					; are split.  1.0 deletes too many.							; are split.  1.0 deletes too many.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Classes.										;;  Classes.

(defclass has-home-space ()								(defclass has-home-space ()
     ((home :initarg :home :reader home-of)))						     ((home :initarg :home :reader home-of)))

;;  The home-space acts as the parameter space.						;;  The home-space acts as the parameter space.
(defclass curved-simplex (has-home-space simplex) ())					(defclass curved-simplex (has-home-space simplex) ())

;;  The home of a noncurved simplex is determined by (the first of)		    |	(defgeneric home-of (simplex)
;;  its vertices.								    |	  (:documentation
(defmethod home-of ((simplex simplex))						    |	   "The home of a noncurved simplex is determined by (the first of)
  (domain-of (first (vertices-of simplex))))					    |	its vertices.")
										    >	  (:method ((simplex simplex)) (domain-of (first (vertices-of simplex)))))

(defclass triangulation (simplicial-complex)						(defclass triangulation (simplicial-complex)
     (;;  Most recent triangle inserted; used for beginning searches.			     (;;  Most recent triangle inserted; used for beginning searches.
      (most-recent :initform nil :accessor %most-recent)))				      (most-recent :initform nil :accessor %most-recent)))

(defclass c-triangulation (triangulation)						(defclass c-triangulation (triangulation)
     (;;  Holds the constraint edges. (The main tool to query this			     (;;  Holds the constraint edges. (The main tool to query this
      ;;  structure is Constraint.)							      ;;  structure is Constraint.)
      (constraints :initform (make-instance 'simplicial-complex)			      (constraints :initform (make-instance 'simplicial-complex)
		   :reader %constraints-of)))								   :reader %constraints-of)))

(defclass CDT (c-triangulation) ())							(defclass CDT (c-triangulation) ())

(defclass named-simplicial-complex (simplicial-complex)					(defclass named-simplicial-complex (simplicial-complex)
  (;;  Holds names.									  (;;  Holds names.
   (name-table :initform (make-hash-table) :reader %name-table-of)			   (name-table :initform (make-hash-table) :reader %name-table-of)
   (default-name :initform nil :accessor %default-name-of)))				   (default-name :initform nil :accessor %default-name-of)))

(defclass mesh (cdt named-simplicial-complex has-home-space)				(defclass mesh (cdt named-simplicial-complex has-home-space)
     (;;  Triangles waiting to be improved during Refine-Mesh.				     (;;  Triangles waiting to be improved during Refine-Mesh.
      (pending-list :initform nil :accessor %pending-list-of)))				      (pending-list :initform nil :accessor %pending-list-of)))

(defmethod initialize-instance :after ((mesh mesh) &rest ignore)			(defmethod initialize-instance :after ((mesh mesh) &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (with-slots (constraints) mesh							  (with-slots (constraints) mesh
	      (setf constraints (make-instance 'named-simplicial-complex))))			      (setf constraints (make-instance 'named-simplicial-complex))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Maintenance of Names.								;;  Maintenance of Names.
										    >	(defgeneric name (simplex mesh)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))

(defmethod name ((simplex simplex) (nsc named-simplicial-complex))			(defmethod name ((simplex simplex) (nsc named-simplicial-complex))
  (gethash (id-number-of simplex) (%name-table-of nsc)))				  (gethash (id-number-of simplex) (%name-table-of nsc)))

(defmethod name ((simplex simplex) (mesh mesh))						(defmethod name ((simplex simplex) (mesh mesh))
  (case (dimension-of simplex)								  (case (dimension-of simplex)
    ((0 1) (name simplex (%constraints-of mesh)))					    ((0 1) (name simplex (%constraints-of mesh)))
    (2 (call-next-method))								    (2 (call-next-method))
    (otherwise (error "Illegal use of NAME. ~s" simplex))))    				    (otherwise (error "Illegal use of NAME. ~s" simplex))))    

										    >	(defgeneric %set-name (simplex mesh name)
										    >	  (:documentation
										    >	   "The purpose of this function is unkown."))
										    >
(defmethod %set-name ((simplex simplex) (nsc named-simplicial-complex) name)		(defmethod %set-name ((simplex simplex) (nsc named-simplicial-complex) name)
  (if name										  (if name
      (setf (gethash (id-number-of simplex) (%name-table-of nsc)) name)			      (setf (gethash (id-number-of simplex) (%name-table-of nsc)) name)
      (remhash (id-number-of simplex) (%name-table-of nsc)))				      (remhash (id-number-of simplex) (%name-table-of nsc)))
  name)											  name)

(defmethod %set-name ((simplex simplex) (mesh mesh) name)				(defmethod %set-name ((simplex simplex) (mesh mesh) name)
  (case (dimension-of simplex)								  (case (dimension-of simplex)
    ((0 1) (%set-name simplex (%constraints-of mesh) name))				    ((0 1) (%set-name simplex (%constraints-of mesh) name))
    (2 (call-next-method))								    (2 (call-next-method))
    (otherwise (error "Illegal use of (SETF NAME). ~s" simplex))))			    (otherwise (error "Illegal use of (SETF NAME). ~s" simplex))))

(defsetf name %set-name)								(defsetf name %set-name)

										    >	(defgeneric insert (simplex nsc &key name &allow-other-keys)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod insert ((simplex simplex) (nsc named-simplicial-complex)			(defmethod insert ((simplex simplex) (nsc named-simplicial-complex)
		   &key (name (%default-name-of nsc))							   &key (name (%default-name-of nsc))
		   &allow-other-keys)									   &allow-other-keys)
  (setf (name simplex nsc) name)							  (setf (name simplex nsc) name)
  (call-next-method))									  (call-next-method))

										    >	(defgeneric delete-maximal-cell (simplex nsc)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod delete-maximal-cell ((simplex simplex)					(defmethod delete-maximal-cell ((simplex simplex)
				(nsc named-simplicial-complex))								(nsc named-simplicial-complex))
  (setf (name simplex nsc) nil)								  (setf (name simplex nsc) nil)
  (call-next-method))									  (call-next-method))

										    >	(defgeneric all-names (nsc)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod all-names ((nsc named-simplicial-complex))					(defmethod all-names ((nsc named-simplicial-complex))
  (let ((names nil))									  (let ((names nil))
    (maphash #'(lambda (ignore name) (declare (ignore ignore))				    (maphash #'(lambda (ignore name) (declare (ignore ignore))
		       (pushnew name names))								       (pushnew name names))
	     (%name-table-of nsc))								     (%name-table-of nsc))
    names))										    names))

(defmethod all-names ((sc simplicial-complex))						(defmethod all-names ((sc simplicial-complex))
  nil)											  nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Utilities.										;;  Utilities.

;;  Rotate the given list to bring the specified position to the front			;;  Rotate the given list to bring the specified position to the front
;;  (items are numbered 0, 1, 2,...).  If no position is specified			;;  (items are numbered 0, 1, 2,...).  If no position is specified
;;  then one item is rotated (the second item is then on the front).			;;  then one item is rotated (the second item is then on the front).
(defun rotate-list (list &optional (position 1))					(defun rotate-list (list &optional (position 1))
  (append (nthcdr position list) 							  (append (nthcdr position list) 
	  (butlast list (- (length list) position))))						  (butlast list (- (length list) position))))

;;  Rotate a list to bring the leftmost occurrence of the specified			;;  Rotate a list to bring the leftmost occurrence of the specified
;;  member to the front.  The test is eql unless altered using the			;;  member to the front.  The test is eql unless altered using the
;;  keyword :test.  Results are undefined if the given item is not a			;;  keyword :test.  Results are undefined if the given item is not a
;;  member of the given list.								;;  member of the given list.
(defun member-rotate (item list &key (test #'eql) (key #'identity))			(defun member-rotate (item list &key (test #'eql) (key #'identity))
  (rotate-list list (position item list :test test :key key)))				  (rotate-list list (position item list :test test :key key)))

;;  Convert a vector into a lisp complex number.					;;  Convert a vector into a lisp complex number.
										    >	(defgeneric complexer (vector)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod complexer ((vector vector-space-element))					(defmethod complexer ((vector vector-space-element))
  (unless (= 2 (dimension-of (domain-of vector)))					  (unless (= 2 (dimension-of (domain-of vector)))
    (error "Wrong length vector for conversion to complex number. ~s" vector))		    (error "Wrong length vector for conversion to complex number. ~s" vector))
  (cl:complex (convert-to-lisp-number (ref vector 0))					  (cl:complex (convert-to-lisp-number (ref vector 0))
	      (convert-to-lisp-number (ref vector 1))))						      (convert-to-lisp-number (ref vector 1))))

										    >	(defgeneric coordinate-list (vector)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod coordinate-list ((vector vector-space-element))				(defmethod coordinate-list ((vector vector-space-element))
  (loop for n below (dimension-of (domain-of vector))					  (loop for n below (dimension-of (domain-of vector))
	collect (convert-to-lisp-number (ref vector n))))					collect (convert-to-lisp-number (ref vector n))))

(defun sqr (item)									(defun sqr (item)
  (* item item))									  (* item item))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Queue (a list implementation of a standard queue).					;;  Queue (a list implementation of a standard queue).

;;  FIXTHIS: All this queue stuff should be somewhere else.  There are			;;  FIXTHIS: All this queue stuff should be somewhere else.  There are
;;  also implementations (with consistent interface) for stack,				;;  also implementations (with consistent interface) for stack,
;;  priority-queue, and random-queue.							;;  priority-queue, and random-queue.

(defclass queue ()									(defclass queue ()
     ((front :initarg :front :accessor front :reader %contents)				     ((front :initarg :front :accessor front :reader %contents)
      ;;  The last item in the queue.							      ;;  The last item in the queue.
      (back :initarg :back :accessor back)))						      (back :initarg :back :accessor back)))

(defun make-queue (&key (initial-contents nil))						(defun make-queue (&key (initial-contents nil))
  (setf initial-contents (copy-list initial-contents))					  (setf initial-contents (copy-list initial-contents))
  (make-instance 'queue :front initial-contents						  (make-instance 'queue :front initial-contents
		 :back (last initial-contents)))							 :back (last initial-contents)))

										    >	(defgeneric clearq (queue)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod clearq ((queue queue))							(defmethod clearq ((queue queue))
  (setf (front queue) nil)								  (setf (front queue) nil)
  (setf (back queue) nil))								  (setf (back queue) nil))

										    >	(defgeneric insertq (item queue)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod insertq (item (queue queue))							(defmethod insertq (item (queue queue))
  (with-slots (front back) queue							  (with-slots (front back) queue
     (cond (front			; Nonempty queue.				     (cond (front			; Nonempty queue.
	    (setf (rest back) (list item))							    (setf (rest back) (list item))
	    (setf back (rest back)))								    (setf back (rest back)))
	   (t				; Empty queue.						   (t				; Empty queue.
	    (setf front (list item))								    (setf front (list item))	
	    (setf back front)))))								    (setf back front)))))

;;  If :delete is null then the item is not removed from the queue.			;;  If :delete is null then the item is not removed from the queue.
										    >	(defgeneric getq (queue &key delete)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod getq ((queue queue) &key (delete t))						(defmethod getq ((queue queue) &key (delete t))
  (with-slots (front) queue								  (with-slots (front) queue
	      (let ((item (first front)))							      (let ((item (first front)))
		(if delete (setf front (rest front)))							(if delete (setf front (rest front)))
		item)))											item)))

										    >	(defgeneric emptyq? (queue)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod emptyq? ((queue queue))							(defmethod emptyq? ((queue queue))
  (not (front queue)))									  (not (front queue)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Geometry.										;;  Geometry.

;;  Given 3 complex numbers forming a triangle, return the complex			;;  Given 3 complex numbers forming a triangle, return the complex
;;  number that is the circumcenter.  Works with lisp complex numbers,			;;  number that is the circumcenter.  Works with lisp complex numbers,
;;  since the weyl versions have some problems.						;;  since the weyl versions have some problems.
(defun complex-circumcenter (a b c)							(defun complex-circumcenter (a b c)
  ;;  Map a and b to 0 and 1.								  ;;  Map a and b to 0 and 1.
  (let* ((bb (cl:- b a))								  (let* ((bb (cl:- b a))
	 (cc (cl:/ (cl:- c a) bb))								 (cc (cl:/ (cl:- c a) bb))
	 (cx (cl:realpart cc))									 (cx (cl:realpart cc))
	 (cy (cl:imagpart cc))									 (cy (cl:imagpart cc))
	 w)    											 w)    
    (when (cl:= 0 cy) (error "Flat triangle. ~s ~s ~s" a b c))				    (when (cl:= 0 cy) (error "Flat triangle. ~s ~s ~s" a b c))
    (setf w (cl:complex 0.5 (cl:/ (cl:+ (cl:* cx cx) (cl:* cy cy) (cl:- cx))		    (setf w (cl:complex 0.5 (cl:/ (cl:+ (cl:* cx cx) (cl:* cy cy) (cl:- cx))
				  (cl:* 2.0 cy))))									  (cl:* 2.0 cy))))
    ;;  Map back.									    ;;  Map back.
    (cl:+ (cl:* w bb) a)))								    (cl:+ (cl:* w bb) a)))

;;  Determine the center of a circle described by two points on the			;;  Determine the center of a circle described by two points on the
;;  circle and a radius.  The two points and the returned center are			;;  circle and a radius.  The two points and the returned center are
;;  all complex numbers.  There can be zero, one, or two solutions to			;;  all complex numbers.  There can be zero, one, or two solutions to
;;  this problem.  If there is no solution then a warning is printed			;;  this problem.  If there is no solution then a warning is printed
;;  and the midpoint of the two vertices is returned.  A radius of 0			;;  and the midpoint of the two vertices is returned.  A radius of 0
;;  is taken as a special case and no warning is issued.  If there are			;;  is taken as a special case and no warning is issued.  If there are
;;  two solutions then normally the solution to the left of the line			;;  two solutions then normally the solution to the left of the line
;;  from a to b is returned.  The other solution is returned if the			;;  from a to b is returned.  The other solution is returned if the
;;  given radius is negative.  Uses Lisp complex numbers.				;;  given radius is negative.  Uses Lisp complex numbers.
(defun circle-center (a b radius)							(defun circle-center (a b radius)
  ;;  Based on using complex arithmetic to map 0,2 to a,b.  c1 and c2			  ;;  Based on using complex arithmetic to map 0,2 to a,b.  c1 and c2
  ;;  represent the center in various coordinate frames.				  ;;  represent the center in various coordinate frames.
  (let* ((bb (cl:* 0.5 (cl:- b a)))							  (let* ((bb (cl:* 0.5 (cl:- b a)))
	 (rad (cl:/ radius (cl:abs bb)))							 (rad (cl:/ radius (cl:abs bb)))
	 (cy (cl:sqrt (cl:- 1 (cl:* rad rad))))							 (cy (cl:sqrt (cl:- 1 (cl:* rad rad))))
	 (c1 (cl:+ 1 cy))									 (c1 (cl:+ 1 cy))
	 ;;  Check for bad radius and alternate solution.					 ;;  Check for bad radius and alternate solution.
	 (c2 (cond 										 (c2 (cond 
	       ((cl:/= 0 (cl:realpart cy))							       ((cl:/= 0 (cl:realpart cy))
		(unless (cl:= 0 radius)									(unless (cl:= 0 radius)
		  (warn "Radius too small; half circle assumed. ~s ~s" a b))				  (warn "Radius too small; half circle assumed. ~s ~s" a b))
		1.0)											1.0)
	       ((cl:plusp radius) c1)								       ((cl:plusp radius) c1)
	       (t (cl:conjugate c1)))))								       (t (cl:conjugate c1)))))
    ;;  Switch back to original reference frame.					    ;;  Switch back to original reference frame.
    (cl:+ a (cl:* bb c2))))								    (cl:+ a (cl:* bb c2))))

										    >	(defgeneric make-mean-point (points &key mean-space point-space)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
;;  Make a point that is the mean of the given points.  The mean-space			;;  Make a point that is the mean of the given points.  The mean-space
;;  is the domain in which the mean is calculated; the point-space is			;;  is the domain in which the mean is calculated; the point-space is
;;  the domain in which the resulting point resides.  The two spaces			;;  the domain in which the resulting point resides.  The two spaces
;;  are presumably related via coerce.							;;  are presumably related via coerce.
(defmethod make-mean-point ((points list) &key						(defmethod make-mean-point ((points list) &key
			    (mean-space (domain-of (first points)))						    (mean-space (domain-of (first points)))
			    (point-space (domain-of (first points))))						    (point-space (domain-of (first points))))
  (let* ((vectors (mapcar #'(lambda (p) (coerce p mean-space)) points))			  (let* ((vectors (mapcar #'(lambda (p) (coerce p mean-space)) points))
	 (mean (/ (apply #'%plus vectors) (float (length points))))				 (mean (/ (apply #'%plus vectors) (float (length points))))
	 (point (make-point point-space (coerce mean point-space))))				 (point (make-point point-space (coerce mean point-space))))
    (unless (eql point-space mean-space)						    (unless (eql point-space mean-space)
      (setf (coerce point mean-space) mean))						      (setf (coerce point mean-space) mean))
    point))										    point))

(defconstant %deg-over-rad (cl:/ 180.0 cl:pi))						(defconstant %deg-over-rad (cl:/ 180.0 cl:pi))

;;  Compute the angle between two vectors.						;;  Compute the angle between two vectors.
										    >	(defgeneric angle (vertex triangle &rest args &key space)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod angle ((a vector-space-element) (b vector-space-element)			(defmethod angle ((a vector-space-element) (b vector-space-element)
		  &key (radians nil) (degrees (not radians)) &allow-other-keys)				  &key (radians nil) (degrees (not radians)) &allow-other-keys)
  ;;  The realpart is needed because we sometimes get a small				  ;;  The realpart is needed because we sometimes get a small
  ;;  imaginary component due to numerical error.					  ;;  imaginary component due to numerical error.
  (let ((angle (cl:realpart (cl:acos (convert-to-lisp-number				  (let ((angle (cl:realpart (cl:acos (convert-to-lisp-number
				      (/ (dot-product a b)								      (/ (dot-product a b)
					 (sqrt (* (dot-product a a)								 (sqrt (* (dot-product a a)
						  (dot-product b b)))))))))								  (dot-product b b)))))))))
    (if degrees (cl:* %deg-over-rad angle)						    (if degrees (cl:* %deg-over-rad angle)
	angle)))										angle)))

;;  Create a parameter-space.  This is used mainly to create simplices			;;  Create a parameter-space.  This is used mainly to create simplices
;;  that are curved in the target-space.  The map should take a				;;  that are curved in the target-space.  The map should take a
;;  vector-space-element and produce an element of the target-space.			;;  vector-space-element and produce an element of the target-space.
;;											;;
;;  If an inverse-map is given then that is used build the				;;  If an inverse-map is given then that is used build the
;;  correspondence between the parameter-space and the target-space			;;  correspondence between the parameter-space and the target-space
;;  (but inverse-maps are usually unavailable).  The inverse-map			;;  (but inverse-maps are usually unavailable).  The inverse-map
;;  should take an element of the target-space and produce a lisp			;;  should take an element of the target-space and produce a lisp
;;  vector.  The dimension of the parameter-space must be specified			;;  vector.  The dimension of the parameter-space must be specified
;;  when an inverse-map is used.							;;  when an inverse-map is used.
;;											;;
;;  If no inverse-map is available then the spaces are tied together			;;  If no inverse-map is available then the spaces are tied together
;;  via the correspondence between the parameter-vectors and the			;;  via the correspondence between the parameter-vectors and the
;;  target-points (i.e., the result will be that the target-points can			;;  target-points (i.e., the result will be that the target-points can
;;  be coerced into the parameter-space where they have the				;;  be coerced into the parameter-space where they have the
;;  coordinates given by the parameter vectors).  The					;;  coordinates given by the parameter vectors).  The
;;  parameter-vectors must be lisp vectors.  [At some point, we may			;;  parameter-vectors must be lisp vectors.  [At some point, we may
;;  want to check that the map actually takes the parameter-vectors			;;  want to check that the map actually takes the parameter-vectors
;;  into the target-points.]								;;  into the target-points.]
;;											;;
										    >	(defgeneric make-parameter-space (map-function target-space &key parameter-vectors
										    >	                                               target-points dimension inverse-map
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod make-parameter-space ((map function) (target-space vector-space)		(defmethod make-parameter-space ((map function) (target-space vector-space)
				 &key parameter-vectors target-points							 &key parameter-vectors target-points
				 dimension inverse-map)									 dimension inverse-map)
  (unless dimension									  (unless dimension
    (if parameter-vectors (setf dimension (length (first parameter-vectors)))		    (if parameter-vectors (setf dimension (length (first parameter-vectors)))
	(error "Cannot determine dimension in Make-Parameter-Space.")))				(error "Cannot determine dimension in Make-Parameter-Space.")))
  (let ((parameter-space (make-euclidean-space dimension))) ; A new space.		  (let ((parameter-space (make-euclidean-space dimension))) ; A new space.
    (make-homomorphism parameter-space map target-space)				    (make-homomorphism parameter-space map target-space)

    ;;  Establish the inverse correspondence between the spaces.			    ;;  Establish the inverse correspondence between the spaces.
    (if inverse-map									    (if inverse-map
	(make-homomorphism target-space								(make-homomorphism target-space
			   #'(lambda (e)									   #'(lambda (e)
			       (make-element parameter-space							       (make-element parameter-space
					     (funcall inverse-map e)))								     (funcall inverse-map e)))
			   parameter-space)									   parameter-space)
	(mapcar #'(lambda (vector point)							(mapcar #'(lambda (vector point)
		    (setf (coerce point parameter-space)						    (setf (coerce point parameter-space)
			  (make-element parameter-space vector)))						  (make-element parameter-space vector)))
		parameter-vectors target-points))							parameter-vectors target-points))
    parameter-space))									    parameter-space))

;;  Split the given simplex along the given face using the given			;;  Split the given simplex along the given face using the given
;;  splitting-point.  The default splitting-point is the mean-point of			;;  splitting-point.  The default splitting-point is the mean-point of
;;  the face.  Results are undefined if the given face does not				;;  the face.  Results are undefined if the given face does not
;;  correspond to part of the simplex.  Note that the calculations for			;;  correspond to part of the simplex.  Note that the calculations for
;;  the splitting-point and the creation of new simplices takes place			;;  the splitting-point and the creation of new simplices takes place
;;  in the simplex's home coordinate system.						;;  in the simplex's home coordinate system.
										    >	(defgeneric split (simplex where &rest args)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod split ((simplex simplex) (where (eql nil)) &key				(defmethod split ((simplex simplex) (where (eql nil)) &key
		  (face (vertices-of simplex))								  (face (vertices-of simplex))
		  (splitting-point									  (splitting-point
		   (make-mean-point face :mean-space (home-of simplex))))				   (make-mean-point face :mean-space (home-of simplex))))
  (loop with points = (vertices-of simplex)						  (loop with points = (vertices-of simplex)
	with home = (home-of simplex)								with home = (home-of simplex)
	for v in face										for v in face
	for new-set = (subst splitting-point v points)						for new-set = (subst splitting-point v points)
	collect (make-instance (class-of simplex)						collect (make-instance (class-of simplex)
		     :vertices new-set :home home)))							     :vertices new-set :home home)))

;;  Split a simplex within a simplicial-complex.					;;  Split a simplex within a simplicial-complex.
(defmethod split ((simplex simplex) (where simplicial-complex) &rest args)		(defmethod split ((simplex simplex) (where simplicial-complex) &rest args)
  (loop with simplices = (apply #'split simplex nil args)				  (loop with simplices = (apply #'split simplex nil args)
	initially (delete-maximal-cell simplex where)						initially (delete-maximal-cell simplex where)
	for s in simplices do									for s in simplices do
	  (insert s where)									  (insert s where)
	finally (return simplices)))								finally (return simplices)))

;;  Splitting a list splits each thing in the list.					;;  Splitting a list splits each thing in the list.
(defmethod split ((things list) where &rest ignore)					(defmethod split ((things list) where &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (loop for thing in things								  (loop for thing in things
	append (split thing where)))								append (split thing where)))

;;  Size of the given simplex.  We use the length of the longest side.			;;  Size of the given simplex.  We use the length of the longest side.
										    >	(defgeneric simplex-size (simplex &optional space)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod simplex-size ((simplex simplex) &optional (space (home-of simplex)))		(defmethod simplex-size ((simplex simplex) &optional (space (home-of simplex)))
  (loop with points = (vertices-of simplex)						  (loop with points = (vertices-of simplex)
        repeat (1- (length points))							        repeat (1- (length points))
        maximize (loop with p = (first points)						        maximize (loop with p = (first points)
                       for other in (rest points)					                       for other in (rest points)
                       maximize (convert-to-lisp-number					                       maximize (convert-to-lisp-number
                                 (distance p other :space space)))			                                 (distance p other :space space)))
        do (setf points (rest points))))						        do (setf points (rest points))))

;;  Returns :left, :right, or :on depending on position of third			;;  Returns :left, :right, or :on depending on position of third
;;  vertex in relation to ray from first to second vertex.  Some			;;  vertex in relation to ray from first to second vertex.  Some
;;  effort has been taken to ensure that this operation is safe in the			;;  effort has been taken to ensure that this operation is safe in the
;;  sense that the answer is the same even when the three vertices are			;;  sense that the answer is the same even when the three vertices are
;;  given in a different order.  Without this caution, you can run			;;  given in a different order.  Without this caution, you can run
;;  into problems (due to numerical error); for instance, a vertex			;;  into problems (due to numerical error); for instance, a vertex
;;  that looks as if it's on the line between two triangles can be			;;  that looks as if it's on the line between two triangles can be
;;  claimed to be :outside of each of them.						;;  claimed to be :outside of each of them.
										    >	(defgeneric bend (space &rest points)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod bend ((space vector-space) &rest three-points)				(defmethod bend ((space vector-space) &rest three-points)
  (unless (= 3 (length three-points))							  (unless (= 3 (length three-points))
    (error "Improper number of arguments to Bend; need space then 3 points."))		    (error "Improper number of arguments to Bend; need space then 3 points."))
  (let* ((ordered (sort (copy-list three-points) #'cl:< :key #'id-number-of))		  (let* ((ordered (sort (copy-list three-points) #'cl:< :key #'id-number-of))
	 (a (coerce (first ordered) space))							 (a (coerce (first ordered) space))
	 (b (coerce (second ordered) space))							 (b (coerce (second ordered) space))
	 (c (coerce (third ordered) space))							 (c (coerce (third ordered) space))
	 (det (* (sign-of-permutation ordered three-points)					 (det (* (sign-of-permutation ordered three-points)
		 (+ (* (- (ref b 1) (ref a 1)) (- (ref c 0) (ref b 0)))					 (+ (* (- (ref b 1) (ref a 1)) (- (ref c 0) (ref b 0)))
		    (* (- (ref a 0) (ref b 0)) (- (ref c 1) (ref b 1)))))))				    (* (- (ref a 0) (ref b 0)) (- (ref c 1) (ref b 1)))))))
    (cond ((> 0 det) :left)								    (cond ((> 0 det) :left)
	  ((< 0 det) :right)									  ((< 0 det) :right)
	  (t :on))))										  (t :on))))

										    >	(defgeneric distance (vector1 vector2 &rest ignore)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod distance ((vectora vector-space-element)					(defmethod distance ((vectora vector-space-element)
		     (vectorb vector-space-element) &rest ignore)					     (vectorb vector-space-element) &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (let ((diff (- vectorb vectora)))							  (let ((diff (- vectorb vectora)))
    (sqrt (dot-product diff diff))))							    (sqrt (dot-product diff diff))))

(defmethod distance ((pointa point) (pointb point) &key (space nil))			(defmethod distance ((pointa point) (pointb point) &key (space nil))
  (unless space										  (unless space
    (error "Must specify space for Distance between points."))				    (error "Must specify space for Distance between points."))
  (call-next-method (coerce pointa space) (coerce pointb space)))			  (call-next-method (coerce pointa space) (coerce pointb space)))

(defmethod distance ((lista list) (listb list) &rest ignore)				(defmethod distance ((lista list) (listb list) &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (unless (= (length lista) (length listb))						  (unless (= (length lista) (length listb))
    (error "Cannot comput distance between lists of different lengths. ~s ~s"		    (error "Cannot comput distance between lists of different lengths. ~s ~s"
	   lista listb))									   lista listb))
  (loop for a in lista									  (loop for a in lista
        for b in listb									        for b in listb
	sum (sqr (- b a)) into sum-of-squares							sum (sqr (- b a)) into sum-of-squares
	finally (return (sqrt sum-of-squares))))						finally (return (sqrt sum-of-squares))))	

;;  Returns T iff the given edges cross each other.  Returns true even			;;  Returns T iff the given edges cross each other.  Returns true even
;;  when one vertex of one edge is :on the other edge.					;;  when one vertex of one edge is :on the other edge.
										    >	(defgeneric edges-cross? (space edge1 edge2)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod edges-cross? ((space vector-space) (edge-a list) (edge-b list))		(defmethod edges-cross? ((space vector-space) (edge-a list) (edge-b list))
  (and (not (eql (bend space (first edge-a) (second edge-a) (first edge-b))		  (and (not (eql (bend space (first edge-a) (second edge-a) (first edge-b))
		 (bend space (first edge-a) (second edge-a) (second edge-b))))				 (bend space (first edge-a) (second edge-a) (second edge-b))))
       (not (eql (bend space (first edge-b) (second edge-b) (first edge-a))		       (not (eql (bend space (first edge-b) (second edge-b) (first edge-a))
		 (bend space (first edge-b) (second edge-b) (second edge-a))))				 (bend space (first edge-b) (second edge-b) (second edge-a))))
       ))										       ))

;;  A bounding-box is a pair (low high) of coordinate lists.  For			;;  A bounding-box is a pair (low high) of coordinate lists.  For
;;  instance, 2D points would produce: ((low-x low-y) (high-x				;;  instance, 2D points would produce: ((low-x low-y) (high-x
;;  high-y)).  Useful mostly for graphics.  Also used for mesh				;;  high-y)).  Useful mostly for graphics.  Also used for mesh
;;  initialization.									;;  initialization.
										    >	(defgeneric bounding-box (point space)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod bounding-box ((point point) (space vector-space))				(defmethod bounding-box ((point point) (space vector-space))
  (let ((c (coordinate-list (coerce point space))))					  (let ((c (coordinate-list (coerce point space))))
    (list c c)))									    (list c c)))

(defmethod bounding-box ((list list) (space vector-space))				(defmethod bounding-box ((list list) (space vector-space))
  (if (= 1 (length list))								  (if (= 1 (length list))
      (bounding-box (first list) space)							      (bounding-box (first list) space)
      (let ((a (bounding-box (first list) space))					      (let ((a (bounding-box (first list) space))
	    (b (bounding-box (rest list) space)))						    (b (bounding-box (rest list) space)))
	(list (mapcar #'cl:min (first a) (first b))						(list (mapcar #'cl:min (first a) (first b))
	      (mapcar #'cl:max (second a) (second b))))))					      (mapcar #'cl:max (second a) (second b))))))

(defmethod bounding-box ((simplex simplex) (space vector-space))			(defmethod bounding-box ((simplex simplex) (space vector-space))
  (bounding-box (vertices-of simplex) space))						  (bounding-box (vertices-of simplex) space))

(defmethod bounding-box ((sc simplicial-complex) (space vector-space))			(defmethod bounding-box ((sc simplicial-complex) (space vector-space))
  (let (old new)									  (let (old new)
    (map-over-cells (cell) sc								    (map-over-cells (cell) sc
      (setf new (bounding-box cell space))						      (setf new (bounding-box cell space))
      (unless old (setf old new))							      (unless old (setf old new))
      (setf old (list (mapcar #'cl:min (first new) (first old))				      (setf old (list (mapcar #'cl:min (first new) (first old))
		      (mapcar #'cl:max (second new) (second old)))))					      (mapcar #'cl:max (second new) (second old)))))
    old))										    old))

;;  Report the measure of the given simplex in the given space.				;;  Report the measure of the given simplex in the given space.
;;  FIXTHIS: This should be a general measure function based on				;;  FIXTHIS: This should be a general measure function based on
;;  determinants so that it works in any dimension.					;;  determinants so that it works in any dimension.
										    >	(defgeneric measure (simplex space)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod measure ((simplex simplex) (space vector-space))				(defmethod measure ((simplex simplex) (space vector-space))
  (let ((vertices (vertices-of simplex)))						  (let ((vertices (vertices-of simplex)))
    (case (dimension-of simplex)							    (case (dimension-of simplex)
      (0 0)										      (0 0)
      (1 (distance (first vertices) (second vertices) :space space))			      (1 (distance (first vertices) (second vertices) :space space))
      (2 (let* ((a (complexer (coerce (first vertices) space)))				      (2 (let* ((a (complexer (coerce (first vertices) space)))
		(b (complexer (coerce (second vertices) space)))					(b (complexer (coerce (second vertices) space)))
		(c (complexer (coerce (third vertices) space)))						(c (complexer (coerce (third vertices) space)))
		(bb (cl:- b a))										(bb (cl:- b a))
		(cc (cl:/ (cl:- c a) bb)))								(cc (cl:/ (cl:- c a) bb)))
	   (cl:* 0.5 (cl:imagpart cc) bb (cl:conjugate bb))))					   (cl:* 0.5 (cl:imagpart cc) bb (cl:conjugate bb))))
      (otherwise (error "Measure not yet implemented for higher dimensions."))		      (otherwise (error "Measure not yet implemented for higher dimensions."))
      )))										      )))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Segments.										;;  Segments.

;;  Given endpoints of an arc together with other information about			;;  Given endpoints of an arc together with other information about
;;  the arc's shape, return a segment corresponding to the arc.  The			;;  the arc's shape, return a segment corresponding to the arc.  The
;;  arc can go :thru a given vertex, can have a given :radius, or can			;;  arc can go :thru a given vertex, can have a given :radius, or can
;;  have a given :center vertex.  A radius that is too small (e.g.,			;;  have a given :center vertex.  A radius that is too small (e.g.,
;;  zero) creates a half circle.  Weird things can happen if the given			;;  zero) creates a half circle.  Weird things can happen if the given
;;  center is impossible for the given endpoints or if more than one			;;  center is impossible for the given endpoints or if more than one
;;  of these options is given.  Direction can be specified, either :cw			;;  of these options is given.  Direction can be specified, either :cw
;;  or :ccw.  If direction is not specified then :ccw is the default.			;;  or :ccw.  If direction is not specified then :ccw is the default.
;;  Uses Lisp complex numbers.								;;  Uses Lisp complex numbers.
										    >	(defgeneric arc (point1 point2 space &key thru radius center clockwise cw
										    >	                        counterclockwise ccw direction)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod arc ((apoint point) (bpoint point) (space vector-space) &key			(defmethod arc ((apoint point) (bpoint point) (space vector-space) &key
		thru radius center									thru radius center
		clockwise (cw clockwise)								clockwise (cw clockwise)
		(counterclockwise (not cw)) (ccw counterclockwise)					(counterclockwise (not cw)) (ccw counterclockwise)
		(direction (if ccw :ccw :cw)))								(direction (if ccw :ccw :cw)))
  ;;  Convert to complex.  A and b are endpoints of the arc; c is the center. 		  ;;  Convert to complex.  A and b are endpoints of the arc; c is the center. 
  (let* ((a (complexer (coerce apoint space)))						  (let* ((a (complexer (coerce apoint space)))
	 (b (complexer (coerce bpoint space)))							 (b (complexer (coerce bpoint space)))
	 (c (cond										 (c (cond
	      ;;  If center was given, we do a simple conversion.				      ;;  If center was given, we do a simple conversion.
	      (center (complexer (coerce center space)))					      (center (complexer (coerce center space)))
	      ;;  If thru was given, we use the circumcenter.					      ;;  If thru was given, we use the circumcenter.
	      (thru (complex-circumcenter a b (complexer (coerce thru space))))			      (thru (complex-circumcenter a b (complexer (coerce thru space))))
	      ;;  If radius was given, we compute the center.					      ;;  If radius was given, we compute the center.
	      (radius (circle-center a b (convert-to-lisp-number radius)))))			      (radius (circle-center a b (convert-to-lisp-number radius)))))
	 theta-a theta-b generator)								 theta-a theta-b generator)
    ;;  Swap the endpoints if not doing :ccw.						    ;;  Swap the endpoints if not doing :ccw.
    (when (not (eql :ccw direction)) 							    (when (not (eql :ccw direction)) 
      (rotatef a b) (rotatef apoint bpoint))						      (rotatef a b) (rotatef apoint bpoint))
    ;;  Determine angles and radius (the existing radius value could			    ;;  Determine angles and radius (the existing radius value could
    ;;  be nil, too small, or negative).						    ;;  be nil, too small, or negative).
    (setf theta-a (cl:phase (cl:- a c)))						    (setf theta-a (cl:phase (cl:- a c)))
    (setf theta-b (cl:phase (cl:- b c)))						    (setf theta-b (cl:phase (cl:- b c)))
    (setf radius (cl:abs (cl:- a c)))							    (setf radius (cl:abs (cl:- a c)))
    ;;  Make sure direction is right.							    ;;  Make sure direction is right.
    (unless (cl:< theta-a theta-b)							    (unless (cl:< theta-a theta-b)
      (setf theta-b (cl:+ theta-b (cl:* 2 cl:pi))))					      (setf theta-b (cl:+ theta-b (cl:* 2 cl:pi))))
    ;;  Create the parametric function.							    ;;  Create the parametric function.
    (setf generator #'(lambda (theta)							    (setf generator #'(lambda (theta)
			(let* ((ltheta (convert-to-lisp-number theta))						(let* ((ltheta (convert-to-lisp-number theta))
			       (d (cl:complex (cl:cos ltheta) (cl:sin ltheta)))					       (d (cl:complex (cl:cos ltheta) (cl:sin ltheta)))
			       (transformed (cl:+ c (cl:* radius d))))						       (transformed (cl:+ c (cl:* radius d))))
			  (make-element space (cl:realpart transformed)						  (make-element space (cl:realpart transformed)
					(cl:imagpart transformed)))))								(cl:imagpart transformed)))))
    ;;  Create the segment.								    ;;  Create the segment.
    (make-instance 'curved-simplex :vertices (list apoint bpoint)			    (make-instance 'curved-simplex :vertices (list apoint bpoint)
		   :home (make-parameter-space								   :home (make-parameter-space
			  #'(lambda (v) (funcall generator (ref v 0)))						  #'(lambda (v) (funcall generator (ref v 0)))
			  space											  space
			  :parameter-vectors (list (vector theta-a)						  :parameter-vectors (list (vector theta-a)
						   (vector theta-b))									   (vector theta-b))
			  :target-points (list apoint bpoint)))))						  :target-points (list apoint bpoint)))))

;;  Note that the generator here take a number (the parameter) and			;;  Note that the generator here take a number (the parameter) and
;;  returns an element of the space.							;;  returns an element of the space.
										    >	(defgeneric make-curved-segment (space param1 endpoint1 param2 endpoint2 generator
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod make-curved-segment ((space vector-space)					(defmethod make-curved-segment ((space vector-space)
				(a-param-value number) (a-endpoint point)						(a-param-value number) (a-endpoint point)
				(b-param-value number) (b-endpoint point)						(b-param-value number) (b-endpoint point)
				(generator function))									(generator function))
  (make-instance 'curved-simplex :vertices (list a-endpoint b-endpoint)			  (make-instance 'curved-simplex :vertices (list a-endpoint b-endpoint)
		 :home (make-parameter-space								 :home (make-parameter-space
			#'(lambda (v) (funcall generator (ref v 0)))						#'(lambda (v) (funcall generator (ref v 0)))
			space											space
			:parameter-vectors (list (vector a-param-value)						:parameter-vectors (list (vector a-param-value)
						 (vector b-param-value))								 (vector b-param-value))
			:target-points (list a-endpoint b-endpoint))))						:target-points (list a-endpoint b-endpoint))))

;;  Return the endpoint common to two segments.						;;  Return the endpoint common to two segments.
(defun common-endpoint (segment-a segment-b)						(defun common-endpoint (segment-a segment-b)
  (first (intersection (vertices-of segment-a) (vertices-of segment-b))))		  (first (intersection (vertices-of segment-a) (vertices-of segment-b))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Triangles.										;;  Triangles.

;;  Report whether the given point is :inside, :outside, or :on the			;;  Report whether the given point is :inside, :outside, or :on the
;;  given triangle.  Works regardless of whether triangle is clockwise			;;  given triangle.  Works regardless of whether triangle is clockwise
;;  or counterclockwise.  Returns multiple values -- if the vertex is			;;  or counterclockwise.  Returns multiple values -- if the vertex is
;;  :on the triangle then an appropriate side or vertex is also				;;  :on the triangle then an appropriate side or vertex is also
;;  returned.										;;  returned.
										    >	(defgeneric point-vs-triangle (vertex triangle &key space)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod point-vs-triangle ((vertex point) (triangle simplex)				(defmethod point-vs-triangle ((vertex point) (triangle simplex)
			      &key (space (home-of triangle)))							      &key (space (home-of triangle)))
  (unless (triangle? triangle)								  (unless (triangle? triangle)
    (error "Point-vs-Triangle only works on triangles. ~s" triangle))			    (error "Point-vs-Triangle only works on triangles. ~s" triangle))
  (loop with on-side = nil								  (loop with on-side = nil
	with vertices = (vertices-of triangle)							with vertices = (vertices-of triangle)
	for va in vertices									for va in vertices
	for vb in (rotate-list vertices)							for vb in (rotate-list vertices)
	for bend = (bend space va vb vertex)							for bend = (bend space va vb vertex)
	collect bend into bends									collect bend into bends
	do (if (eql bend :on) (setf on-side (list va vb)))					do (if (eql bend :on) (setf on-side (list va vb)))
	finally											finally
     (cond										     (cond
       ((and (member :left bends) (member :right bends)) (return :outside))		       ((and (member :left bends) (member :right bends)) (return :outside))
       (on-side (return (values :on (cond						       (on-side (return (values :on (cond
				      ((0? (distance (first on-side) vertex						      ((0? (distance (first on-side) vertex
						     :space space))									     :space space))
				       (first on-side))									       (first on-side))
				      ((0? (distance (second on-side) vertex						      ((0? (distance (second on-side) vertex
						     :space space))									     :space space))
				       (second on-side))								       (second on-side))
				      (t on-side)))))									      (t on-side)))))
       (T (return :inside)))))								       (T (return :inside)))))
		    											    
;;  Return the (counterclockwise) oriented side opposite the given			;;  Return the (counterclockwise) oriented side opposite the given
;;  vertex.										;;  vertex.
										    >	(defgeneric ccw-side (vertex triangle)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod ccw-side ((vertex point) (triangle simplex))					(defmethod ccw-side ((vertex point) (triangle simplex))
  (let ((side (opposite vertex triangle)))						  (let ((side (opposite vertex triangle)))
    (if (eql :left (apply #'bend (home-of triangle) vertex side))			    (if (eql :left (apply #'bend (home-of triangle) vertex side))
	side (rotate-list side))))								side (rotate-list side))))

;;  Given a set of adjacency triples of the form (left-ptr vertex			;;  Given a set of adjacency triples of the form (left-ptr vertex
;;  right-ptr), return a list of triangles created by these triples.			;;  right-ptr), return a list of triangles created by these triples.
;;  When triangles are created, the points are in counterclockwise			;;  When triangles are created, the points are in counterclockwise
;;  order.  If a poison-vertex is given then no triangle that contains			;;  order.  If a poison-vertex is given then no triangle that contains
;;  that vertex or pair of triangles that cover that vertex will be			;;  that vertex or pair of triangles that cover that vertex will be
;;  allowed until the very last triangle created.  This function takes			;;  allowed until the very last triangle created.  This function takes
;;  linear time: Whenever a triangle is created, two new vertices must			;;  linear time: Whenever a triangle is created, two new vertices must
;;  be inspected (they are pushed onto triples).  The sum				;;  be inspected (they are pushed onto triples).  The sum
;;  3*(triangles-to-do) + |triples| always decreases.					;;  3*(triangles-to-do) + |triples| always decreases.
(defun triangulate-triples (triples poison-vertex space triangle-class			(defun triangulate-triples (triples poison-vertex space triangle-class
				    &rest args)										    &rest args)
  (loop	with left and right and triangle and relation					  (loop	with left and right and triangle and relation
	;; T when we need to watch for pair of covering triangles.				;; T when we need to watch for pair of covering triangles.
	with on-flag = nil									with on-flag = nil		
	with triangle-list         ;;  What we return.						with triangle-list         ;;  What we return.
	with triangles-to-do = (- (length triples) 2)						with triangles-to-do = (- (length triples) 2)
	;;  Choose the next vertex.								;;  Choose the next vertex.
	while (and (> triangles-to-do 0) triples)						while (and (> triangles-to-do 0) triples)
	for triple = (pop triples)								for triple = (pop triples)
	for v = (second triple)									for v = (second triple)
	;;   Use it if...  it hasn't been done (once underway, a				;;   Use it if...  it hasn't been done (once underway, a
	;;   triple can appear more than once), it has a left					;;   triple can appear more than once), it has a left
	;;   neighbor, it has a right neighbor, and the triangle bends				;;   neighbor, it has a right neighbor, and the triangle bends
	;;   the right way.									;;   the right way.
	do (when (and v										do (when (and v	
		      (first triple) (setq left (second (first triple)))				      (first triple) (setq left (second (first triple)))
		      (third triple) (setq right (second (third triple)))				      (third triple) (setq right (second (third triple)))
		      (eql :left (bend space left right v)))						      (eql :left (bend space left right v)))
	     (setf triangle (apply #'make-instance triangle-class				     (setf triangle (apply #'make-instance triangle-class
				   :vertices (list left right v)							   :vertices (list left right v)
				   :home space args))									   :home space args))
	     ;;  Check for the poison-vertex.  Automatically ok if				     ;;  Check for the poison-vertex.  Automatically ok if
	     ;;  there's no poison vertex or we're on the last					     ;;  there's no poison vertex or we're on the last
	     ;;  triangle.  Also, ok if this is first triangle that				     ;;  triangle.  Also, ok if this is first triangle that
	     ;;  poison-vertex is :on.								     ;;  poison-vertex is :on.
	     (setf relation (if poison-vertex							     (setf relation (if poison-vertex
				(point-vs-triangle									(point-vs-triangle
				 poison-vertex triangle :space space)))							 poison-vertex triangle :space space)))
	     (when (or (null poison-vertex) (= triangles-to-do 1)				     (when (or (null poison-vertex) (= triangles-to-do 1)
		       (eql :outside relation)								       (eql :outside relation)
		       (and (eql :on relation) (not on-flag) (setq on-flag T)))				       (and (eql :on relation) (not on-flag) (setq on-flag T)))
	       ;;  Save the triangle, cancel v, and update the					       ;;  Save the triangle, cancel v, and update the
	       ;;  neighboring vertices.  The neighboring vertices				       ;;  neighboring vertices.  The neighboring vertices
	       ;;  should be rechecked (put back on the list).					       ;;  should be rechecked (put back on the list).
	       (decf triangles-to-do) (push triangle triangle-list)				       (decf triangles-to-do) (push triangle triangle-list)
	       (setf (second triple) nil)							       (setf (second triple) nil)
	       (setf (third (first triple)) (third triple))					       (setf (third (first triple)) (third triple))
	       (setf (first (third triple)) (first triple))					       (setf (first (third triple)) (first triple))
	       (push (first triple) triples)							       (push (first triple) triples)
	       (push (third triple) triples)))							       (push (third triple) triples)))
	finally (return triangle-list))) ; Return the list of triangles.			finally (return triangle-list))) ; Return the list of triangles.

;;  Given a list of vertices that describe a star-shaped polygon in			;;  Given a list of vertices that describe a star-shaped polygon in
;;  counterclockwise order and a star-source vertex, return a set of			;;  counterclockwise order and a star-source vertex, return a set of
;;  triangles that fills the star-shaped polygon.  Note that the star			;;  triangles that fills the star-shaped polygon.  Note that the star
;;  source is not used as a vertex in the triangulation; it's needed			;;  source is not used as a vertex in the triangulation; it's needed
;;  to make the triangulation algorithm efficient.  Planned use:			;;  to make the triangulation algorithm efficient.  Planned use:
;;  retriangulate a hole in a triangulation after a single vertex has			;;  retriangulate a hole in a triangulation after a single vertex has
;;  been eliminated.									;;  been eliminated.
										    >	(defgeneric star-triangulate (star-shape star-source space triangle-class &rest ar
										    >	  (:documentation
										    >	   "The purpose of this method is unknown."))
										    >
(defmethod star-triangulate ((star-shape list) (star-source point)			(defmethod star-triangulate ((star-shape list) (star-source point)
			     (space vector-space) triangle-class 						     (space vector-space) triangle-class 
			     &rest args)									     &rest args)
  ;;  We convert the vertex list into a list of adjacency triples of			  ;;  We convert the vertex list into a list of adjacency triples of
  ;;  the form (left v right).								  ;;  the form (left v right).
  (let ((triples (mapcar #'(lambda (v) (list nil v nil)) star-shape)))			  (let ((triples (mapcar #'(lambda (v) (list nil v nil)) star-shape)))
    (mapc #'(lambda (pred current succ) 						    (mapc #'(lambda (pred current succ) 
	      (setf (third current) pred) (setf (first current) succ))				      (setf (third current) pred) (setf (first current) succ))
	  triples (rotate-list triples) (rotate-list triples 2))				  triples (rotate-list triples) (rotate-list triples 2))
    ;;  Pass the triples to our triangulator.						    ;;  Pass the triples to our triangulator.
    (apply #'triangulate-triples							    (apply #'triangulate-triples
	   triples star-source space triangle-class args)))					   triples star-source space triangle-class args)))

;;  Given a list of vertices that describe a flat polygon in				;;  Given a list of vertices that describe a flat polygon in
;;  counterclockwise order, return a set of triangles that fills the			;;  counterclockwise order, return a set of triangles that fills the
;;  flat polygon.  The polygon must be illuminated by the base and all			;;  flat polygon.  The polygon must be illuminated by the base and all
;;  vertices must be to one side of the base.  The base is determined			;;  vertices must be to one side of the base.  The base is determined
;;  by the first and last vertices given.  Planned use: Triangulate			;;  by the first and last vertices given.  Planned use: Triangulate
;;  the hole that appears when a constraint side is forced through a			;;  the hole that appears when a constraint side is forced through a
;;  triangulation.  There is one hole on each side of such a				;;  triangulation.  There is one hole on each side of such a
;;  constraint side.									;;  constraint side.
										    >	(defgeneric flat-triangulate (flat-polygon space triangle-class &rest args)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod flat-triangulate ((flat-polygon list) (space vector-space)			(defmethod flat-triangulate ((flat-polygon list) (space vector-space)
			     triangle-class &rest args)								     triangle-class &rest args)
  ;;  We convert the vertex list into a list of adjacency triples of			  ;;  We convert the vertex list into a list of adjacency triples of
  ;;  the form (left v right)								  ;;  the form (left v right)
  (let ((triples (mapcar #'(lambda (v) (list nil v nil)) flat-polygon)))		  (let ((triples (mapcar #'(lambda (v) (list nil v nil)) flat-polygon)))
    (mapc #'(lambda (pred current succ)							    (mapc #'(lambda (pred current succ)
	      (setf (third current) pred) (setf (first current) succ))				      (setf (third current) pred) (setf (first current) succ))
	  triples (rest triples) (rest (rest triples)))						  triples (rest triples) (rest (rest triples)))
    ;;  Pass the triples to our triangulator.						    ;;  Pass the triples to our triangulator.
    (apply #'triangulate-triples triples nil space triangle-class args)))		    (apply #'triangulate-triples triples nil space triangle-class args)))

;;  Return the circumcenter of the given triangle.					;;  Return the circumcenter of the given triangle.
										    >	(defgeneric circumcenter (triangle &key space)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod circumcenter ((triangle simplex) &key (space (home-of triangle)))		(defmethod circumcenter ((triangle simplex) &key (space (home-of triangle)))
  (unless (triangle? triangle)								  (unless (triangle? triangle)
    (error "Circumcenter is implemented only for triangles. ~s" triangle))		    (error "Circumcenter is implemented only for triangles. ~s" triangle))
  (let ((center (apply #'complex-circumcenter						  (let ((center (apply #'complex-circumcenter
		       (mapcar #'(lambda (v) (complexer (coerce v space)))				       (mapcar #'(lambda (v) (complexer (coerce v space)))
			       (vertices-of triangle)))))							       (vertices-of triangle)))))
    (make-point space (cl:realpart center) (cl:imagpart center))))			    (make-point space (cl:realpart center) (cl:imagpart center))))

										    >	(defgeneric circumradius (triangle &key space)
										    >	  (:documentation
										    >	   "The purpose of this method is unknown."))
										    >
(defmethod circumradius ((triangle simplex) &key (space (home-of triangle)))		(defmethod circumradius ((triangle simplex) &key (space (home-of triangle)))
  (distance (first (vertices-of triangle))						  (distance (first (vertices-of triangle))
	    (circumcenter triangle :space space) :space space))					    (circumcenter triangle :space space) :space space))

;;  Return the triangle's angle at the given vertex.					;;  Return the triangle's angle at the given vertex.
(defmethod angle ((vertex point) (triangle simplex)					(defmethod angle ((vertex point) (triangle simplex)
		  &rest args &key (space (home-of triangle)))						  &rest args &key (space (home-of triangle)))
  (unless (triangle? triangle)								  (unless (triangle? triangle)
    (error "Function Angle is implemented only for triangles. ~s" triangle))		    (error "Function Angle is implemented only for triangles. ~s" triangle))
  (let ((others (remove vertex (vertices-of triangle)))					  (let ((others (remove vertex (vertices-of triangle)))
	(v (coerce vertex space)))								(v (coerce vertex space)))
    (apply #'angle (- (coerce (first others) space) v)					    (apply #'angle (- (coerce (first others) space) v)
	   (- (coerce (second others) space) v) args)))						   (- (coerce (second others) space) v) args)))

										    >	(defgeneric angles (triangle &key space)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod angles ((triangle simplex) &key (space (home-of triangle)))			(defmethod angles ((triangle simplex) &key (space (home-of triangle)))
  (loop for v in (vertices-of triangle)							  (loop for v in (vertices-of triangle)
	collect (angle v triangle :space space)))						collect (angle v triangle :space space)))
    
										    >	(defgeneric vertices-sorted-by-angle (triangle &key space)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod vertices-sorted-by-angle ((triangle simplex) &key				(defmethod vertices-sorted-by-angle ((triangle simplex) &key
				     (space (home-of triangle)))							     (space (home-of triangle)))
  (loop with (a b c) = (mapcar #'(lambda (v) (coerce v space))				  (loop with (a b c) = (mapcar #'(lambda (v) (coerce v space))
				 (vertices-of triangle))								 (vertices-of triangle))
	repeat 3										repeat 3
	for diff = (- c b)									for diff = (- c b)
	for size = (convert-to-lisp-number (dot-product diff diff))				for size = (convert-to-lisp-number (dot-product diff diff))
	collect (cons size a) into pairs			   				collect (cons size a) into pairs			   
	do (rotatef a b c)									do (rotatef a b c)
	finally (return (mapcar #'rest (sort pairs #'cl:< :key #'first)))))			finally (return (mapcar #'rest (sort pairs #'cl:< :key #'first)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Triangulations.									;;  Triangulations.

(defmethod insert ((triangle simplex) (triangulation triangulation)			(defmethod insert ((triangle simplex) (triangulation triangulation)
		   &rest ignore)									   &rest ignore)
  (declare (ignore ignore)) 								  (declare (ignore ignore)) 
  (unless (= 2 (dimension-of triangle))							  (unless (= 2 (dimension-of triangle))
    (error "Only triangles can be INSERTed into a triangulation. ~s" triangle))		    (error "Only triangles can be INSERTed into a triangulation. ~s" triangle))
  (setf (%most-recent triangulation) triangle)						  (setf (%most-recent triangulation) triangle)
  (call-next-method))									  (call-next-method))

;;  Return a list of all triangles adjacent to the given vertices.			;;  Return a list of all triangles adjacent to the given vertices.
										    >	(defgeneric neighbors (vertices triangulation)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod neighbors ((vertices list) (triangulation triangulation))			(defmethod neighbors ((vertices list) (triangulation triangulation))
  (case (length vertices)								  (case (length vertices)
    (1 (cofacets (cofacets (get-cell vertices triangulation) triangulation)		    (1 (cofacets (cofacets (get-cell vertices triangulation) triangulation)
		 triangulation))									 triangulation))
    (2 (cofacets (get-cell vertices triangulation) triangulation))))			    (2 (cofacets (get-cell vertices triangulation) triangulation))))

;;  Report the neighbor of the given triangle across the given side.			;;  Report the neighbor of the given triangle across the given side.
										    >	(defgeneric neighbor (triangle side triangulation)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod neighbor ((triangle simplex) (side list)					(defmethod neighbor ((triangle simplex) (side list)
		     (triangulation triangulation))							     (triangulation triangulation))
  (find triangle (cofacets (get-cell side triangulation) triangulation)			  (find triangle (cofacets (get-cell side triangulation) triangulation)
	:test-not #'eql))									:test-not #'eql))

;;  Return a list of all the triangles within a given region.  The			;;  Return a list of all the triangles within a given region.  The
;;  region's boundaries are defined by the function Neighbor.  This			;;  region's boundaries are defined by the function Neighbor.  This
;;  method is not terribly efficient, but it probably won't be done			;;  method is not terribly efficient, but it probably won't be done
;;  all that often.									;;  all that often.
										    >	(defgeneric neighborhood (start triangulation)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod neighborhood ((start simplex) (triangulation triangulation))			(defmethod neighborhood ((start simplex) (triangulation triangulation))
  (unless (triangle? start)								  (unless (triangle? start)
    (error "Neighborhood must start at a triangle. ~s" start))				    (error "Neighborhood must start at a triangle. ~s" start))
  (loop with stack = (list start)							  (loop with stack = (list start)
        with mark-list = (list start)							        with mark-list = (list start)
        while stack			; Process triangles until we run out.		        while stack			; Process triangles until we run out.
        for triangle = (pop stack)							        for triangle = (pop stack)
        collect triangle								        collect triangle
        ;;  Check each neighbor; if it's not on the stack then put it			        ;;  Check each neighbor; if it's not on the stack then put it
        ;;  there and mark it.								        ;;  there and mark it.
        do (loop for side in (facets triangle triangulation)				        do (loop for side in (facets triangle triangulation)
		 for neighbor = (neighbor triangle (vertices-of side)					 for neighbor = (neighbor triangle (vertices-of side)
					  triangulation)									  triangulation)
                 if (and neighbor (not (member neighbor mark-list)))			                 if (and neighbor (not (member neighbor mark-list)))
                   do (push neighbor stack)						                   do (push neighbor stack)
                      (push neighbor mark-list))))					                      (push neighbor mark-list))))

;;  Return a triangle base (a list of two points) that is between the			;;  Return a triangle base (a list of two points) that is between the
;;  given vertex and the corresponding triangle apex.  Triangle				;;  given vertex and the corresponding triangle apex.  Triangle
;;  orientation does not matter (aside from not :flat).					;;  orientation does not matter (aside from not :flat).
										    >	(defgeneric near-base (triangle vertex &key space)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod near-base ((triangle simplex) (vertex point)					(defmethod near-base ((triangle simplex) (vertex point)
		      &key (space (home-of triangle)))							      &key (space (home-of triangle)))
  (unless (triangle? triangle)								  (unless (triangle? triangle)
    (error "Near-Base works only on triangles. ~s" triangle))				    (error "Near-Base works only on triangles. ~s" triangle))
  (loop with (a b c) = (vertices-of triangle)						  (loop with (a b c) = (vertices-of triangle)
	with direction = (bend space a b c)							with direction = (bend space a b c)
	repeat 3										repeat 3
	if (eql direction (bend space vertex c b))						if (eql direction (bend space vertex c b))
	  return (list b c)									  return (list b c)
	do (rotatef a b c)))									do (rotatef a b c)))

;;  Given a triangle and a destination (a vertex), travel from the			;;  Given a triangle and a destination (a vertex), travel from the
;;  triangle to the destination.  We return the triangle that contains			;;  triangle to the destination.  We return the triangle that contains
;;  the destination if one exists.  Otherwise, we return multiple			;;  the destination if one exists.  Otherwise, we return multiple
;;  values: nil and the side where we fell off the triangulation.			;;  values: nil and the side where we fell off the triangulation.
;;  Travel is not necessarily along a straight line, although each			;;  Travel is not necessarily along a straight line, although each
;;  triangle we visit is closer than the previous one.					;;  triangle we visit is closer than the previous one.
										    >	(defgeneric directed-locate (triangle destination triangulation &key space)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod directed-locate ((triangle simplex) (destination point)			(defmethod directed-locate ((triangle simplex) (destination point)
			    (triangulation triangulation)							    (triangulation triangulation)
			    &key (space (home-of triangle)))							    &key (space (home-of triangle)))
  (unless (triangle? triangle)								  (unless (triangle? triangle)
    (error "Directed-Locate must start at a triangle. ~s" triangle))			    (error "Directed-Locate must start at a triangle. ~s" triangle))
  ;;  Find a side of the triangle that points toward the destination.			  ;;  Find a side of the triangle that points toward the destination.
  (loop for side = (near-base triangle destination :space space)			  (loop for side = (near-base triangle destination :space space)
	;;  If no side found then we're done.							;;  If no side found then we're done.
	do (unless side (return triangle))							do (unless side (return triangle))
	   ;;  Update triangle.  If no triangle, we've fallen off.				   ;;  Update triangle.  If no triangle, we've fallen off.
	   (setf triangle (neighbor triangle side triangulation))				   (setf triangle (neighbor triangle side triangulation))
	   (unless triangle (return (values nil side)))))					   (unless triangle (return (values nil side)))))

;;  Find the triangle that contains the given vertex.					;;  Find the triangle that contains the given vertex.
										    >	(defgeneric locate (vertex triangulation)
										    >	  (:documentation
										    >	   "The purpose of this method is unknown."))
										    >
(defmethod locate ((vertex point) (triangulation triangulation))			(defmethod locate ((vertex point) (triangulation triangulation))
  ;;  Check first to see if it's already present in the triangulation...		  ;;  Check first to see if it's already present in the triangulation...
  (or (first (neighbors (list vertex) triangulation))					  (or (first (neighbors (list vertex) triangulation))
      ;;  Then try a directed search...							      ;;  Then try a directed search...
      (let ((start (%most-recent triangulation)))					      (let ((start (%most-recent triangulation)))
	(if (maximal-cell? start triangulation)							(if (maximal-cell? start triangulation)
	    (directed-locate start vertex triangulation)))					    (directed-locate start vertex triangulation)))
      ;;  Finally, try looking at everything.						      ;;  Finally, try looking at everything.
      (catch 'found									      (catch 'found
	(map-over-maximal-cells (triangle) triangulation					(map-over-maximal-cells (triangle) triangulation
	   (if (not (eql :outside (point-vs-triangle vertex triangle)))				   (if (not (eql :outside (point-vs-triangle vertex triangle)))
	       (throw 'found triangle)))							       (throw 'found triangle)))
	nil)))											nil)))

;;  An inefficient way to look at all triangles in a triangulation.			;;  An inefficient way to look at all triangles in a triangulation.
;;  Not used elsewhere, but handy for debugging.					;;  Not used elsewhere, but handy for debugging.
										    >	(defgeneric triangles (triangulation)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod triangles ((triangulation triangulation))					(defmethod triangles ((triangulation triangulation))
  (let ((triangles nil))								  (let ((triangles nil))
    (map-over-maximal-cells (triangle) triangulation					    (map-over-maximal-cells (triangle) triangulation
			    (push triangle triangles))								    (push triangle triangles))
    triangles))										    triangles))

;;  Report all vertices adjacent to given vertex (not necessarily in order).		;;  Report all vertices adjacent to given vertex (not necessarily in order).
										    >	(defgeneric adj-vertices (vertex triangulation)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod adj-vertices ((vertex point) (triangulation triangulation))			(defmethod adj-vertices ((vertex point) (triangulation triangulation))
  (loop for edge in (cofacets (get-cell (list vertex) triangulation)			  (loop for edge in (cofacets (get-cell (list vertex) triangulation)
			      triangulation)									      triangulation)
	for vertices = (vertices-of edge)							for vertices = (vertices-of edge)
	collect (if (eql vertex (first vertices))						collect (if (eql vertex (first vertices))
		    (second vertices)									    (second vertices)
		    (first vertices))))									    (first vertices))))

;;  Returns T iff the given edge can be flipped without producing an			;;  Returns T iff the given edge can be flipped without producing an
;;  inverted triangle.									;;  inverted triangle.
										    >	(defgeneric flip-ok? (edge triangulation)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod flip-ok? ((edge list) (triangulation triangulation))				(defmethod flip-ok? ((edge list) (triangulation triangulation))
  (let* ((triangles (neighbors edge triangulation))					  (let* ((triangles (neighbors edge triangulation))
	 (apexes (mapcar #'(lambda (tri) (first (opposite edge tri)))				 (apexes (mapcar #'(lambda (tri) (first (opposite edge tri)))
			 triangles))										 triangles))
	 (space (home-of (first triangles))))							 (space (home-of (first triangles))))
    (and (= 2 (length triangles))							    (and (= 2 (length triangles))
	 (eql (apply #'bend space (first edge) apexes)						 (eql (apply #'bend space (first edge) apexes)
	      (apply #'bend space (second edge) (reverse apexes))))))				      (apply #'bend space (second edge) (reverse apexes))))))

;;  Check if Delaunay property holds for the given edge.  The Delaunay			;;  Check if Delaunay property holds for the given edge.  The Delaunay
;;  property here is that the opposite angles sum to less than or			;;  property here is that the opposite angles sum to less than or
;;  equal to 180 degrees.  There are lots of choices on how to				;;  equal to 180 degrees.  There are lots of choices on how to
;;  implement the Delaunay property (e.g., look at the circles, choose			;;  implement the Delaunay property (e.g., look at the circles, choose
;;  the smallest angle sum, etc.).  This one has the advantage that it			;;  the smallest angle sum, etc.).  This one has the advantage that it
;;  also works for curved surface Delaunay triangulations.  At some			;;  also works for curved surface Delaunay triangulations.  At some
;;  point, it may be desirable to switch to a faster method.				;;  point, it may be desirable to switch to a faster method.
										    >	(defgeneric delaunay? (edge triangulation &key space)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod delaunay? ((edge list) (triangulation triangulation) &key space)		(defmethod delaunay? ((edge list) (triangulation triangulation) &key space)
  (let* ((triangles (neighbors edge triangulation))					  (let* ((triangles (neighbors edge triangulation))
	 (t1 (first triangles))									 (t1 (first triangles))
	 (t2 (second triangles)))								 (t2 (second triangles)))
    (unless space (setf space (home-of t1)))						    (unless space (setf space (home-of t1)))
    (or  (< (length triangles) 2)							    (or  (< (length triangles) 2)
	 (<= (+ (angle (first (opposite edge t1)) t1 :space space)				 (<= (+ (angle (first (opposite edge t1)) t1 :space space)
		(angle (first (opposite edge t2)) t2 :space space))					(angle (first (opposite edge t2)) t2 :space space))
	     180.0))))										     180.0))))

;;  Flip the given side of the triangulation.  In other words, the			;;  Flip the given side of the triangulation.  In other words, the
;;  side implicitly defines a quadrilateral; replace the side with the			;;  side implicitly defines a quadrilateral; replace the side with the
;;  other diagonal of the quadrilateral.  This function will go ahead			;;  other diagonal of the quadrilateral.  This function will go ahead
;;  and Flip even when inverted triangles are produced.  To avoid			;;  and Flip even when inverted triangles are produced.  To avoid
;;  this, check beforehand using Flip-OK?.						;;  this, check beforehand using Flip-OK?.
										    >	(defgeneric flip (side triangulation)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod flip ((side list) (triangulation triangulation))				(defmethod flip ((side list) (triangulation triangulation))
  (let* ((triangles (neighbors side triangulation))					  (let* ((triangles (neighbors side triangulation))
	 (vert (first (opposite side (second triangles)))))					 (vert (first (opposite side (second triangles)))))
    (delete-maximal-cell (second triangles) triangulation)				    (delete-maximal-cell (second triangles) triangulation)
    (split (first triangles) triangulation						    (split (first triangles) triangulation
	   :face side :splitting-point vert)))							   :face side :splitting-point vert)))

;;  Split the given edge of the triangulation.  Expect strange results			;;  Split the given edge of the triangulation.  Expect strange results
;;  if the splitting-vertex is not on or near the edge.					;;  if the splitting-vertex is not on or near the edge.
										    >	(defgeneric split-edge (edge triangulation splitting-vertex)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod split-edge ((edge list) (triangulation triangulation)			(defmethod split-edge ((edge list) (triangulation triangulation)
		       (splitting-vertex point))							       (splitting-vertex point))
  (loop with triangles = (neighbors edge triangulation)					  (loop with triangles = (neighbors edge triangulation)
	for triangle in triangles								for triangle in triangles
	do (split triangle triangulation :face edge						do (split triangle triangulation :face edge
		  :splitting-point splitting-vertex)))							  :splitting-point splitting-vertex)))

;;  Force an edge between two existing vertices of the triangulation.			;;  Force an edge between two existing vertices of the triangulation.
;;  In a sense, this is an extended version of Flip.					;;  In a sense, this is an extended version of Flip.
										    >	(defgeneric force-edge (edge triangulation)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod force-edge ((edge list) (triangulation triangulation))			(defmethod force-edge ((edge list) (triangulation triangulation))
  ;;  Don't do anything if the edge already exists.					  ;;  Don't do anything if the edge already exists.
  (unless (get-cell edge triangulation)							  (unless (get-cell edge triangulation)
    ;;  We want to travel in a line across the triangulation, deleting			    ;;  We want to travel in a line across the triangulation, deleting
    ;;  the crossed triangles and accumulating the left- and				    ;;  the crossed triangles and accumulating the left- and
    ;;  right-chains of vertices that bound them.					    ;;  right-chains of vertices that bound them.
    (loop with (start dest) = edge							    (loop with (start dest) = edge
	  with triangles = (neighbors (list start) triangulation)				  with triangles = (neighbors (list start) triangulation)
	  with space and opposite								  with space and opposite
	  ;;  Determine the starting triangle; it must be one that				  ;;  Determine the starting triangle; it must be one that
	  ;;  "points at" the dest.								  ;;  "points at" the dest.
	  with triangle										  with triangle
	    = (loop for tri in triangles							    = (loop for tri in triangles
		    do (setf space (home-of tri))							    do (setf space (home-of tri))
		       (if (edges-cross? space (opposite start tri) edge)				       (if (edges-cross? space (opposite start tri) edge)
			   (return tri)))									   (return tri)))
	  ;;  Vertices vl and vr are :left and :right (or :on) of the				  ;;  Vertices vl and vr are :left and :right (or :on) of the
	  ;;  edge, respectively.  (We are assuming that start is at				  ;;  edge, respectively.  (We are assuming that start is at
	  ;;  the bottom and dest is at the top.)						  ;;  the bottom and dest is at the top.)
	  with (vr vl) = (ccw-side start triangle)						  with (vr vl) = (ccw-side start triangle)
	  with left-chain = (list vl start)							  with left-chain = (list vl start)
	  with right-chain = (list vr start)							  with right-chain = (list vr start)
	  until (eql vr dest)		; Quit if dest is reached.				  until (eql vr dest)		; Quit if dest is reached.
	  for side = (list vl vr)								  for side = (list vl vr)
	  for next-triangle = (neighbor triangle side triangulation)				  for next-triangle = (neighbor triangle side triangulation)
	  ;;  Delete the old triangle and update (vl vr).					  ;;  Delete the old triangle and update (vl vr).
	  do (unless next-triangle								  do (unless next-triangle
	       (error "Boundary (constraint) edges cross. ~s ~s" edge side))			       (error "Boundary (constraint) edges cross. ~s ~s" edge side))
	     (setf opposite (first (opposite side next-triangle)))				     (setf opposite (first (opposite side next-triangle)))
	     (delete-maximal-cell triangle triangulation)					     (delete-maximal-cell triangle triangulation)
	     (setf triangle next-triangle)							     (setf triangle next-triangle)
	     (case (bend space start dest opposite)						     (case (bend space start dest opposite)
	       (:left (setf vl opposite) (push vl left-chain))					       (:left (setf vl opposite) (push vl left-chain))
	       ((:right :on) (setf vr opposite) (push vr right-chain)))				       ((:right :on) (setf vr opposite) (push vr right-chain)))
	  finally       									  finally       
       ;;  Get rid of the final triangle and create new triangles.			       ;;  Get rid of the final triangle and create new triangles.
       (delete-maximal-cell triangle triangulation)					       (delete-maximal-cell triangle triangulation)
       (loop for tri in (append								       (loop for tri in (append
			  (flat-triangulate (cons dest left-chain) space					  (flat-triangulate (cons dest left-chain) space
					    (class-of triangle))								    (class-of triangle))
			  (flat-triangulate (reverse right-chain) space						  (flat-triangulate (reverse right-chain) space
					    (class-of triangle)))								    (class-of triangle)))
	     do (insert tri triangulation)))))							     do (insert tri triangulation)))))

;;  Remove a vertex and retriangulate.  The vertex must be completely			;;  Remove a vertex and retriangulate.  The vertex must be completely
;;  surrounded by triangles for this to make sense.  Nil is returned			;;  surrounded by triangles for this to make sense.  Nil is returned
;;  if the operation fails.  Failure implies that no vertex is				;;  if the operation fails.  Failure implies that no vertex is
;;  eliminated.										;;  eliminated.
										    >	(defgeneric remove-vertex (vertex triangulation)
										    >	  (:documentation
										    >	   "The purpose of this method is unknown."))
										    >
(defmethod remove-vertex ((vertex point) (triangulation triangulation))			(defmethod remove-vertex ((vertex point) (triangulation triangulation))
  ;;  Determine surrounding vertices, in counterclockwise order.			  ;;  Determine surrounding vertices, in counterclockwise order.
  (loop with neighbors = (neighbors (list vertex) triangulation)			  (loop with neighbors = (neighbors (list vertex) triangulation)
	with triangle = (first neighbors)							with triangle = (first neighbors)
	with class = (class-of triangle)							with class = (class-of triangle)
	with space = (home-of triangle)								with space = (home-of triangle)
	with v = (first (ccw-side vertex triangle))						with v = (first (ccw-side vertex triangle))
	repeat (length neighbors)								repeat (length neighbors)
	for edge = (opposite v triangle)							for edge = (opposite v triangle)
	collect v into surrounding								collect v into surrounding
	do (setf triangle (neighbor triangle edge triangulation))				do (setf triangle (neighbor triangle edge triangulation))
	   (setf v (find vertex edge :test-not #'eql))						   (setf v (find vertex edge :test-not #'eql))
	   (if (null triangle) (return nil))							   (if (null triangle) (return nil))
	finally											finally
     ;;  Remove the old triangles and retriangulate.					     ;;  Remove the old triangles and retriangulate.
     (loop for tri in neighbors do (delete-maximal-cell tri triangulation))		     (loop for tri in neighbors do (delete-maximal-cell tri triangulation))
     (loop for tri in (star-triangulate surrounding vertex space class)			     (loop for tri in (star-triangulate surrounding vertex space class)
	   do (insert tri triangulation))							   do (insert tri triangulation))
     (return T)))									     (return T)))

;;  Place the given vertex into the triangulation and retriangulate.			;;  Place the given vertex into the triangulation and retriangulate.
;;  This is the main method for building a triangulation.				;;  This is the main method for building a triangulation.
										    >	(defgeneric place (vertex triangulation &key triangle)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod place ((vertex point) (triangulation triangulation) &key			(defmethod place ((vertex point) (triangulation triangulation) &key
		  (triangle (locate vertex triangulation)))						  (triangle (locate vertex triangulation)))
  ;;  Do nothing if the vertex already appears in the triangulation.			  ;;  Do nothing if the vertex already appears in the triangulation.
  (unless (get-cell (list vertex) triangulation)					  (unless (get-cell (list vertex) triangulation)
    (unless triangle									    (unless triangle
      (error "Unable to PLACE; no triangle found. ~s" vertex))				      (error "Unable to PLACE; no triangle found. ~s" vertex))
    (unless (member triangle triangulation)						    (unless (member triangle triangulation)
      (error "Unable to PLACE; triangle has been deleted. ~s" triangle))		      (error "Unable to PLACE; triangle has been deleted. ~s" triangle))
    (multiple-value-bind								    (multiple-value-bind
	(relation hit) (point-vs-triangle vertex triangle)					(relation hit) (point-vs-triangle vertex triangle)
      (case relation									      (case relation
	;;  Inside of triangle; this is the normal case.					;;  Inside of triangle; this is the normal case.
	(:inside (split triangle triangulation :splitting-point vertex))			(:inside (split triangle triangulation :splitting-point vertex))
	;;  On triangle.  Here we have to be careful; we've landed on				;;  On triangle.  Here we have to be careful; we've landed on
	;;  the triangle's boundary.  This case should be rare.					;;  the triangle's boundary.  This case should be rare.
	(:on (cond ((listp hit)									(:on (cond ((listp hit)
		    (split-edge hit triangulation vertex))						    (split-edge hit triangulation vertex))
		   (t											   (t
		    (warn "Placed ~s atop existing vertex ~s." vertex hit)				    (warn "Placed ~s atop existing vertex ~s." vertex hit)
		    (unless (remove-vertex hit triangulation)						    (unless (remove-vertex hit triangulation)
		      (error "Cannot Remove ~s, so cannot Place ~s"					      (error "Cannot Remove ~s, so cannot Place ~s"
			     hit vertex))									     hit vertex))
		    (place vertex triangulation))))							    (place vertex triangulation))))
	;;  Outside the triangle.  This case should never happen.				;;  Outside the triangle.  This case should never happen.
	(:outside										(:outside
	 (error "Cannot PLACE; ~s is :outside ~s." vertex triangle))))))			 (error "Cannot PLACE; ~s is :outside ~s." vertex triangle))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Constrained-Triangulations (C-Triangulations).					;;  Constrained-Triangulations (C-Triangulations).
;;											;;
;;  A triangulation in which some edges (the constraint edges) and			;;  A triangulation in which some edges (the constraint edges) and
;;  vertices (the constraint vertices) are special.  Constraint edges			;;  vertices (the constraint vertices) are special.  Constraint edges
;;  cannot be flipped (although they can be Split).  Edges adjacent to			;;  cannot be flipped (although they can be Split).  Edges adjacent to
;;  exactly one triangle also cannot be flipped and ideally these			;;  exactly one triangle also cannot be flipped and ideally these
;;  should be constraint edges although this is not enforced.				;;  should be constraint edges although this is not enforced.
;;  Constraint segments act as barriers through the use of function			;;  Constraint segments act as barriers through the use of function
;;  Neighbor; this function normally returns a neighbor, but it cannot			;;  Neighbor; this function normally returns a neighbor, but it cannot
;;  see past a constraint edge when *cross-edges* is nil.  Most				;;  see past a constraint edge when *cross-edges* is nil.  Most
;;  triangulation operations are inherited unchanged, but some have			;;  triangulation operations are inherited unchanged, but some have
;;  new behaviors.									;;  new behaviors.

;;  Given a list of vertices, return the corresponding constraint.			;;  Given a list of vertices, return the corresponding constraint.
;;  Return nil if there is no such constraint.  To make sense, the			;;  Return nil if there is no such constraint.  To make sense, the
;;  list should be of length 1 or 2.  This is the main tool for				;;  list should be of length 1 or 2.  This is the main tool for
;;  querying the constraints table of the c-triangulation.				;;  querying the constraints table of the c-triangulation.
										    >	(defgeneric constraint (vertices triangulation)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod constraint ((vertices list) (c-triangulation c-triangulation))		(defmethod constraint ((vertices list) (c-triangulation c-triangulation))
  (get-cell vertices (%constraints-of c-triangulation)))				  (get-cell vertices (%constraints-of c-triangulation)))

;;  Modified Neighbor (uses *cross-edges*).						;;  Modified Neighbor (uses *cross-edges*).
(defmethod neighbor ((triangle simplex) (side list)					(defmethod neighbor ((triangle simplex) (side list)
		     (c-triangulation c-triangulation))							     (c-triangulation c-triangulation))
  (unless (and (not *cross-edges*) (constraint side c-triangulation))			  (unless (and (not *cross-edges*) (constraint side c-triangulation))
    (call-next-method)))								    (call-next-method)))

(defmethod flip-ok? ((edge list) (c-triangulation c-triangulation))			(defmethod flip-ok? ((edge list) (c-triangulation c-triangulation))
  (unless (constraint edge c-triangulation)						  (unless (constraint edge c-triangulation)
    (call-next-method)))								    (call-next-method)))

(defmethod flip ((edge list) (c-triangulation c-triangulation))				(defmethod flip ((edge list) (c-triangulation c-triangulation))
  (if (constraint edge c-triangulation)							  (if (constraint edge c-triangulation)
      (error "Cannot flip a constraint edge. ~s" edge)					      (error "Cannot flip a constraint edge. ~s" edge)
      (call-next-method)))								      (call-next-method)))

(defmethod split-edge ((edge list) (c-triangulation c-triangulation)			(defmethod split-edge ((edge list) (c-triangulation c-triangulation)
		       (splitting-vertex point))							       (splitting-vertex point))
  (if (constraint edge c-triangulation)							  (if (constraint edge c-triangulation)
      (error "Use Split to split a constraint edge. ~s" edge)				      (error "Use Split to split a constraint edge. ~s" edge)
      (call-next-method)))								      (call-next-method)))

;;  Force an edge between existing vertices.  *Cross-edges* is set so			;;  Force an edge between existing vertices.  *Cross-edges* is set so
;;  that the operation fails if an attempt is made to force an edge			;;  that the operation fails if an attempt is made to force an edge
;;  through a constraint edge.								;;  through a constraint edge.
(defmethod force-edge ((edge list) (c-triangulation c-triangulation))			(defmethod force-edge ((edge list) (c-triangulation c-triangulation))
  (let ((*cross-edges* nil))								  (let ((*cross-edges* nil))
    (call-next-method)))								    (call-next-method)))

(defmethod remove-vertex ((vertex point) (c-triangulation c-triangulation))		(defmethod remove-vertex ((vertex point) (c-triangulation c-triangulation))
  (unless (constraint (list vertex) c-triangulation)					  (unless (constraint (list vertex) c-triangulation)
    (call-next-method)))								    (call-next-method)))

;;  Place segment or single vertex into a c-triangulation as a				;;  Place segment or single vertex into a c-triangulation as a
;;  constraint.  Note that Place acts differently when placing a			;;  constraint.  Note that Place acts differently when placing a
;;  dimension-zero simplex than when placing a point.					;;  dimension-zero simplex than when placing a point.
(defmethod place ((simplex simplex) (c-triangulation c-triangulation)			(defmethod place ((simplex simplex) (c-triangulation c-triangulation)
		  &rest ignore)										  &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (when (> (dimension-of simplex) 1)							  (when (> (dimension-of simplex) 1)
    (error "Only segments and vertices can be PLACEd. ~s" simplex))			    (error "Only segments and vertices can be PLACEd. ~s" simplex))
  (insert simplex (%constraints-of c-triangulation)) ; Must do this first.		  (insert simplex (%constraints-of c-triangulation)) ; Must do this first.
  (loop for v in (vertices-of simplex)							  (loop for v in (vertices-of simplex)
	do (place v c-triangulation))								do (place v c-triangulation))
  (when (segment? simplex)								  (when (segment? simplex)
    (force-edge (vertices-of simplex) c-triangulation)))				    (force-edge (vertices-of simplex) c-triangulation)))

;;  Split triangle on one side of a constraint that is being split.			;;  Split triangle on one side of a constraint that is being split.
										    >	(defgeneric %split-constraint-one-side (edge triangle new-vertex concave triangula
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod %split-constraint-one-side ((edge list) (triangle simplex)			(defmethod %split-constraint-one-side ((edge list) (triangle simplex)
				       (new-vertex point) concave							       (new-vertex point) concave
				       (c-triangulation c-triangulation))						       (c-triangulation c-triangulation))
  (cond       										  (cond       
    ;;  Difficult case: we are on the same side as the triangle's apex			    ;;  Difficult case: we are on the same side as the triangle's apex
    ;;  and the new-vertex is :outside the triangle.					    ;;  and the new-vertex is :outside the triangle.
    ((and concave (eql :outside (point-vs-triangle new-vertex triangle)))		    ((and concave (eql :outside (point-vs-triangle new-vertex triangle)))
     (let ((old-neighbors (neighbors edge c-triangulation))				     (let ((old-neighbors (neighbors edge c-triangulation))
	   (hit-tri (directed-locate triangle new-vertex c-triangulation)))			   (hit-tri (directed-locate triangle new-vertex c-triangulation)))
       (place new-vertex c-triangulation :triangle hit-tri)				       (place new-vertex c-triangulation :triangle hit-tri)
       (force-edge (list new-vertex (first edge)) c-triangulation)			       (force-edge (list new-vertex (first edge)) c-triangulation)
       (force-edge (list new-vertex (second edge)) c-triangulation)			       (force-edge (list new-vertex (second edge)) c-triangulation)
       (loop with new = (first								       (loop with new = (first
			  (set-difference (neighbors edge c-triangulation)					  (set-difference (neighbors edge c-triangulation)
			      old-neighbors))									      old-neighbors))
	     for tri in (neighborhood (or new triangle) c-triangulation)			     for tri in (neighborhood (or new triangle) c-triangulation)
	     do (delete-maximal-cell tri c-triangulation))))					     do (delete-maximal-cell tri c-triangulation))))
    ;;  Easy case: replace a single triangle with 2 new ones.				    ;;  Easy case: replace a single triangle with 2 new ones.
    (T (split triangle c-triangulation :face edge :splitting-point new-vertex))		    (T (split triangle c-triangulation :face edge :splitting-point new-vertex))
    ))											    ))

;;  Allow the splitting of a constraint segment.  We return the two			;;  Allow the splitting of a constraint segment.  We return the two
;;  new segments.  Splitting a constraint is a pain; there doesn't			;;  new segments.  Splitting a constraint is a pain; there doesn't
;;  seem to be any way to do it that is esthetically pleasing.				;;  seem to be any way to do it that is esthetically pleasing.
(defmethod split ((simplex simplex) (c-triangulation c-triangulation)			(defmethod split ((simplex simplex) (c-triangulation c-triangulation)
		  &rest args)										  &rest args)
  (cond											  (cond
    ((triangle? simplex) (call-next-method))						    ((triangle? simplex) (call-next-method))
    ((segment? simplex)									    ((segment? simplex)
     (loop with points = (vertices-of simplex)						     (loop with points = (vertices-of simplex)
	   with new-segments = (apply #'split simplex						   with new-segments = (apply #'split simplex
				      (%constraints-of c-triangulation) args)						      (%constraints-of c-triangulation) args)
	   with new-vert = (apply #'common-endpoint new-segments)				   with new-vert = (apply #'common-endpoint new-segments)
	   ;;  We temporarily re-insert the segment.						   ;;  We temporarily re-insert the segment.
	   initially (insert simplex (%constraints-of c-triangulation))				   initially (insert simplex (%constraints-of c-triangulation))

	   ;;  Do each side of the old segment.							   ;;  Do each side of the old segment.
	   for triangle in (neighbors points c-triangulation)					   for triangle in (neighbors points c-triangulation)
	   for space = (home-of triangle)							   for space = (home-of triangle)
	   for apex = (first (opposite points triangle))					   for apex = (first (opposite points triangle))
	   for verts = (vertices-of triangle)							   for verts = (vertices-of triangle)
	   for concave = (eql (apply #'bend space (subst new-vert apex verts))			   for concave = (eql (apply #'bend space (subst new-vert apex verts))
			      (apply #'bend space verts))							      (apply #'bend space verts))
	   do (%split-constraint-one-side points triangle new-vert				   do (%split-constraint-one-side points triangle new-vert
		     concave c-triangulation)								     concave c-triangulation)
	   ;;  Finally, we remove the old segment as a constraint.				   ;;  Finally, we remove the old segment as a constraint.
	   finally (delete-maximal-cell simplex							   finally (delete-maximal-cell simplex
					(%constraints-of c-triangulation))							(%constraints-of c-triangulation))
		   (return new-segments)))								   (return new-segments)))
    (T (error "Can only SPLIT segments and triangles. ~s" simplex))))			    (T (error "Can only SPLIT segments and triangles. ~s" simplex))))
	   											   
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  CDTs (Constrained Delaunay Triangulations).						;;  CDTs (Constrained Delaunay Triangulations).
;;											;;
;;  A constrained-triangulation with the empty circle property.				;;  A constrained-triangulation with the empty circle property.
;;  Delaunay properties are maintained via the function Insert; each			;;  Delaunay properties are maintained via the function Insert; each
;;  newly inserted triangle is checked.  Delaunay checking can be			;;  newly inserted triangle is checked.  Delaunay checking can be
;;  turned off by setting *delaunay* to nil.  *Delaunay* is also used			;;  turned off by setting *delaunay* to nil.  *Delaunay* is also used
;;  internally to decrease the amount of checking done when a new			;;  internally to decrease the amount of checking done when a new
;;  vertex is inserted via Place (this also prevents an infinite loop			;;  vertex is inserted via Place (this also prevents an infinite loop
;;  that can occur when 4 points are nearly cocircular).				;;  that can occur when 4 points are nearly cocircular).

;;  Constraint edge always satisifies Delaunay property.				;;  Constraint edge always satisifies Delaunay property.
(defmethod delaunay? ((edge list) (cdt cdt) &rest ignore)				(defmethod delaunay? ((edge list) (cdt cdt) &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (if (constraint edge cdt) T (call-next-method)))					  (if (constraint edge cdt) T (call-next-method)))

;;  Check Delaunay properties on insertion.						;;  Check Delaunay properties on insertion.
(defmethod insert ((triangle simplex) (cdt cdt) &rest ignore)				(defmethod insert ((triangle simplex) (cdt cdt) &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (call-next-method)									  (call-next-method)
  (cond											  (cond
    ((typep *delaunay* 'point)								    ((typep *delaunay* 'point)
     (let ((side (opposite *delaunay* triangle)))					     (let ((side (opposite *delaunay* triangle)))
       (unless (delaunay? side cdt) (flip side cdt))))					       (unless (delaunay? side cdt) (flip side cdt))))
    (*delaunay* (loop for edge in (facets triangle cdt)					    (*delaunay* (loop for edge in (facets triangle cdt)
		      for side = (vertices-of edge)							      for side = (vertices-of edge)
		      if (not (delaunay? side cdt))							      if (not (delaunay? side cdt))
			do (flip side cdt) (return)))))								do (flip side cdt) (return)))))

;;  Limit delaunay checking when placing a new vertex.					;;  Limit delaunay checking when placing a new vertex.
(defmethod place ((vertex point) (cdt cdt) &rest ignore)				(defmethod place ((vertex point) (cdt cdt) &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (let ((*delaunay* vertex))								  (let ((*delaunay* vertex))
    (call-next-method)))								    (call-next-method)))

;;  Limit delaunay checking.								;;  Limit delaunay checking.
(defmethod split-edge ((edge list) (cdt cdt) (splitting-vertex point))			(defmethod split-edge ((edge list) (cdt cdt) (splitting-vertex point))
  (let ((*delaunay* splitting-vertex))							  (let ((*delaunay* splitting-vertex))
    (call-next-method)))								    (call-next-method)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Meshes.										;;  Meshes.
;;											;;
;;  A mesh is basically a CDT with names and a home-space.				;;  A mesh is basically a CDT with names and a home-space.
;;  Refine-Mesh can be used to improve a mesh.						;;  Refine-Mesh can be used to improve a mesh.

(defmethod insert ((triangle simplex) (mesh mesh) &rest ignore)				(defmethod insert ((triangle simplex) (mesh mesh) &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (call-next-method)									  (call-next-method)
  ;;  Save new triangles for later processing.						  ;;  Save new triangles for later processing.
  (when (member triangle mesh) (push triangle (%pending-list-of mesh))))		  (when (member triangle mesh) (push triangle (%pending-list-of mesh))))

										    >	(defgeneric dimension-of (mesh)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod dimension-of ((mesh mesh))							(defmethod dimension-of ((mesh mesh))
  (dimension-of (home-of mesh)))							  (dimension-of (home-of mesh)))

;;  When a new vertex is placed into a mesh, we want to avoid				;;  When a new vertex is placed into a mesh, we want to avoid
;;  introducing new edges that are especially small, so we remove any			;;  introducing new edges that are especially small, so we remove any
;;  vertices that are too close to the new vertex.  A proof shows that			;;  vertices that are too close to the new vertex.  A proof shows that
;;  only adjacent vertices (those adjacent to the new vertex) need to			;;  only adjacent vertices (those adjacent to the new vertex) need to
;;  be considered.  [There can be vertices closer that are not				;;  be considered.  [There can be vertices closer that are not
;;  adjacent, but if such a vertex exists then there are already short			;;  adjacent, but if such a vertex exists then there are already short
;;  edges in the vicinity anyway.]  The idea is to use this only for			;;  edges in the vicinity anyway.]  The idea is to use this only for
;;  vertices that are forced upon us by being part of a boundary.			;;  vertices that are forced upon us by being part of a boundary.
;;  Thus, we use this when we split boundary edges.  This also needs			;;  Thus, we use this when we split boundary edges.  This also needs
;;  to be used if we insert boundary edges in among existing mesh			;;  to be used if we insert boundary edges in among existing mesh
;;  points (the current version doesn't allow this).					;;  points (the current version doesn't allow this).
										    >	(defgeneric %delete-too-close (vertex mesh too-close)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod %delete-too-close ((vertex point) (mesh mesh) too-close)			(defmethod %delete-too-close ((vertex point) (mesh mesh) too-close)
  (loop with space = (home-of mesh)							  (loop with space = (home-of mesh)
	for v in (adj-vertices vertex mesh)							for v in (adj-vertices vertex mesh)
	if (< (distance vertex v :space space) too-close)					if (< (distance vertex v :space space) too-close)
	  do (remove-vertex v mesh)))								  do (remove-vertex v mesh)))

;;  The following 3 methods (remove-vertex,						;;  The following 3 methods (remove-vertex,
;;  %split-constraint-one-side, and split) cover all the ways that new			;;  %split-constraint-one-side, and split) cover all the ways that new
;;  triangles or boundaries can be introduced into a mesh during			;;  triangles or boundaries can be introduced into a mesh during
;;  refine-mesh.  These methods handle the necessary updating of			;;  refine-mesh.  These methods handle the necessary updating of
;;  names.										;;  names.
(defmethod remove-vertex ((vertex point) (mesh mesh))					(defmethod remove-vertex ((vertex point) (mesh mesh))
  (setf (%default-name-of mesh)								  (setf (%default-name-of mesh)
	(name (first (neighbors (list vertex) mesh)) mesh))					(name (first (neighbors (list vertex) mesh)) mesh))
  (call-next-method))									  (call-next-method))

;;  Name updating.									;;  Name updating.
(defmethod %split-constraint-one-side ((edge list) (triangle simplex)			(defmethod %split-constraint-one-side ((edge list) (triangle simplex)
				       (new-vertex point) concave							       (new-vertex point) concave
				       (mesh mesh))									       (mesh mesh))
  (setf (%default-name-of mesh) (name triangle mesh))					  (setf (%default-name-of mesh) (name triangle mesh))
  (call-next-method))									  (call-next-method))

;;  Name updating along with code to delete any vertices too-close to			;;  Name updating along with code to delete any vertices too-close to
;;  a new boundary vertex.								;;  a new boundary vertex.
(defmethod split ((simplex simplex) (mesh mesh) &rest ignore)				(defmethod split ((simplex simplex) (mesh mesh) &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (cond											  (cond
    ((triangle? simplex)								    ((triangle? simplex)
     (setf (%default-name-of mesh) (name simplex mesh))					     (setf (%default-name-of mesh) (name simplex mesh))
     (call-next-method))								     (call-next-method))
    ((segment? simplex)									    ((segment? simplex)
     (setf (%default-name-of (%constraints-of mesh)) (name simplex mesh))		     (setf (%default-name-of (%constraints-of mesh)) (name simplex mesh))
     (let* ((new-segments (call-next-method))						     (let* ((new-segments (call-next-method))
	    (new-vert (apply #'common-endpoint new-segments))					    (new-vert (apply #'common-endpoint new-segments))
	    (points (vertices-of simplex))							    (points (vertices-of simplex))
	    (space (home-of mesh))								    (space (home-of mesh))
	    (too-close (min (distance new-vert (first points) :space space)			    (too-close (min (distance new-vert (first points) :space space)
			    (distance new-vert (second points) :space space))))					    (distance new-vert (second points) :space space))))
           ;;  We throw out vertices that are clearly too close, but			           ;;  We throw out vertices that are clearly too close, but
           ;;  the factor *too-close-factor* (constant less than 1)			           ;;  the factor *too-close-factor* (constant less than 1)
           ;;  prevents us from throwing away too many -- at the cost			           ;;  prevents us from throwing away too many -- at the cost
           ;;  of generating some edges that are possibly shorter than			           ;;  of generating some edges that are possibly shorter than
           ;;  necessary.								           ;;  necessary.
       (%delete-too-close new-vert mesh (* *too-close-factor* too-close))		       (%delete-too-close new-vert mesh (* *too-close-factor* too-close))
       new-segments))									       new-segments))
    (T (call-next-method))))								    (T (call-next-method))))

;;  Place a boundary and set its name.							;;  Place a boundary and set its name.
(defmethod place ((simplex simplex) (mesh mesh) &key name &allow-other-keys)		(defmethod place ((simplex simplex) (mesh mesh) &key name &allow-other-keys)
  (call-next-method)									  (call-next-method)
  (when (and name (segment? simplex)) (setf (name simplex mesh) name)))			  (when (and name (segment? simplex)) (setf (name simplex mesh) name)))

;;  Return the center of the given triangle.  What we mean by the			;;  Return the center of the given triangle.  What we mean by the
;;  center depends on the type of mesh that we are doing or on what			;;  center depends on the type of mesh that we are doing or on what
;;  approximation we are using for the circumcenter.  Here, we do a			;;  approximation we are using for the circumcenter.  Here, we do a
;;  straightforward standard circumcenter.						;;  straightforward standard circumcenter.
										    >	(defgeneric triangle-center (triangle mesh)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod triangle-center ((triangle simplex) (mesh mesh))				(defmethod triangle-center ((triangle simplex) (mesh mesh))
  (unless (eql (home-of triangle) (home-of mesh))					  (unless (eql (home-of triangle) (home-of mesh))
    (warn "Possible improper use of Triangle-Center."))					    (warn "Possible improper use of Triangle-Center."))
  (circumcenter triangle))								  (circumcenter triangle))

;;  Checks if given simplex is larger than the-bound.  The-bound can			;;  Checks if given simplex is larger than the-bound.  The-bound can
;;  be nil or a number or a function of two numbers that returns a			;;  be nil or a number or a function of two numbers that returns a
;;  number.  The function is evaluated at the mean of the vertices of			;;  number.  The function is evaluated at the mean of the vertices of
;;  the simplex (calculated in space).  Nil effectively acts as				;;  the simplex (calculated in space).  Nil effectively acts as
;;  infinity.										;;  infinity.
										    >	(defgeneric too-big? (simplex the-bound space)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod too-big? ((simplex simplex) (the-bound T) (space vector-space))		(defmethod too-big? ((simplex simplex) (the-bound T) (space vector-space))
  (let ((bound (cond									  (let ((bound (cond
		 ((null the-bound) nil)									 ((null the-bound) nil)
		 ((numberp the-bound) the-bound)							 ((numberp the-bound) the-bound)
		 ((functionp the-bound)									 ((functionp the-bound)
		  (apply the-bound (coordinate-list							  (apply the-bound (coordinate-list
				    (make-mean-point (vertices-of simplex)						    (make-mean-point (vertices-of simplex)
						     :mean-space space									     :mean-space space
						     :point-space space))))								     :point-space space))))
		 (T (warn "Ignoring unknown bound ~s in Too-Big?" the-bound)				 (T (warn "Ignoring unknown bound ~s in Too-Big?" the-bound)
		    nil))))										    nil))))
    (if bound (< bound (simplex-size simplex space)))))					    (if bound (< bound (simplex-size simplex space)))))

;;  Returns a grade for the given triangle showing whether the				;;  Returns a grade for the given triangle showing whether the
;;  triangle needs to be improved.							;;  triangle needs to be improved.
										    >	(defgeneric grade (triangle mesh angle-bounds size-list)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod grade ((triangle simplex) (mesh mesh)					(defmethod grade ((triangle simplex) (mesh mesh)
		  (angle-bounds list) (size-list list))							  (angle-bounds list) (size-list list))
  (let* ((space (home-of mesh))								  (let* ((space (home-of mesh))
	 (vertices (vertices-sorted-by-angle triangle :space space)))				 (vertices (vertices-sorted-by-angle triangle :space space)))
    (cond										    (cond
      ;;  Largest angle too large.							      ;;  Largest angle too large.
      ((and (second angle-bounds)							      ((and (second angle-bounds)
	    (> (angle (third vertices) triangle :space space)					    (> (angle (third vertices) triangle :space space)
	       (second angle-bounds)))								       (second angle-bounds)))
       :bad-shape)									       :bad-shape)
      ;;  Smallest angle too small (and not a boundary angle).				      ;;  Smallest angle too small (and not a boundary angle).
      ((and (first angle-bounds)							      ((and (first angle-bounds)
	    (< (angle (first vertices) triangle :space space)					    (< (angle (first vertices) triangle :space space)
	       (first angle-bounds))								       (first angle-bounds))
	    (or (not (constraint (opposite (second vertices) triangle) mesh))			    (or (not (constraint (opposite (second vertices) triangle) mesh))
		(not (constraint (opposite (third vertices) triangle) mesh))))				(not (constraint (opposite (third vertices) triangle) mesh))))
       :bad-shape)									       :bad-shape)
      ;;  Size too big.									      ;;  Size too big.
      ((too-big? triangle								      ((too-big? triangle
		 (second (member (name triangle mesh) size-list)) space)				 (second (member (name triangle mesh) size-list)) space)
       :bad-size)									       :bad-size)
      ;;  Bounday size too big.								      ;;  Bounday size too big.
      ((loop for edge in (facets triangle mesh)						      ((loop for edge in (facets triangle mesh)
	     for segment = (constraint (vertices-of edge) mesh)					     for segment = (constraint (vertices-of edge) mesh)
	     if (and segment									     if (and segment
		     (too-big? segment (second (member (name segment mesh)				     (too-big? segment (second (member (name segment mesh)
						       size-list)) space))								       size-list)) space))
	       return T)									       return T)
       :bad-segment)									       :bad-segment)
      (T :good))))									      (T :good))))

;;  Improve the triangle.  Different techniques are used depending on			;;  Improve the triangle.  Different techniques are used depending on
;;  whether the triangle is obtuse, near-right, or acute.  A proof			;;  whether the triangle is obtuse, near-right, or acute.  A proof
;;  shows this works and has the advantage of avoiding the calculation			;;  shows this works and has the advantage of avoiding the calculation
;;  of circumcenters for obtuse triangles.						;;  of circumcenters for obtuse triangles.
										    >	(defgeneric improve (triangle mesh)
										    >	  (:documentation
										    >	   "The purpose of this method is unknown."))
										    >
(defmethod improve ((triangle simplex) (mesh mesh))					(defmethod improve ((triangle simplex) (mesh mesh))
  (let* ((space (home-of mesh))								  (let* ((space (home-of mesh))
	 (vertex (third (vertices-sorted-by-angle triangle :space space)))			 (vertex (third (vertices-sorted-by-angle triangle :space space)))
	 (max-angle (angle vertex triangle :space space))					 (max-angle (angle vertex triangle :space space))
	 (side (opposite vertex triangle))							 (side (opposite vertex triangle))
	 (constraint (constraint side mesh)))							 (constraint (constraint side mesh)))
    (cond										    (cond
      ;;  Acute triangle.  Place the circumcenter.					      ;;  Acute triangle.  Place the circumcenter.
      ((< max-angle 89.9)								      ((< max-angle 89.9)
       (place (triangle-center triangle mesh) mesh :triangle triangle))			       (place (triangle-center triangle mesh) mesh :triangle triangle))
      											      
      ;;  The long side is a boundary.  Split the boundary.				      ;;  The long side is a boundary.  Split the boundary.
      (constraint (split constraint mesh))						      (constraint (split constraint mesh))

      ;;  Obtuse triangle.  Recursively split the neighboring triangle.			      ;;  Obtuse triangle.  Recursively split the neighboring triangle.
      ((> max-angle 90.1) (improve (neighbor triangle side mesh) mesh))			      ((> max-angle 90.1) (improve (neighbor triangle side mesh) mesh))

      ;;  Near-right triangle; hypotenuse is not a boundary.  Break			      ;;  Near-right triangle; hypotenuse is not a boundary.  Break
      ;;  the hypotenuse.								      ;;  the hypotenuse.
      (t (split-edge side mesh (make-mean-point side					      (t (split-edge side mesh (make-mean-point side
						:mean-space (home-of triangle)								:mean-space (home-of triangle)
						:point-space space))))))								:point-space space))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Initializations used by the Mesher Interface.					;;  Initializations used by the Mesher Interface.

;;  Create a background-box for the mesh.  This is a box that contains			;;  Create a background-box for the mesh.  This is a box that contains
;;  all the boundaries of the mesh.  Used to initialize the mesh's			;;  all the boundaries of the mesh.  Used to initialize the mesh's
;;  CDT.										;;  CDT.
										    >	(defgeneric do-background-box (box border mesh)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod do-background-box ((box list) (border number) (mesh mesh))			(defmethod do-background-box ((box list) (border number) (mesh mesh))
  (let* ((space (home-of mesh))								  (let* ((space (home-of mesh))
	 (low (mapcar #'(lambda (c) (cl:- c border)) (first box)))				 (low (mapcar #'(lambda (c) (cl:- c border)) (first box)))
	 (high (mapcar #'(lambda (c) (cl:+ c border)) (second box)))				 (high (mapcar #'(lambda (c) (cl:+ c border)) (second box)))
	 (ll (apply #'make-point space low))							 (ll (apply #'make-point space low))
	 (hh (apply #'make-point space high))							 (hh (apply #'make-point space high))
	 (lh (make-point space (first low) (second high)))					 (lh (make-point space (first low) (second high)))
	 (hl (make-point space (first high) (second low))))					 (hl (make-point space (first high) (second low))))
    (insert (make-simplex ll hl hh) mesh)						    (insert (make-simplex ll hl hh) mesh)
    (insert (make-simplex ll hh lh) mesh)))						    (insert (make-simplex ll hh lh) mesh)))

;;  Initialization needed in Name-Region.						;;  Initialization needed in Name-Region.
										    >	(defgeneric build-cdt-from-boundaries (mesh)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod build-cdt-from-boundaries ((mesh mesh))					(defmethod build-cdt-from-boundaries ((mesh mesh))
  ;;  Determine bounding-box and build containing rectangle.				  ;;  Determine bounding-box and build containing rectangle.
  (loop with box =  (bounding-box (mapcar #'first (%pending-list-of mesh))		  (loop with box =  (bounding-box (mapcar #'first (%pending-list-of mesh))
				  (home-of mesh))									  (home-of mesh))
	with boundaries = (reverse (%pending-list-of mesh))					with boundaries = (reverse (%pending-list-of mesh))
	initially (setf (%pending-list-of mesh) nil)						initially (setf (%pending-list-of mesh) nil)
		  (do-background-box box (* 0.1 (apply #'distance box)) mesh)				  (do-background-box box (* 0.1 (apply #'distance box)) mesh)
	for (boundary name) in boundaries							for (boundary name) in boundaries
	do (place boundary mesh :name name)))							do (place boundary mesh :name name)))

;;  Initialization needed in Refine-Mesh.						;;  Initialization needed in Refine-Mesh.
										    >	(defgeneric refine-mesh-prep (mesh)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod refine-mesh-prep ((mesh mesh))						(defmethod refine-mesh-prep ((mesh mesh))
  ;;  Make sure control variables are set properly.					  ;;  Make sure control variables are set properly.
  (setf *delaunay* T)									  (setf *delaunay* T)
  (setf *cross-edges* nil)								  (setf *cross-edges* nil)
  (setf *mesh* mesh)									  (setf *mesh* mesh)
  (setf *space* (home-of mesh))								  (setf *space* (home-of mesh))
  ;;  Place exsting triangles into pending-list in standard order			  ;;  Place exsting triangles into pending-list in standard order
  ;;  (this ensures we get the same results on different runs).  Also,			  ;;  (this ensures we get the same results on different runs).  Also,
  ;;  we get rid of unnamed triangles here.						  ;;  we get rid of unnamed triangles here.
  (let ((triangles nil))								  (let ((triangles nil))
    (map-over-maximal-cells (tri) mesh							    (map-over-maximal-cells (tri) mesh
      (if (name tri mesh)								      (if (name tri mesh)
	  (push tri triangles)									  (push tri triangles)
	  (delete-maximal-cell tri mesh)))							  (delete-maximal-cell tri mesh)))
  (setf (%pending-list-of mesh) (sort triangles #'cl:> :key #'id-number-of))))		  (setf (%pending-list-of mesh) (sort triangles #'cl:> :key #'id-number-of))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Mesher Interface.									;;  Mesher Interface.
;;											;;
;;  These are the functions that form the major part of the mesh			;;  These are the functions that form the major part of the mesh
;;  interface.  All of them appear in the manual.					;;  interface.  All of them appear in the manual.
										    >	(defgeneric boundary-complex-of (mesh)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))

(defmethod boundary-complex-of ((mesh mesh))						(defmethod boundary-complex-of ((mesh mesh))
  (%constraints-of mesh))								  (%constraints-of mesh))

;;  Create an empty mesh.								;;  Create an empty mesh.
										    >	(defgeneric create-mesh (space)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod create-mesh ((space euclidean-space))					(defmethod create-mesh ((space euclidean-space))
  (setf *mesh* (make-instance 'mesh :home space)))					  (setf *mesh* (make-instance 'mesh :home space)))

;;  Insert boundaries into the mesh during mesh-initialization.  Can			;;  Insert boundaries into the mesh during mesh-initialization.  Can
;;  insert a 0-dimensional simplex, a 1-dimensional simplex (a				;;  insert a 0-dimensional simplex, a 1-dimensional simplex (a
;;  segment), or a simplicial-complex containing such simplices.			;;  segment), or a simplicial-complex containing such simplices.
										    >	(defgeneric insert-boundary (simplex mesh &key name)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod insert-boundary ((simplex simplex) (mesh mesh) &key name)			(defmethod insert-boundary ((simplex simplex) (mesh mesh) &key name)
  (when (%most-recent mesh)								  (when (%most-recent mesh)
    (error "Misuse of Insert-Boundary.  Use only during mesh initialization."))		    (error "Misuse of Insert-Boundary.  Use only during mesh initialization."))
  (when (< 1 (dimension-of simplex))							  (when (< 1 (dimension-of simplex))
    (error "Illegal boundary simplex.  Only dimension 0 or 1 allowed. ~s"		    (error "Illegal boundary simplex.  Only dimension 0 or 1 allowed. ~s"
	   simplex))										   simplex))
  (push (list simplex name) (%pending-list-of mesh)))					  (push (list simplex name) (%pending-list-of mesh)))

;;  Name a subregion of the mesh.  The first time this is called it			;;  Name a subregion of the mesh.  The first time this is called it
;;  builds the CDT of the boundaries.							;;  builds the CDT of the boundaries.
										    >	(defgeneric name-region (name point mesh)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod name-region ((name symbol) (point point) (mesh mesh))			(defmethod name-region ((name symbol) (point point) (mesh mesh))
  ;;  Build the CDT on the first call.							  ;;  Build the CDT on the first call.
  (unless (%most-recent mesh)								  (unless (%most-recent mesh)
    (build-cdt-from-boundaries mesh))							    (build-cdt-from-boundaries mesh))
  ;;  Region naming.									  ;;  Region naming.
  (mapcar #'(lambda (tri) (setf (name tri mesh) name))					  (mapcar #'(lambda (tri) (setf (name tri mesh) name))
	  (neighborhood (locate point mesh) mesh))						  (neighborhood (locate point mesh) mesh))
  mesh)											  mesh)

;;  Check and improve each triangle of the mesh, including new ones.			;;  Check and improve each triangle of the mesh, including new ones.
										    >	(defgeneric refine-mesh (mesh &key angle-bounds size-list)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod refine-mesh ((mesh mesh) &key (angle-bounds '(30)) (size-list nil))		(defmethod refine-mesh ((mesh mesh) &key (angle-bounds '(30)) (size-list nil))
  (refine-mesh-prep mesh)								  (refine-mesh-prep mesh)
  ;;  Pull triangles from the improvement queue until the queue is empty.		  ;;  Pull triangles from the improvement queue until the queue is empty.
  (loop with triangle									  (loop with triangle
	with improvement-queue = (make-queue)							with improvement-queue = (make-queue)
     	do										     	do
     ;;  Load any pending triangles into the improvement queue.				     ;;  Load any pending triangles into the improvement queue.
     (loop for tri in (%pending-list-of mesh)						     (loop for tri in (%pending-list-of mesh)
	   do (when (and (maximal-cell? tri mesh)						   do (when (and (maximal-cell? tri mesh)
			 (not (eql (grade tri mesh angle-bounds size-list)					 (not (eql (grade tri mesh angle-bounds size-list)
				   :good)))										   :good)))
		(insertq tri improvement-queue)))							(insertq tri improvement-queue)))
     (setf (%pending-list-of mesh) nil)							     (setf (%pending-list-of mesh) nil)
     (when (emptyq? improvement-queue) (return))					     (when (emptyq? improvement-queue) (return))
     (setf triangle (getq improvement-queue :delete nil))				     (setf triangle (getq improvement-queue :delete nil))
     (if (maximal-cell? triangle mesh)							     (if (maximal-cell? triangle mesh)
	 (improve triangle mesh)								 (improve triangle mesh)
	 (getq improvement-queue :delete T))) ; Delete only when really gone.			 (getq improvement-queue :delete T))) ; Delete only when really gone.
  mesh)											  mesh)

(defmacro make-mesh ((space &rest keyargs &key size-list angle-bounds)			(defmacro make-mesh ((space &rest keyargs &key size-list angle-bounds)
		     &body body)									     &body body)
  (declare (ignore size-list angle-bounds))						  (declare (ignore size-list angle-bounds))
  (loop for clause in body								  (loop for clause in body
	for (type name . rest) = (if (listp clause) clause					for (type name . rest) = (if (listp clause) clause
				     (error "Improper clause in Make-Mesh: ~s"						     (error "Improper clause in Make-Mesh: ~s"
					    clause))										    clause))
	collect 										collect 
	(cond				; string= allows use across packages.			(cond				; string= allows use across packages.
	  ((string= type "POINT")								  ((string= type "POINT")
	   `(setf (gethash ',name %pt-table) (make-point *space* ,@rest)))			   `(setf (gethash ',name %pt-table) (make-point *space* ,@rest)))
	  ((string= type "REGION")								  ((string= type "REGION")
	   `(setf (gethash ',name %rg-table) (make-point *space* ,@rest)))			   `(setf (gethash ',name %rg-table) (make-point *space* ,@rest)))
	  ((string= type "BOUNDARY")								  ((string= type "BOUNDARY")
	   `(%mm-boundary ,@(rest clause)))							   `(%mm-boundary ,@(rest clause)))
	  (t (error "Unknown descriptor in Make-Mesh: ~s" clause)))				  (t (error "Unknown descriptor in Make-Mesh: ~s" clause)))
	into new-body										into new-body
	finally											finally
     (return `(let ((%pt-table (make-hash-table))					     (return `(let ((%pt-table (make-hash-table))
		    (%rg-table (make-hash-table)))							    (%rg-table (make-hash-table)))
		(setf *space* ,space)									(setf *space* ,space)
		(setf *mesh* (create-mesh *space*))							(setf *mesh* (create-mesh *space*))
		(gethash nil %pt-table) ; Prevents a warning message.					(gethash nil %pt-table) ; Prevents a warning message.
		,@new-body										,@new-body
		(maphash #'(lambda (name point)								(maphash #'(lambda (name point)
			     (name-region name point *mesh*)) %rg-table)					     (name-region name point *mesh*)) %rg-table)
		(refine-mesh *mesh* ,@keyargs)								(refine-mesh *mesh* ,@keyargs)
		*mesh*))))										*mesh*))))

(defmacro %mm-get-point (desc)								(defmacro %mm-get-point (desc)
  (cond											  (cond
    ((atom desc) `(or (gethash ',desc %pt-table)					    ((atom desc) `(or (gethash ',desc %pt-table)
		      (error "Unbound point name: ~s" ',desc)))						      (error "Unbound point name: ~s" ',desc)))
    ((string= (first desc) "PT") `(make-point *space* ,@(rest desc)))			    ((string= (first desc) "PT") `(make-point *space* ,@(rest desc)))
    (t `(error "Unknown point descriptor: ~s" ',desc))))				    (t `(error "Unknown point descriptor: ~s" ',desc))))
													
(defmacro %mm-boundary (name options type . desc)					(defmacro %mm-boundary (name options type . desc)
  (cond											  (cond
    ((string= type "LINE")								    ((string= type "LINE")
     `(%boundary-line (list ,@(mapcar #'(lambda (x) `(%mm-get-point ,x)) desc))		     `(%boundary-line (list ,@(mapcar #'(lambda (x) `(%mm-get-point ,x)) desc))
		      ',name ,@options))								      ',name ,@options))
    ((string= type "ARC")								    ((string= type "ARC")
     (loop while desc									     (loop while desc
	   for (point arc-args) = desc								   for (point arc-args) = desc
	   collect `(%mm-get-point ,point) into new-desc					   collect `(%mm-get-point ,point) into new-desc
	   collect										   collect
	   (if (listp arc-args)									   (if (listp arc-args)
	       (let ((part (or (member :thru arc-args)						       (let ((part (or (member :thru arc-args)
			       (member :center arc-args))))							       (member :center arc-args))))
		 (when (second part)									 (when (second part)
		   (setf (second part) `(%mm-get-point ,(second part))))				   (setf (second part) `(%mm-get-point ,(second part))))
		 `(list ,@arc-args))									 `(list ,@arc-args))
	       `(error "Improperly formed arc options: ~s" ',arc-args))				       `(error "Improperly formed arc options: ~s" ',arc-args))
	   into new-desc									   into new-desc
	   do (setf desc (rest (rest desc)))							   do (setf desc (rest (rest desc)))
	   finally										   finally
	(return `(%boundary-arc (list ,@new-desc) ',name ,@options))))				(return `(%boundary-arc (list ,@new-desc) ',name ,@options))))
    (t `(error "Unknown type in boundary descriptor: ~s" ',type))))			    (t `(error "Unknown type in boundary descriptor: ~s" ',type))))

;;  Macro to handle the boundary construction.  Handles the boundary			;;  Macro to handle the boundary construction.  Handles the boundary
;;  options :closed? and :split.  Also inserts the new boundaries into			;;  options :closed? and :split.  Also inserts the new boundaries into
;;  the mesh.  To use this, the body is expected to return a list of			;;  the mesh.  To use this, the body is expected to return a list of
;;  the boundary simplices.								;;  the boundary simplices.
(defmacro defun-boundary (function-name (point-list name) &body body)			(defmacro defun-boundary (function-name (point-list name) &body body)
  `(defun ,function-name (,point-list ,name &key (closed? nil) (split 0))		  `(defun ,function-name (,point-list ,name &key (closed? nil) (split 0))
     (if closed? (setf ,point-list							     (if closed? (setf ,point-list
		       (append ,point-list (list (first ,point-list)))))				       (append ,point-list (list (first ,point-list)))))
     (loop with boundaries = (progn ,@body)						     (loop with boundaries = (progn ,@body)
	   repeat split										   repeat split
	   do (setf boundaries (split boundaries nil))						   do (setf boundaries (split boundaries nil))
	   finally										   finally
	(loop for b in boundaries								(loop for b in boundaries
	      do (insert-boundary b *mesh* :name ,name)))))					      do (insert-boundary b *mesh* :name ,name)))))

(defun-boundary %boundary-line (points name)						(defun-boundary %boundary-line (points name)
  (loop for a in points									  (loop for a in points
	for b in (rest points)									for b in (rest points)
	collect (make-simplex a b)))								collect (make-simplex a b)))

(defun-boundary %boundary-arc (point-arc-list name)					(defun-boundary %boundary-arc (point-arc-list name)
  (loop for (apoint arc-args bpoint) = point-arc-list					  (loop for (apoint arc-args bpoint) = point-arc-list
	while bpoint										while bpoint
	collect (if arc-args									collect (if arc-args
		    (apply #'arc apoint bpoint *space* arc-args)					    (apply #'arc apoint bpoint *space* arc-args)
		    (make-simplex apoint bpoint))							    (make-simplex apoint bpoint))
	do (setf point-arc-list (rest (rest point-arc-list)))))					do (setf point-arc-list (rest (rest point-arc-list)))))

;;  Macro for building 2D meshes.  Creates a function that can create			;;  Macro for building 2D meshes.  Creates a function that can create
;;  a mesh.  The function can take keyword arguments to control the			;;  a mesh.  The function can take keyword arguments to control the
;;  mesh requirements.  Defaults for the keyword arguments can be			;;  mesh requirements.  Defaults for the keyword arguments can be
;;  specified within defmesh.								;;  specified within defmesh.
(defmacro defmesh (name (&key size-list angle-bounds) &body body)			(defmacro defmesh (name (&key size-list angle-bounds) &body body)
  `(defun ,name (&key (size-list ,size-list)						  `(defun ,name (&key (size-list ,size-list)
		      (angle-bounds (or ,angle-bounds '(30))))						      (angle-bounds (or ,angle-bounds '(30))))
     (make-mesh ((get-euclidean-space 2)						     (make-mesh ((get-euclidean-space 2)
		 :size-list size-list :angle-bounds angle-bounds)					 :size-list size-list :angle-bounds angle-bounds)
		,@body)))										,@body)))

(defmesh circle (:size-list '(circle-boundary .1))					(defmesh circle (:size-list '(circle-boundary .1))
  (region inside 0 0)									  (region inside 0 0)
  (point origin 0 0)									  (point origin 0 0)
  (boundary circle-boundary (:closed? t) arc						  (boundary circle-boundary (:closed? t) arc
	    (pt 1 0) (:center origin) (pt 0 1) (:center origin)					    (pt 1 0) (:center origin) (pt 0 1) (:center origin)
	    (pt -1 0) (:center origin) (pt 0 -1) (:center origin)))				    (pt -1 0) (:center origin) (pt 0 -1) (:center origin)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  File I/O.										;;  File I/O.
										    >	(defgeneric make-mesh-from-file (stream &key angle-bounds size-list)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))

(defmethod make-mesh-from-file ((stream stream) &key angle-bounds size-list)		(defmethod make-mesh-from-file ((stream stream) &key angle-bounds size-list)
  (unless (string= (read stream) "MESHREQUEST")						  (unless (string= (read stream) "MESHREQUEST")
    (error "File should start with token `MeshRequest'."))				    (error "File should start with token `MeshRequest'."))
  (loop with space and boundary-complex and region-points				  (loop with space and boundary-complex and region-points
	and file-angle-bounds and file-size-list						and file-angle-bounds and file-size-list
	with vertex-table = (make-hash-table)							with vertex-table = (make-hash-table)
	for token = (read stream nil '%EOF%)							for token = (read stream nil '%EOF%)
	until (string= token "%EOF%")								until (string= token "%EOF%")
	do											do
     (cond										     (cond
       ((string= token "VERTEXSET")							       ((string= token "VERTEXSET")
	(when space										(when space
	  (error "Multiple VertexSets in file."))						  (error "Multiple VertexSets in file."))
	(setf space (get-euclidean-space (read stream)))					(setf space (get-euclidean-space (read stream)))
	(setf *space* space)									(setf *space* space)
	(read-vertex-set stream vertex-table space))						(read-vertex-set stream vertex-table space))
       ((string= token "SIMPLICIALCOMPLEX")						       ((string= token "SIMPLICIALCOMPLEX")
	(unless space										(unless space
	  (error "VertexSet must be defined before SimplicialComplex."))			  (error "VertexSet must be defined before SimplicialComplex."))
	(setf boundary-complex									(setf boundary-complex
	      (read-boundary-simplicial-complex stream vertex-table)))				      (read-boundary-simplicial-complex stream vertex-table)))
       ((string= token "REGIONS")							       ((string= token "REGIONS")
	(setf region-points (read-region-points stream space)))					(setf region-points (read-region-points stream space)))
       ((string= token "ANGLEBOUNDS")							       ((string= token "ANGLEBOUNDS")
	(setf file-angle-bounds (list (read stream) (read stream))))				(setf file-angle-bounds (list (read stream) (read stream))))
       ((string= token "SIZETABLE")							       ((string= token "SIZETABLE")
	(setf file-size-list (read-size-table stream)))						(setf file-size-list (read-size-table stream)))
       (t										       (t
	(error "Confused in file; cannot understand this token: ~s" token)))			(error "Confused in file; cannot understand this token: ~s" token)))
	finally											finally
     (let ((mesh (create-mesh space)))							     (let ((mesh (create-mesh space)))
       (map-over-maximal-cells (boundary) boundary-complex				       (map-over-maximal-cells (boundary) boundary-complex
	 (insert-boundary boundary mesh								 (insert-boundary boundary mesh
			  :name (name boundary boundary-complex)))						  :name (name boundary boundary-complex)))
       (loop for (name point) in region-points						       (loop for (name point) in region-points
	     do (name-region name point mesh))							     do (name-region name point mesh))
       (refine-mesh mesh :angle-bounds (or angle-bounds file-angle-bounds)		       (refine-mesh mesh :angle-bounds (or angle-bounds file-angle-bounds)
		    :size-list (or size-list file-size-list))						    :size-list (or size-list file-size-list))
       (return mesh))))									       (return mesh))))

										    >	(defgeneric read-point (stream space)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod read-point ((stream stream) (space domain))					(defmethod read-point ((stream stream) (space domain))
  (apply #'make-point space (loop repeat (dimension-of space)				  (apply #'make-point space (loop repeat (dimension-of space)
				  collect (read stream))))								  collect (read stream))))

										    >	(defgeneric read-vertex-set (stream vertex-table space)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod read-vertex-set ((stream stream) (vertex-table hash-table)			(defmethod read-vertex-set ((stream stream) (vertex-table hash-table)
			    (space domain))									    (space domain))
  (loop with numvertices = (read stream)						  (loop with numvertices = (read stream)
	for i below numvertices									for i below numvertices
	do (setf (gethash i vertex-table) (read-point stream space))))				do (setf (gethash i vertex-table) (read-point stream space))))
    											    
;;  If a complex is passed in via keyword then new simplices are added			;;  If a complex is passed in via keyword then new simplices are added
;;  to that complex.									;;  to that complex.
										    >	(defgeneric read-simplicial-complex (stream vertex-table &key complex)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod read-simplicial-complex							(defmethod read-simplicial-complex
    ((stream stream) (vertex-table hash-table)						    ((stream stream) (vertex-table hash-table)
     &key (complex (make-instance 'named-simplicial-complex)))				     &key (complex (make-instance 'named-simplicial-complex)))
  (loop with simp-dimension = (read stream)						  (loop with simp-dimension = (read stream)
	with numsimps = (read stream)								with numsimps = (read stream)
	with current-name = nil and count = 0							with current-name = nil and count = 0
	until (>= count numsimps)								until (>= count numsimps)
	for next = (read stream)								for next = (read stream)
	if (typep next 'symbol) do								if (typep next 'symbol) do
	  (setf current-name next)								  (setf current-name next)
	else do											else do
	  (insert (apply #'make-simplex (gethash next vertex-table)				  (insert (apply #'make-simplex (gethash next vertex-table)
			 (loop repeat simp-dimension								 (loop repeat simp-dimension
			       collect (gethash (read stream) vertex-table)))					       collect (gethash (read stream) vertex-table)))
		  complex :name current-name)								  complex :name current-name)
	  (incf count))										  (incf count))
  complex)										  complex)

;;  Special code for boundaries so that arcs can be used.  This is			;;  Special code for boundaries so that arcs can be used.  This is
;;  basically a hack that is here until we get a chance to put in			;;  basically a hack that is here until we get a chance to put in
;;  general code for curved objects.							;;  general code for curved objects.
										    >	(defgeneric read-boundary-simplicial-complex (stream vertex-table &key complex)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod read-boundary-simplicial-complex						(defmethod read-boundary-simplicial-complex
    ((stream stream) (vertex-table hash-table)						    ((stream stream) (vertex-table hash-table)
     &key (complex (make-instance 'named-simplicial-complex)))				     &key (complex (make-instance 'named-simplicial-complex)))
  (loop with simp-dimension = (read stream)						  (loop with simp-dimension = (read stream)
	with numsimps = (read stream)								with numsimps = (read stream)
	with current-name = nil and count = 0							with current-name = nil and count = 0
	until (>= count numsimps)								until (>= count numsimps)
	initially (unless (and (numberp simp-dimension) (= simp-dimension 1))			initially (unless (and (numberp simp-dimension) (= simp-dimension 1))
		    (error "Use 1 for boundary SimplicialComplex, not ~s."				    (error "Use 1 for boundary SimplicialComplex, not ~s."
			   simp-dimension))									   simp-dimension))
	for next = (read stream)								for next = (read stream)
	if (typep next 'symbol) do								if (typep next 'symbol) do
	  (setf current-name next)								  (setf current-name next)
	else do											else do
	  (let* ((arc-args (read stream))							  (let* ((arc-args (read stream))
		 (other arc-args))									 (other arc-args))
	    (if (listp arc-args)								    (if (listp arc-args)
		(setf other (read stream))								(setf other (read stream))
		(setf arc-args nil))									(setf arc-args nil))
	    (when arc-args									    (when arc-args
	      (let ((code (string (first arc-args))))						      (let ((code (string (first arc-args))))
		(unless (= 2 (length arc-args))								(unless (= 2 (length arc-args))
		  (error "Badly formed arc descriptor: ~s" arc-args))					  (error "Badly formed arc descriptor: ~s" arc-args))
		(setf (first arc-args)									(setf (first arc-args)
		      (case (aref code 0)								      (case (aref code 0)
			(#\C :center)										(#\C :center)
			(#\T :thru)										(#\T :thru)
			(#\R :radius)										(#\R :radius)
			(otherwise (error "Unrecognized arc descriptor: ~s"					(otherwise (error "Unrecognized arc descriptor: ~s"
					  arc-args))))										  arc-args))))
		(unless (numberp (second arc-args))							(unless (numberp (second arc-args))
		  (error "Second element should be a number: ~s" arc-args))				  (error "Second element should be a number: ~s" arc-args))
		(unless (eql (first arc-args) :radius)							(unless (eql (first arc-args) :radius)
		  (setf (second arc-args)								  (setf (second arc-args)
			(gethash (second arc-args) vertex-table)))						(gethash (second arc-args) vertex-table)))
		;;  Any more than single character implies clockwise.					;;  Any more than single character implies clockwise.
		(if (> (length code) 1)									(if (> (length code) 1)
		    (setf arc-args (append arc-args '(:cw t))))))					    (setf arc-args (append arc-args '(:cw t))))))
	    (setf next (gethash next vertex-table))						    (setf next (gethash next vertex-table))
	    (setf other (gethash other vertex-table))						    (setf other (gethash other vertex-table))
	    (insert (if arc-args								    (insert (if arc-args
			(apply #'arc next other *space* arc-args)						(apply #'arc next other *space* arc-args)
			(make-simplex next other))								(make-simplex next other))
		    complex :name current-name)								    complex :name current-name)
	    (incf count)))									    (incf count)))
  complex)										  complex)

										    >	(defgeneric read-region-points (stream space)
										    >	  (:documentation
										    >	   "The purspose of this function is unknown."))
										    >
(defmethod read-region-points ((stream stream) (space domain))				(defmethod read-region-points ((stream stream) (space domain))
  (loop with numpoints = (read stream)							  (loop with numpoints = (read stream)
	repeat numpoints									repeat numpoints
	for name = (read stream)								for name = (read stream)
	for point = (read-point stream space)							for point = (read-point stream space)
	collect (list name point)								collect (list name point)
	do (unless (typep name 'symbol)								do (unless (typep name 'symbol)
	     (error "Bad name for Region: ~s ~s" name point))))					     (error "Bad name for Region: ~s ~s" name point))))

										    >	(defgeneric read-size-table (stream)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod read-size-table ((stream stream))						(defmethod read-size-table ((stream stream))
  (loop with numentries = (read stream)							  (loop with numentries = (read stream)
	repeat numentries									repeat numentries
	for name = (read stream)								for name = (read stream)
	for size = (read stream)								for size = (read stream)
	collect name										collect name
	collect size										collect size
	do (unless (and (typep name 'symbol) (typep size 'number))				do (unless (and (typep name 'symbol) (typep size 'number))
	     (error "Improper entry for SizeTable: ~s ~s" name size))))				     (error "Improper entry for SizeTable: ~s ~s" name size))))

										    >	(defgeneric fwrite (tuple stream &rest ignore)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod fwrite ((tuple tuple) stream &rest ignore)					(defmethod fwrite ((tuple tuple) stream &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (apply #'format stream "~s~@{ ~s~}~%"							  (apply #'format stream "~s~@{ ~s~}~%"
	 (loop for i below (dimension-of (domain-of tuple))					 (loop for i below (dimension-of (domain-of tuple))
	       collect (ref tuple i))))								       collect (ref tuple i))))

;;  Write the vertex set of anything for which we can do				;;  Write the vertex set of anything for which we can do
;;  map-over-cells.  The vertex-table is returned.					;;  map-over-cells.  The vertex-table is returned.
										    >	(defgeneric write-vertex-set (thing stream)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod write-vertex-set ((thing t) stream)						(defmethod write-vertex-set ((thing t) stream)
  (let ((count 0)									  (let ((count 0)
	(space nil)										(space nil)
	(vertex-table (make-hash-table)))							(vertex-table (make-hash-table)))
    (map-over-cells (vertex 0) thing							    (map-over-cells (vertex 0) thing
	 (setf vertex (first (vertices-of vertex)))						 (setf vertex (first (vertices-of vertex)))
	 (incf count)										 (incf count)
	 (if space										 (if space
	     (unless (eql space (domain-of vertex))						     (unless (eql space (domain-of vertex))
	       (error "Mismatched vertex domains in ~s." thing))				       (error "Mismatched vertex domains in ~s." thing))
	     (setf space (domain-of vertex))))							     (setf space (domain-of vertex))))
    (format stream "VertexSet ~s ~s~%" (dimension-of space) count)			    (format stream "VertexSet ~s ~s~%" (dimension-of space) count)
    (setf count 0)									    (setf count 0)
    (map-over-cells (vertex 0) thing							    (map-over-cells (vertex 0) thing
	 (setf vertex (first (vertices-of vertex)))						 (setf vertex (first (vertices-of vertex)))
	 (fwrite vertex stream)									 (fwrite vertex stream)
	 (setf (gethash (id-number-of vertex) vertex-table) count)				 (setf (gethash (id-number-of vertex) vertex-table) count)
	 (incf count))										 (incf count))
    vertex-table))									    vertex-table))

(defmethod fwrite ((simplex simplex) stream &key					(defmethod fwrite ((simplex simplex) stream &key
		   (vertex-table (write-vertex-set simplex stream)))					   (vertex-table (write-vertex-set simplex stream)))
  (apply #'format stream "~s~@{ ~s~}~%"							  (apply #'format stream "~s~@{ ~s~}~%"
	 (loop for v in (vertices-of simplex)							 (loop for v in (vertices-of simplex)
	       collect (gethash (id-number-of v) vertex-table))))				       collect (gethash (id-number-of v) vertex-table))))

(defmethod fwrite ((sc simplicial-complex) stream &key					(defmethod fwrite ((sc simplicial-complex) stream &key
		   (vertex-table (write-vertex-set sc stream)))						   (vertex-table (write-vertex-set sc stream)))
  (let ((count 0)									  (let ((count 0)
	(max-dimension nil)									(max-dimension nil)
	(names (all-names sc)))									(names (all-names sc)))
    (map-over-maximal-cells (cell) sc							    (map-over-maximal-cells (cell) sc
      (incf count)									      (incf count)
      (if max-dimension									      (if max-dimension
	  (unless (= max-dimension (dimension-of cell))						  (unless (= max-dimension (dimension-of cell))
	    (error "Inconsistent maximal-cell dimensions in ~s." sc))				    (error "Inconsistent maximal-cell dimensions in ~s." sc))
	  (setf max-dimension (dimension-of cell))))						  (setf max-dimension (dimension-of cell))))
    (format stream "SimplicialComplex ~s ~s~%" max-dimension count)			    (format stream "SimplicialComplex ~s ~s~%" max-dimension count)
    (if names										    (if names
	(loop for name in names do								(loop for name in names do
	  (format stream "~s~%" name)								  (format stream "~s~%" name)
	  (map-over-cells (cell max-dimension) sc						  (map-over-cells (cell max-dimension) sc
	      (when (eql name (name cell sc))							      (when (eql name (name cell sc))
		(fwrite cell stream :vertex-table vertex-table))))					(fwrite cell stream :vertex-table vertex-table))))
	(map-over-cells (cell max-dimension) sc							(map-over-cells (cell max-dimension) sc
	    (fwrite cell stream :vertex-table vertex-table)))))					    (fwrite cell stream :vertex-table vertex-table)))))

(defmethod fwrite ((mesh mesh) stream &rest ignore)					(defmethod fwrite ((mesh mesh) stream &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (format stream "Mesh~%")								  (format stream "Mesh~%")
  (let ((vertex-table (write-vertex-set mesh stream)))					  (let ((vertex-table (write-vertex-set mesh stream)))
    (fwrite (%constraints-of mesh) stream :vertex-table vertex-table)			    (fwrite (%constraints-of mesh) stream :vertex-table vertex-table)
    (call-next-method mesh stream :vertex-table vertex-table)))				    (call-next-method mesh stream :vertex-table vertex-table)))

;;  User interface.									;;  User interface.
										    >	(defgeneric write-mesh (mesh stream)
										    >	  (:documentation
										    >	   "The purpose of this method is unknown."))
										    >
(defmethod write-mesh ((mesh mesh) stream)						(defmethod write-mesh ((mesh mesh) stream)
  (unless stream (setf stream *standard-output*))					  (unless stream (setf stream *standard-output*))
  (fwrite mesh stream))									  (fwrite mesh stream))
  
										    >	(defgeneric read-mesh (stream)
										    >	  (:documentation
										    >	   "The purpose of this method is unknown."))
										    >
(defmethod read-mesh ((stream stream))							(defmethod read-mesh ((stream stream))
  (let ((token (read stream))								  (let ((token (read stream))
	(vertex-table (make-hash-table))							(vertex-table (make-hash-table))
	(space nil)										(space nil)
	(mesh nil))										(mesh nil))
    (when (string= token "MESH") (setf token (read stream)))				    (when (string= token "MESH") (setf token (read stream)))
    ;;  Vertex set.									    ;;  Vertex set.
    (unless (string= token "VERTEXSET")							    (unless (string= token "VERTEXSET")
      (error "Expected VertexSet instead of ~s." token))				      (error "Expected VertexSet instead of ~s." token))
    (setf space (get-euclidean-space (read stream)))					    (setf space (get-euclidean-space (read stream)))
    (setf *space* space)								    (setf *space* space)
    (setf mesh (create-mesh space))							    (setf mesh (create-mesh space))
    (read-vertex-set stream vertex-table space)						    (read-vertex-set stream vertex-table space)
    ;;  Boundary complex.								    ;;  Boundary complex.
    (setf token (read stream))								    (setf token (read stream))
    (unless (string= token "SIMPLICIALCOMPLEX")						    (unless (string= token "SIMPLICIALCOMPLEX")
      (error "Expected boundary SimplicialComplex instead of ~s." token))		      (error "Expected boundary SimplicialComplex instead of ~s." token))
    (read-simplicial-complex stream vertex-table					    (read-simplicial-complex stream vertex-table
			     :complex (%constraints-of mesh))							     :complex (%constraints-of mesh))
    ;;  Mesh complex.									    ;;  Mesh complex.
    (setf token (read stream))								    (setf token (read stream))
    (unless (string= token "SIMPLICIALCOMPLEX")						    (unless (string= token "SIMPLICIALCOMPLEX")
      (error "Expected SimplicialComplex instead of ~s." token))			      (error "Expected SimplicialComplex instead of ~s." token))
    (read-simplicial-complex stream vertex-table :complex mesh)				    (read-simplicial-complex stream vertex-table :complex mesh)
    ;;  End of file.									    ;;  End of file.
    (setf token (read stream nil '%eof%))						    (setf token (read stream nil '%eof%))
    (unless (eql token '%eof%)								    (unless (eql token '%eof%)
      (warn "Unexpected data instead of end-of-file. ~s" token))			      (warn "Unexpected data instead of end-of-file. ~s" token))
    mesh))  										    mesh))  

;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-		;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-
;;; ===========================================================================		;;; ===========================================================================
;;;				  Morphisms						;;;				  Morphisms
;;; ===========================================================================		;;; ===========================================================================
;;; (c) Copyright 1989, 1991 Cornell University						;;; (c) Copyright 1989, 1991 Cornell University

;;; morphisms.lisp,v 1.7 1994/10/21 18:16:43 rz Exp					;;; morphisms.lisp,v 1.7 1994/10/21 18:16:43 rz Exp

(in-package "WEYLI")								    |	(in-package :weyli)

(make::adjust-version-numbers Weyl "1.7")					    |	;;; DELETE (make::adjust-version-numbers Weyl "1.7")

(defmethod print-object ((homo morphism) stream)					(defmethod print-object ((homo morphism) stream)
  (format stream									  (format stream
	  #+Genera "~S~S"									  #+Genera "~S~S"
	  #-Genera "~S->~S"									  #-Genera "~S->~S"
	  (morphism-domain homo) (morphism-range homo)))					  (morphism-domain homo) (morphism-range homo)))

(defun make-morphism (domain map range &key (replace? t))			    |	(defvar *morphism-composition-table*
  (let ((old-h (get-morphisms domain range))					    |	    (make-hash-table))
	(h (make-instance 'morphism :domain domain :map map :range range)))	    |
    (when replace?								    |	(defgeneric compose (morphism1 morphism2)
      (loop for morph in old-h							    |	  (:documentation
	    do (delete-morphism morph :error? t)))				    |	   "The purpose of this function is unknown."))
    (push h (domain-morphisms-from domain))    					    |
    (push h (domain-morphisms-to range))					    |	(defmethod compose ((f homomorphism) (g homomorphism))
    h))										    |	  (let ((cache (gethash f *morphism-composition-table*))
										    >		comp)
										    >	    (cond ((setq comp (assoc g cache))
										    >		   (second comp))
										    >		  ((eql (morphism-range f) (morphism-domain g))
										    >		   (setq comp
										    >			 (make-instance
										    >	                  'homomorphism
										    >	                  :domain (morphism-domain f)
										    >	                  :map (lambda (x)
										    >	                         (%funcall (morphism-map g)
										    >	                                   (%funcall (morphism-map f) x)))
										    >	                  :range (morphism-range g)))
										    >		   (push (list g comp) (gethash f *morphism-composition-table*))
										    >		   comp)
										    >		  (t (error "Incompatible homomorphisms: ~S o ~S"
										    >			    f g)))))

(defun get-morphisms (&key type domain range direct?)					(defun get-morphisms (&key type domain range direct?)
  (let (morphisms)									  (let (morphisms)
    (labels ((get-morphisms-from (d predecessor)					    (labels ((get-morphisms-from (d predecessor)
	       (loop for morph in (domain-morphisms-from d) do					       (loop for morph in (domain-morphisms-from d) do
		 (when (or (null type) (typep morph type))				                     (when (or (null type) (typep morph type))
		   (cond ((eql range (morphism-range morph))				                       (cond ((eql range (morphism-range morph))
			  (push (if predecessor						                              (push (if predecessor
				    (compose predecessor morph)				                                        (compose predecessor morph)
				    morph)						                                        morph)
				morphisms))						                                    morphisms))
			 (t								                             (t
			  (setq morph (if predecessor					                              (setq morph (if predecessor
					  (compose predecessor morph)			                                              (compose predecessor morph)
					  morph))					                                              morph))
			  (when (null range)						                              (when (null range)
			    (push morph morphisms))					                                (push morph morphisms))
			  (when (null direct?)						                              (when (null direct?)
			    (get-morphisms-from (morphism-range morph)			                                (get-morphisms-from (morphism-range morph)
					     morph)))))))				                                                    morph)))))))
	     (get-morphisms-to (d successor)							     (get-morphisms-to (d successor)
	       ;; We know that the range is null here, otherwise we				       ;; We know that the range is null here, otherwise we
	       ;; would have called GET-MORPHISMS-FROM						       ;; would have called GET-MORPHISMS-FROM
	       (loop for morph in (domain-morphisms-to d) do					       (loop for morph in (domain-morphisms-to d) do
		 (when (or (null type) (typep morph type))				                     (when (or (null type) (typep morph type))
		   (setq morph (if successor						                       (setq morph (if successor
				   (compose morph successor)				                                       (compose morph successor)
				   morph))						                                       morph))
		   (push morph morphisms)						                       (push morph morphisms)
		   (when (null direct?)							                       (when (null direct?)
		     (get-morphisms-to (morphism-domain morph) morph))))))		                         (get-morphisms-to (morphism-domain morph) morph))))))
      (cond (domain									      (cond (domain
	     (get-morphisms-from domain nil))							     (get-morphisms-from domain nil))
	    (range										    (range
	     (get-morphisms-to range nil))							     (get-morphisms-to range nil))
	    (t (loop for d in *domains*								    (t (loop for d in *domains*
		     do (get-morphisms-to d nil))))							     do (get-morphisms-to d nil))))
      morphisms)))									      morphisms)))

										    >	(defun make-morphism (domain map range &key (replace? t))
										    >	  (let ((old-h (get-morphisms :domain domain :range range))
										    >		(h (make-instance 'morphism :domain domain :map map :range range)))
										    >	    (when replace?
										    >	      (loop for morph in old-h
										    >		    do (delete-morphism morph :error? t)))
										    >	    (push h (domain-morphisms-from domain))    
										    >	    (push h (domain-morphisms-to range))
										    >	    h))
										    >
										    >	(defgeneric delete-morphism (morphism)
										    >	  (:documentation
										    >	   "Delete the morphism."))
										    >
(defmethod delete-morphism ((morph morphism))						(defmethod delete-morphism ((morph morphism))
  (let ((domain (morphism-domain morph))						  (let ((domain (morphism-domain morph))
	(range (morphism-range morph)))								(range (morphism-range morph)))
    (setf (domain-morphisms-from domain)						    (setf (domain-morphisms-from domain)
	  (delete morph (domain-morphisms-from domain)))    					  (delete morph (domain-morphisms-from domain)))    
    (setf (domain-morphisms-to range)							    (setf (domain-morphisms-to range)
	  (delete morph (domain-morphisms-to range)))))						  (delete morph (domain-morphisms-to range)))))

										    |	;;; Homomorphisms
  										    <
										    <
;; Homomorphisms								    <

(defun make-homomorphism (domain map range)						(defun make-homomorphism (domain map range)
  (let ((h (make-instance 'homomorphism :domain domain :map map :range range)))		  (let ((h (make-instance 'homomorphism :domain domain :map map :range range)))
    (push h (domain-morphisms-from domain))						    (push h (domain-morphisms-from domain))
    (push h (domain-morphisms-to range))						    (push h (domain-morphisms-to range))
    h))											    h))

(defun get-homomorphisms (&key domain range)						(defun get-homomorphisms (&key domain range)
  (get-morphisms :type 'homomorphism :domain domain :range range))			  (get-morphisms :type 'homomorphism :domain domain :range range))

(defun get-embeddable-domains (domain)							(defun get-embeddable-domains (domain)
  (let ((domains ()))									  (let ((domains ()))
    (loop for homo in (domain-morphisms-from domain)					    (loop for homo in (domain-morphisms-from domain)
	  do (when (typep homo 'homomorphism)							  do (when (typep homo 'homomorphism)
	       (push (morphism-range homo) domains)))						       (push (morphism-range homo) domains)))
    domains))										    domains))

(defun make-automorphism (domain map &optional range)					(defun make-automorphism (domain map &optional range)
  (declare (ignore range))								  (declare (ignore range))
  (make-homomorphism domain map domain))						  (make-homomorphism domain map domain))

(defun get-automorphisms (&key domain)							(defun get-automorphisms (&key domain)
  (get-morphisms :type 'automorphism :domain domain :range domain))			  (get-morphisms :type 'automorphism :domain domain :range domain))

;; Operations with morphisms							    |	;;; Operations with morphisms
										    >	(defgeneric apply-morphism (morphism argument)
										    >	  (:documentation
										    >	   "Apply the morphism to the argument."))

(defmethod apply-morphism ((h morphism) argument)					(defmethod apply-morphism ((h morphism) argument)
  (when (eql (domain-of argument) (morphism-domain h))					  (when (eql (domain-of argument) (morphism-domain h))
    (%funcall (morphism-map h) argument)))						    (%funcall (morphism-map h) argument)))

;; Converts a LISP number into a a Weyl number in the appropriate		    |	(defgeneric canonicalize-number (elt)
;; canonical domain.  These guys CANNOT use coerce!!!!				    |	  (:documentation
(defgeneric canonicalize-number (elt)) 						    |	   "Converts a LISP number into a a Weyl number in the appropriate
										    >	canonical domain. These guys CANNOT use coerce!!!!"))

(defmethod canonicalize-number ((num integer))						(defmethod canonicalize-number ((num integer))
  (make-element (get-rational-integers) num))						  (make-element (get-rational-integers) num))

(defmethod canonicalize-number ((num rational-integer))					(defmethod canonicalize-number ((num rational-integer))
  (cond ((typep (domain-of num) 'general-expressions)					  (cond ((typep (domain-of num) 'general-expressions)
	 (make-element (get-rational-integers) (integer-value num)))				 (make-element (get-rational-integers) (integer-value num)))
	(t num)))										(t num)))

(defmethod canonicalize-number ((num ratio))						(defmethod canonicalize-number ((num ratio))
  (make-instance 'rational-number :domain (get-rational-numbers)			  (make-instance 'rational-number :domain (get-rational-numbers)
		 :numerator (cl:numerator num)								 :numerator (cl:numerator num)
		 :denominator (cl:denominator num)))							 :denominator (cl:denominator num)))

(defmethod canonicalize-number ((num rational-number))					(defmethod canonicalize-number ((num rational-number))
  (cond ((typep (domain-of num) 'general-expressions)					  (cond ((typep (domain-of num) 'general-expressions)
	 (make-instance 'rational-number :domain (get-rational-numbers)				 (make-instance 'rational-number :domain (get-rational-numbers)
			:numerator (qo-numerator num)								:numerator (qo-numerator num)
			:denominator (qo-denominator num)))							:denominator (qo-denominator num)))
	(t num)))										(t num)))

(defmethod canonicalize-number ((num float))						(defmethod canonicalize-number ((num float))
  (make-instance 'floating-point-number							  (make-instance 'floating-point-number
		 :domain (get-real-numbers)								 :domain (get-real-numbers)
		 :value num))										 :value num))

(defmethod canonicalize-number ((num floating-point-number))				(defmethod canonicalize-number ((num floating-point-number))
  (cond ((typep (domain-of num) 'general-expressions)					  (cond ((typep (domain-of num) 'general-expressions)
	 (make-instance 'floating-point-number							 (make-instance 'floating-point-number
			:domain (get-real-numbers)								:domain (get-real-numbers)
			:value (fp-value num)))									:value (fp-value num)))
	(t num)))										(t num)))

(defmethod canonicalize-number ((num bigfloat))						(defmethod canonicalize-number ((num bigfloat))
  (cond ((typep (domain-of num) 'general-expressions)					  (cond ((typep (domain-of num) 'general-expressions)
	 (make-bigfloat (get-real-numbers)							 (make-bigfloat (get-real-numbers)
			(bigfloat-mantissa num)									(bigfloat-mantissa num)
			(bigfloat-exponent num)))								(bigfloat-exponent num)))
	(t num)))										(t num)))

(defmethod canonicalize-number ((num cl:complex))					(defmethod canonicalize-number ((num cl:complex))
  (make-element (get-complex-numbers)							  (make-element (get-complex-numbers)
		(cl:realpart num)									(cl:realpart num)
		(cl:imagpart num)))									(cl:imagpart num)))

(defmethod canonicalize-number ((num complex-number))					(defmethod canonicalize-number ((num complex-number))
  (cond ((typep (domain-of num) 'general-expressions)					  (cond ((typep (domain-of num) 'general-expressions)
	 (make-element (get-complex-numbers)							 (make-element (get-complex-numbers)
		       (cn-realpart num)								       (cn-realpart num)
		       (cn-imagpart num)))								       (cn-imagpart num)))
	(t num)))										(t num)))

(defmethod canonicalize-number ((num GFp-element)) num)					(defmethod canonicalize-number ((num GFp-element)) num)

(defmethod canonicalize-number ((num GFm-element)) num)					(defmethod canonicalize-number ((num GFm-element)) num)

;; This is what allows lisp numbers to be used relatively freely.		    |	;;; This is what allows lisp numbers to be used relatively freely.
;; Unfortunately, this introduces more consing than would be idea.		    |	;;; Unfortunately, this introduces more consing than would be idea.
(defmethod apply-morphism ((map morphism) (elt number))					(defmethod apply-morphism ((map morphism) (elt number))
  (apply-morphism map (canonicalize-number elt)))					  (apply-morphism map (canonicalize-number elt)))

(defvar *morphism-composition-table*						    |	;;; Support for COERCIONS
    (make-hash-table))								    <
										    <
(defmethod compose ((f homomorphism) (g homomorphism))				    <
  (let ((cache (gethash f *morphism-composition-table*))			    <
	comp)									    <
    (cond ((setq comp (assoc g cache))						    <
	   (second comp))							    <
	  ((eql (morphism-range f) (morphism-domain g))				    <
	   (setq comp								    <
		 (make-instance 'homomorphism					    <
		   :domain (morphism-domain f)					    <
		   :map #'(lambda (x)						    <
			    (%funcall (morphism-map g)				    <
				      (%funcall (morphism-map f) x)))		    <
		   :range (morphism-range g)))					    <
	   (push (list g comp) (gethash f *morphism-composition-table*))	    <
	   comp)								    <
	  (t (error "Incompatible homomorphisms: ~S o ~S"			    <
		    f g)))))							    <
										    <
;; Support for COERCIONS							    <

(defun reachable-domains (domain)							(defun reachable-domains (domain)
  (flet ((next-domains (x)								  (flet ((next-domains (x)
	   (loop for m in (domain-morphisms-from x)						   (loop for m in (domain-morphisms-from x)
		 collect (morphism-range m))))								 collect (morphism-range m))))
    (let (domains)									    (let (domains)
      (map-over-tree d (domain :depth-first? t						      (map-over-tree d (domain :depth-first? t
				:collection-fun next-domains)				                               :collection-fun next-domains)
		     (push d domains))							        (push d domains))
      domains)))									      domains)))

(defun find-common-domains (d1 d2)							(defun find-common-domains (d1 d2)
  (flet ((next-domains (x)								  (flet ((next-domains (x)
	   (loop for m in (domain-morphisms-from x)						   (loop for m in (domain-morphisms-from x)
		 collect (morphism-range m))))								 collect (morphism-range m))))
    (let ((d1-domains (reachable-domains d1))						    (let ((d1-domains (reachable-domains d1))
	  domains)										  domains)
      (map-over-tree d (d2 :breadth-first? t						      (map-over-tree d (d2 :breadth-first? t
			   :collection-fun next-domains)							   :collection-fun next-domains)
	(when (member d d1-domains)								(when (member d d1-domains)
	  (pushnew d domains)									  (pushnew d domains)
	  (terminate-branch)))									  (terminate-branch)))
      domains)))									      domains)))

;; Since we don't have an error system in Common Lisp yet, we use the		    |	;;; FIXME : Common Lisp does have an error system, now.
;; following flag to control whether an error is generated or NIL is		    |	;;;
;; returned from COERCE.							    |	;;; Since we don't have an error system in Common Lisp yet, we use the
										    >	;;; following flag to control whether an error is generated or NIL is
										    >	;;; returned from COERCE.

(defvar *coercibility-checking* nil)							(defvar *coercibility-checking* nil)

;; This method provides the the default homorphism coercions			    |	;;; This method provides the the default homorphism coercions
(defmethod coerce (elt (domain domain))							(defmethod coerce (elt (domain domain))
  (let (homos)										  (let (homos)
    (cond ((null (typep elt 'domain-element))						    (cond ((null (typep elt 'domain-element))
	   (unless *coercibility-checking*							   (unless *coercibility-checking*
	     (error "Don't know how to coerce ~S to be an element of ~S"			     (error "Don't know how to coerce ~S to be an element of ~S"
		    elt domain)))									    elt domain)))
	  ((eql (domain-of elt) domain)								  ((eql (domain-of elt) domain)
	   elt)											   elt)
	  ((null (setq homos (get-homomorphisms :domain (domain-of elt)				  ((null (setq homos (get-homomorphisms :domain (domain-of elt)
						:range domain)))									:range domain)))
	   (unless *coercibility-checking*							   (unless *coercibility-checking*
	     (error "Don't know how to coerce ~S to be an element of ~S"			     (error "Don't know how to coerce ~S to be an element of ~S"
		    elt domain)))									    elt domain)))
	  ((null (rest homos))									  ((null (rest homos))
	   (apply-morphism (first homos) elt))							   (apply-morphism (first homos) elt))
	  (t (error "More than one homomorphism from ~S to ~S.~%~				  (t (error "More than one homomorphism from ~S to ~S.~%~
                     Can't do automatic coercion"					                     Can't do automatic coercion"
		    (domain-of elt) domain)))))								    (domain-of elt) domain)))))

;; This method must be primary because there are more specific			    |	;;; This method must be primary because there are more specific
;; versions of it.								    |	;;; versions of it.
(defmethod coerce ((elt number) (domain domain))					(defmethod coerce ((elt number) (domain domain))
  (coerce (canonicalize-number elt) domain))						  (coerce (canonicalize-number elt) domain))

;; FIXTHIS: Why is this here?  Both branches are the same.				;; FIXTHIS: Why is this here?  Both branches are the same.
(defmethod coerce ((elt numeric) (domain domain))					(defmethod coerce ((elt numeric) (domain domain))
  (cond ((and (typep (domain-of elt) 'general-expressions)				  (cond ((and (typep (domain-of elt) 'general-expressions)
	      (not (typep domain 'general-expressions)))					      (not (typep domain 'general-expressions)))
	 (call-next-method (canonicalize-number elt) domain))					 (call-next-method (canonicalize-number elt) domain))
	(t (call-next-method (canonicalize-number elt) domain))))				(t (call-next-method (canonicalize-number elt) domain))))

(defmethod coercible? (elt (d domain))							(defmethod coercible? (elt (d domain))
  (let ((*coercibility-checking* t))							  (let ((*coercibility-checking* t))
    (coerce elt d)))									    (coerce elt d)))

;; This code provides the default methods for binary operators.			    |	;;; This code provides the default methods for binary operators.

(defvar *coerce-where-possible* t)							(defvar *coerce-where-possible* t)

(defmacro def-binary-coercion (op illegal-mess ambig-mess				(defmacro def-binary-coercion (op illegal-mess ambig-mess
				  &key (numeric-numeric? t)				                               &key (numeric-numeric? t)
				  (domain-element-domain-element? t))			                               (domain-element-domain-element? t))
  `(progn										  `(progn
     ,(when domain-element-domain-element?						    ,(when domain-element-domain-element?
	`(defmethod ,op ((x domain-element) (y domain-element))				           `(defmethod ,op ((x domain-element) (y domain-element))
	   (when (null *coerce-where-possible*)						             (when (null *coerce-where-possible*)
	     (error ,illegal-mess x y))							               (error ,illegal-mess x y))
	   (let ((domain-x (domain-of x))						             (let ((domain-x (domain-of x))
		 (domain-y (domain-of y))						                   (domain-y (domain-of y))
		 common-domains)							                   common-domains)
	     (when (eql domain-x domain-y)						               (when (eql domain-x domain-y)
	       (error ,illegal-mess x y))						                 (error ,illegal-mess x y))
	     (setq common-domains (find-common-domains domain-x domain-y))		               (setq common-domains (find-common-domains domain-x domain-y))
	     (cond ((null common-domains)						               (cond ((null common-domains)
		    (error ,illegal-mess x y))						                      (error ,illegal-mess x y))
		   ((null (rest common-domains))					                     ((null (rest common-domains))
		    (,op (coerce x (first common-domains))				                      (,op (coerce x (first common-domains))
			 (coerce y (first common-domains))))				                           (coerce y (first common-domains))))
		   (t (error ,ambig-mess  x y))))))					                     (t (error ,ambig-mess  x y))))))
											    ;; If the domain of y is non-strict then always try to coerce x
     ;; If the domain of y is non-strict then always try to coerce x			    ;; into (domain-of y).  If the domain of y is strict, then
     ;; into (domain-of y).  If the domain of y is strict, then				    ;; canoncalize x, ie, coerce x into its natural algebraic domain
     ;; canoncalize x, ie, coerce x into its natural algebraic domain			    ;; R, Z, C, etc, and try again.
     ;; R, Z, C, etc, and try again.							    (defmethod ,op ((x number) (y domain-element))
     (defmethod ,op ((x number) (y domain-element))					      (cond ((typep (domain-of y) 'non-strict-domain)
       (cond ((typep (domain-of y) 'non-strict-domain)					             (,op (coerce x (domain-of y)) y))
	      (,op (coerce x (domain-of y)) y))						            (*coerce-where-possible*	       
	     (*coerce-where-possible*	       						             (,op (canonicalize-number x) y))
	       (,op (canonicalize-number x) y))						            (t (error ,illegal-mess x y))))
	     (t (error ,illegal-mess x y))))						    (defmethod ,op ((x domain-element) (y number))
											      (cond ((typep (domain-of x) 'non-strict-domain)
     (defmethod ,op ((x domain-element) (y number))					             (,op x (coerce y (domain-of x))))
       (cond ((typep (domain-of x) 'non-strict-domain)					            (*coerce-where-possible*	       
	      (,op x (coerce y (domain-of x))))						             (,op x (canonicalize-number y)))
	     (*coerce-where-possible*	       						            (t (error ,illegal-mess x y))))
	       (,op x (canonicalize-number y)))						    ;; If the domain of y is non-strict then proceed as with numbers
	     (t (error ,illegal-mess x y))))						    ;; (always coerce).  If the domain of y is strict, but the domain
											    ;; of x is not, then coerce x into its natural algebraic domain
     ;; If the domain of y is non-strict then proceed as with numbers			    ;; and try again.
     ;; (always coerce).  If the domain of y is strict, but the domain			    (defmethod ,op ((x numeric) (y domain-element))
     ;; of x is not, then coerce x into its natural algebraic domain			      (cond ((eql (domain-of x) (domain-of y))
     ;; and try again.									             (call-next-method))
     (defmethod ,op ((x numeric) (y domain-element))					            ((typep (domain-of y) 'non-strict-domain)
       (cond ((eql (domain-of x) (domain-of y))						             (,op (coerce x (domain-of y)) y))
	      (call-next-method))							            ((and *coerce-where-possible*
	     ((typep (domain-of y) 'non-strict-domain)					                  (typep (domain-of x) 'non-strict-domain))
	      (,op (coerce x (domain-of y)) y))						             (,op (canonicalize-number x) y))
	     ((and *coerce-where-possible*						            (t (call-next-method))))
		   (typep (domain-of x) 'non-strict-domain))				    (defmethod ,op ((x domain-element) (y numeric))
	       (,op (canonicalize-number x) y))						      (cond ((eql (domain-of x) (domain-of y))
	     (t (call-next-method))))							             (call-next-method))
											            ((typep (domain-of x) 'non-strict-domain)
     (defmethod ,op ((x domain-element) (y numeric))					             (,op x (coerce y (domain-of x))))
       (cond ((eql (domain-of x) (domain-of y))						            ((and *coerce-where-possible*
	      (call-next-method))							                  (typep (domain-of y) 'non-strict-domain))
	     ((typep (domain-of x) 'non-strict-domain)					             (,op x (canonicalize-number y)))
	      (,op x (coerce y (domain-of x))))						            (t (call-next-method))))
	     ((and *coerce-where-possible*						    ,(when numeric-numeric?
		   (typep (domain-of y) 'non-strict-domain))				           `(defmethod ,op ((x numeric) (y numeric))
	       (,op x (canonicalize-number y)))						             (let ((x-domain (domain-of x))
	     (t (call-next-method))))							                   (y-domain (domain-of y)))
											               (cond ((eql x-domain y-domain)
     ,(when numeric-numeric?								                      (call-next-method))
	`(defmethod ,op ((x numeric) (y numeric))					                     ((typep (domain-of x) 'non-strict-domain)
	   (let ((x-domain (domain-of x))						                      (,op x (coerce y (domain-of x))))
		 (y-domain (domain-of y)))						                     ((typep (domain-of y) 'non-strict-domain)
	     (cond ((eql x-domain y-domain)						                      (,op (coerce x (domain-of y)) y))
		    (call-next-method))							                     (t (call-next-method))))))))
		   ((typep (domain-of x) 'non-strict-domain)
		    (,op x (coerce y (domain-of x))))					(def-binary-coercion binary=
		   ((typep (domain-of y) 'non-strict-domain)				    "No way to compare ~S and ~S"
		    (,op (coerce x (domain-of y)) y))					  "Ambiguous coercion for = (~S, ~S)"
		   (t (call-next-method))))))))						  :numeric-numeric? nil)

(def-binary-coercion binary=								(def-binary-coercion binary>
  "No way to compare ~S and ~S"								    "No way to compare ~S and ~S"
  "Ambiguous coercion for = (~S, ~S)"							  "Ambiguous coercion for > (~S, ~S)"
  :numeric-numeric? nil)								  :numeric-numeric? nil)

(def-binary-coercion binary>								(def-binary-coercion binary>=
  "No way to compare ~S and ~S"								    "No way to compare ~S and ~S"
  "Ambiguous coercion for > (~S, ~S)"							  "Ambiguous coercion for >= (~S, ~S)"
  :numeric-numeric? nil)								  :numeric-numeric? nil)

(def-binary-coercion binary>=								(def-binary-coercion plus
  "No way to compare ~S and ~S"								    "No way to add ~S and ~S"
  "Ambiguous coercion for >= (~S, ~S)"							  "Ambiguous coercion for addition (~S, ~S)"
  :numeric-numeric? nil)								  :numeric-numeric? nil)

(def-binary-coercion plus								(def-binary-coercion difference
  "No way to add ~S and ~S"								    "No way to subtract ~S and ~S"
  "Ambiguous coercion for addition (~S, ~S)"						  "Ambiguous coercion for subtraction (~S, ~S)"
  :numeric-numeric? nil)								  :numeric-numeric? nil)

(def-binary-coercion difference								(def-binary-coercion times
  "No way to subtract ~S and ~S"							    "No way to multiply ~S and ~S"
  "Ambiguous coercion for subtraction (~S, ~S)"						  "Ambiguous coercion for multiplication (~S, ~S)"
  :numeric-numeric? nil)								  :numeric-numeric? nil)

(def-binary-coercion times							    (
  "No way to multiply ~S and ~S"						    (
  "Ambiguous coercion for multiplication (~S, ~S)"				    (
  :numeric-numeric? nil)							    (
										    (
										    >	;;; FIXME : Explicitly define a generic function for quotient.
(def-binary-coercion quotient								(def-binary-coercion quotient
  "No way to compute the quotient of ~S and ~S"						    "No way to compute the quotient of ~S and ~S"
  "Ambiguous coercion for division (~S, ~S)"						  "Ambiguous coercion for division (~S, ~S)"
  :numeric-numeric? nil)								  :numeric-numeric? nil)

(def-binary-coercion expt								(def-binary-coercion expt
  "No way to raise ~S to the ~S power"							  "No way to raise ~S to the ~S power"
  "Ambiguous coercion for exponentiation (~S, ~S)")					  "Ambiguous coercion for exponentiation (~S, ~S)")

										    >	;;; FIXME : Explicitly define a generic function for remainder.
(def-binary-coercion remainder								(def-binary-coercion remainder
  "No way to compute the remainder of ~S and ~S"					  "No way to compute the remainder of ~S and ~S"
  "Ambiguous coercion for remainder (~S, ~S)"						  "Ambiguous coercion for remainder (~S, ~S)"
  :numeric-numeric? nil)								  :numeric-numeric? nil)

;; The numeric-numeric method for GCD and LCM are in numbers.lisp			;; The numeric-numeric method for GCD and LCM are in numbers.lisp
(def-binary-coercion binary-gcd								(def-binary-coercion binary-gcd
  "No way to compute the GCD of ~S and ~S"						    "No way to compute the GCD of ~S and ~S"
  "Ambiguous coercion for gcd (~S, ~S)"							  "Ambiguous coercion for gcd (~S, ~S)"
  :numeric-numeric? nil)								  :numeric-numeric? nil)

(def-binary-coercion binary-lcm								(def-binary-coercion binary-lcm
  "No way to compute the LCM of ~S and ~S"						    "No way to compute the LCM of ~S and ~S"
  "Ambiguous coercion for lcm (~S, ~S)"							  "Ambiguous coercion for lcm (~S, ~S)"
  :numeric-numeric? nil)								  :numeric-numeric? nil)

										    >	;;; FIXME : Explicitly define a generic function for max-pair.
(def-binary-coercion max-pair								(def-binary-coercion max-pair
  "No way to compute the maximum of ~S and ~S"						    "No way to compute the maximum of ~S and ~S"
  "Ambiguous coercion for max (~S, ~S)"							  "Ambiguous coercion for max (~S, ~S)"
  :domain-element-domain-element? nil							  :domain-element-domain-element? nil
  :numeric-numeric? nil)								  :numeric-numeric? nil)

										    >	;;; FIXME : Explicitly define a generic function for min-pair.
(def-binary-coercion min-pair								(def-binary-coercion min-pair
  "No way to compute the minimum of ~S and ~S"						    "No way to compute the minimum of ~S and ~S"
  "Ambiguous coercion for min (~S, ~S)"							  "Ambiguous coercion for min (~S, ~S)"
  :domain-element-domain-element? nil							  :domain-element-domain-element? nil
  :numeric-numeric? nil)								  :numeric-numeric? nil)

										    >	;;; FIXME : Explicitly define a generic function for floor2.
(def-binary-coercion floor2								(def-binary-coercion floor2
  "No way to compute the floor of ~S modulo ~S"						    "No way to compute the floor of ~S modulo ~S"
  "Ambiguous coercion for floor (~S, ~S)"						  "Ambiguous coercion for floor (~S, ~S)"
  :numeric-numeric? nil)								  :numeric-numeric? nil)

										    >	;;; FIXME : Explicitly define a generic function for ceiling2.
(def-binary-coercion ceiling2								(def-binary-coercion ceiling2
  "No way to compute the ceiling of ~S modulo ~S"					    "No way to compute the ceiling of ~S modulo ~S"
  "Ambiguous coercion for ceiling (~S, ~S)"						  "Ambiguous coercion for ceiling (~S, ~S)"
  :numeric-numeric? nil)								  :numeric-numeric? nil)

										    >	;;; FIXME : Explicitly define a generic function for round2.
(def-binary-coercion round2								(def-binary-coercion round2
  "No way to round ~S modulo ~S"							    "No way to round ~S modulo ~S"
  "Ambiguous coercion for round (~S, ~S)"						  "Ambiguous coercion for round (~S, ~S)"
  :numeric-numeric? nil)								  :numeric-numeric? nil)

										    >	;;; FIXME : Explicitly define a generic function for truncate2.
(def-binary-coercion truncate2								(def-binary-coercion truncate2
  "No way to truncate ~S modulo ~S"							    "No way to truncate ~S modulo ~S"
  "Ambiguous coercion for truncate (~S, ~S)"						  "Ambiguous coercion for truncate (~S, ~S)"
  :numeric-numeric? nil)								  :numeric-numeric? nil)

										    >	;;; FIXME : Explicitly define a generic function for dot-product.
(def-binary-coercion dot-product							(def-binary-coercion dot-product
  "No way to compute the dot-product of ~S and ~S"					    "No way to compute the dot-product of ~S and ~S"
  "Ambiguous coercion for dot-product (~S, ~S)")					  "Ambiguous coercion for dot-product (~S, ~S)")
;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-		;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-
;;; ===========================================================================		;;; ===========================================================================
;;;			      General Polynomial Domain					;;;			      General Polynomial Domain
;;; ===========================================================================		;;; ===========================================================================
;;; (c) Copyright 1989, 1993 Cornell University						;;; (c) Copyright 1989, 1993 Cornell University

;;; mpolynomial.lisp,v 1.10 1995/05/24 17:42:05 rz Exp					;;; mpolynomial.lisp,v 1.10 1995/05/24 17:42:05 rz Exp

(in-package "WEYLI")								    |	(in-package :weyli)

(make::adjust-version-numbers Weyl "1.10")					    |	;;; DELETE (make::adjust-version-numbers Weyl "1.10")

(define-domain-element-classes multivariate-polynomial-ring				(define-domain-element-classes multivariate-polynomial-ring
    mpolynomial epolynomial)								  mpolynomial epolynomial)

(defmethod initialize-instance :after ((d multivariate-polynomial-ring)			(defmethod initialize-instance :after ((d multivariate-polynomial-ring)
				       &rest plist)									       &rest plist)
  (declare (ignore plist))								  (declare (ignore plist))
  (with-slots (zero one coefficient-domain) d						  (with-slots (zero one coefficient-domain) d
    (setq zero (make-polynomial d (zero coefficient-domain)))				    (setq zero (make-polynomial d (zero coefficient-domain)))
    (setq one (make-polynomial d (one coefficient-domain)))))				    (setq one (make-polynomial d (one coefficient-domain)))))

(define-domain-creator polynomial-ring						    |	(eval-when (:compile-toplevel :load-toplevel)
										    >	  (define-domain-creator polynomial-ring
		       ((coefficient-domain domain) (variables list))			      ((coefficient-domain domain) (variables list))
  (let ((domain (make-instance 'multivariate-polynomial-ring				    (let ((domain (make-instance 'multivariate-polynomial-ring
			       :variables (loop for var in variables			                                 :variables (loop for var in variables
						collect (coerce var *general*))		                                                  collect (coerce var *general*))
			       :coefficient-domain coefficient-domain			                                 :coefficient-domain coefficient-domain
			       :print-function 'polynomial-ring-print-object)))		                                 :print-function 'polynomial-ring-print-object)))
    (make-homomorphism coefficient-domain						      (make-homomorphism coefficient-domain
		       #'(lambda (c) (make-polynomial domain c))			                         #'(lambda (c) (make-polynomial domain c))
		       domain)								                         domain)
    domain))									    |	      domain)))

(defun polynomial-ring-print-object (d stream)						(defun polynomial-ring-print-object (d stream)
  (format stream "~A[" (coefficient-domain-of d))					  (format stream "~A[" (coefficient-domain-of d))
  (display-list (ring-variables d) stream)						  (display-list (ring-variables d) stream)
  (princ "]" stream))									  (princ "]" stream))

										    >	(defgeneric get-polynomial-ring (domain variables)
										    >	  (:documentation
										    >	   "The purpose of this method is unknown."))
										    >
(defmethod get-polynomial-ring								(defmethod get-polynomial-ring
	   ((coefficient-domain domain) (variables list))				    ((coefficient-domain domain) (variables list))
  (let ((kernels ()))									  (let ((kernels ()))
    (loop for var in variables								    (loop for var in variables
	  do (loop for v in (different-kernels (coerce var *general*)				  do (loop for v in (different-kernels (coerce var *general*)
				      kernels)						                                               kernels)
		   do (pushnew v kernels :test #'ge-equal)))						   do (pushnew v kernels :test #'ge-equal)))
    (setq kernels (nreverse kernels))							    (setq kernels (nreverse kernels))
    (add-domain #'(lambda (d)								    (add-domain #'(lambda (d)
		    (and (typep d 'polynomial-ring)							    (and (typep d 'polynomial-ring)
			 (eql (coefficient-domain-of d) coefficient-domain)					 (eql (coefficient-domain-of d) coefficient-domain)
			 (ge-lequal (ring-variables d) kernels)))						 (ge-lequal (ring-variables d) kernels)))
      (make-polynomial-ring* coefficient-domain kernels))))				      (make-polynomial-ring* coefficient-domain kernels))))

											;;; ===========================================================================
;;; ===========================================================================		;;;			       Polynomial Elements
;;;			       Polynomial Elements					;;; ===========================================================================
;;; ===========================================================================
											;;; Polynomials are a structure consisting of three parts: an order
;;; Polynomials are a structure consisting of three parts: an order			;;; number, the variable at this level, and a list of the terms of the
;;; number, the variable at this level, and a list of the terms of the			;;; polynomial.  Term-list are exponent coefficient pairs.
;;; polynomial.  Term-list are exponent coefficient pairs.
											;; Polynomials  := <coef> | (<var-number> . <term-list>)
;; Polynomials  := <coef> | (<var-number> . <term-list>)				;; term-list := nil | ((<exponent> . <coefficient>) . <term-list>)
;; term-list := nil | ((<exponent> . <coefficient>) . <term-list>)
											(defmacro poly-order-number (poly)
(defmacro poly-order-number (poly)							  `(first ,poly))
  `(first ,poly))
											(defmacro poly-terms (poly)
(defmacro poly-terms (poly)								  `(rest ,poly))
  `(rest ,poly))
											(defmacro poly-coef? (x)
(defmacro poly-coef? (x)								  `(not (listp ,x)))
  `(not (listp ,x)))
										    (
										    >	(defgeneric scalar? (object)
										    >	  (:documentation
										    >	   "The purpose of this method is unknown."))
										    >
(defmethod scalar? ((x mpolynomial))							(defmethod scalar? ((x mpolynomial))
  (poly-coef? (poly-form x)))								  (poly-coef? (poly-form x)))

(defmethod 0? ((x mpolynomial))							    <
  (poly-0? (poly-form x)))							    <
										    <
(defsubst poly-0? (x)									(defsubst poly-0? (x)
  (and (poly-coef? x) (0? x))) 								  (and (poly-coef? x) (0? x))) 

(defmethod 1? ((x mpolynomial))							    |	(defmethod 0? ((x mpolynomial))
  (poly-1? (poly-form x)))							    |	  (poly-0? (poly-form x)))

(defsubst poly-1? (x)									(defsubst poly-1? (x)
  (and (poly-coef? x) (1? x)))								  (and (poly-coef? x) (1? x)))

										    >	(defmethod 1? ((x mpolynomial))
										    >	  (poly-1? (poly-form x)))
										    >
(defun make-poly-form (poly terms)							(defun make-poly-form (poly terms)
  (cons (poly-order-number poly) terms))						  (cons (poly-order-number poly) terms))

										    >	(defgeneric make-polynomial (domain form)
										    >	  (:documentation
										    >	   "The purpose of this method is unknown."))
										    >
(defmethod make-polynomial ((domain multivariate-polynomial-ring) form)			(defmethod make-polynomial ((domain multivariate-polynomial-ring) form)
  (make-instance 'mpolynomial :domain domain :form form))				  (make-instance 'mpolynomial :domain domain :form form))

(defmethod variable-symbol ((domain variable-hash-table) (poly mpolynomial))		(defmethod variable-symbol ((domain variable-hash-table) (poly mpolynomial))
  (aref (variable-index-table domain) (poly-order-number (poly-form poly)) 0))		  (aref (variable-index-table domain) (poly-order-number (poly-form poly)) 0))

(defsubst more-main? (x y)								(defsubst more-main? (x y)
  (cl:< (poly-order-number x) (poly-order-number y)))					  (cl:< (poly-order-number x) (poly-order-number y)))

(defun more-main-order-number? (x y) (cl:< x y))					(defun more-main-order-number? (x y) (cl:< x y))

(defsubst same-variable? (x y)								(defsubst same-variable? (x y)
  (cl:= (poly-order-number x) (poly-order-number y)))					  (cl:= (poly-order-number x) (poly-order-number y)))

;; The following macros are for dealing with term-lists.				;; The following macros are for dealing with term-lists.

(defmacro le (terms) `(first  (first ,terms)))						(defmacro le (terms) `(first  (first ,terms)))

(defmacro lc (terms) `(rest (first ,terms)))						(defmacro lc (terms) `(rest (first ,terms)))

(defmacro lt (terms) `(first ,terms))							(defmacro lt (terms) `(first ,terms))

(defmacro red (terms) `(rest ,terms))							(defmacro red (terms) `(rest ,terms))

(defmacro make-terms (e c &optional (terms ()))						(defmacro make-terms (e c &optional (terms ()))
  (if (null terms)									  (if (null terms)
      `(list (cons ,e ,c))	 							      `(list (cons ,e ,c))	 
      `(cons (cons ,e ,c) ,terms)))							      `(cons (cons ,e ,c) ,terms)))

(defmacro make-many-terms (&rest e-c-pairs)						(defmacro make-many-terms (&rest e-c-pairs)
  (if (null e-c-pairs) `(terms0)							  (if (null e-c-pairs) `(terms0)
      `(make-terms ,(first e-c-pairs) ,(second e-c-pairs)				      `(make-terms ,(first e-c-pairs) ,(second e-c-pairs)
		   (make-many-terms ,@(rest (rest e-c-pairs))))))			        (make-many-terms ,@(rest (rest e-c-pairs))))))

(defmacro terms0? (x) `(null ,x))							(defmacro terms0? (x) `(null ,x))

(defmacro terms0 () '())								(defmacro terms0 () '())

;; This is not part of the interface.  It is mostly used for testing.		    |	(defgeneric make-poly (domain variable &optional terms)
										    >	  (:documentation
										    >	   "This is not part of the interface. It is mostly used for
										    >	testing."))
										    >
(defmethod make-poly									(defmethod make-poly
    ((domain multivariate-polynomial-ring) variable &optional terms)  			    ((domain multivariate-polynomial-ring) variable &optional terms)  
  (unless terms										  (unless terms
    (setq terms (make-terms 1 (coerce 1 (coefficient-domain-of domain)))))		    (setq terms (make-terms 1 (coerce 1 (coefficient-domain-of domain)))))
  (make-polynomial domain (cons (variable-index domain variable) terms)))		  (make-polynomial domain (cons (variable-index domain variable) terms)))

;; Some useful control abstractions for term lists					;; Some useful control abstractions for term lists

;; This is the version we should use when the walker is re-installed properly.		;; This is the version we should use when the walker is re-installed properly.
#+ignore 										#+ignore 
(defmacro map-over-each-term (terms (e c) &body body)					(defmacro map-over-each-term (terms (e c) &body body)
  (let ((collects? nil) (updates? nil))							  (let ((collects? nil) (updates? nil))
    (walker::walk-form `(progn ,@body) nil						    (walker::walk-form `(progn ,@body) nil
		       #'(lambda (form context env)							       #'(lambda (form context env)
			   (declare (ignore env))								   (declare (ignore env))
			   (cond ((and (eql context :eval) (not (atom form)))					   (cond ((and (eql context :eval) (not (atom form)))
				  (cond ((eql (first form) 'collect-term)						  (cond ((eql (first form) 'collect-term)
					 (setq collects? t))									 (setq collects? t))
					((eql (first form) 'update-term)							((eql (first form) 'update-term)
					 (setq updates? t)))))									 (setq updates? t)))))
			 form))								                           form))
    											    `(let ((.ans-terms. (list nil))
    												   ,@(when collects? 
    `(let ((.ans-terms. (list nil))							                   `((.terms. nil))))
	   ,@(when collects? 								      (macrolet (,@(when collects?
	       `((.terms. nil))))							                         '((collect-term (.e. .c.)
       (macrolet (,@(when collects?							                            `(progn (setf (rest .terms.) (make-terms , .e. , .c.))
		      '((collect-term (.e. .c.)						                              (setf .terms. (rest .terms.))))))
			 `(progn (setf (rest .terms.) (make-terms , .e. , .c.))		                 ,@(when updates?
				 (setf .terms. (rest .terms.))))))			                         '((update-term (.e. .c.)
		  ,@(when updates?							                            `(progn (setf (le .t.) , .e.)
		      '((update-term (.e. .c.)						                              (setf (lc .t.) , .c.))))))
			 `(progn (setf (le .t.) , .e.)					        ,@(when collects?
				 (setf (lc .t.) , .c.))))))				                '((setq .terms. .ans-terms.)))
	 ,@(when collects?								        (loop for .t. on ,terms
	     '((setq .terms. .ans-terms.)))						              for ((,(and (not (eql e 'ignore)) e)
	 (loop for .t. on ,terms							                     . ,(and (not (eql c 'ignore)) c))) = .t.
	       for ((,(and (not (eql e 'ignore)) e)					              do ,@body))
			   . ,(and (not (eql c 'ignore)) c))) = .t.			      (rest .ans-terms.))))
	       do ,@body))
       (rest .ans-terms.))))								(defmacro map-over-each-term (terms (e c) &body body)
											  `(let ((.ans-terms. (list nil))
(defmacro map-over-each-term (terms (e c) &body body)						 (.terms. nil))
  `(let ((.ans-terms. (list nil))							    (macrolet ((collect-term (.e. .c.)
	 (.terms. nil))									                 `(progn (setf (rest .terms.) (make-terms , .e. , .c.))
     (macrolet ((collect-term (.e. .c.)							                   (setf .terms. (rest .terms.))))
			      `(progn (setf (rest .terms.) (make-terms , .e. , .c.	               (update-term (.e. .c.)
				      (setf .terms. (rest .terms.))))			                 `(progn (setf (le .t.) , .e.)
		(update-term (.e. .c.)							                   (setf (lc .t.) , .c.))))
			     `(progn (setf (le .t.) , .e.)				      (setq .terms. .ans-terms.)
				     (setf (lc .t.) , .c.))))				      (loop for .t. on ,terms
       (setq .terms. .ans-terms.)							            for ((,(and (not (eql e 'ignore)) e)
       (loop for .t. on ,terms								                   . ,(and (not (eql c 'ignore)) c))) = .t.
	     for ((,(and (not (eql e 'ignore)) e)					            do ,@body))
			 . ,(and (not (eql c 'ignore)) c))) = .t.			    (rest .ans-terms.)))
	     do ,@body))
     (rest .ans-terms.)))								(defmacro pair-up-terms (terms1 (e1 c1) terms2 (e2 c2) order-predicate &body body)
											  (unless (atom order-predicate)
(defmacro pair-up-terms (terms1 (e1 c1) terms2 (e2 c2) order-predicate &body body)	    (error "Invalid order predicate for PAIR-UP-TERMS: ~S" order-predicate))
  (unless (atom order-predicate)							  `(let ((.ans-terms. (list nil))
    (error "Invalid order predicate for PAIR-UP-TERMS: ~S" order-predicate))			 (.terms. nil)
  `(let ((.ans-terms. (list nil))								 (.t1. ,terms1)
	 (.terms. nil)										 (.t2. ,terms2)
	 (.t1. ,terms1)										 ,e1 ,c1 ,e2 ,c2)
	 (.t2. ,terms2)									    (macrolet ((collect-term (.e. .c.)
	 ,e1 ,c1 ,e2 ,c2)								                 `(progn (setf (rest .terms.) (make-terms , .e. , .c.))
     (macrolet ((collect-term (.e. .c.)							                   (setf .terms. (rest .terms.))))		
		  `(progn (setf (rest .terms.) (make-terms , .e. , .c.))		               (update-term1 (.e. .c.)
			  (setf .terms. (rest .terms.))))				                 `(progn (setf (le .t1.) .e.)
		(update-term1 (.e. .c.)							                   (setf (lc .t1.) .c.)))
		  `(progn (setf (le .t1.) .e.)						               (update-term2 (.e. .c.)
			  (setf (lc .t1.) .c.)))					                 `(progn (setf (le .t2.) .e.)
		(update-term2 (.e. .c.)							                   (setf (lc .t2.) .c.))))
		  `(progn (setf (le .t2.) .e.)						      (setq .terms. .ans-terms.)
			  (setf (lc .t2.) .c.))))					      (loop
       (setq .terms. .ans-terms.)							       (cond ((terms0? .t1.)
       (loop										              (cond ((terms0? .t2.)
	 (cond ((terms0? .t1.)								                     (return (rest .ans-terms.)))
		(cond ((terms0? .t2.)							                    (t (setq ,e2 (le .t2.) ,c2 (lc .t2.) .t2. (red .t2.))
		       (return (rest .ans-terms.)))					                       (setq ,e1 nil))))
		      (t (setq ,e2 (le .t2.) ,c2 (lc .t2.) .t2. (red .t2.))		             ((or (terms0? .t2.) (,order-predicate (le .t1.) (le .t2.)))
			 (setq ,e1 nil))))						              (setq ,e1 (le .t1.) ,c1 (lc .t1.) .t1. (red .t1.))
	       ((or (terms0? .t2.) (,order-predicate (le .t1.) (le .t2.)))		              (setq ,e2 nil))
		(setq ,e1 (le .t1.) ,c1 (lc .t1.) .t1. (red .t1.))			             ((,order-predicate (le .t2.) (le .t1.))
		(setq ,e2 nil))								              (setq ,e2 (le .t2.) ,c2 (lc .t2.) .t2. (red .t2.))
	       ((,order-predicate (le .t2.) (le .t1.))					              (setq ,e1 nil))
		(setq ,e2 (le .t2.) ,c2 (lc .t2.) .t2. (red .t2.))			             (t
		(setq ,e1 nil))								              (setq ,e1 (le .t1.) ,c1 (lc .t1.) .t1. (red .t1.))
	       (t									              (setq ,e2 (le .t2.) ,c2 (lc .t2.) .t2. (red .t2.))))
		(setq ,e1 (le .t1.) ,c1 (lc .t1.) .t1. (red .t1.))			       ,@body))))
		(setq ,e2 (le .t2.) ,c2 (lc .t2.) .t2. (red .t2.))))
	 ,@body))))									;; Simple version for book
											#+ignore
;; Simple version for book								(defmacro accummulate-terms (terms accumulator element-fun &optional (identity (te
#+ignore										  `(let ((answer ,identity))
(defmacro accummulate-terms (terms accumulator element-fun &optional (identity (te	    (map-over-each-term terms (e c)
  `(let ((answer ,identity))								      (setq answer (,accumulator answer (,element-fun e c))))))
     (map-over-each-term terms (e c)
       (setq answer (,accumulator answer (,element-fun e c))))))			(defvar *empty-accumulation-slot* (list nil))

(defvar *empty-accumulation-slot* (list nil))						(defmacro accumulate-terms (terms (accumulator &optional (identity (terms0)))
														    (e c)
(defmacro accumulate-terms (terms (accumulator &optional (identity (terms0)))					    &body element-forms)
			    (e c)							  `(let ((.accum-list. (list *empty-accumulation-slot*))
			    &body element-forms)						 (.accum-fun. ,accumulator))
  `(let ((.accum-list. (list *empty-accumulation-slot*))				    (map-over-each-term ,terms (,e ,c)
	 (.accum-fun. ,accumulator))							      (insert-into-accumulation-list .accum-list. (progn ,@element-forms) .accum-f
     (map-over-each-term ,terms (,e ,c)							    (accumulate-accumulation-list .accum-list. .accum-fun. ,identity)))
      (insert-into-accumulation-list .accum-list. (progn ,@element-forms) .accum-f
     (accumulate-accumulation-list .accum-list. .accum-fun. ,identity)))		(defun insert-into-accumulation-list (l element accumulator)
											  (cond ((eq (car l) *empty-accumulation-slot*)
(defun insert-into-accumulation-list (l element accumulator)					 (setf (car l) element))
  (cond ((eq (car l) *empty-accumulation-slot*)							(t (setq element (%funcall accumulator (car l) element))
	 (setf (car l) element))								   (setf (car l) *empty-accumulation-slot*)
	(t (setq element (%funcall accumulator (car l) element))				   (when (null (cdr l))
	   (setf (car l) *empty-accumulation-slot*)						     (setf (cdr l) (list *empty-accumulation-slot*)))
	   (when (null (cdr l))									   (insert-into-accumulation-list (cdr l) element accumulator)))
	     (setf (cdr l) (list *empty-accumulation-slot*)))				  l)
	   (insert-into-accumulation-list (cdr l) element accumulator)))
  l)											(defun accumulate-accumulation-list (accum-list accumulator identity)
											  (cond ((null accum-list) identity)
(defun accumulate-accumulation-list (accum-list accumulator identity)				((eq (car accum-list) *empty-accumulation-slot*)
  (cond ((null accum-list) identity)								 (accumulate-accumulation-list (cdr accum-list) accumulator identity))
	((eq (car accum-list) *empty-accumulation-slot*)					(t (do ((sum (car accum-list))
	 (accumulate-accumulation-list (cdr accum-list) accumulator identity))				(l (cdr accum-list) (cdr l)))
	(t (do ((sum (car accum-list))								       ((null l) sum)
		(l (cdr accum-list) (cdr l)))							     (unless (eq (car l) *empty-accumulation-slot*)
	       ((null l) sum)									       (setq sum (%funcall accumulator sum (car l))))))))
	     (unless (eq (car l) *empty-accumulation-slot*)
	       (setq sum (%funcall accumulator sum (car l))))))))			;;; ===========================================================================
											;;;				     EXPONENT ARITHMETIC
;;; ===========================================================================		;;; ===========================================================================
;;;				     EXPONENT ARITHMETIC
;;; ===========================================================================		(defmacro e= (x y) `(cl:= ,x ,y))

(defmacro e= (x y) `(cl:= ,x ,y))							(defmacro e> (x y) `(cl:> ,x ,y))

(defmacro e> (x y) `(cl:> ,x ,y))							(defmacro e< (x y) `(cl:< ,x ,y))

(defmacro e< (x y) `(cl:< ,x ,y))							(defmacro e0 () 0)

(defmacro e0 () 0)									(defmacro e0? (x)  `(cl:= (e0) ,x))

(defmacro e0? (x)  `(cl:= (e0) ,x))							(defmacro e1 () 1)

(defmacro e1 () 1)									(defmacro e1? (x)  `(cl:= (e1) ,x))

(defmacro e1? (x)  `(cl:= (e1) ,x))							(defmacro e+ (x y) `(cl:+ ,x ,y))

(defmacro e+ (x y) `(cl:+ ,x ,y))							(defmacro e1+ (x) `(cl:1+ ,x))

(defmacro e1+ (x) `(cl:1+ ,x))								(defmacro e1- (x) `(cl:1- ,x))

(defmacro e1- (x) `(cl:1- ,x))								(defmacro e- (x y) `(cl:- ,x ,y))

(defmacro e- (x y) `(cl:- ,x ,y))							(defmacro e* (x y) `(cl:* ,x ,y))

(defmacro e* (x y) `(cl:* ,x ,y))							(defmacro e/ (x y) `(cl:/ ,x ,y))

(defmacro e/ (x y) `(cl:/ ,x ,y))							(defmacro eminus? (x) `(cl:minusp ,x))

(defmacro eminus? (x) `(cl:minusp ,x))							(defmacro eoddp (x) `(cl:oddp ,x))

(defmacro eoddp (x) `(cl:oddp ,x))							(defmacro eminus (x) `(cl:- ,x))

(defmacro eminus (x) `(cl:- ,x))							(defmacro emax (x y) `(cl:max ,x ,y))

(defmacro emax (x y) `(cl:max ,x ,y))						    (
										    (
										    >	(defgeneric make-polynomial-morphism (domain range &rest pairs)
										    >	  (:documentation
										    >	   "The purpose of this method is unknown."))

;; The pairs are variables in the domain and their values in the range			;; The pairs are variables in the domain and their values in the range
(defmethod make-polynomial-morphism							(defmethod make-polynomial-morphism
       ((domain polynomial-ring) (range polynomial-ring) &rest pairs)			    ((domain polynomial-ring) (range polynomial-ring) &rest pairs)
  (let ((array (make-array (length (ring-variables domain))))				  (let ((array (make-array (length (ring-variables domain))))
	(range-coefficient-domain (coefficient-domain-of range)))				(range-coefficient-domain (coefficient-domain-of range)))
    (loop for (v value) in pairs							    (loop for (v value) in pairs
	  do (setf (aref array (variable-index domain v))					  do (setf (aref array (variable-index domain v))
		   (poly-form value)))									   (poly-form value)))
    (%funcall (if (eql domain range) #'make-automorphism #'make-homomorphism)		    (%funcall (if (eql domain range) #'make-automorphism #'make-homomorphism)
      domain										              domain
      #'(lambda (poly)									              #'(lambda (poly)
	  (bind-domain-context range		;; Because all computations are in	                  (bind-domain-context range ;; Because all computations are in th
	  (labels ((transform (form)							                    (labels ((transform (form)
		     (cond ((poly-coef? form)						                               (cond ((poly-coef? form)
			    (coerce form range-coefficient-domain))			                                      (coerce form range-coefficient-domain))
			   (t (let* ((terms (poly-terms form))				                                     (t (let* ((terms (poly-terms form))
				     (old-e (le terms))					                                               (old-e (le terms))
				     (ans (transform (lc terms)))			                                               (ans (transform (lc terms)))
				     (value (aref array (poly-order-number form)))	                                               (value (aref array (poly-order-numb
				(map-over-each-term (red terms) (e c)			                                          (map-over-each-term (red terms) (e c)
				  (setq ans (poly-plus					                                            (setq ans (poly-plus
					      (poly-times (poly-expt value (e- old	                                                       (poly-times (poly-expt valu
							  ans)				                                                                   ans)
					      (transform c)))				                                                       (transform c)))
				  (setq old-e e))					                                            (setq old-e e))
				(poly-times ans (poly-expt value old-e)))))))		                                          (poly-times ans (poly-expt value old-e))
	    (make-polynomial range (transform (poly-form poly))))))			                      (make-polynomial range (transform (poly-form poly))))))
      range)))										              range)))

(defmethod make-polynomial-morphism							(defmethod make-polynomial-morphism
    ((domain free-module) (range free-module) &rest pairs)				    ((domain free-module) (range free-module) &rest pairs)
  (unless (and (typep (coefficient-domain-of domain) 'polynomial-ring)			  (unless (and (typep (coefficient-domain-of domain) 'polynomial-ring)
	       (typep (coefficient-domain-of range) 'polynomial-ring))				       (typep (coefficient-domain-of range) 'polynomial-ring))
    (error "Don't know how to create a polynomial map from ~S to ~S"			    (error "Don't know how to create a polynomial map from ~S to ~S"
	   domain range))									   domain range))
  (let ((morphism (%apply #'make-polynomial-morphism					  (let ((morphism (%apply #'make-polynomial-morphism
			 (coefficient-domain-of domain)					                          (coefficient-domain-of domain)
			 (coefficient-domain-of range)					                          (coefficient-domain-of range)
			 pairs)))							                          pairs)))
    (%funcall (if (eql domain range) #'make-automorphism #'make-homomorphism)		    (%funcall (if (eql domain range) #'make-automorphism #'make-homomorphism)
      domain										              domain
      #'(lambda (vector)								              #'(lambda (vector)
	  (%apply #'make-element							                  (%apply #'make-element
		  range									                          range
		  (loop with vect = (tuple-value vector)				                          (loop with vect = (tuple-value vector)
			for i below (array-dimension vect 0)				                                for i below (array-dimension vect 0)
			collect (apply-morphism morphism (aref vect i)))))		                                collect (apply-morphism morphism (aref vect i)))))
	     range)))									              range)))

(defmethod print-object ((p mpolynomial) stream)				    |	(defun poly-monomial? (poly)
  (print-mpolynomial-form (domain-of p) (poly-form p) stream))			    |	  (cond ((poly-coef? poly) t)
										    >		((terms0? (red (poly-terms poly)))
										    >		 (poly-monomial? (lc (poly-terms poly))))
										    >		(t nil)))
										    >
										    >	(defgeneric print-mpolynomial-form (domain p stream)
										    >	  (:documentation
										    >	   "The purpose of this method is unknown."))

(defmethod print-mpolynomial-form ((domain multivariate-polynomial-ring)		(defmethod print-mpolynomial-form ((domain multivariate-polynomial-ring)
                                   p stream)						                                   p stream)
  (let* ((coef-domain (coefficient-domain-of domain))					  (let* ((coef-domain (coefficient-domain-of domain))
	 (simple-coefs?										 (simple-coefs?
	  (and (typep coef-domain 'numeric-domain)						  (and (typep coef-domain 'numeric-domain)
	       (not (typep coef-domain 'complex-numbers))))					       (not (typep coef-domain 'complex-numbers))))
	 (complex-num-coefs? (typep coef-domain 'complex-numbers)))				 (complex-num-coefs? (typep coef-domain 'complex-numbers)))
    (labels										    (labels
      ((print-form (form)								      ((print-form (form)
         (if (poly-coef? form)								         (if (poly-coef? form)
           (princ form stream)								           (princ form stream)
           (let ((terms (poly-terms form))						           (let ((terms (poly-terms form))
                 (variable (variable-symbol						                 (variable (variable-symbol
                            domain (poly-order-number form))))				                            domain (poly-order-number form))))
             (let ((c (lc terms)))							             (let ((c (lc terms)))
               (when (and (poly-coef? c) 						               (when (and (poly-coef? c) 
                          (= c (- (one domain))))					                          (= c (- (one domain))))
                 (princ "- " stream)							                 (princ "- " stream)
                 (setq c (- c)))							                 (setq c (- c)))
               (print-term variable (le terms) c))					               (print-term variable (le terms) c))
             (map-over-each-term (red terms) (e c)					             (map-over-each-term (red terms) (e c)
               (if (and (poly-coef? c)							               (if (and (poly-coef? c)
                        (number? c) (real? c) (minus? c))				                        (number? c) (real? c) (minus? c))
                 (progn (princ " - " stream) (setq c (- c)))				                 (progn (princ " - " stream) (setq c (- c)))
                 (princ " + " stream))							                 (princ " + " stream))
               (print-term variable e c)))))						               (print-term variable e c)))))
       (print-term (v e c)								       (print-term (v e c)
         (unless (and (poly-1? c) (not (e0? e)))					         (unless (and (poly-1? c) (not (e0? e)))
           (cond ((or (and simple-coefs? (poly-monomial? c))				           (cond ((or (and simple-coefs? (poly-monomial? c))
		      (and complex-num-coefs? (poly-coef? c)						      (and complex-num-coefs? (poly-coef? c)
			   (or (0? (realpart c)) (0? (imagpart c)))))						   (or (0? (realpart c)) (0? (imagpart c)))))
											                  (print-form c))
                  (print-form c))							                 (t (princ "(" stream)
                 (t (princ "(" stream)							                    (print-form c)
                    (print-form c)							                    (princ ")" stream))))
                    (princ ")" stream))))						         (unless (e0? e)
         (unless (e0? e)								           (and (not (poly-1? c))
           (and (not (poly-1? c))							                (princ " " stream))
                (princ " " stream))							           (display v stream)
           (display v stream)								           (if (not (e1? e))
           (if (not (e1? e))								             #+Genera
             #+Genera									             (format stream "~S" e)
             (format stream "~S" e)							             #-Genera
             #-Genera									             (format stream "^~S" e)))))
             (format stream "^~S" e)))))						      (print-form p))))
      (print-form p))))
										    (
(defun poly-monomial? (poly)							    |	(defmethod print-object ((p mpolynomial) stream)
  (cond ((poly-coef? poly) t)							    |	  (print-mpolynomial-form (domain-of p) (poly-form p) stream))
	((terms0? (red (poly-terms poly)))					    <
	 (poly-monomial? (lc (poly-terms poly))))				    <
	(t nil)))								    <

;;; ===========================================================================		;;; ===========================================================================
;;;				    POLYNOMIAL ARITHMETIC				;;;				    POLYNOMIAL ARITHMETIC
;;; ===========================================================================		;;; ===========================================================================

;; Coercions 										;; Coercions 

(defmethod coerce (elt (domain multivariate-polynomial-ring))				(defmethod coerce (elt (domain multivariate-polynomial-ring))
  (let ((value (coercible? elt (coefficient-domain-of domain))))			  (let ((value (coercible? elt (coefficient-domain-of domain))))
    (cond ((not (null value))								    (cond ((not (null value))
	   (make-polynomial domain value))							   (make-polynomial domain value))
	  (t (call-next-method)))))								  (t (call-next-method)))))

(defmethod coerce								    |	(defmethod coerce ((exp symbol) (domain multivariate-polynomial-ring))
    ((exp (or symbol list)) (domain multivariate-polynomial-ring))		    |	  (coerce (coerce exp *general*) domain))
										    >
										    >	(defmethod coerce ((exp list) (domain multivariate-polynomial-ring))
  (coerce (coerce exp *general*) domain))						  (coerce (coerce exp *general*) domain))

(defmethod coerce ((p mpolynomial) (d general-expressions))				(defmethod coerce ((p mpolynomial) (d general-expressions))
  (let ((domain (domain-of p)))								  (let ((domain (domain-of p)))
    (labels ((transform (form)								    (labels ((transform (form)
	     (if (poly-coef? form)							               (if (poly-coef? form)
		 (coerce form d)							                   (coerce form d)
		 (let ((terms (poly-terms form))					                   (let ((terms (poly-terms form))
		       (variable (variable-symbol					                         (variable (variable-symbol
				  domain (poly-order-number form)))			                                    domain (poly-order-number form)))
		       (sum ()))							                         (sum ()))
		   (map-over-each-term terms (e c)					                     (map-over-each-term terms (e c)
		     (push (cond ((e0? e) (transform c))				                       (push (cond ((e0? e) (transform c))
				 ((poly-1? c)						                                   ((poly-1? c)
				  (if (e1? e) variable					                                    (if (e1? e) variable
				      (make-ge-expt d variable e)))			                                        (make-ge-expt d variable e)))
				 ((e1? e)						                                   ((e1? e)
				  (make-ge-times d					                                    (make-ge-times d
				    (list (transform c) variable)))			                                                   (list (transform c) variable)))
				 (t (make-ge-times d					                                   (t (make-ge-times d
				      (list (transform c)				                                                     (list (transform c)
					    (make-ge-expt d variable e)))))		                                                           (make-ge-expt d variabl
			   sum))							                             sum))
		   (if (null (rest sum))						                     (if (null (rest sum))
		       (first sum)							                         (first sum)
		       (make-ge-plus d (nreverse sum)))))))				                         (make-ge-plus d (nreverse sum)))))))
      (transform (poly-form p)))))							      (transform (poly-form p)))))

(defmethod coerce ((exp general-expression)						(defmethod coerce ((exp general-expression)
		   (domain multivariate-polynomial-ring)) 						   (domain multivariate-polynomial-ring)) 
  (with-slots (variables) domain 							  (with-slots (variables) domain 
    (cond ((member exp variables :test #'ge-equal)					    (cond ((member exp variables :test #'ge-equal)
	   (make-polynomial domain								   (make-polynomial domain
	     (cons (variable-index domain exp)						                            (cons (variable-index domain exp)
		   (make-terms 1 (one (coefficient-domain-of domain))))))		                                  (make-terms 1 (one (coefficient-domain-of domain
	  ((and (ge-atom? exp)									  ((and (ge-atom? exp)
		(let ((var (coercible? exp (coefficient-domain-of domain))))				(let ((var (coercible? exp (coefficient-domain-of domain))))
		  (and var (make-polynomial domain var)))))						  (and var (make-polynomial domain var)))))
	  ((ge-plus? exp)									  ((ge-plus? exp)
	   (let ((sum (zero domain)))								   (let ((sum (zero domain)))
	     (loop for x in (terms-of exp)							     (loop for x in (terms-of exp)
		   do (setq sum (+ sum (coerce x domain))))						   do (setq sum (+ sum (coerce x domain))))
	     sum))										     sum))
	  ((ge-times? exp)									  ((ge-times? exp)
	   (let ((prod (one domain)))								   (let ((prod (one domain)))
	     (loop for x in (terms-of exp)							     (loop for x in (terms-of exp)
		   do (setq prod (* prod (coerce x domain))))						   do (setq prod (* prod (coerce x domain))))
	     prod))										     prod))
	  ((and (ge-expt? exp)									  ((and (ge-expt? exp)
		(integer? (exponent-of exp))								(integer? (exponent-of exp))
		(plus? (exponent-of exp)))								(plus? (exponent-of exp)))
	   (expt (coerce (base-of exp) domain) (exponent-of exp)))				   (expt (coerce (base-of exp) domain) (exponent-of exp)))
	  (t (coerce exp (coefficient-domain-of domain))))))					  (t (coerce exp (coefficient-domain-of domain))))))

(defun poly-simp (variable x)								(defun poly-simp (variable x)
  (cond ((terms0? x)									  (cond ((terms0? x)
	 (zero *coefficient-domain*))								 (zero *coefficient-domain*))
	((atom x)										((atom x)
	 (error "An atom, ~A, was passed to poly-simp, this is a bug" X))			 (error "An atom, ~A, was passed to poly-simp, this is a bug" X))
	((and (e0? (le x))			;just a coefficient				((and (e0? (le x))              ;just a coefficient
	      (terms0? (red x)))		;and no additional terms			      (terms0? (red x)))        ;and no additional terms
	 (lc x))										 (lc x))
	(t (make-poly-form variable x))))							(t (make-poly-form variable x))))

(defun terms-term (terms n)								(defun terms-term (terms n)
  (do ((terms terms (red terms)))							  (do ((terms terms (red terms)))
      ((terms0? terms) (zero *coefficient-domain*))					      ((terms0? terms) (zero *coefficient-domain*))
    (cond ((e= (le terms) n) (return (lc terms)))					    (cond ((e= (le terms) n) (return (lc terms)))
          ((e< (le terms) n)								          ((e< (le terms) n)
           (return (zero *coefficient-domain*))))))					           (return (zero *coefficient-domain*))))))

(defmethod-sd plus ((x mpolynomial) (y mpolynomial))				    |	;;; The term lists are assumed to come from legitimate polynomials, so
  (bind-domain-context domain							    |	;;; none of their coefficients can be zero.  Consequently, make-terms
    (make-polynomial domain (poly-plus (poly-form x) (poly-form y)))))		    |	;;; can be used in some places.
										    >
										    >	(defun terms-plus (x y)			;x and y are term lists
										    >	  (pair-up-terms x (e1 c1) y (e2 c2) e>
										    >	    (if e1 (if e2 (let ((c-sum (poly-plus c1 c2)))
										    >			    (if (not (poly-0? c-sum))
										    >				(collect-term e1 c-sum)))
										    >		       (collect-term e1 c1))
										    >		(collect-term e2 c2))))

(defun poly-plus (x y)									(defun poly-plus (x y)
  (cond ((poly-coef? x)									  (cond ((poly-coef? x)
	 (if (poly-coef? y) (+ x y)								 (if (poly-coef? y) (+ x y)
	     (if (poly-0? x) y									     (if (poly-0? x) y
		 (poly-simp y (terms-plus (make-terms (e0) x)						 (poly-simp y (terms-plus (make-terms (e0) x)
					  (poly-terms y))))))									  (poly-terms y))))))
	((poly-coef? y)										((poly-coef? y)
	 (if (poly-0? y) x									 (if (poly-0? y) x
	     (poly-simp x (terms-plus (make-terms (e0) y) (poly-terms x)))))			     (poly-simp x (terms-plus (make-terms (e0) y) (poly-terms x)))))
	((same-variable? x y)									((same-variable? x y)
	 (poly-simp x (terms-plus (poly-terms y) (poly-terms x))))				 (poly-simp x (terms-plus (poly-terms y) (poly-terms x))))
	((more-main? x y)									((more-main? x y)
	 (poly-simp x (terms-plus (make-terms (e0) y) (poly-terms x))))				 (poly-simp x (terms-plus (make-terms (e0) y) (poly-terms x))))
	(t (poly-simp y (terms-plus (make-terms (e0) x) (poly-terms y))))))			(t (poly-simp y (terms-plus (make-terms (e0) x) (poly-terms y))))))

										    |	(defmethod-sd plus ((x mpolynomial) (y mpolynomial))
;;; The term lists are assumed to come from legitimate polynomials, so		    |	  (bind-domain-context domain
;;; none of their coefficients can be zero.  Consequently, make-terms		    |	    (make-polynomial domain (poly-plus (poly-form x) (poly-form y)))))
;;; can be used in some places.							    <
										    <
(defun terms-plus (x y)			;x and y are term lists			    <
  (pair-up-terms x (e1 c1) y (e2 c2) e>						    <
    (if e1 (if e2 (let ((c-sum (poly-plus c1 c2)))				    <
		    (if (not (poly-0? c-sum))					    <
			(collect-term e1 c-sum)))				    <
	       (collect-term e1 c1))						    <
	(collect-term e2 c2))))							    <
										    <
(defmethod minus ((x mpolynomial))						    <
  (let ((domain (domain-of x)))							    <
    (bind-domain-context (domain-of x)						    <
      (make-polynomial domain (poly-minus (poly-form x))))))			    <

(defun poly-minus (p)									(defun poly-minus (p)
  (cond ((poly-coef? p)									  (cond ((poly-coef? p)
	 (minus p))										 (minus p))
	(t (make-poly-form p (terms-minus (poly-terms p))))))					(t (make-poly-form p (terms-minus (poly-terms p))))))

(defun terms-minus (x)									(defun terms-minus (x)
  (map-over-each-term x (e c)								  (map-over-each-term x (e c)
    (collect-term e (poly-minus c))))							    (collect-term e (poly-minus c))))

(defmethod minus? ((x mpolynomial))						    |	(defmethod minus ((x mpolynomial))
										    >	  (let ((domain (domain-of x)))
  (bind-domain-context (domain-of x)							    (bind-domain-context (domain-of x)
    (poly-minus? (poly-form x))))						    |	      (make-polynomial domain (poly-minus (poly-form x))))))

(defun poly-minus? (p)									(defun poly-minus? (p)
  (if (poly-coef? p) (minus? p)								  (if (poly-coef? p) (minus? p)
      (terms-minus? (poly-terms p))))							      (terms-minus? (poly-terms p))))

(defun terms-minus? (terms)								(defun terms-minus? (terms)
  (poly-minus? (lc terms)))								  (poly-minus? (lc terms)))

(defmethod-sd difference ((x mpolynomial) (y mpolynomial))			    |	(defmethod minus? ((x mpolynomial))
  (bind-domain-context domain							    |	  (bind-domain-context (domain-of x)
    (make-polynomial domain (poly-difference (poly-form x) (poly-form y)))))	    |	    (poly-minus? (poly-form x))))
										    >
										    >	(defun terms-difference (x y)			;x and y are term lists
										    >	  (pair-up-terms x (e1 c1) y (e2 c2) e>
										    >	    (if e1 (if e2 (let ((c-sum (poly-difference c1 c2)))
										    >			    (if (not (poly-0? c-sum))
										    >				(collect-term e1 c-sum)))
										    >		       (collect-term e1 c1))
										    >		(collect-term e2 (poly-minus c2)))))

(defun poly-difference (x y)								(defun poly-difference (x y)
  (cond ((poly-coef? x)									  (cond ((poly-coef? x)
	 (if (poly-coef? y) (- x y)								 (if (poly-coef? y) (- x y)
	     (if (poly-0? x) (poly-minus y)							     (if (poly-0? x) (poly-minus y)
		 (poly-simp y (terms-difference (make-terms (e0) x)					 (poly-simp y (terms-difference (make-terms (e0) x)
						(poly-terms y))))))									(poly-terms y))))))
	((poly-coef? y)										((poly-coef? y)
	 (if (poly-0? y) x									 (if (poly-0? y) x
	     (poly-simp x (terms-difference (poly-terms x)					     (poly-simp x (terms-difference (poly-terms x)
					    (make-terms (e0) y)))))								    (make-terms (e0) y)))))
	((same-variable? x y)									((same-variable? x y)
	 (poly-simp x (terms-difference (poly-terms x) (poly-terms y))))			 (poly-simp x (terms-difference (poly-terms x) (poly-terms y))))
	((more-main? x y)									((more-main? x y)
	 (poly-simp x (terms-difference (poly-terms x) (make-terms (e0) y))))			 (poly-simp x (terms-difference (poly-terms x) (make-terms (e0) y))))
	(t (poly-simp y (terms-difference (make-terms (e0) x)					(t (poly-simp y (terms-difference (make-terms (e0) x)
					  (poly-terms y))))))									  (poly-terms y))))))

(defun terms-difference (x y)			;x and y are term lists		    |	(defmethod-sd difference ((x mpolynomial) (y mpolynomial))
  (pair-up-terms x (e1 c1) y (e2 c2) e>						    <
    (if e1 (if e2 (let ((c-sum (poly-difference c1 c2)))			    <
		    (if (not (poly-0? c-sum))					    <
			(collect-term e1 c-sum)))				    <
	       (collect-term e1 c1))						    <
	(collect-term e2 (poly-minus c2)))))					    <
										    <
(defmethod-sd times ((x mpolynomial) (y mpolynomial))				    <
  (bind-domain-context domain								  (bind-domain-context domain
    (make-polynomial domain (poly-times (poly-form x) (poly-form y))))) 	    |	    (make-polynomial domain (poly-difference (poly-form x) (poly-form y)))))
										    <
(defun poly-times (x y)								    <
  (cond ((poly-coef? x)								    <
	 (if (poly-coef? y) (* x y)						    <
	     (poly-simp y (terms-mon-times (poly-terms y) (e0) x))))		    <
	((poly-coef? y)								    <
	 (poly-simp x (terms-mon-times (poly-terms x) (e0) y)))			    <
	((same-variable? x y)							    <
	 (poly-simp x (terms-times (poly-terms x) (poly-terms y))))		    <
	((more-main? x y)							    <
	 (poly-simp x (terms-mon-times (poly-terms x) (e0) y)))			    <
	(t (poly-simp y (terms-mon-times (poly-terms y) (e0) x)))))		    <

(defun terms-mon-times (poly-terms e c)							(defun terms-mon-times (poly-terms e c)
  (if (poly-0? c) (terms0)								  (if (poly-0? c) (terms0)
      (map-over-each-term poly-terms (te tc)						      (map-over-each-term poly-terms (te tc)
	(collect-term (e+ e te) (poly-times tc c)))))						(collect-term (e+ e te) (poly-times tc c)))))

#+AMBook										#+AMBook
(defun terms-times (x y)								(defun terms-times (x y)
  (accumulate-terms y (#'terms-plus) (e c) (terms-mon-times x e c)))			  (accumulate-terms y (#'terms-plus) (e c) (terms-mon-times x e c)))

(defun terms-times (x y)								(defun terms-times (x y)
  (let (;; Multiply x by the first term of y.  This is the initial		    |	  (let ( ;; Multiply x by the first term of y.  This is the initial
	;; term list we will modify.								;; term list we will modify.
	(answer (terms-mon-times x (le y) (lc y))) 						(answer (terms-mon-times x (le y) (lc y))) 
	e c)											e c)
    (setq answer (cons nil answer))							    (setq answer (cons nil answer))
    (loop for (e-y . c-y) in (red y)							    (loop for (e-y . c-y) in (red y)
	  for ans = answer do									  for ans = answer do
      (loop for (e-x . c-x) in x do							          (loop for (e-x . c-x) in x do
	(unless (poly-0? (setq c (poly-times c-x c-y)))					                (unless (poly-0? (setq c (poly-times c-x c-y)))
	  (setq e (e+ e-x e-y))								                  (setq e (e+ e-x e-y))
	  ;; Find place to insert this term.						                  ;; Find place to insert this term.
	  (loop										                  (loop			
	    ;; Sure would be nice if the complier recognized and optimized		                   ;; Sure would be nice if the complier recognized and optimized
	    ;; the usages of (red ans)							                   ;; the usages of (red ans)
	    (cond ((or (terms0? (red ans)) (e> e (le (red ans))))			                   (cond ((or (terms0? (red ans)) (e> e (le (red ans))))
		   (setf (red ans) (make-terms e c (red ans)))				                          (setf (red ans) (make-terms e c (red ans)))
		   (return t))								                          (return t))	
		  ((e= e (le (red ans)))						                         ((e= e (le (red ans)))
		   (setf (lc (red ans)) (poly-plus (lc (red ans)) c))			                          (setf (lc (red ans)) (poly-plus (lc (red ans)) c))
		   (return t))								                          (return t))
		  (t  (setq ans (red ans))))))))					                         (t  (setq ans (red ans))))))))
    (loop for ans on answer								    (loop for ans on answer
	  do (when (poly-0? (lc (red ans)))							  do (when (poly-0? (lc (red ans)))
	       (setf (red ans) (red (red ans)))))						       (setf (red ans) (red (red ans)))))
    (red answer)))			     						    (red answer)))			     

;;; In both POLY-EXPTSQ and POLY-EXPT the second argument is a			    |	(defun poly-times (x y)
;;; repetition count, and is thus is actually an integer.			    |	  (cond ((poly-coef? x)
										    >		 (if (poly-coef? y) (* x y)
										    >		     (poly-simp y (terms-mon-times (poly-terms y) (e0) x))))
										    >		((poly-coef? y)
										    >		 (poly-simp x (terms-mon-times (poly-terms x) (e0) y)))
										    >		((same-variable? x y)
										    >		 (poly-simp x (terms-times (poly-terms x) (poly-terms y))))
										    >		((more-main? x y)
										    >		 (poly-simp x (terms-mon-times (poly-terms x) (e0) y)))
										    >		(t (poly-simp y (terms-mon-times (poly-terms y) (e0) x)))))

(defmethod expt ((base mpolynomial) (expt integer))				    |	(defmethod-sd times ((x mpolynomial) (y mpolynomial))
  (let ((domain (domain-of base)))						    <
    (bind-domain-context domain								  (bind-domain-context domain
      (make-polynomial domain (poly-expt (poly-form base) expt)))))		    |	    (make-polynomial domain (poly-times (poly-form x) (poly-form y))))) 

(defmethod expt ((base mpolynomial) (expt rational-integer))			    |	;;; In both POLY-EXPTSQ and POLY-EXPT the second argument is a
  ;; Ignoring the domain of expt!!  FIXTHIS					    |	;;; repetition count, and is thus is actually an integer.
  (let ((domain (domain-of base)))						    <
    (bind-domain-context domain							    <
      (make-polynomial domain (poly-expt (poly-form base)			    <
					 (integer-value expt))))))		    <

(defun poly-exptsq (p n)								(defun poly-exptsq (p n)
  (%funcall (repeated-squaring #'poly-times (one *coefficient-domain*))			  (%funcall (repeated-squaring #'poly-times (one *coefficient-domain*))
		p n))									            p n))

(defun poly-expt (p n)									(defun poly-expt (p n)
  (cond ((e0? n) (one *coefficient-domain*))						  (cond ((e0? n) (one *coefficient-domain*))
	((e1? n) p)										((e1? n) p)
	((poly-coef? p) (expt p n))								((poly-coef? p) (expt p n))
	((poly-monomial? p)	 								((poly-monomial? p)	 
	 (let ((c (poly-expt (lc (poly-terms p)) n)))						 (let ((c (poly-expt (lc (poly-terms p)) n)))
	   (if (poly-0? c) c									   (if (poly-0? c) c
	       (poly-simp p (make-terms (e* n (le (poly-terms p))) c)))))			       (poly-simp p (make-terms (e* n (le (poly-terms p))) c)))))
	(t (let ((bl (do ((b (poly-simp p (red (poly-terms p))))				(t (let ((bl (do ((b (poly-simp p (red (poly-terms p))))
			  (bl (list (poly-simp p (red (poly-terms p))))						  (bl (list (poly-simp p (red (poly-terms p))))
			      (cons (poly-times b (car bl)) bl))						      (cons (poly-times b (car bl)) bl))
			  (m 1 (1+ m)))										  (m 1 (1+ m)))
			 ((cl:= m n) bl)))									 ((cl:= m n) bl)))
		 (monomial										 (monomial
		   (make-poly-form p (make-terms (le (poly-terms p))			                  (make-poly-form p (make-terms (le (poly-terms p))
						 (lc (poly-terms p))))))		                                                (lc (poly-terms p))))))
	     (do ((x^m monomial (poly-times x^m monomial))					     (do ((x^m monomial (poly-times x^m monomial))
		  (u (cdr bl) (cdr u))									  (u (cdr bl) (cdr u))
		  (m 1 (1+ m))										  (m 1 (1+ m))
		  (nom n (cl:/ (cl:* nom (cl:- n m)) (1+ m)))						  (nom n (cl:/ (cl:* nom (cl:- n m)) (1+ m)))
		  (answer (car bl)									  (answer (car bl)
			  (poly-plus										  (poly-plus
			   (poly-times										   (poly-times
			    (poly-times (coerce nom *coefficient-domain*) x^m)					    (poly-times (coerce nom *coefficient-domain*) x^m)
			    (car u))										    (car u))
			   answer)))										   answer)))
		 ((null u)										 ((null u)
		  (poly-plus x^m answer)))))))								  (poly-plus x^m answer)))))))

(defmethod-sd quotient ((x mpolynomial) (y mpolynomial))			    |	(defmethod expt ((base mpolynomial) (expt integer))
										    >	  (let ((domain (domain-of base)))
  (bind-domain-context domain								    (bind-domain-context domain
    (make-polynomial domain (poly-quotient (poly-form x) (poly-form y)))))	    |	      (make-polynomial domain (poly-expt (poly-form base) expt)))))
										    <
(defun terms-cquotient (terms c)						    <
  (map-over-each-term terms (te tc)						    <
    (collect-term te (poly-quotient tc c))))					    <

(defun poly-quotient (x y)							    |	(defmethod expt ((base mpolynomial) (expt rational-integer))
  (let ((ans (catch 'quotient-error						    |	  ;; Ignoring the domain of expt!!  FIXTHIS
	       (poly-quotient* x y))))						    |	  (let ((domain (domain-of base)))
    (cond ((stringp ans)							    |	    (bind-domain-context domain
	   (error ans x y))							    |	      (make-polynomial domain (poly-expt (poly-form base)
	  (t ans))))								    |						 (integer-value expt))))))

(defun poly-test-quotient (x y)							    |	(defun terms-quotient (u v)
  (let ((ans (catch 'quotient-error						    |	  (do ((coef)
	       (poly-quotient* x y))))						    |	       (exp)
    (if (stringp ans) nil							    |	       (quotient (terms0)))
	ans)))									    |	      ((e< (le u) (le v))       
										    >	       (throw 'quotient-error
										    >		 "~S is not exactly divisible by ~S"))
										    >	    (setq coef (poly-quotient* (lc u) (lc v)))
										    >	    (setq exp (e- (le u) (le v)))
										    >	    (setq u (terms-difference u (terms-mon-times v exp coef)))
										    >	    (setq quotient (terms-plus (make-terms exp coef) quotient))
										    >	    (if (terms0? u)
										    >		(return quotient))))

(defun poly-quotient* (x y)								(defun poly-quotient* (x y)
  (cond ((poly-0? y)									  (cond ((poly-0? y)
	 (throw 'quotient-error  "~S was divided by zero"))					 (throw 'quotient-error  "~S was divided by zero"))
	((poly-0? x) x)										((poly-0? x) x)
	((poly-coef? x)										((poly-coef? x)
	 (if (poly-coef? y)									 (if (poly-coef? y)
	     (cond ((typep *coefficient-domain* 'field)						     (cond ((typep *coefficient-domain* 'field)
		    (/ x y))										    (/ x y))
		   (t (multiple-value-bind (q r) (truncate x y)						   (t (multiple-value-bind (q r) (truncate x y)
			(if (0? r) q										(if (0? r) q
			    (throw 'quotient-error								    (throw 'quotient-error
			      "Inexact division of ~S by ~S")))))						      "Inexact division of ~S by ~S")))))
	     (throw 'quotient-error								     (throw 'quotient-error
	       "~S was divided by a polynomial of higher degree ~S")))				       "~S was divided by a polynomial of higher degree ~S")))
	((or (poly-coef? y)									((or (poly-coef? y)
	     (more-main? x y))									     (more-main? x y))
	 (make-poly-form x (terms-cquotient (poly-terms x) y)))					 (make-poly-form x (terms-cquotient (poly-terms x) y)))
	((more-main? y x)									((more-main? y x)
	 (throw 'quotient-error									 (throw 'quotient-error
	   "~S was divided by a polynomial of more main variable: ~S"))				   "~S was divided by a polynomial of more main variable: ~S"))
	(t (poly-simp x (terms-quotient (poly-terms x) (poly-terms y))))))			(t (poly-simp x (terms-quotient (poly-terms x) (poly-terms y))))))

(defun terms-quotient (u v)							    |	(defun poly-quotient (x y)
  (do ((coef)									    |	  (let ((ans (catch 'quotient-error
       (exp)									    |		       (poly-quotient* x y))))
       (quotient (terms0)))							    |	    (cond ((stringp ans)
      ((e< (le u) (le v))       						    |		   (error ans x y))
       (throw 'quotient-error							    |		  (t ans))))
	 "~S is not exactly divisible by ~S"))					    <
    (setq coef (poly-quotient* (lc u) (lc v)))					    <
    (setq exp (e- (le u) (le v)))						    <
    (setq u (terms-difference u (terms-mon-times v exp coef)))			    <
    (setq quotient (terms-plus (make-terms exp coef) quotient))			    <
    (if (terms0? u)								    <
	(return quotient))))							    <

(defmethod-sd remainder ((x mpolynomial) (y mpolynomial))			    |	(defun terms-cquotient (terms c)
										    >	  (map-over-each-term terms (te tc)
										    >	    (collect-term te (poly-quotient tc c))))
										    >
										    >	(defmethod-sd quotient ((x mpolynomial) (y mpolynomial))
  (bind-domain-context domain								  (bind-domain-context domain
    (make-polynomial domain							    |	    (make-polynomial domain (poly-quotient (poly-form x) (poly-form y)))))
      (poly-pseudo-remainder (poly-form x) (poly-form y)))))			    |
										    >	(defun poly-test-quotient (x y)
										    >	  (let ((ans (catch 'quotient-error
										    >		       (poly-quotient* x y))))
										    >	    (if (stringp ans) nil
										    >		ans)))
										    >
										    >	(defun terms-pseudo-remainder (u v)
										    >	  (if (e< (le u) (le v)) u
										    >	      (do ((k (e- (le u) (le v)) m)
										    >		   (m))
										    >		  (nil)
										    >		(setq u (terms-difference (terms-mon-times u (e0) (lc v))
										    >					  (terms-mon-times v k (lc u))))
										    >		(cond ((terms0? u) (return u))
										    >		      ((eminus? (setq m (e- (le u) (le v))))
										    >		       (return (if (e0? k) u
										    >				   (terms-mon-times u (e0) (poly-expt (lc v) k))))))
										    >		(if (e> (e- k 1) m)
										    >		    (setq u (terms-mon-times u
										    >					     (e0)
										    >					     (poly-expt (lc v) (e- (e- k 1) m))))))))

(defun poly-pseudo-remainder (p q)							(defun poly-pseudo-remainder (p q)
  (cond ((poly-coef? p)									  (cond ((poly-coef? p)
	 (cond ((poly-coef? q) (remainder p q))							 (cond ((poly-coef? q) (remainder p q))
	       (t p)))										       (t p)))
	((poly-coef? q)										((poly-coef? q)
	 (with-slots (coefficient-domain) p							 (with-slots (coefficient-domain) p
	   (zero coefficient-domain)))								   (zero coefficient-domain)))
	((same-variable? p q)									((same-variable? p q)
	 (poly-simp p (terms-pseudo-remainder (poly-terms p)					 (poly-simp p (terms-pseudo-remainder (poly-terms p)
					      (poly-terms q)))) 								      (poly-terms q)))) 
	((more-main? p q)									((more-main? p q)
	 (poly-simp p (terms-coef-remainder (poly-terms p) q)))					 (poly-simp p (terms-coef-remainder (poly-terms p) q)))
	(t p)))											(t p)))

(defun terms-coef-remainder (u q)							(defun terms-coef-remainder (u q)
  (map-over-each-term u (e c) 								  (map-over-each-term u (e c) 
    (collect-term e (poly-pseudo-remainder c q))))					    (collect-term e (poly-pseudo-remainder c q))))

(defun terms-pseudo-remainder (u v)						    |	(defmethod-sd remainder ((x mpolynomial) (y mpolynomial))
  (if (e< (le u) (le v)) u							    <
      (do ((k (e- (le u) (le v)) m)						    <
	   (m))									    <
	  (nil)									    <
	(setq u (terms-difference (terms-mon-times u (e0) (lc v))		    <
				  (terms-mon-times v k (lc u))))		    <
	(cond ((terms0? u) (return u))						    <
	      ((eminus? (setq m (e- (le u) (le v))))				    <
	       (return (if (e0? k) u						    <
			   (terms-mon-times u (e0) (poly-expt (lc v) k))))))	    <
	(if (e> (e- k 1) m)							    <
	    (setq u (terms-mon-times u						    <
				     (e0)					    <
				     (poly-expt (lc v) (e- (e- k 1) m))))))))	    <
										    <
(defmethod-sd truncate2 ((x mpolynomial) (y mpolynomial))			    <
  (bind-domain-context domain								  (bind-domain-context domain
    (multiple-value-bind (quo rem) (poly-truncate2 (poly-form x) (poly-form y))	    |	    (make-polynomial domain
      (values (make-polynomial domain quo)					    |	      (poly-pseudo-remainder (poly-form x) (poly-form y)))))
	      (make-polynomial domain rem)))))					    <

(defun poly-truncate2 (u v)								(defun poly-truncate2 (u v)
  (cond ((poly-coef? v)									  (cond ((poly-coef? v)
	 (cond ((typep *coefficient-domain* 'field)						 (cond ((typep *coefficient-domain* 'field)
		(values (poly-times u (/ v))								(values (poly-times u (/ v))
			(zero *coefficient-domain*)))								(zero *coefficient-domain*)))
	       (t (error "Not implemented yet"))))						       (t (error "Not implemented yet"))))
	(t (error "not implemented yet"))))							(t (error "not implemented yet"))))

(defmethod height ((x mpolynomial))						    |	(defmethod-sd truncate2 ((x mpolynomial) (y mpolynomial))
  (poly-height (poly-form x)))							    |	  (bind-domain-context domain
										    >	    (multiple-value-bind (quo rem) (poly-truncate2 (poly-form x) (poly-form y))
										    >	      (values (make-polynomial domain quo)
										    >		      (make-polynomial domain rem)))))

(defun poly-height (x)									(defun poly-height (x)
  (if (poly-coef? x) (height x)								  (if (poly-coef? x) (height x)
      (let (h)										      (let (h)
        (map-over-each-term (poly-terms x) (e  c)					        (map-over-each-term (poly-terms x) (e  c)
          (setq h (if h (max h (poly-height c))						          (setq h (if h (max h (poly-height c))
                      (poly-height c))))						                      (poly-height c))))
        h)))										        h)))

										    >	(defmethod height ((x mpolynomial))
										    >	  (poly-height (poly-form x)))
										    >
;; The following routine gives a bound on the absolute value of largest 		;; The following routine gives a bound on the absolute value of largest 
;; coefficient that can occur in a factor involving the main variable (using		;; coefficient that can occur in a factor involving the main variable (using
;; Gelfond's bound).									;; Gelfond's bound).
(defun poly-factor-cbound (p)								(defun poly-factor-cbound (p)
  (if (poly-coef? p) (height p)								  (if (poly-coef? p) (height p)
      (* (expt 2 (le (poly-terms p))) (sqrt (le (poly-terms p)))			      (* (expt 2 (le (poly-terms p))) (sqrt (le (poly-terms p)))
         (poly-height p))))								         (poly-height p))))

(defmethod-sd binary-gcd ((x mpolynomial) (y mpolynomial))			    <
  (bind-domain-context domain							    <
    (make-polynomial domain (poly-gcd (poly-form x) (poly-form y))))) 		    <
										    <
(defvar poly-gcd-algorithm 'poly-subresultant-gcd					(defvar poly-gcd-algorithm 'poly-subresultant-gcd
  "Algorithm to be used to compute the GCD of two polynomials with the			  "Algorithm to be used to compute the GCD of two polynomials with the
   same main variable")									   same main variable")

										    >	(defun terms-content (p)
										    >	  (do ((gcd (lc p) (poly-gcd gcd (lc pp)))
										    >	       (pp (red p) (red pp)))
										    >	      ((terms0? pp)
										    >	       (if (poly-minus? (lc p))
										    >		   (poly-minus gcd)
										    >		   gcd))))
										    >
										    >	(defun poly-content (p)
										    >	  (cond ((poly-coef? p) p)
										    >		(t (terms-content (poly-terms p)))))
										    >
(defun poly-gcd (p q)									(defun poly-gcd (p q)
  (cond ((poly-1? p) p)									  (cond ((poly-1? p) p)
	((poly-1? q) q)										((poly-1? q) q)
	((poly-coef? p)										((poly-coef? p)
	 (cond ((poly-coef? q) (gcd p q))							 (cond ((poly-coef? q) (gcd p q))
	       (t (poly-gcd (poly-content q) p))))						       (t (poly-gcd (poly-content q) p))))
	((poly-coef? q)										((poly-coef? q)
	 (poly-gcd (poly-content p) q))								 (poly-gcd (poly-content p) q))
	((more-main? p q)									((more-main? p q)
	 (poly-gcd (poly-content p) q))								 (poly-gcd (poly-content p) q))
	((more-main? q p)									((more-main? q p)
	 (poly-gcd (poly-content q) p))								 (poly-gcd (poly-content q) p))
	(t (if (e< (le (poly-terms p)) (le (poly-terms q)))					(t (if (e< (le (poly-terms p)) (le (poly-terms q)))
	       (rotatef p q))									       (rotatef p q))
	   (let ((pc (poly-content p))								   (let ((pc (poly-content p))
		 (qc (poly-content q)))									 (qc (poly-content q)))
	     (poly-times (poly-gcd pc qc)							     (poly-times (poly-gcd pc qc)
			 (%funcall poly-gcd-algorithm								 (%funcall poly-gcd-algorithm
				       (poly-quotient p pc)								       (poly-quotient p pc)
				       (poly-quotient q qc)))))))							       (poly-quotient q qc)))))))

										    >	(defmethod-sd binary-gcd ((x mpolynomial) (y mpolynomial))
										    >	  (bind-domain-context domain
										    >	    (make-polynomial domain (poly-gcd (poly-form x) (poly-form y))))) 
										    >
(defun poly-lcm (p q)									(defun poly-lcm (p q)
  (poly-times (poly-quotient p (poly-gcd p q)) q))					  (poly-times (poly-quotient p (poly-gcd p q)) q))

(defun poly-content (p)								    |	(defun poly-split-on-vars 
  (cond ((poly-coef? p) p)							    |	    (poly vars &optional (pvars (reverse (poly-list-of-variables poly))))
	(t (terms-content (poly-terms p)))))					    |	  (let ((polys (list poly)))
										    |	    (unless (or (poly-coef? poly) (subsetp pvars vars)) 
(defun terms-content (p)							    |	      (loop for bad-v in (loop for v in pvars
  (do ((gcd (lc p) (poly-gcd gcd (lc pp)))					    |	                               when (not (member v vars))
       (pp (red p) (red pp)))							    |	                               collect v)
      ((terms0? pp)								    |	            for var = (list bad-v)
       (if (poly-minus? (lc p))							    |	            for new-polys = nil
	   (poly-minus gcd)							    |	            do (loop for p in polys do 
	   gcd))))								    |	                     (loop for deg below (1+ (poly-degree p var))
										    >	                           for coef = (poly-coefficient p var deg)
										    >	                           do (unless (0? coef)
										    >	                                (push coef new-polys))))
										    >	            (setq polys new-polys)))
										    >	    polys))

;; The following routine takes a list of polynomials and returns a list of		;; The following routine takes a list of polynomials and returns a list of
;; polynomials that all involve the same variables.  When computing the GCD		;; polynomials that all involve the same variables.  When computing the GCD
;; of the original polynomials, you only need to compute the GCD of the 		;; of the original polynomials, you only need to compute the GCD of the 
;; polynomials in returned list.							;; polynomials in returned list.
(defun poly-find-common-vars (polys)							(defun poly-find-common-vars (polys)
  (let (pvars vars all-polys)								  (let (pvars vars all-polys)
    (loop for same-vars = t 								    (loop for same-vars = t 
          do 										          do 
          (setq pvars (loop for p in polys						          (setq pvars (loop for p in polys
                            collect (reverse (poly-list-of-variables p))))		                            collect (reverse (poly-list-of-variables p))))
          (setq vars (loop for vs in (rest pvars)					          (setq vars (loop for vs in (rest pvars)
                           with ans = (first pvars)					                           with ans = (first pvars)
                           do (unless (equal ans vs)					                           do (unless (equal ans vs)
                                (setq same-vars nil)					                                (setq same-vars nil)
                                (setq ans (intersection ans vs)))			                                (setq ans (intersection ans vs)))
                           finally (return ans)))					                           finally (return ans)))
          (when same-vars 								          (when same-vars 
            (return t))									            (return t))
          (setq all-polys nil)								          (setq all-polys nil)
          (loop for p in polys								          (loop for p in polys
                for vs in pvars								                for vs in pvars
                do (setq all-polys (nconc all-polys 					                do (setq all-polys (nconc all-polys 
                                          (poly-split-on-vars p vars vs))))		                                          (poly-split-on-vars p vars vs))))
          (setq polys all-polys))							          (setq polys all-polys))
    polys))										    polys))

(defun poly-split-on-vars 							    <
       (poly vars &optional (pvars (reverse (poly-list-of-variables poly))))	    <
  (let ((polys (list poly)))							    <
    (unless (or (poly-coef? poly) (subsetp pvars vars)) 			    <
      (loop for bad-v in (loop for v in pvars					    <
                               when (not (member v vars))			    <
                               collect v)					    <
            for var = (list bad-v)						    <
            for new-polys = nil							    <
            do (loop for p in polys do 						    <
                     (loop for deg below (1+ (poly-degree p var))		    <
                           for coef = (poly-coefficient p var deg)		    <
                           do (unless (0? coef)					    <
                                (push coef new-polys))))			    <
            (setq polys new-polys)))						    <
    polys))									    <
										    <
(defun poly-mgcd (polys)								(defun poly-mgcd (polys)
  (let ((d *coefficient-domain*)							  (let ((d *coefficient-domain*)
        gcd odd-poly even-poly new-polys)						        gcd odd-poly even-poly new-polys)
    (loop 										    (loop 
      (setq odd-poly (first polys))							     (setq odd-poly (first polys))
      (setq even-poly (second polys))							     (setq even-poly (second polys))
      (loop for (op ep) on (poly-find-common-vars polys) by #'cddr			     (loop for (op ep) on (poly-find-common-vars polys) by #'cddr
            do (setq odd-poly (poly-plus odd-poly (poly-times (random-constant d)	           do (setq odd-poly (poly-plus odd-poly (poly-times (random-constant d)
                                                              op)))			                                                             op)))
            (when ep									           (when ep
              (setq even-poly (poly-plus even-poly (poly-times (random-constant d)	             (setq even-poly (poly-plus even-poly (poly-times (random-constant d)
                                                               ep)))))			                                                              ep)))))
      (print "Begin GCD")								     (print "Begin GCD")
      (setq gcd (spmod-gcd1 odd-poly even-poly))					     (setq gcd (spmod-gcd1 odd-poly even-poly))
      (print "Begin Test divides")							     (print "Begin Test divides")
      (setq new-polys nil)								     (setq new-polys nil)
      (loop for p in polys								     (loop for p in polys
            do (unless (poly-test-quotient p gcd)					           do (unless (poly-test-quotient p gcd)
                 (push p new-polys)))							                (push p new-polys)))
      (print new-polys)									     (print new-polys)
      (if (null new-polys)								     (if (null new-polys)
        (return gcd)									         (return gcd)
        (push gcd new-polys)))))							         (push gcd new-polys)))))

;;; The following should ultimately be optimized to use SpGCD.				;;; The following should ultimately be optimized to use SpGCD.
(defun poly-content-and-prim-part (p)							(defun poly-content-and-prim-part (p)
  (let ((content (poly-content p)))							  (let ((content (poly-content p)))
    (values content (poly-quotient p content))))					    (values content (poly-quotient p content))))

(defun poly-prim-part (p)							    <
  (make-poly-form p (terms-prim-part (poly-terms p))))				    <
										    <
(defun terms-prim-part (p)								(defun terms-prim-part (p)
  (if (terms0? p) p									  (if (terms0? p) p
      (terms-cquotient p (terms-content p))))						      (terms-cquotient p (terms-content p))))

(defun poly-monicize (p)							    |	(defun poly-prim-part (p)
  (make-poly-form p (terms-monicize (poly-terms p))))				    |	  (make-poly-form p (terms-prim-part (poly-terms p))))

(defun terms-monicize (terms)								(defun terms-monicize (terms)
  (let ((inv (recip (lc terms))))							  (let ((inv (recip (lc terms))))
    (map-over-each-term terms (e c)							    (map-over-each-term terms (e c)
      (collect-term e (* c inv)))))							      (collect-term e (* c inv)))))

(defun poly-euclidean-gcd (p q)							    |	(defun poly-monicize (p)
  (poly-simp p (terms-euclidean-gcd (poly-terms p) (poly-terms q))))		    |	  (make-poly-form p (terms-monicize (poly-terms p))))

(defun terms-euclidean-gcd (u v)							(defun terms-euclidean-gcd (u v)
  (do ((u u v)										  (do ((u u v)
       (v v (terms-pseudo-remainder u v)))						       (v v (terms-pseudo-remainder u v)))
      ((terms0? v)									      ((terms0? v)
       (terms-prim-part u))								       (terms-prim-part u))
;    (print v)									    |	    ;; (print v)
    (if (e0? (le v)) (return (make-terms (e0) (one *coefficient-domain*))))))		    (if (e0? (le v)) (return (make-terms (e0) (one *coefficient-domain*))))))

(defun poly-primitive-gcd (p q)							    |	(defun poly-euclidean-gcd (p q)
  (poly-simp p (terms-primitive-gcd (poly-terms p) (poly-terms q))))		    |	  (poly-simp p (terms-euclidean-gcd (poly-terms p) (poly-terms q))))

(defun terms-primitive-gcd (u v)							(defun terms-primitive-gcd (u v)
  (do ((u u v)										  (do ((u u v)
       (v v (terms-prim-part (terms-pseudo-remainder u v))))				       (v v (terms-prim-part (terms-pseudo-remainder u v))))
      ((terms0? v)									      ((terms0? v)
       u)										       u)
;    (print v)									    |	    ;; (print v)
    (if (e0? (le v)) (return (make-terms (e0) (one *coefficient-domain*))))))		    (if (e0? (le v)) (return (make-terms (e0) (one *coefficient-domain*))))))

										    >	(defun poly-primitive-gcd (p q)
										    >	  (poly-simp p (terms-primitive-gcd (poly-terms p) (poly-terms q))))
										    >
(defun poly-reduced-gcd (p q)								(defun poly-reduced-gcd (p q)
  (poly-simp p (terms-reduced-gcd (poly-terms p) (poly-terms q))))			  (poly-simp p (terms-reduced-gcd (poly-terms p) (poly-terms q))))

(defun terms-reduced-gcd (u v) 								(defun terms-reduced-gcd (u v) 
  (let ((delta (e- (le u) (le v))))							  (let ((delta (e- (le u) (le v))))
    (do ((u u v)									    (do ((u u v)
	 (v v (terms-cquotient (terms-pseudo-remainder u v) beta))				 (v v (terms-cquotient (terms-pseudo-remainder u v) beta))
	 (beta 1 (poly-expt (lc v) (e1+ delta))))						 (beta 1 (poly-expt (lc v) (e1+ delta))))
      ((terms0? v) (terms-prim-part u))							      ((terms0? v) (terms-prim-part u))
;;      (print v)								    |	      ;;(print v)
      (if (e0? (le v)) (return (make-terms (e0) (one *coefficient-domain*))))		      (if (e0? (le v)) (return (make-terms (e0) (one *coefficient-domain*))))
      (setq delta (e- (le u) (le v))))))						      (setq delta (e- (le u) (le v))))))

(defun poly-subresultant-gcd (p q)							(defun poly-subresultant-gcd (p q)
  (let ((result (terms-subresultant-gcd (poly-terms p) (poly-terms q))))		  (let ((result (terms-subresultant-gcd (poly-terms p) (poly-terms q))))
    (if (e0? (le result))								    (if (e0? (le result))
	(one *coefficient-domain*)								(one *coefficient-domain*)
	(poly-simp p result))))									(poly-simp p result))))

										    >	(defgeneric resultant (polynomial polynomial~ variable)
										    >	  (:documentation
										    >	   "The purpose of this method is unknown."))
										    >
(defmethod resultant ((x mpolynomial) (y mpolynomial) var)				(defmethod resultant ((x mpolynomial) (y mpolynomial) var)
  (let ((domain (domain-of x)) 								  (let ((domain (domain-of x)) 
        pvar one into-varlist out-varlist)						        pvar one into-varlist out-varlist)
    (unless (eql (domain-of y) domain)							    (unless (eql (domain-of y) domain)
      (error "Incompatible domains for resultant"))					      (error "Incompatible domains for resultant"))
    (setq one (one (coefficient-domain-of domain)))					    (setq one (one (coefficient-domain-of domain)))
    (setq pvar (poly-form (coerce var domain)))						    (setq pvar (poly-form (coerce var domain)))
    (setq into-varlist (list (list (poly-order-number pvar)				    (setq into-varlist (list (list (poly-order-number pvar)
                                   (make-poly-form (list '-1) 				                                   (make-poly-form (list '-1) 
                                                   (make-terms (e1) one))))		                                                   (make-terms (e1) one))))
          out-varlist (list (list -1 (make-poly-form pvar				          out-varlist (list (list -1 (make-poly-form pvar
                                                     (make-terms (e1) one)))))		                                                     (make-terms (e1) one)))))
    (bind-domain-context domain								    (bind-domain-context domain
      (make-polynomial domain 								      (make-polynomial domain 
        (poly-subst 									                       (poly-subst 
         (poly-resultant (poly-subst (poly-form x) into-varlist)			                        (poly-resultant (poly-subst (poly-form x) into-varlist)
                         (poly-subst (poly-form y) into-varlist))			                                        (poly-subst (poly-form y) into-varlist))
         out-varlist)))))								                        out-varlist)))))

(defun poly-resultant (p q)								(defun poly-resultant (p q)
  (let ((result (terms-subresultant-gcd (poly-terms p) (poly-terms q))))		  (let ((result (terms-subresultant-gcd (poly-terms p) (poly-terms q))))
    (if (e0? (le result))								    (if (e0? (le result))
	(lc result)										(lc result)
	(zero *coefficient-domain*))))								(zero *coefficient-domain*))))

(defun terms-subresultant-gcd (u v) 							(defun terms-subresultant-gcd (u v) 
  (let ((delta (e- (le u) (le v)))							  (let ((delta (e- (le u) (le v)))
	beta)											beta)
    (do ((u u v)									    (do ((u u v)
	 (v v (terms-cquotient (terms-pseudo-remainder u v) beta))				 (v v (terms-cquotient (terms-pseudo-remainder u v) beta))
	 (first-time t nil)									 (first-time t nil)
	 (h ;; (poly-expt (lc v) (e- (le u) (le v)))						 (h ;; (poly-expt (lc v) (e- (le u) (le v)))
	    ;; (if (e1? delta) (lc v)							          ;; (if (e1? delta) (lc v)
	    ;; 	(poly-quotient (poly-times h (poly-expt (lc v) delta))			          ;; 	(poly-quotient (poly-times h (poly-expt (lc v) delta))
	    ;;		       (poly-expt h delta)))					          ;;		       (poly-expt h delta)))
	   ))										          ))
	((terms0? v)										((terms0? v)
	 (terms-prim-part u))									 (terms-prim-part u))
      (if (e0? (le v))									      (if (e0? (le v))
	  (return v))										  (return v))
      (setq delta (e- (le u) (le v)))							      (setq delta (e- (le u) (le v)))
      (setq beta (if first-time								      (setq beta (if first-time
		     (if (eoddp delta) 1 -1)								     (if (eoddp delta) 1 -1)
		     (if (eoddp delta) 									     (if (eoddp delta) 
			 (poly-times (lc u) (poly-expt h delta))						 (poly-times (lc u) (poly-expt h delta))
			 (poly-times (poly-minus (lc u))							 (poly-times (poly-minus (lc u))
				     (poly-expt h delta)))))								     (poly-expt h delta)))))
      (if first-time									      (if first-time
	  (setq h (poly-expt (lc v) (e- (le u) (le v))))					  (setq h (poly-expt (lc v) (e- (le u) (le v))))
	  (setq h 										  (setq h 
	    (if (e1? delta) (lc v)							                (if (e1? delta) (lc v)
		(poly-quotient (poly-times h (poly-expt (lc v) delta))			                    (poly-quotient (poly-times h (poly-expt (lc v) delta))
			       (poly-expt h delta)))))					                                   (poly-expt h delta)))))
;;      (format t "~& = ~S,  = ~S, V = ~S, h = ~S" beta delta v h)		    |	      ;;      (format t "~& = ~S,  = ~S, V = ~S, h = ~S" beta delta v h)
      )))										      )))

(defun poly-coerce (poly domain)							(defun poly-coerce (poly domain)
  (cond ((poly-coef? poly)								  (cond ((poly-coef? poly)
	 (coerce poly domain))									 (coerce poly domain))
	(t (poly-simp poly (terms-coerce (poly-terms poly) domain)))))				(t (poly-simp poly (terms-coerce (poly-terms poly) domain)))))

(defun terms-coerce (terms domain)							(defun terms-coerce (terms domain)
  (map-over-each-term terms (e c)							  (map-over-each-term terms (e c)
    (collect-term e (poly-coerce c domain))))						    (collect-term e (poly-coerce c domain))))

(defun poly-subst (poly var-value)							(defun poly-subst (poly var-value)
  (let ((temp nil))									  (let ((temp nil))
    (cond ((null var-value)								    (cond ((null var-value)
	   poly)										   poly)
	  ((poly-coef? poly) (coerce poly *coefficient-domain*))				  ((poly-coef? poly) (coerce poly *coefficient-domain*))
	  ((setq temp (second (assoc (poly-order-number poly) var-value				  ((setq temp (second (assoc (poly-order-number poly) var-value
				       :test #'eql)))	   				                                     :test #'eql)))	   
           (terms-horners-rule (poly-terms poly) temp var-value))			           (terms-horners-rule (poly-terms poly) temp var-value))
          (t (terms-horners-rule 							          (t (terms-horners-rule 
              (poly-terms poly) 							              (poly-terms poly) 
              (poly-simp poly (make-terms (e1) (one *coefficient-domain*)))		              (poly-simp poly (make-terms (e1) (one *coefficient-domain*)))
              var-value)								              var-value)
             ;; This assumed that more main variables were not substituted for		             ;; This assumed that more main variables were not substituted for
             #+ignore									             #+ignore
             (poly-simp poly (terms-subst (poly-terms poly) var-value))			             (poly-simp poly (terms-subst (poly-terms poly) var-value))
             ))))									             ))))

(defun terms-subst (terms var-val-pairs)						(defun terms-subst (terms var-val-pairs)
  (let (temp)										  (let (temp)
    (map-over-each-term terms (e c)							    (map-over-each-term terms (e c)
      (unless (poly-0? (setq temp (poly-subst c var-val-pairs)))			      (unless (poly-0? (setq temp (poly-subst c var-val-pairs)))
	(collect-term e temp)))))								(collect-term e temp)))))

(defun terms-horners-rule (terms value &optional var-value)				(defun terms-horners-rule (terms value &optional var-value)
  (let ((old-e (le terms))								  (let ((old-e (le terms))
	(ans (poly-subst (lc terms) var-value)))						(ans (poly-subst (lc terms) var-value)))
    (map-over-each-term (red terms) (e c) 						    (map-over-each-term (red terms) (e c) 
      (setq ans (poly-plus (poly-times (poly-expt value (e- old-e e)) ans)		      (setq ans (poly-plus (poly-times (poly-expt value (e- old-e e)) ans)
			   (poly-subst c var-value)))								   (poly-subst c var-value)))
      (setq old-e e))									      (setq old-e e))
    (poly-times ans (poly-expt value old-e))))						    (poly-times ans (poly-expt value old-e))))

(defmethod substitute (value variable (p mpolynomial) &rest ignore)			(defmethod substitute (value variable (p mpolynomial) &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (substitute (list (coerce value (domain-of p)))					  (substitute (list (coerce value (domain-of p)))
	      (list (coerce variable (domain-of p)))						      (list (coerce variable (domain-of p)))
	      p))										      p))

(defmethod substitute 									(defmethod substitute 
    ((value mpolynomial) (variable mpolynomial) (p mpolynomial) &rest			    ((value mpolynomial) (variable mpolynomial) (p mpolynomial) &rest
     ignore)										     ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (substitute (list value) (list variable) p))						  (substitute (list value) (list variable) p))

(defmethod substitute ((values list) (variables list) (p mpolynomial)			(defmethod substitute ((values list) (variables list) (p mpolynomial)
		       &rest ignore)									       &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (let ((domain (domain-of p))								  (let ((domain (domain-of p))
	(new-domain (domain-of (first values))))						(new-domain (domain-of (first values))))
    (loop for var in variables								    (loop for var in variables
	  unless (eql (domain-of var) domain)							  unless (eql (domain-of var) domain)
	    do (error "Domain of ~S was expected to be ~S" var domain))			          do (error "Domain of ~S was expected to be ~S" var domain))
    (loop for val in values								    (loop for val in values
	  unless (eql (domain-of val) new-domain)						  unless (eql (domain-of val) new-domain)
	    do (error "Domain of ~S was expected to be ~S" val new-domain))		          do (error "Domain of ~S was expected to be ~S" val new-domain))
    (loop for var in (ring-variables domain)						    (loop for var in (ring-variables domain)
	  do (unless (find var variables 							  do (unless (find var variables 
			   :test #'(lambda (a b) 								   :test #'(lambda (a b) 
				     (ge-equal a (variable-symbol domain b)))) 						     (ge-equal a (variable-symbol domain b)))) 
	       (push (coerce var domain) variables)						       (push (coerce var domain) variables)
	       (push (if (coercible? var new-domain)						       (push (if (coercible? var new-domain)
			 (coerce var new-domain)								 (coerce var new-domain)
			 nil)											 nil)
		     values)))										     values)))
    (bind-domain-context new-domain							    (bind-domain-context new-domain
      (make-polynomial new-domain							      (make-polynomial new-domain
	(poly-subst (poly-form p)							                       (poly-subst (poly-form p)
		    (loop for var in variables						                                   (loop for var in variables
			  for val in values						                                         for val in values
			  collect (list (variable-index domain var)			                                         collect (list (variable-index domain var)
					(and val (poly-form val)))))))))		                                                       (and val (poly-form val))))

(defun poly-variable-list (p &optional (varlist ()))					(defun poly-variable-list (p &optional (varlist ()))
    (cond ((poly-coef? p) varlist)							    (cond ((poly-coef? p) varlist)
	  (t (when (not (member (poly-order-number p) varlist))					  (t (when (not (member (poly-order-number p) varlist))
	       (push (poly-order-number p) varlist))						       (push (poly-order-number p) varlist))
	     (do ((terms (poly-terms p) (red terms)))						     (do ((terms (poly-terms p) (red terms)))
		 ((terms0? terms) varlist)								 ((terms0? terms) varlist)
	       (setq varlist (poly-variable-list (lc terms) varlist))))))			       (setq varlist (poly-variable-list (lc terms) varlist))))))

										    >	(defgeneric partial-deriv (polynomial variable)
										    >	  (:documentation
										    >	   "The purpose of this method is unknown."))
										    >
(defmethod partial-deriv ((p mpolynomial) x)						(defmethod partial-deriv ((p mpolynomial) x)
  (error "Don't know how to compute the partial deriv with respect to ~S"		  (error "Don't know how to compute the partial deriv with respect to ~S"
	 x))											 x))

(defmethod partial-deriv ((p mpolynomial) (x symbol))					(defmethod partial-deriv ((p mpolynomial) (x symbol))
  (partial-deriv p (coerce x *general*)))						  (partial-deriv p (coerce x *general*)))

(defmethod partial-deriv ((p mpolynomial) (x general-expression))			(defmethod partial-deriv ((p mpolynomial) (x general-expression))
  (let ((domain (domain-of p)))								  (let ((domain (domain-of p)))
    (with-slots (variables) domain							    (with-slots (variables) domain
      (if (member x variables :test #'ge-equal)						      (if (member x variables :test #'ge-equal)
	  (partial-deriv p (coerce x domain))							  (partial-deriv p (coerce x domain))
	  (call-next-method)))))								  (call-next-method)))))

(defmethod partial-deriv ((p mpolynomial) (x mpolynomial))				(defmethod partial-deriv ((p mpolynomial) (x mpolynomial))
  (let ((domain (domain-of p))								  (let ((domain (domain-of p))
	terms)											terms)
    (cond ((and (eql domain (domain-of x))						    (cond ((and (eql domain (domain-of x))
		(null (red (setq terms (poly-terms (poly-form x)))))					(null (red (setq terms (poly-terms (poly-form x)))))
		(e1? (le terms))									(e1? (le terms))
		(poly-1? (lc terms)))									(poly-1? (lc terms)))
	   (bind-domain-context domain								   (bind-domain-context domain
	     (make-polynomial domain								     (make-polynomial domain
			      (poly-derivative (poly-form p) (poly-form x)))))					      (poly-derivative (poly-form p) (poly-form x)))))
	  (t (error "~S is not a variable in ~S" x domain)))))					  (t (error "~S is not a variable in ~S" x domain)))))

;;; var in the following is expected to be a polynomial of degree one			;;; var in the following is expected to be a polynomial of degree one
;;; with coefficient 1.									;;; with coefficient 1.

(defun poly-derivative (p var)								(defun poly-derivative (p var)
  (cond ((poly-coef? p) (zero *coefficient-domain*))					  (cond ((poly-coef? p) (zero *coefficient-domain*))
	((same-variable? var p)									((same-variable? var p)
	 (poly-simp p (terms-derivative (poly-terms p))))					 (poly-simp p (terms-derivative (poly-terms p))))
	((more-main? var p)									((more-main? var p)
	 (zero *coefficient-domain*))								 (zero *coefficient-domain*))
	(t (poly-simp p (let (dc)								(t (poly-simp p (let (dc)
			  (map-over-each-term (poly-terms p) (e c)						  (map-over-each-term (poly-terms p) (e c)
			    (if (not (poly-0?									    (if (not (poly-0?
				      (setq dc (poly-derivative c var))))						      (setq dc (poly-derivative c var))))
				(collect-term e dc))))))))								(collect-term e dc))))))))

(defun terms-derivative (x)								(defun terms-derivative (x)
  (map-over-each-term x (e c)								  (map-over-each-term x (e c)
    (if (not (e0? e))									    (if (not (e0? e))
	(collect-term (e1- e)									(collect-term (e1- e)
		      (poly-times (coerce e *coefficient-domain*) c)))))				      (poly-times (coerce e *coefficient-domain*) c)))))

(defmethod deriv ((poly mpolynomial) &rest vars)					(defmethod deriv ((poly mpolynomial) &rest vars)
  (let* ((domain (domain-of poly))							  (let* ((domain (domain-of poly))
	 deriv diff)										 deriv diff)
    (bind-domain-context domain								    (bind-domain-context domain
      (loop for var in vars do								      (loop for var in vars do
	(setq var (coerce var *general*))						            (setq var (coerce var *general*))
	(setq deriv (zero domain))							            (setq deriv (zero domain))
	(loop with variables = (list-of-variables poly)					            (loop with variables = (list-of-variables poly)
	      for kernel in variables do						                  for kernel in variables do
	  (when (depends-on? kernel var)						                  (when (depends-on? kernel var)
	    (setq diff (deriv kernel var))						                    (setq diff (deriv kernel var))
	    (loop for new in (different-kernels diff variables) do			                    (loop for new in (different-kernels diff variables) do
	      (add-new-variable domain new))						                          (add-new-variable domain new))
	    (setq deriv									                    (setq deriv
		  (+ deriv (* (partial-deriv poly kernel)				                          (+ deriv (* (partial-deriv poly kernel)
			      (coerce diff domain))))))					                                      (coerce diff domain))))))
	(setq poly deriv)))								            (setq poly deriv)))
    poly))		   								    poly))		   

(defun poly-max-coefficient (p)								(defun poly-max-coefficient (p)
  (unless (poly-coef? p)								  (unless (poly-coef? p)
    (terms-max-coefficient (poly-terms p))))						    (terms-max-coefficient (poly-terms p))))

(defun terms-max-coefficient (terms &optional (max 0))					(defun terms-max-coefficient (terms &optional (max 0))
  (map-over-each-term terms (ignore c)							  (map-over-each-term terms (ignore c)
    (setq max (if (poly-coef? c) (max max (abs c))					    (setq max (if (poly-coef? c) (max max (abs c))
		  (terms-max-coefficient (poly-terms c) max))))						  (terms-max-coefficient (poly-terms c) max))))
  max)											  max)

(defmethod degree								    |	(defgeneric degree (polynomial variable &rest rest)
    ((p mpolynomial) (var (or symbol ge-variable)) &rest ignore)		    |	  (:documentation
										    >	   "The purpose of this method is unknown."))
										    >
										    >	(defmethod degree ((p mpolynomial) (var symbol) &rest ignore)
										    >	  (declare (ignore ignore))
										    >	  (degree p (coerce var (domain-of p))))
										    >
										    >	(defmethod degree ((p mpolynomial) (var ge-variable) &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (degree p (coerce var (domain-of p))))						  (degree p (coerce var (domain-of p))))

(defmethod degree ((p mpolynomial) (x mpolynomial) &rest ignore)			(defmethod degree ((p mpolynomial) (x mpolynomial) &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (let ((domain (domain-of p))								  (let ((domain (domain-of p))
	terms)											terms)
    (cond ((and (eql domain (domain-of x))						    (cond ((and (eql domain (domain-of x))
		(null (red (setq terms (poly-terms (poly-form x)))))					(null (red (setq terms (poly-terms (poly-form x)))))
		(e1? (le terms))									(e1? (le terms))
		(poly-1? (lc terms)))									(poly-1? (lc terms)))
	   (bind-domain-context domain								   (bind-domain-context domain
	     (poly-degree (poly-form p) (poly-form x))))					     (poly-degree (poly-form p) (poly-form x))))
	  (t (error "~S is not a variable in ~S" x domain)))))					  (t (error "~S is not a variable in ~S" x domain)))))

(defun poly-degree (p var)								(defun poly-degree (p var)
  (cond ((poly-coef? p) (e0))								  (cond ((poly-coef? p) (e0))
	((same-variable? var p)									((same-variable? var p)
	 (le (poly-terms p)))									 (le (poly-terms p)))
	((more-main? var p) (e0))								((more-main? var p) (e0))
	(t (do ((l (poly-terms p) (red l))							(t (do ((l (poly-terms p) (red l))
		(e (e0)))										(e (e0)))
	       ((terms0? l) e)									       ((terms0? l) e)
	     (setq e (emax e (poly-degree (lc l) var)))))))					     (setq e (emax e (poly-degree (lc l) var)))))))

;;; The following routine returns a list of pairs (var . degree).			;;; The following routine returns a list of pairs (var . degree).
;;; There should probably be a structure defined called variable			;;; There should probably be a structure defined called variable
;;; information which is actually returned.						;;; information which is actually returned.
(defun poly-degree-vector (p)								(defun poly-degree-vector (p)
  (unless (poly-coef? p) 								  (unless (poly-coef? p) 
    (let ((pdv (list (cons (poly-order-number p) (le (poly-terms p))))))		    (let ((pdv (list (cons (poly-order-number p) (le (poly-terms p))))))
      (terms-degree-vector (poly-terms p) pdv)						      (terms-degree-vector (poly-terms p) pdv)
      (sort pdv #'(lambda (x y)								      (sort pdv #'(lambda (x y)
		    (more-main-order-number? (first x) (first y)))))))					    (more-main-order-number? (first x) (first y)))))))

(defun add-variable-degree (pdv var deg)						(defun add-variable-degree (pdv var deg)
  (loop for var-info in pdv								  (loop for var-info in pdv
	when (eql (car var-info) var)								when (eql (car var-info) var)
	 return (if (cl:> deg (cdr var-info))						        return (if (cl:> deg (cdr var-info))
		    (setf (cdr var-info) deg))						                   (setf (cdr var-info) deg))
	when (more-main-order-number? var (car var-info))					when (more-main-order-number? var (car var-info))
	 return nil									        return nil
	finally (setq pdv (nconc pdv (list (cons var deg)))))					finally (setq pdv (nconc pdv (list (cons var deg)))))
  pdv)											  pdv)

(defun terms-degree-vector (terms pdv)							(defun terms-degree-vector (terms pdv)
  (map-over-each-term terms (ignore c)							  (map-over-each-term terms (ignore c)
    (unless (poly-coef? c)								    (unless (poly-coef? c)
      (setq pdv (add-variable-degree pdv						      (setq pdv (add-variable-degree pdv
				     (poly-order-number c)								     (poly-order-number c)
				     (le (poly-terms c))))								     (le (poly-terms c))))
      (terms-degree-vector (poly-terms c) pdv)))					      (terms-degree-vector (poly-terms c) pdv)))
  pdv)											  pdv)

										    >	(defgeneric list-of-variables (polynomial &optional variables)
										    >	  (:documentation
										    >	   "The purpose of this method is unknown."))
										    >
(defmethod list-of-variables ((x mpolynomial) &optional list-of-variables)		(defmethod list-of-variables ((x mpolynomial) &optional list-of-variables)
  (let ((domain (domain-of x)))								  (let ((domain (domain-of x)))
    (loop for order-number in (poly-list-of-variables (poly-form x))			    (loop for order-number in (poly-list-of-variables (poly-form x))
          do (pushnew (get-variable-name order-number domain)				          do (pushnew (get-variable-name order-number domain)
                      list-of-variables :test #'ge-equal))				                      list-of-variables :test #'ge-equal))
    list-of-variables))									    list-of-variables))

(defun poly-list-of-variables (p &optional list-of-vars)				(defun poly-list-of-variables (p &optional list-of-vars)
  (labels ((terms-list-of-vars (terms)							  (labels ((terms-list-of-vars (terms)
	     (map-over-each-term terms (ignore c)						     (map-over-each-term terms (ignore c)
	       (p-list-of-vars c)))								       (p-list-of-vars c)))
	   (p-list-of-vars (p)									   (p-list-of-vars (p)
	     (cond ((poly-coef? p))								     (cond ((poly-coef? p))
		   (t (pushnew (poly-order-number p) list-of-vars)					   (t (pushnew (poly-order-number p) list-of-vars)
		      (terms-list-of-vars (poly-terms p))))))						      (terms-list-of-vars (poly-terms p))))))
    (p-list-of-vars p)									    (p-list-of-vars p)
    list-of-vars))									    list-of-vars))

(defmethod coefficient								    |	(defgeneric coefficient (polynomial variables &optional exponent)
    ((p mpolynomial) (var (or symbol ge-variable)) &optional (exponent 1))	    |	  (:documentation
										    >	   "The purpose of this method is unknown."))
										    >
										    >	(defmethod coefficient ((p mpolynomial) (var symbol) &optional (exponent 1))
										    >	  (coefficient p (coerce var (domain-of p)) exponent))  
										    >
										    >	(defmethod coefficient ((p mpolynomial) (var ge-variable) &optional (exponent 1))
  (coefficient p (coerce var (domain-of p)) exponent))  				  (coefficient p (coerce var (domain-of p)) exponent))  

(defmethod coefficient									(defmethod coefficient
      ((p mpolynomial) (var mpolynomial) &optional (exponent 1))			    ((p mpolynomial) (var mpolynomial) &optional (exponent 1))
  (let ((domain (domain-of p)))								  (let ((domain (domain-of p)))
    (bind-domain-context domain								    (bind-domain-context domain
      (make-polynomial domain								      (make-polynomial domain
	(cond ((eql domain (domain-of var))						                       (cond ((eql domain (domain-of var))
	       (if (not (poly-coef? (poly-form var)))					                              (if (not (poly-coef? (poly-form var)))
		   (poly-coefficient (poly-form p)					                                  (poly-coefficient (poly-form p)
				     (poly-form var)					                                                    (poly-form var)
				     exponent)						                                                    exponent)
		   (poly-c-coefficient (poly-form p)					                                  (poly-c-coefficient (poly-form p)
				       (poly-form var)					                                                      (poly-form var)
				       exponent)))					                                                      exponent)))
	      (t (poly-c-coefficient (poly-form p) var					                             (t (poly-c-coefficient (poly-form p) var
				     exponent)))))))					                                                    exponent)))))))

(defun poly-coefficient (poly var exp)							(defun poly-coefficient (poly var exp)
  (cond ((poly-coef? poly)								  (cond ((poly-coef? poly)
	 (if (e0? exp) poly (zero *coefficient-domain*)))					 (if (e0? exp) poly (zero *coefficient-domain*)))
	((same-variable? poly var)								((same-variable? poly var)
	 (do ((l (poly-terms poly) (red l)))							 (do ((l (poly-terms poly) (red l)))
	     ((terms0? l) (zero *coefficient-domain*))						     ((terms0? l) (zero *coefficient-domain*))
	   (if (e= (le l) exp)									   (if (e= (le l) exp)
	       (return (lc l)))))								       (return (lc l)))))
	((more-main? var poly)									((more-main? var poly)
	 (if (e0? exp) poly (zero *coefficient-domain*)))					 (if (e0? exp) poly (zero *coefficient-domain*)))
	(t (do ((l (poly-terms poly))								(t (do ((l (poly-terms poly))
		(coef (zero *coefficient-domain*)))							(coef (zero *coefficient-domain*)))
	       ((terms0? l) coef)								       ((terms0? l) coef)
	     (setq coef (poly-plus								     (setq coef (poly-plus
			  (poly-times							                         (poly-times
			   (poly-simp poly						                          (poly-simp poly
				      (make-terms (le l)				                                     (make-terms (le l)
						  (one *coefficient-domain*)))		                                                 (one *coefficient-domain*)))
			   (poly-coefficient (lc l) var exp))				                          (poly-coefficient (lc l) var exp))
			  coef))							                         coef))
	     (setq l (red l))))))								     (setq l (red l))))))

(defun poly-c-coefficient (poly var exp)						(defun poly-c-coefficient (poly var exp)
  (cond ((poly-coef? poly) (coefficient poly var exp))					  (cond ((poly-coef? poly) (coefficient poly var exp))
	(t (do ((l (poly-terms poly))								(t (do ((l (poly-terms poly))
		(coef (zero *coefficient-domain*)))							(coef (zero *coefficient-domain*)))
	       ((terms0? l) coef)								       ((terms0? l) coef)
	     (setq coef (poly-plus								     (setq coef (poly-plus
			  (poly-times							                         (poly-times
			   (poly-simp poly						                          (poly-simp poly
				      (make-terms (le l)				                                     (make-terms (le l)
						  (one *coefficient-domain*)))		                                                 (one *coefficient-domain*)))
			   (poly-c-coefficient (lc l) var exp))				                          (poly-c-coefficient (lc l) var exp))
			  coef))							                         coef))
	     (setq l (red l))))))								     (setq l (red l))))))

(defun poly-leading-coefficient (poly)							(defun poly-leading-coefficient (poly)
  (if (poly-coef? poly) poly								  (if (poly-coef? poly) poly
      (poly-leading-coefficient (lc (poly-terms poly)))))				      (poly-leading-coefficient (lc (poly-terms poly)))))

(defmethod-sd binary= ((x mpolynomial) (y mpolynomial))					(defmethod-sd binary= ((x mpolynomial) (y mpolynomial))
  (bind-domain-context domain								  (bind-domain-context domain
    (poly-0? (poly-difference (poly-form x) (poly-form y)))))				    (poly-0? (poly-difference (poly-form x) (poly-form y)))))

(defmethod-sd binary> ((x mpolynomial) (y mpolynomial))					(defmethod-sd binary> ((x mpolynomial) (y mpolynomial))
  (let ((pf-x (poly-form x))								  (let ((pf-x (poly-form x))
	(pf-y (poly-form y)))									(pf-y (poly-form y)))
    (cond ((and (poly-coef? pf-x) (poly-coef? pf-y))					    (cond ((and (poly-coef? pf-x) (poly-coef? pf-y))
	   (> pf-x pf-y))									   (> pf-x pf-y))
	  (t (call-next-method)))))								  (t (call-next-method)))))

										    >	(defgeneric get-variable-name (order-number domain)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod get-variable-name (order-number (domain variable-hash-table))		(defmethod get-variable-name (order-number (domain variable-hash-table))
  (aref (variable-index-table domain) order-number 0))					  (aref (variable-index-table domain) order-number 0))

(defmethod variable-index ((domain domain) (p mpolynomial))				(defmethod variable-index ((domain domain) (p mpolynomial))
  (poly-order-number (poly-form p)))							  (poly-order-number (poly-form p)))

(defmethod parse-linear-equation ((p mpolynomial) &rest variables)			(defmethod parse-linear-equation ((p mpolynomial) &rest variables)
  (let ((domain (domain-of p)))								  (let ((domain (domain-of p)))
    (bind-domain-context domain								    (bind-domain-context domain
      (loop for var in variables							      (loop for var in variables
	    with poly = (poly-form p)								    with poly = (poly-form p)
	    and coefs										    and coefs
	    unless (eql (domain-of var) domain)							    unless (eql (domain-of var) domain)
	      do (error "~S is not a variable of ~S" var domain)			            do (error "~S is not a variable of ~S" var domain)
	    do (setq var (poly-form var))							    do (setq var (poly-form var))
	       (push (poly-coefficient poly var 1) coefs)				            (push (poly-coefficient poly var 1) coefs)
	       (setq poly (poly-difference poly						            (setq poly (poly-difference poly
					   (poly-times (first coefs) var)))		                                        (poly-times (first coefs) var)))
	    finally (return (values								    finally (return (values
			      (values							                             (values
				(mapcar #'(lambda (c)					                              (mapcar #'(lambda (c)
					    (make-polynomial domain c))			                                          (make-polynomial domain c))
					(reverse coefs)))				                                      (reverse coefs)))
			      (make-polynomial domain poly)))))))			                             (make-polynomial domain poly)))))))
										    (
; This has not been tested well enough.							; This has not been tested well enough.

(in-package "WEYLI")									(in-package "WEYLI")

;; We define a class for representing multipoles here.					;; We define a class for representing multipoles here.
;; We make it a subclass of domain-element,so that we may associate			;; We make it a subclass of domain-element,so that we may associate
;; something in the domain inheritence hierarchy with it later.				;; something in the domain inheritence hierarchy with it later.
;; Maybe powerseries-domain?								;; Maybe powerseries-domain?

;;Also when we want to generalize the transformations					;;Also when we want to generalize the transformations
;;to other interactions , it may be necessarry to inherit mutipole			;;to other interactions , it may be necessarry to inherit mutipole
;;from xyz that inherits from domain-element						;;from xyz that inherits from domain-element

;; Center will be a pair of real numbers (a complex number)&&				;; Center will be a pair of real numbers (a complex number)&&
;; range will be a real number &&							;; range will be a real number &&
;; form will be a list of real numbers.							;; form will be a list of real numbers.

;We will assume that each multipole is 10 terms long					;We will assume that each multipole is 10 terms long

(defvar *number-of-terms* 10)								(defvar *number-of-terms* 10)

;; The domain of multipole expansions.  Multipole expansions are best			;; The domain of multipole expansions.  Multipole expansions are best
;; thought of as functions from one domain into another, but which			;; thought of as functions from one domain into another, but which
;; have a very specific represnetation.  They are a representation of			;; have a very specific represnetation.  They are a representation of
;; a Hilbert space.									;; a Hilbert space.
(defclass multipole-ring (function-space ring has-coefficient-domain)			(defclass multipole-ring (function-space ring has-coefficient-domain)
    ())											    ())

(defmethod print-object ((domain multipole-ring) stream)				(defmethod print-object ((domain multipole-ring) stream)
  (format stream "MultiPole(~S->~S)"							  (format stream "MultiPole(~S->~S)"
	  (funct-domain-of domain) (funct-range-of domain)))					  (funct-domain-of domain) (funct-range-of domain)))

;; The form of a multipole expansion is just a list of coefficients.			;; The form of a multipole expansion is just a list of coefficients.
(defclass multipole-expansion (domain-element) 						(defclass multipole-expansion (domain-element) 
     ((center :initarg :center :reader center-of)					     ((center :initarg :center :reader center-of)
      (range :initarg :range :accessor range-of)					      (range :initarg :range :accessor range-of)
      (form :initarg :form :reader form-of)))						      (form :initarg :form :reader form-of)))

(define-domain-creator multipole-ring ((domain domain) (range domain))			(define-domain-creator multipole-ring ((domain domain) (range domain))
  (let ((domain (make-instance 'multipole-ring :domain domain :range range)))		  (let ((domain (make-instance 'multipole-ring :domain domain :range range)))
    (make-homomorphism coefficient-domain						    (make-homomorphism coefficient-domain
		       #'(lambda (c) (make-multipole-expansion domain 0 c))				       #'(lambda (c) (make-multipole-expansion domain 0 c))
		       domain)										       domain)
    domain))										    domain))

;; This method creates a multipole for a given charge at a given			;; This method creates a multipole for a given charge at a given
;; position. Is it better not to check for being in-bound?				;; position. Is it better not to check for being in-bound?
(defmethod make-multipole-expansion ((domain multipole-ring)				(defmethod make-multipole-expansion ((domain multipole-ring)
				     (position number) &rest coefs)							     (position number) &rest coefs)
  (when (not (in-bound? position))							  (when (not (in-bound? position))
    (error "Point out of range: ~S" position))						    (error "Point out of range: ~S" position))
  (let* ((coef-domain (coefficient-domain-of domain))					  (let* ((coef-domain (coefficient-domain-of domain))
	 (array (make-array *number-of-terms*							 (array (make-array *number-of-terms*
			    :initial-element (zero coef-domain))))						    :initial-element (zero coef-domain))))
    (loop for i fixnum below *number-of-terms*						    (loop for i fixnum below *number-of-terms*
	  for c in coefs									  for c in coefs
	  do (setf (svref array i) (coerce c coef-domain)))					  do (setf (svref array i) (coerce c coef-domain)))
    (make-instance 'multipole-expansion :domain domain					    (make-instance 'multipole-expansion :domain domain
		  :center position									  :center position
		  :range (zero (range-domain-of domain))						  :range (zero (range-domain-of domain))
		  :form array)))									  :form array)))
;; Shifting multipoles									;; Shifting multipoles

(defmethod shift-multipole ((m multipole-expansion) (xy number))			(defmethod shift-multipole ((m multipole-expansion) (xy number))
  (let ((domain (domain-of m))))							  (let ((domain (domain-of m))))
  (make-instance 'multipole :domain 'power-series?					  (make-instance 'multipole :domain 'power-series?
		 :center xy										 :center xy
		 :range (+ (range-of m) (abs xy))							 :range (+ (range-of m) (abs xy))
		 :form (shift-m-form (form-of m) (center-of m)						 :form (shift-m-form (form-of m) (center-of m)
				     (coerce xy (coefficient-domain-of domain)))))					     (coerce xy (coefficient-domain-of domain)))))



;; The work involved will be in								;; The work involved will be in
;; 1) computing the new range.								;; 1) computing the new range.
;; 2) extracting the old form and producing the new one					;; 2) extracting the old form and producing the new one


;;adding two mutipoles									;;adding two mutipoles
(defmethod-sd plus ((m multipole-expansion) (n multipole-expansion))			(defmethod-sd plus ((m multipole-expansion) (n multipole-expansion))
  (when (not (eq (center-of m) (center-of n)))						  (when (not (eq (center-of m) (center-of n)))
    (error "Can't add multipole-expansions with different centers"))			    (error "Can't add multipole-expansions with different centers"))
  (make-instance 'multipole :domain 'power-series?					  (make-instance 'multipole :domain 'power-series?
		 :center (center-of m)									 :center (center-of m)
		 :range (max (range-of m) (range-of n))							 :range (max (range-of m) (range-of n))
		 :form (mpef-pairwise-m-sum (form-of m) (form-of n))))					 :form (mpef-pairwise-m-sum (form-of m) (form-of n))))
;;The work involved will be in								;;The work involved will be in
;; 1)error check to ensure that the centers coincide					;; 1)error check to ensure that the centers coincide
;; 2)computing the new form								;; 2)computing the new form
;; 3)choosing the greater of the two ranges						;; 3)choosing the greater of the two ranges
;; 4)fixing the center									;; 4)fixing the center




;;We now define a class called local-field.						;;We now define a class called local-field.
;;This is a representation of the local field.						;;This is a representation of the local field.
;;Again what would the domain be? We may want it to be					;;Again what would the domain be? We may want it to be
;;powerseries or something else (We might want mutipole expansions			;;powerseries or something else (We might want mutipole expansions
;;and local expansions to be in different domains)					;;and local expansions to be in different domains)

(defclass local-field (domain-element)							(defclass local-field (domain-element)
     ((center :initarg :center :reader center-of)					     ((center :initarg :center :reader center-of)
      (range :initarg :range :reader range-of)						      (range :initarg :range :reader range-of)
      (form :initarg :form :reader form-of)))						      (form :initarg :form :reader form-of)))

;shifting local fields									;shifting local fields
(defmethod shift-local-field ((l local-field) (posn number))				(defmethod shift-local-field ((l local-field) (posn number))
  (when (> (abs (- posn (center-of l)))							  (when (> (abs (- posn (center-of l)))
	   (range-of l))									   (range-of l))
    (error "Can't make this shift"))							    (error "Can't make this shift"))
  (make-instance 'local-field :domain 'power-series?					  (make-instance 'local-field :domain 'power-series?
		 :center posn										 :center posn
		 :range (- (range-of l) (abs (- posn (center-of l))))					 :range (- (range-of l) (abs (- posn (center-of l))))
		 :form (shift-l-form (form-of l) (center-of l) posn)))					 :form (shift-l-form (form-of l) (center-of l) posn)))

;the work involved will be in								;the work involved will be in
;;1)making sure that the position is within the local field (error check)		;;1)making sure that the position is within the local field (error check)
;;2)computing the new center (easy) and the new range					;;2)computing the new center (easy) and the new range
;;3)computing the new form (hard)							;;3)computing the new form (hard)

;adding local fields									;adding local fields
(defmethod plus ((l1 local-field)(l2 local-field))					(defmethod plus ((l1 local-field)(l2 local-field))
  (cond ((neq (center-of l1) (center-of l2)) nil)					  (cond ((neq (center-of l1) (center-of l2)) nil)
	(t (make-instance 'local-field :domain 'power-series?					(t (make-instance 'local-field :domain 'power-series?
			  :center (center-of l1)								  :center (center-of l1)
			  :range (min (range-of l1) (range-of l2))						  :range (min (range-of l1) (range-of l2))
			  :form (mpef-pairwise-m-sum (form-of l1) (form-of l2)))))				  :form (mpef-pairwise-m-sum (form-of l1) (form-of l2)))))

;;the work involved will be in								;;the work involved will be in
;;1)making sure that the centers coincide(error check)					;;1)making sure that the centers coincide(error check)
;;2)computing the new center (easy) and the new range (easy)				;;2)computing the new center (easy) and the new range (easy)
;;3)computing the new form								;;3)computing the new form

;this is the key method that localizes a multipole					;this is the key method that localizes a multipole

(defmethod localize ((m multipole) (posn number))					(defmethod localize ((m multipole) (posn number))
  (when (< (dist posn (center-of m)) (* (coerce 2 r) (range-of m)))			  (when (< (dist posn (center-of m)) (* (coerce 2 r) (range-of m)))
    (error "Some problem in localize"))							    (error "Some problem in localize"))
  (make-instance 'local-field :domain 'power-series?					  (make-instance 'local-field :domain 'power-series?
		 :center posn										 :center posn
		 :range (range-of m)									 :range (range-of m)
		 :form (localize-form (form-of m) (center-of m) posn)))					 :form (localize-form (form-of m) (center-of m) posn)))

;;the work involved will be in								;;the work involved will be in
;;1)Checking that the posn is sufficiently away from the multipole			;;1)Checking that the posn is sufficiently away from the multipole
;;2)Computing the range									;;2)Computing the range
;;3)Computing the new form(very hard)							;;3)Computing the new form(very hard)

;; IN-BOUND? checks that the number lies within the vertical strip			;; IN-BOUND? checks that the number lies within the vertical strip
;; bounded by Re = 0 and Re = 1								;; bounded by Re = 0 and Re = 1
(defmethod in-bound? ((position complex-number))					(defmethod in-bound? ((position complex-number))
  (and (< 0 (cn-realpart position) 1)							  (and (< 0 (cn-realpart position) 1)
       (< 0 (cn-imagpart position) 1)))							       (< 0 (cn-imagpart position) 1)))

(defmethod in-bound? ((position floating-point-number))					(defmethod in-bound? ((position floating-point-number))
  (< 0 (fp-value position) 1))								  (< 0 (fp-value position) 1))

(defmethod in-bound? ((position rational-integer))					(defmethod in-bound? ((position rational-integer))
  (< 0 (integer-value position) 1))							  (< 0 (integer-value position) 1))


;The param order may be confusing.The kth term is ak.(a1,a2...)				;The param order may be confusing.The kth term is ak.(a1,a2...)

(defmethod the-kthterm (form k)								(defmethod the-kthterm (form k)
  (or (nth (- k 1) form) (zero *coefficient-domain*)))					  (or (nth (- k 1) form) (zero *coefficient-domain*)))

;(a0,a1,a2...)										;(a0,a1,a2...)
(defmethod kthterm (form  k)								(defmethod kthterm (form  k)
  (let ((result (nth k form)))								  (let ((result (nth k form)))
       (if (eq result nil) (coerce 0 c)							       (if (eq result nil) (coerce 0 c)
	   result)))										   result)))

;shift from center z1 to z2								;shift from center z1 to z2

(defun shift-m-form (form z1 z2)							(defun shift-m-form (form z1 z2)
  (shift-m-form* form (difference z1 z2)))						  (shift-m-form* form (difference z1 z2)))


(defun shift-m-form* (form z0)								(defun shift-m-form* (form z0)
  (do ((result nil) (l 1))								  (do ((result nil) (l 1))
      ((eq l *number-of-terms*) result)							      ((eq l *number-of-terms*) result)
    (setf result (append result (list (what-is-the-lthterm form z0 l))))		    (setf result (append result (list (what-is-the-lthterm form z0 l))))
    (setf l (+ l 1))))									    (setf l (+ l 1))))

(defun what-is-the-lthterm (form z0 l)							(defun what-is-the-lthterm (form z0 l)
  (do ((result (coerce 0 r))								  (do ((result (coerce 0 r))
       (k 1))										       (k 1))
      ((= k (+ l 1))  result)								      ((= k (+ l 1))  result)
    (setf result (+ result (* (the-kthterm form k)					    (setf result (+ result (* (the-kthterm form k)
			      (expt z0 (- l k))									      (expt z0 (- l k))
			      (combinations (- l 1) (- k 1)))))							      (combinations (- l 1) (- k 1)))))
    (setf k (+ k 1))))									    (setf k (+ k 1))))

(defun dist (cn1  cn2)									(defun dist (cn1  cn2)
  (abs (- cn1 cn2)))									  (abs (- cn1 cn2)))

;; I use mpef- as the prefix before functions that work with multipole			;; I use mpef- as the prefix before functions that work with multipole
;; expansion forms.									;; expansion forms.


(defun mpef-pairwise-m-sum (f1 f2)							(defun mpef-pairwise-m-sum (f1 f2)
  (cond ((null f1) f2)									  (cond ((null f1) f2)
	((null f2) nil)										((null f2) nil)
	(t (cons (+ (first f1) (first f2))							(t (cons (+ (first f1) (first f2))
		 (mpef-pairwise-m-sum (rest f1) (rest f2))))))						 (mpef-pairwise-m-sum (rest f1) (rest f2))))))

;shift from center z1 to center z2							;shift from center z1 to center z2

(defun shift-l-form (form z1  z2 )							(defun shift-l-form (form z1  z2 )
  (shift-l-form* form (- z1 z2)))							  (shift-l-form* form (- z1 z2)))

(defun shift-l-form* (form z0)								(defun shift-l-form* (form z0)
  (let ((result nil))									  (let ((result nil))
    (dotimes (l *number-of-terms* result)						    (dotimes (l *number-of-terms* result)
      (setf result (append result (list (what-is-the-lthterm2 form z0 l)))))))		      (setf result (append result (list (what-is-the-lthterm2 form z0 l)))))))

(defun what-is-the-lthterm2 (form z0)							(defun what-is-the-lthterm2 (form z0)
  (do ((result (coerce 0 c)) (k l))							  (do ((result (coerce 0 c)) (k l))
      ((= k *number-of-terms*) result)							      ((= k *number-of-terms*) result)
    (setf result (+ result (* (the-kthterm form (+ k 1))				    (setf result (+ result (* (the-kthterm form (+ k 1))
			      (expt (minus z0) (- k l))								      (expt (minus z0) (- k l))
			      (combinations k l))))								      (combinations k l))))
    (setf k (+ k 1)))) 									    (setf k (+ k 1)))) 

(defun localize-form (form z1  z2 )							(defun localize-form (form z1  z2 )
  (localize-form* form (- z1 z2)))							  (localize-form* form (- z1 z2)))

(defun localize-form* (form z0 ) 							(defun localize-form* (form z0 ) 
  (cons (do ((result (coerce 0 c)) (k 1))						  (cons (do ((result (coerce 0 c)) (k 1))
	    ((= k *number-of-terms*) result)							    ((= k *number-of-terms*) result)
	  (setf result (+ result (* (the-kthterm form k)					  (setf result (+ result (* (the-kthterm form k)
				    (expt (/ (- z0)) k))))								    (expt (/ (- z0)) k))))
          (setf k (+ k 1)))              						          (setf k (+ k 1)))              
	(rest-of-local form z0)))								(rest-of-local form z0)))

(defun rest-of-local (form z0 )								(defun rest-of-local (form z0 )
  (do ((l 1)(result nil))								  (do ((l 1)(result nil))
      ((= l (- *number-of-terms* 1)) result) ;;;ha ha ha ha				      ((= l (- *number-of-terms* 1)) result) ;;;ha ha ha ha
    (setf result (append result (list (lth-local-term form z0 l))))			    (setf result (append result (list (lth-local-term form z0 l))))
    (setf l (+ l 1))))									    (setf l (+ l 1))))

(defun lth-local-term (form z0  l)							(defun lth-local-term (form z0  l)
  (do ((result (coerce 0 c)) (k 1))							  (do ((result (coerce 0 c)) (k 1))
      ((= k *number-of-terms*) result)							      ((= k *number-of-terms*) result)
    (setf result (+ result (* (the-kthterm form k )					    (setf result (+ result (* (the-kthterm form k )
			      (expt (recip (- z0)) (+ k l))							      (expt (recip (- z0)) (+ k l))
			      (combinations (+ l (- k 1)) (- k 1)))))   					      (combinations (+ l (- k 1)) (- k 1)))))   
    (setf k (+ k 1))))									    (setf k (+ k 1))))














Files ../simlab/weyl/src/multipole.lisp and ../weyl/multipole.lisp are identical
;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-		;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-
;;; ===========================================================================		;;; ===========================================================================
;;;			  Algebraic Domains						;;;			  Algebraic Domains
;;; ===========================================================================		;;; ===========================================================================
;;; (c) Copyright 1994 Cornell University						;;; (c) Copyright 1994 Cornell University
;;; new-domains.lisp,v 1.2 1995/05/24 17:42:06 rz Exp					;;; new-domains.lisp,v 1.2 1995/05/24 17:42:06 rz Exp

;;; NB: initialization code moved to seperate file new-domains-init.lisp.		;;; NB: initialization code moved to seperate file new-domains-init.lisp.
;;; This allows seperate compilation of files.						;;; This allows seperate compilation of files.

(in-package "USER")									(in-package "USER")

(defconstant *math-operator-properties*							(defconstant *math-operator-properties*
    '(identity unary-inverse binary-inverse))						    '(identity unary-inverse binary-inverse))

;;; Operators										;;; Operators
(defclass math-operator ()								(defclass math-operator ()
     ((name :initarg :name :accessor name-of)						     ((name :initarg :name :accessor name-of)
      (nargs :initarg :nargs :accessor nargs-of)					      (nargs :initarg :nargs :accessor nargs-of)
      (identity :initarg :identity :accessor %identity-of)				      (identity :initarg :identity :accessor %identity-of)
      (unary-inverse :initarg :unary-inverse :accessor %unary-inverse-of)		      (unary-inverse :initarg :unary-inverse :accessor %unary-inverse-of)
      (binary-inverse :initarg :binary-inverse :accessor %binary-inverse-of)))		      (binary-inverse :initarg :binary-inverse :accessor %binary-inverse-of)))

(defmethod print-object ((op math-operator) stream)					(defmethod print-object ((op math-operator) stream)
  (format stream "#<Op: ~A (~D)>" (name-of op) (nargs-of op)))				  (format stream "#<Op: ~A (~D)>" (name-of op) (nargs-of op)))

(defvar *math-operators* (make-hash-table)						(defvar *math-operators* (make-hash-table)
  "Table of all know mathematical operators")						  "Table of all know mathematical operators")

(defmacro math-operator (name)								(defmacro math-operator (name)
  `(gethash ,name *math-operators*))							  `(gethash ,name *math-operators*))

(defmacro define-math-operator-accessors ()						(defmacro define-math-operator-accessors ()
  (flet ((internal-name (op)								  (flet ((internal-name (op)
	   (intern (format nil "%~A-OF" op)))							   (intern (format nil "%~A-OF" op)))
	 (external-name (op)									 (external-name (op)
	   (intern (format nil "~A-OF" op))))							   (intern (format nil "~A-OF" op))))
    `(progn										    `(progn
       ,@(loop for op in *math-operator-properties*					       ,@(loop for op in *math-operator-properties*
	       append										       append
	       `((defmacro ,(external-name op) (obj)						       `((defmacro ,(external-name op) (obj)
		   `(name-of (,',(internal-name op) ,obj)))						   `(name-of (,',(internal-name op) ,obj)))
		 (defmethod ,(internal-name op) ((obj symbol))						 (defmethod ,(internal-name op) ((obj symbol))
		   (when (setq obj (math-operator obj))							   (when (setq obj (math-operator obj))
		     (,(internal-name op) obj))))))))							     (,(internal-name op) obj))))))))

(define-math-operator-accessors)							(define-math-operator-accessors)
												

(defmacro define-math-operator (name (nargs) &rest properties)				(defmacro define-math-operator (name (nargs) &rest properties)
  `(let ((operator (make-instance 'math-operator :name ',name :nargs ,nargs))		  `(let ((operator (make-instance 'math-operator :name ',name :nargs ,nargs))
	 temp1 temp2)										 temp1 temp2)

     ,@(loop for op in *math-operator-properties*					     ,@(loop for op in *math-operator-properties*
	     collect										     collect
	     `(when (setq temp1 ',(getf properties						     `(when (setq temp1 ',(getf properties
					(intern (symbol-name op) "KEYWORD")))							(intern (symbol-name op) "KEYWORD")))
		 (unless (setq temp2 (math-operator temp1))						 (unless (setq temp2 (math-operator temp1))
		   (error "The ~S operator must be defined before it is used."				   (error "The ~S operator must be defined before it is used."
			  temp1))										  temp1))
		 (setf (,(intern (format nil "%~A-OF" op)) operator) temp2)))				 (setf (,(intern (format nil "%~A-OF" op)) operator) temp2)))

     (setf (math-operator ',name) operator)						     (setf (math-operator ',name) operator)
     ',name))										     ',name))


;; The PRETTY-NAME slot of a domain will be used by the print-object			;; The PRETTY-NAME slot of a domain will be used by the print-object
;; method.  The CREATOR and CREATOR-ARGS slots of a domain are used			;; method.  The CREATOR and CREATOR-ARGS slots of a domain are used
;; when the domain is creator from other domains.  There is no				;; when the domain is creator from other domains.  There is no
;; overwhelming reason why these should have been split into two			;; overwhelming reason why these should have been split into two
;; slots, but I suspect that we may want to do some optimizations on			;; slots, but I suspect that we may want to do some optimizations on
;; the CREATOR slot at some point in the future.					;; the CREATOR slot at some point in the future.

; For testing purposes, remove dependence on anything in WEYL.				; For testing purposes, remove dependence on anything in WEYL.
;(defclass domain (weyli::has-property-list)						;(defclass domain (weyli::has-property-list)

(defclass domain ()									(defclass domain ()
     ((pretty-name :initform nil							     ((pretty-name :initform nil
		   :initarg :pretty-name								   :initarg :pretty-name
		   :accessor pretty-name-of)								   :accessor pretty-name-of)
      (creator :initform :primitive							      (creator :initform :primitive
	       :initarg :creator								       :initarg :creator
	       :accessor creator-of)								       :accessor creator-of)
      (creator-args :initform nil							      (creator-args :initform nil
		    :initarg :creator-args								    :initarg :creator-args
		    :accessor creator-args-of)))							    :accessor creator-args-of)))

(defmethod print-object ((obj domain) stream)						(defmethod print-object ((obj domain) stream)
  (if (pretty-name-of obj)								  (if (pretty-name-of obj)
      (princ (pretty-name-of obj) stream)						      (princ (pretty-name-of obj) stream)
      (format stream "#<Domain ~A>" (creator-of obj))))					      (format stream "#<Domain ~A>" (creator-of obj))))

										    >	;;; FIXME : This is an alternate definition from that in
										    >	;;; domain-support.lisp.
(defmacro define-domain-creator (name (domain . args) &body body)			(defmacro define-domain-creator (name (domain . args) &body body)
  (let ((create-function (intern (format nil "MAKE-~A" name)))				  (let ((create-function (intern (format nil "MAKE-~A" name)))
	(predicate (intern (format nil "~A?" name)))						(predicate (intern (format nil "~A?" name)))
	arguments)										arguments)
    (loop for arg in args								    (loop for arg in args
	  do (cond ((member arg '(&optional &key)))						  do (cond ((member arg '(&optional &key)))
		   ((atom arg) (push arg arguments))							   ((atom arg) (push arg arguments))
		   (t (push (first arg) arguments))))							   (t (push (first arg) arguments))))
    (setq arguments (nreverse arguments))						    (setq arguments (nreverse arguments))
     											     
    `(progn										    `(progn
       (defun ,create-function ,args							       (defun ,create-function ,args
         (let ((,domain									         (let ((,domain
		  (make-instance 'domain								  (make-instance 'domain
		     :creator ',name									     :creator ',name
		     :creator-args (list ,@arguments))))						     :creator-args (list ,@arguments))))
	   ,@body										   ,@body
	   ,domain))										   ,domain))
       (defun ,predicate (domain)							       (defun ,predicate (domain)
	 (eql (creator-of domain) ',name))							 (eql (creator-of domain) ',name))
       ',name)))									       ',name)))


(define-domain-creator rational-integers (domain)					(define-domain-creator rational-integers (domain)
  (setf (pretty-name-of domain) "Z"))							  (setf (pretty-name-of domain) "Z"))





;; This is the basic table of all properties of domains.  It is				;; This is the basic table of all properties of domains.  It is
;; indexed by property name.  (It could be made into a simple array,			;; indexed by property name.  (It could be made into a simple array,
;; but a hash table gives us a bit more flexibility now.)				;; but a hash table gives us a bit more flexibility now.)
(defvar *domain-property-table* (make-hash-table))					(defvar *domain-property-table* (make-hash-table))

(defun compare-pterm-lists (term1 term2)						(defun compare-pterm-lists (term1 term2)
  (loop for a in term1									  (loop for a in term1
	for b in term2										for b in term2
	do (unless (eql a b)  ;; FIXTHIS: This predicate may need to be improved!		do (unless (eql a b)  ;; FIXTHIS: This predicate may need to be improved!
	     (return nil))									     (return nil))
	finally (return t)))									finally (return t)))

(defun assert-property (property terms)							(defun assert-property (property terms)
  (let ((table (gethash property *domain-property-table*)))				  (let ((table (gethash property *domain-property-table*)))
    (loop for prop in table								    (loop for prop in table
	  do (when (compare-pterm-lists prop terms)						  do (when (compare-pterm-lists prop terms)
	       (return t))									       (return t))
	     finally (setf (gethash property *domain-property-table*)				     finally (setf (gethash property *domain-property-table*)
			   (cons terms table)))))								   (cons terms table)))))

(defun test-property (property terms)							(defun test-property (property terms)
  (let ((table (gethash property *domain-property-table*)))				  (let ((table (gethash property *domain-property-table*)))
    (loop for prop in table								    (loop for prop in table
	  do (when (compare-pterm-lists prop terms)						  do (when (compare-pterm-lists prop terms)
	       (return prop)))))								       (return prop)))))

;; This version of delete expects an exact match before deleteing a			;; This version of delete expects an exact match before deleteing a
;; property.  This is probably OK, buts its worth thinking about.			;; property.  This is probably OK, buts its worth thinking about.
(defun delete-property (property terms)							(defun delete-property (property terms)
  (setf (gethash property *domain-property-table*)					  (setf (gethash property *domain-property-table*)
	(delete terms (gethash property *domain-property-table*))))				(delete terms (gethash property *domain-property-table*))))

;; The function will be passed two arguments, the name of the property			;; The function will be passed two arguments, the name of the property
;; and the list terms of the property.							;; and the list terms of the property.
(defmethod %map-over-properties ((domain domain) function)				(defmethod %map-over-properties ((domain domain) function)
  (maphash #'(lambda (key value)							  (maphash #'(lambda (key value)
	       (loop for term in value								       (loop for term in value
		     do (when (eql (car term) domain)							     do (when (eql (car term) domain)
			  (funcall function key term)								  (funcall function key term)
			  (return t))))										  (return t))))
	   *domain-property-table*))								   *domain-property-table*))

(defmacro map-over-properties (domain (property terms) &body body)			(defmacro map-over-properties (domain (property terms) &body body)
  `(%map-over-properties ,domain #'(lambda (,property ,terms) ,@body)))			  `(%map-over-properties ,domain #'(lambda (,property ,terms) ,@body)))

(defmethod show-properties								(defmethod show-properties
    ((domain domain) &optional (stream *standard-output*))				    ((domain domain) &optional (stream *standard-output*))
  (map-over-properties domain (prop val)						  (map-over-properties domain (prop val)
      (print (list prop '= val) stream)))						      (print (list prop '= val) stream)))

;; NEEDS FIXING:									;; NEEDS FIXING:
;; Bad idea to destructively modify a data structure while 				;; Bad idea to destructively modify a data structure while 
;; mapping over it.									;; mapping over it.
(defmethod delete-domain ((domain domain))						(defmethod delete-domain ((domain domain))
  (map-over-properties domain (property terms)						  (map-over-properties domain (property terms)
    (delete-property property terms)))							    (delete-property property terms)))

(defvar *math-properties* nil)								(defvar *math-properties* nil)
(defvar *primitive-properties* nil)							(defvar *primitive-properties* nil)

(defmacro define-primitive-property (property-name args)				(defmacro define-primitive-property (property-name args)
  (when (member property-name *math-properties*)					  (when (member property-name *math-properties*)
    (error "~A has already been used as a non-primitive property!"			    (error "~A has already been used as a non-primitive property!"
	   property-name))									   property-name))
  (let ((assert-function-name (intern (format nil "~A!" property-name)))		  (let ((assert-function-name (intern (format nil "~A!" property-name)))
	(predicate-function-name (intern (format nil "~A?" property-name)))			(predicate-function-name (intern (format nil "~A?" property-name)))
	req-args opt-args)									req-args opt-args)
    (labels ((make-predicate (args body)						    (labels ((make-predicate (args body)
	       (if (null args) body								       (if (null args) body
		   `(if (null ,(first args)) ,body							   `(if (null ,(first args)) ,body
			,(make-predicate (rest args)								,(make-predicate (rest args)
					 (append body (list (first args))))))))							 (append body (list (first args))))))))
      (loop for prop in args								      (loop for prop in args
	    with req = t									    with req = t
	    do (cond ((eql prop '&optional)							    do (cond ((eql prop '&optional)
		      (setq req nil))									      (setq req nil))
		     ((null req)									     ((null req)
		      (if (atom prop)									      (if (atom prop)
			  (push (list prop :true) opt-args)							  (push (list prop :true) opt-args)
			  (push prop opt-args)))								  (push prop opt-args)))
		     (t (push prop req-args))))								     (t (push prop req-args))))
      (setq req-args (reverse req-args))						      (setq req-args (reverse req-args))
      (setq opt-args (reverse opt-args))						      (setq opt-args (reverse opt-args))
     											     
      `(progn										      `(progn
	 (defun ,assert-function-name (,@req-args						 (defun ,assert-function-name (,@req-args
					 ,@(when opt-args									 ,@(when opt-args
					     '(&optional))									     '(&optional))
					 ,@opt-args)										 ,@opt-args)
	   (assert-property ',property-name							   (assert-property ',property-name
			    (list ,@req-args									    (list ,@req-args
				  ,@(loop for arg in opt-args								  ,@(loop for arg in opt-args
					  collect (first arg)))))								  collect (first arg)))))
	 (defun ,predicate-function-name (,@req-args						 (defun ,predicate-function-name (,@req-args
					    ,@(when opt-args									    ,@(when opt-args
						'(&optional))										'(&optional))
					    ,@(loop for arg in opt-args								    ,@(loop for arg in opt-args
						    collect (first arg)))								    collect (first arg)))
	   (test-property ',property-name							   (test-property ',property-name
			  ,(make-predicate (mapcar #'first opt-args)						  ,(make-predicate (mapcar #'first opt-args)
					   `(list . ,req-args))))								   `(list . ,req-args))))
	 (pushnew ',property-name *primitive-properties*)					 (pushnew ',property-name *primitive-properties*)

	 ',property-name))))									 ',property-name))))

(defun assert-function-name (name)							(defun assert-function-name (name)
  (unless (or (member name *primitive-properties*)					  (unless (or (member name *primitive-properties*)
	      (member name *math-properties*))							      (member name *math-properties*))
    (error "The property ~S is not yet defined"						    (error "The property ~S is not yet defined"
	   name))										   name))
  (intern (format nil "~A!" name)))							  (intern (format nil "~A!" name)))

(defun predicate-function-name (name)							(defun predicate-function-name (name)
  (unless (or (member name *primitive-properties*)					  (unless (or (member name *primitive-properties*)
	      (member name *math-properties*))							      (member name *math-properties*))
    (error "The property ~S is not yet defined"						    (error "The property ~S is not yet defined"
	   name))										   name))
  (intern (format nil "~A?" name)))							  (intern (format nil "~A?" name)))

;; The predicate is a form that must evaluate to true to assert this			;; The predicate is a form that must evaluate to true to assert this
;; property.										;; property.
(defmacro define-math-property (property-name args &body body)				(defmacro define-math-property (property-name args &body body)
  (when (member property-name *primitive-properties*)					  (when (member property-name *primitive-properties*)
    (error "~A has already been used as a primitive property!"				    (error "~A has already been used as a primitive property!"
	   property-name))									   property-name))
  (when (null body)									  (when (null body)
    (error "~S should probably be a primitive property" property-name))			    (error "~S should probably be a primitive property" property-name))
  (let ((assert-name (intern (format nil "~A!" property-name)))				  (let ((assert-name (intern (format nil "~A!" property-name)))
	(predicate-name (intern (format nil "~A?" property-name)))				(predicate-name (intern (format nil "~A?" property-name)))
	opt-args req-args)									opt-args req-args)
    (loop for prop in args								    (loop for prop in args
	    with req = t									    with req = t
	    do (cond ((eql prop '&optional)							    do (cond ((eql prop '&optional)
		      (setq req nil))									      (setq req nil))
		     ((null req)									     ((null req)
		      (if (atom prop)									      (if (atom prop)
			  (push (list prop :true) opt-args)							  (push (list prop :true) opt-args)
			  (push prop opt-args)))								  (push prop opt-args)))
		     (t (push prop req-args))))								     (t (push prop req-args))))
    (setq req-args (reverse req-args))							    (setq req-args (reverse req-args))
    (setq opt-args (reverse opt-args))							    (setq opt-args (reverse opt-args))
    											    
      `(progn										      `(progn
	 (defun ,assert-name (,@req-args							 (defun ,assert-name (,@req-args
					 ,@(when opt-args									 ,@(when opt-args
					     '(&optional))									     '(&optional))
					 ,@opt-args)										 ,@opt-args)
	   ,@(loop for property in body								   ,@(loop for property in body
		   collect `(,(assert-function-name (first property))					   collect `(,(assert-function-name (first property))
				     ,@(rest property))))								     ,@(rest property))))

	 (defun ,predicate-name (,@req-args							 (defun ,predicate-name (,@req-args
					    ,@(when opt-args									    ,@(when opt-args
						'(&optional))										'(&optional))
					    ,@(loop for arg in opt-args								    ,@(loop for arg in opt-args
						    collect (first arg)))								    collect (first arg)))
	   (and											   (and
	     ,@(loop for property in body							     ,@(loop for property in body
		     collect `(,(predicate-function-name (first property))				     collect `(,(predicate-function-name (first property))
			       ,@(rest property)))))								       ,@(rest property)))))

	 (pushnew ',property-name *math-properties*)						 (pushnew ',property-name *math-properties*)
	 ',property-name)))									 ',property-name)))
;;; -*- Base: 10; Mode: Lisp; Syntax: Common-lisp; Lowercase: T -*-			;;; -*- Base: 10; Mode: Lisp; Syntax: Common-lisp; Lowercase: T -*-											
																						
;;; ===========================================================================		;;; ===========================================================================											
;;;			 Topology and the Basics of Geometry				;;;			 Topology and the Basics of Geometry											
;;; ===========================================================================		;;; ===========================================================================											
;;; (c) Copyright 1994 Cornell University						;;; (c) Copyright 1994 Cornell University											
																						
;;; new-topology.lisp,v 1.3 1995/05/12 20:50:35 chew Exp				;;; new-topology.lisp,v 1.3 1995/05/12 20:50:35 chew Exp											
																						
(in-package :WEYLI)									(in-package :WEYLI)											
																						
(make::adjust-version-numbers Weyl "1.3")						(make::adjust-version-numbers Weyl "1.3")											
																						
;; The following declaration causes all elements of euclidean spaces			;; The following declaration causes all elements of euclidean spaces											
;; to be points.									;; to be points.											
(define-domain-element-classes euclidean-space point)					(define-domain-element-classes euclidean-space point)											
																						
;; This is needed to avoid a precedence problem. 					;; This is needed to avoid a precedence problem. 											
(defmethod make-element ((domain euclidean-space) (value vector) &rest values)		(defmethod make-element ((domain euclidean-space) (value vector) &rest values)											
  (declare (ignore values))								  (declare (ignore values))											
  (make-element-free-module-vector domain value))					  (make-element-free-module-vector domain value))											
																						
#+ignore										#+ignore											
(defmethod print-object ((elt euclidean-space-element) stream)				(defmethod print-object ((elt euclidean-space-element) stream)											
  (print-free-module-element elt stream))						  (print-free-module-element elt stream))											
																						
(define-domain-creator euclidean-space (dimension &optional (domain *general*))		(define-domain-creator euclidean-space (dimension &optional (domain *general*))											
  (make-instance 'euclidean-space 							  (make-instance 'euclidean-space 											
		 :coefficient-domain domain								 :coefficient-domain domain											
		 :dimension dimension)									 :dimension dimension)											
  :predicate #'(lambda (d)								  :predicate #'(lambda (d)											
		 (and (eql (class-name (class-of d)) 'euclidean-space)					 (and (eql (class-name (class-of d)) 'euclidean-space)											
		      (eql (coefficient-domain-of d) domain)						      (eql (coefficient-domain-of d) domain)											
		      (eql (dimension-of d) dimension))))						      (eql (dimension-of d) dimension))))											
																						
(defmethod print-object ((domain euclidean-space) stream)				(defmethod print-object ((domain euclidean-space) stream)											
  (format stream #+Genera "E~D" #-Genera "E^~D"						  (format stream #+Genera "E~D" #-Genera "E^~D"											
	  (dimension-of domain)))								  (dimension-of domain)))											
																						
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;											
;;  Classes.										;;  Classes.											
;;  FIXTHIS: this should go back into space-classes.					;;  FIXTHIS: this should go back into space-classes.											
																						
;;  To fit within a complex, each cell class must have the following			;;  To fit within a complex, each cell class must have the following											
;;  functions: cell-id, facets, and dimension-of.  Function cell-id			;;  functions: cell-id, facets, and dimension-of.  Function cell-id											
;;  returns something (it doesn't really matter what) so that two			;;  returns something (it doesn't really matter what) so that two											
;;  cell-ids are #'equal iff the two cells are equivalent.  [It also			;;  cell-ids are #'equal iff the two cells are equivalent.  [It also											
;;  has to hash efficiently, so for Lucid, we have to use id-numbers			;;  has to hash efficiently, so for Lucid, we have to use id-numbers											
;;  instead of points because all points hash to the same location.]			;;  instead of points because all points hash to the same location.]											
;;  Function facets returns all the subcells that are one dimension			;;  Function facets returns all the subcells that are one dimension											
;;  lower than the cell.  Function dimension-of does what you'd				;;  lower than the cell.  Function dimension-of does what you'd											
;;  expect.										;;  expect.											
(defclass cell (has-id-number) ())							(defclass cell (has-id-number) ())											
																						
(defclass simplex (cell)								(defclass simplex (cell)											
     (;;  Maintained in order of id-number.						     (;;  Maintained in order of id-number.											
      (vertices :initform nil :initarg :vertices :reader vertices-of)))			      (vertices :initform nil :initarg :vertices :reader vertices-of)))											
																						
(defmethod initialize-instance :after ((simplex simplex)				(defmethod initialize-instance :after ((simplex simplex)											
				       &rest ignore &key home)								       &rest ignore &key home)											
  (declare (ignore ignore home))							  (declare (ignore ignore home))											
  (with-slots (vertices) simplex							  (with-slots (vertices) simplex											
    (setf vertices (sort (copy-list vertices) #'cl:< :key #'id-number-of))))		    (setf vertices (sort (copy-list vertices) #'cl:< :key #'id-number-of))))											
																						
(defclass polygon (cell)								(defclass polygon (cell)											
     (;;  Maintained with smallest id-number first, then adjacent			     (;;  Maintained with smallest id-number first, then adjacent											
      ;;  vertex with smaller id-number, followed by other vertices in			      ;;  vertex with smaller id-number, followed by other vertices in											
      ;;  order around the polygon.							      ;;  order around the polygon.											
      (vertices :initform nil :initarg :vertices :reader vertices-of)))			      (vertices :initform nil :initarg :vertices :reader vertices-of)))											
																						
(defmethod initialize-instance :after ((polygon polygon) &rest ignore)			(defmethod initialize-instance :after ((polygon polygon) &rest ignore)											
  (declare (ignore ignore))								  (declare (ignore ignore))											
  (warn "Polygons are not completely implemented."))					  (warn "Polygons are not completely implemented."))											
																						
(defclass cell-complex ()								(defclass cell-complex ()											
     (;;  Used to recognize cells that are equivalent.					     (;;  Used to recognize cells that are equivalent.											
      (cell-table :initform (make-hash-table :test #'equal)				      (cell-table :initform (make-hash-table :test #'equal)											
		  :reader cell-table-of)								  :reader cell-table-of)											
      (facet-table :initform (make-hash-table) :reader facet-table-of)			      (facet-table :initform (make-hash-table) :reader facet-table-of)											
      (cofacet-table :initform (make-hash-table) :reader cofacet-table-of)))		      (cofacet-table :initform (make-hash-table) :reader cofacet-table-of)))											
																						
(defclass simplicial-complex (cell-complex) ())						(defclass simplicial-complex (cell-complex) ())											
																						
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;											
;;  Points.										;;  Points.											
;;											;;											
(defmethod-sd binary= ((p1 abstract-point) (p2 abstract-point))				(defmethod-sd binary= ((p1 abstract-point) (p2 abstract-point))											
  (cl:= (id-number-of p1) (id-number-of p2)))						  (cl:= (id-number-of p1) (id-number-of p2)))											
																						
(defmethod-sd binary= ((p1 point) (p2 point))						(defmethod-sd binary= ((p1 point) (p2 point))											
  (let ((p1-tuple (tuple-value p1))							  (let ((p1-tuple (tuple-value p1))											
	(p2-tuple (tuple-value p2)))								(p2-tuple (tuple-value p2)))											
    (loop for i fixnum below (array-dimension p1-tuple 0)				    (loop for i fixnum below (array-dimension p1-tuple 0)											
	  do (unless (= (svref p1-tuple i) (svref p2-tuple i))					  do (unless (= (svref p1-tuple i) (svref p2-tuple i))											
	       (return nil))									       (return nil))											
	     finally (return t))))								     finally (return t))))											
																						
(defmethod make-point ((domain vector-space) (value vector) &rest values)		(defmethod make-point ((domain vector-space) (value vector) &rest values)											
  (let ((coef-domain (coefficient-domain-of domain)))					  (let ((coef-domain (coefficient-domain-of domain)))											
    (unless (and (eql (array-dimension value 0) (dimension-of domain))			    (unless (and (eql (array-dimension value 0) (dimension-of domain))											
    	     (null values))								    	     (null values))											
      (error "Wrong number of vector elements in ~S" domain))				      (error "Wrong number of vector elements in ~S" domain))											
    (make-instance 'point :domain domain						    (make-instance 'point :domain domain											
    	       :values (%apply #'vector							    	       :values (%apply #'vector											
    			       (loop for i fixnum below (length value)			    			       (loop for i fixnum below (length value)											
    				     collect (coerce (aref value i)			    				     collect (coerce (aref value i)											
    						     coef-domain))))))			    						     coef-domain))))))											
																						
(defmethod make-point ((domain vector-space) value &rest values)			(defmethod make-point ((domain vector-space) value &rest values)											
  (let ((coef-domain (coefficient-domain-of domain)))					  (let ((coef-domain (coefficient-domain-of domain)))											
    (unless (eql (1- (dimension-of domain)) (length values))				    (unless (eql (1- (dimension-of domain)) (length values))											
      (error "Wrong number of vector elements in ~S" domain))				      (error "Wrong number of vector elements in ~S" domain))											
    (make-instance 'point :domain domain						    (make-instance 'point :domain domain											
    	       :values (%apply #'vector							    	       :values (%apply #'vector											
    			       (coerce value coef-domain)				    			       (coerce value coef-domain)											
    			       (loop for v in values					    			       (loop for v in values											
    				     collect (coerce v coef-domain))))))		    				     collect (coerce v coef-domain))))))											
																						
(defmethod make-point ((domain vector-space) (value vector-space-element)		(defmethod make-point ((domain vector-space) (value vector-space-element)											
    		   &rest values)							    		   &rest values)											
  (apply #'make-point domain (tuple-value value) values))				  (apply #'make-point domain (tuple-value value) values))											
																						
(defmethod make-point ((domain abstract-space) value &rest values)			(defmethod make-point ((domain abstract-space) value &rest values)											
  (declare (ignore values))								  (declare (ignore values))											
  (if (null value)									  (if (null value)											
      (make-instance 'abstract-point :domain domain)					      (make-instance 'abstract-point :domain domain)											
      (make-instance 'named-point :domain domain :name value)))				      (make-instance 'named-point :domain domain :name value)))											
																						
(defmethod print-object ((point named-point) stream)					(defmethod print-object ((point named-point) stream)											
  (format stream "<~A>" (name-of point)))						  (format stream "<~A>" (name-of point)))											
																						
(defmethod print-object ((point abstract-point) stream)					(defmethod print-object ((point abstract-point) stream)											
  (format stream "<~S>" (id-number-of point)))						  (format stream "<~S>" (id-number-of point)))											
																						
;;  #P appears before coordinates of points.						;;  #P appears before coordinates of points.											
(defmethod print-object ((point point) stream)						(defmethod print-object ((point point) stream)											
  (format stream "#P") (call-next-method))						  (format stream "#P") (call-next-method))											
																						
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;											
;;  Cells.										;;  Cells.											
																						
;;  Had to use defmethod instead of defmethod-sd.  The -sd version			;;  Had to use defmethod instead of defmethod-sd.  The -sd version											
;;  checks domains and cells don't have domains.					;;  checks domains and cells don't have domains.											
(defmethod binary= ((cell1 cell) (cell2 cell))						(defmethod binary= ((cell1 cell) (cell2 cell))											
  (equal (cell-id cell1) (cell-id cell2)))						  (equal (cell-id cell1) (cell-id cell2)))											
																						
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;											
;;  Simplices.										;;  Simplices.											
																						
(defmethod make-simplex ((point abstract-point) &rest rest)				(defmethod make-simplex ((point abstract-point) &rest rest)											
  (loop with domain = (domain-of point)							  (loop with domain = (domain-of point)											
	for other in rest									for other in rest											
	if (not (eql domain (domain-of other)))							if (not (eql domain (domain-of other)))											
	  do											  do											
       (error "Cannot make simplex with points from differing domains. ~s"		       (error "Cannot make simplex with points from differing domains. ~s"											
	      (cons point rest)))								      (cons point rest)))											
  (make-instance 'simplex :vertices (cons point (copy-list rest))))			  (make-instance 'simplex :vertices (cons point (copy-list rest))))											
																						
(defmethod print-object ((simplex simplex) stream)					(defmethod print-object ((simplex simplex) stream)											
  (format stream "[~S~{, ~S~}]"								  (format stream "[~S~{, ~S~}]"											
	  (first (vertices-of simplex)) (rest (vertices-of simplex))))				  (first (vertices-of simplex)) (rest (vertices-of simplex))))											
																						
(defmethod cell-id ((simplex simplex))							(defmethod cell-id ((simplex simplex))											
  (mapcar #'id-number-of (vertices-of simplex)))					  (mapcar #'id-number-of (vertices-of simplex)))											
																						
(defmethod facets ((simplex simplex) (complex (eql nil)))				(defmethod facets ((simplex simplex) (complex (eql nil)))											
  (with-slots (vertices) simplex							  (with-slots (vertices) simplex											
    (if (rest vertices)									    (if (rest vertices)											
	(let ((f-list nil))									(let ((f-list nil))											
	  (choose (vertices-of simplex) (facet (dimension-of simplex))				  (choose (vertices-of simplex) (facet (dimension-of simplex))											
		  (push (apply #'make-simplex facet) f-list))						  (push (apply #'make-simplex facet) f-list))											
	  f-list))))										  f-list))))											
																						
(defmethod dimension-of ((s simplex))							(defmethod dimension-of ((s simplex))											
  (- (length (vertices-of s)) 1))							  (- (length (vertices-of s)) 1))											
																						
;;  Return the list of vertices opposite the given face of the				;;  Return the list of vertices opposite the given face of the											
;;  simplex.  The input face can be a simplex, a list of vertices, or			;;  simplex.  The input face can be a simplex, a list of vertices, or											
;;  a single point.									;;  a single point.											
(defmethod opposite ((face simplex) (simplex simplex))					(defmethod opposite ((face simplex) (simplex simplex))											
  (set-difference (vertices-of simplex) (vertices-of face)))				  (set-difference (vertices-of simplex) (vertices-of face)))											
																						
(defmethod opposite ((face list) (simplex simplex))					(defmethod opposite ((face list) (simplex simplex))											
  (set-difference (vertices-of simplex) face))						  (set-difference (vertices-of simplex) face))											
																						
(defmethod opposite ((face point) (simplex simplex))					(defmethod opposite ((face point) (simplex simplex))											
  (remove face (vertices-of simplex)))							  (remove face (vertices-of simplex)))											
																						
(defmethod face? ((points list) (simplex simplex))					(defmethod face? ((points list) (simplex simplex))											
  (subsetp points (vertices-of simplex)))						  (subsetp points (vertices-of simplex)))											
																						
(defmethod face? ((simplex1 simplex) (simplex2 simplex))				(defmethod face? ((simplex1 simplex) (simplex2 simplex))											
  (subsetp (vertices-of simplex1) (vertices-of simplex2)))				  (subsetp (vertices-of simplex1) (vertices-of simplex2)))											
																						
(defun segment? (thing)									(defun segment? (thing)											
  (and (typep thing 'simplex) (= (length (vertices-of thing)) 2)))			  (and (typep thing 'simplex) (= (length (vertices-of thing)) 2)))											
																						
(defun triangle? (thing)								(defun triangle? (thing)											
  (and (or (typep thing 'simplex) (typep thing 'polygon))				  (and (or (typep thing 'simplex) (typep thing 'polygon))											
       (= (length (vertices-of thing)) 3)))						       (= (length (vertices-of thing)) 3)))											
																						
(defun tetrahedron? (thing)								(defun tetrahedron? (thing)											
  (and (typep thing 'simplex) (= (length (vertices-of thing)) 4)))			  (and (typep thing 'simplex) (= (length (vertices-of thing)) 4)))											
																						
(defun sign-of-permutation (lista listb)						(defun sign-of-permutation (lista listb)											
  (cond ((and (null lista) (null listb)) 1)						  (cond ((and (null lista) (null listb)) 1)											
	((eql (first lista) (first listb))							((eql (first lista) (first listb))											
	 (sign-of-permutation (rest lista) (rest listb)))					 (sign-of-permutation (rest lista) (rest listb)))											
	((member (first lista) (rest listb))							((member (first lista) (rest listb))											
	 (* -1 (sign-of-permutation								 (* -1 (sign-of-permutation											
		(rest lista)										(rest lista)											
		(substitute (first listb) (first lista) (rest listb)))))				(substitute (first listb) (first lista) (rest listb)))))											
	(t 0)))											(t 0)))											
																						
;;  FIXTHIS:  This function doesn't work any more.					;;  FIXTHIS:  This function doesn't work any more.											
#+ignore										#+ignore											
(defmacro map-over-oriented-faces ((face orientation simplex complex)			(defmacro map-over-oriented-faces ((face orientation simplex complex)											
 				   &rest body)						 				   &rest body)											
  "Map over the faces of SIMPLEX, taking ORIENTATION into account"			  "Map over the faces of SIMPLEX, taking ORIENTATION into account"											
  `(if (plusp (dimension-of ,simplex))							  `(if (plusp (dimension-of ,simplex))											
       (loop for v in (vertices-of ,simplex)						       (loop for v in (vertices-of ,simplex)											
	     for ,orientation = t then (null ,orientation)					     for ,orientation = t then (null ,orientation)											
	     do (multiple-value-bind								     do (multiple-value-bind											
		    (,face sign)									    (,face sign)											
		    (canonical-cell									    (canonical-cell											
		     ,complex (remove v (vertices-of ,simplex)))					     ,complex (remove v (vertices-of ,simplex)))											
		  (if (< sign 0) (setf ,orientation (minus ,orientation)))				  (if (< sign 0) (setf ,orientation (minus ,orientation)))											
		  ,@body))))										  ,@body))))											
																						
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;											
;;  Polygons.										;;  Polygons.											
																						
(defmethod cell-id ((polygon polygon))							(defmethod cell-id ((polygon polygon))											
  (let ((id-list (mapcar #'id-number-of (vertices-of polygon))))			  (let ((id-list (mapcar #'id-number-of (vertices-of polygon))))											
    (if (= 3 (length (vertices-of polygon)))						    (if (= 3 (length (vertices-of polygon)))											
	id-list											id-list											
	(cons :p id-list))))	       ; Uses :p to distinguish from simplices.			(cons :p id-list))))	       ; Uses :p to distinguish from simplices.											
																						
(defmethod facets ((polygon polygon) (complex (eql nil)))				(defmethod facets ((polygon polygon) (complex (eql nil)))											
  (loop with vertices = (vertices-of polygon)						  (loop with vertices = (vertices-of polygon)											
	for a in (cons (first (last vertices)) vertices) and b in vertices			for a in (cons (first (last vertices)) vertices) and b in vertices											
	collect (make-simplex a b)))								collect (make-simplex a b)))											
																						
(defmethod dimension-of ((polygon polygon))						(defmethod dimension-of ((polygon polygon))											
  2)											  2)											
																						
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;											
;;  Cell-Complexes.									;;  Cell-Complexes.											
																						
(defmethod get-cell ((cell cell) (complex cell-complex))				(defmethod get-cell ((cell cell) (complex cell-complex))											
  (if (member cell complex) cell							  (if (member cell complex) cell											
      (gethash (cell-id cell) (cell-table-of complex))))				      (gethash (cell-id cell) (cell-table-of complex))))											
																						
;;  Allow get-cell to take a list of vertices (representing a simplex).			;;  Allow get-cell to take a list of vertices (representing a simplex).											
(defmethod get-cell ((vertex-list list) (complex cell-complex))				(defmethod get-cell ((vertex-list list) (complex cell-complex))											
  (gethash (sort (mapcar #'id-number-of vertex-list) #'cl:<)				  (gethash (sort (mapcar #'id-number-of vertex-list) #'cl:<)											
	   (cell-table-of complex)))								   (cell-table-of complex)))											
																						
(defmethod member ((cell cell) (complex cell-complex) &rest ignore)			(defmethod member ((cell cell) (complex cell-complex) &rest ignore)											
  (declare (ignore ignore))								  (declare (ignore ignore))											
  (second (multiple-value-list (gethash (id-number-of cell)				  (second (multiple-value-list (gethash (id-number-of cell)											
					(facet-table-of complex)))))								(facet-table-of complex)))))											
																						
(defmethod facets ((cell cell) (complex cell-complex))					(defmethod facets ((cell cell) (complex cell-complex))											
  (gethash (id-number-of cell) (facet-table-of complex)))				  (gethash (id-number-of cell) (facet-table-of complex)))											
																						
(defmethod facets ((cells list) (complex cell-complex))					(defmethod facets ((cells list) (complex cell-complex))											
  (loop for cell in cells								  (loop for cell in cells											
	append (facets cell complex) into facet-list						append (facets cell complex) into facet-list											
	finally (return (remove-duplicates facet-list))))					finally (return (remove-duplicates facet-list))))											
																						
(defmethod cofacets ((cell cell) (complex cell-complex))				(defmethod cofacets ((cell cell) (complex cell-complex))											
  (gethash (id-number-of cell) (cofacet-table-of complex)))				  (gethash (id-number-of cell) (cofacet-table-of complex)))											
																						
(defmethod cofacets ((cells list) (complex cell-complex))				(defmethod cofacets ((cells list) (complex cell-complex))											
  (loop for cell in cells								  (loop for cell in cells											
	append (cofacets cell complex) into cofacet-list					append (cofacets cell complex) into cofacet-list											
	finally (return (remove-duplicates cofacet-list))))					finally (return (remove-duplicates cofacet-list))))											
																						
(defmethod maximal-cell? ((cell cell) (complex cell-complex))				(defmethod maximal-cell? ((cell cell) (complex cell-complex))											
  (and (member cell complex) (null (cofacets cell complex))))				  (and (member cell complex) (null (cofacets cell complex))))											
																						
;;  Destructive modification of cell-complex.						;;  Destructive modification of cell-complex.											
(defmethod insert ((cell cell) (complex cell-complex) &rest ignore)			(defmethod insert ((cell cell) (complex cell-complex) &rest ignore)											
  (declare (ignore ignore))								  (declare (ignore ignore))											
  (with-slots (cell-table facet-table cofacet-table) complex				  (with-slots (cell-table facet-table cofacet-table) complex											
    ;;  Internal insert.  Checking only needs to be done on insert;			    ;;  Internal insert.  Checking only needs to be done on insert;											
    ;;  %insert does no checking.  Implements distinction between			    ;;  %insert does no checking.  Implements distinction between											
    ;;  user-level insert and internal insert; nice for triangulations			    ;;  user-level insert and internal insert; nice for triangulations											
    ;;  where user-level inserts only triangles, while internal				    ;;  where user-level inserts only triangles, while internal											
    ;;  inserts can do 1- and 0-simplices.  If there is already an			    ;;  inserts can do 1- and 0-simplices.  If there is already an											
    ;;  equivalent cell in the complex then we return the equivalent			    ;;  equivalent cell in the complex then we return the equivalent											
    ;;  cell (and do no insertion); otherwise we return the newly			    ;;  cell (and do no insertion); otherwise we return the newly											
    ;;  inserted cell.  [May want to make %insert a method on its own			    ;;  inserted cell.  [May want to make %insert a method on its own											
    ;;  at some point.]									    ;;  at some point.]											
    (labels ((%insert (cell complex)							    (labels ((%insert (cell complex)											
	       (or (get-cell cell complex)							       (or (get-cell cell complex)											
		   (loop with facets-list								   (loop with facets-list											
			 for facet in (facets cell nil)								 for facet in (facets cell nil)											
			 do (setf facet (%insert facet complex))						 do (setf facet (%insert facet complex))											
			    (push facet facets-list)								    (push facet facets-list)											
			    (push cell (gethash (id-number-of facet)						    (push cell (gethash (id-number-of facet)											
						cofacet-table))										cofacet-table))											
			 finally										 finally											
		      (setf (gethash (cell-id cell) cell-table) cell)					      (setf (gethash (cell-id cell) cell-table) cell)											
		      (setf (gethash (id-number-of cell) facet-table)					      (setf (gethash (id-number-of cell) facet-table)											
			    facets-list)									    facets-list)											
		      (return cell)))))									      (return cell)))))											
      (%insert cell complex))))								      (%insert cell complex))))											
																						
;;  Destructive modification.  Can only delete a maximal cell.				;;  Destructive modification.  Can only delete a maximal cell.											
(defmethod delete-maximal-cell ((cell cell) (complex cell-complex))			(defmethod delete-maximal-cell ((cell cell) (complex cell-complex))											
  (unless (member cell complex)								  (unless (member cell complex)											
    (error "Cannot delete ~s from ~s.  It is not a member." cell complex))		    (error "Cannot delete ~s from ~s.  It is not a member." cell complex))											
  (when (cofacets cell complex)								  (when (cofacets cell complex)											
    (error "Cannot delete a cell that is not maximal. ~s" cell))			    (error "Cannot delete a cell that is not maximal. ~s" cell))											
  (with-slots (cell-table facet-table cofacet-table) complex				  (with-slots (cell-table facet-table cofacet-table) complex											
    (labels ((%delete (cell complex)							    (labels ((%delete (cell complex)											
	       (loop with cofacets								       (loop with cofacets											
		     for facet in (facets cell complex) do						     for facet in (facets cell complex) do											
		       (setf cofacets (remove cell (cofacets facet complex)))				       (setf cofacets (remove cell (cofacets facet complex)))											
		       (cond										       (cond											
			 (cofacets (setf (gethash (id-number-of facet)						 (cofacets (setf (gethash (id-number-of facet)											
						  cofacet-table)									  cofacet-table)											
					 cofacets))										 cofacets))											
			 (t (remhash (id-number-of facet) cofacet-table)					 (t (remhash (id-number-of facet) cofacet-table)											
			    (%delete facet complex))))								    (%delete facet complex))))											
	       (remhash (cell-id cell) cell-table)						       (remhash (cell-id cell) cell-table)											
	       (remhash (id-number-of cell) facet-table)))					       (remhash (id-number-of cell) facet-table)))											
      (%delete cell complex))))								      (%delete cell complex))))											
																						
;;  Use function on all cells of complex that have the given				;;  Use function on all cells of complex that have the given											
;;  dimension.  If dimension is null then use function on all cells.			;;  dimension.  If dimension is null then use function on all cells.											
(defmethod %map-over-cells ((function function) (complex cell-complex)			(defmethod %map-over-cells ((function function) (complex cell-complex)											
			    dimension)										    dimension)											
  (maphash #'(lambda (cell-id cell)							  (maphash #'(lambda (cell-id cell)											
	       (declare (ignore cell-id))							       (declare (ignore cell-id))											
	       (when (or (null dimension) (= dimension (dimension-of cell)))			       (when (or (null dimension) (= dimension (dimension-of cell)))											
		 (funcall function cell)))								 (funcall function cell)))											
	   (cell-table-of complex)))								   (cell-table-of complex)))											
																						
;;  Syntactic sugar.									;;  Syntactic sugar.											
(defmacro map-over-cells ((cell &optional (dimension nil)) structure			(defmacro map-over-cells ((cell &optional (dimension nil)) structure											
			  &body body)										  &body body)											
  `(%map-over-cells #'(lambda (,cell) ,@body) ,structure ,dimension))			  `(%map-over-cells #'(lambda (,cell) ,@body) ,structure ,dimension))											
																						
;;  More syntactic sugar.								;;  More syntactic sugar.											
(defmacro map-over-maximal-cells ((cell) complex &body body)				(defmacro map-over-maximal-cells ((cell) complex &body body)											
  `(map-over-cells (,cell) ,complex							  `(map-over-cells (,cell) ,complex											
     (when (maximal-cell? ,cell ,complex)						     (when (maximal-cell? ,cell ,complex)											
       ,@body)))									       ,@body)))											
																						
(defmethod union ((complex1 cell-complex) (complex2 cell-complex) &rest rest)		(defmethod union ((complex1 cell-complex) (complex2 cell-complex) &rest rest)											
  (when rest										  (when rest											
    (error "Too many arguments to Union."))						    (error "Too many arguments to Union."))											
  (unless (eql (class-of complex1) (class-of complex2))					  (unless (eql (class-of complex1) (class-of complex2))											
    (error "~s and ~s are not of the same class." complex1 complex2))			    (error "~s and ~s are not of the same class." complex1 complex2))											
  (let ((new (make-instance (class-of complex1))))					  (let ((new (make-instance (class-of complex1))))											
    (map-over-maximal-cells (cell) complex1 (insert cell new))				    (map-over-maximal-cells (cell) complex1 (insert cell new))											
    (map-over-maximal-cells (cell) complex2 (insert cell new))				    (map-over-maximal-cells (cell) complex2 (insert cell new))											
    new))										    new))											
																						
(defmethod intersection ((complex1 cell-complex) (complex2 cell-complex)		(defmethod intersection ((complex1 cell-complex) (complex2 cell-complex)											
			 &rest rest)										 &rest rest)											
  (when rest										  (when rest											
    (error "Too many arguments to Intersection."))					    (error "Too many arguments to Intersection."))											
  (unless (eql (class-of complex1) (class-of complex2))					  (unless (eql (class-of complex1) (class-of complex2))											
    (error "~s and ~s are not of the same class." complex1 complex2))			    (error "~s and ~s are not of the same class." complex1 complex2))											
  (let ((new (make-instance (class-of complex1))))					  (let ((new (make-instance (class-of complex1))))											
    (map-over-cells (cell) complex1							    (map-over-cells (cell) complex1											
      (when (get-cell cell complex2) (insert cell new)))				      (when (get-cell cell complex2) (insert cell new)))											
    new))										    new))											
		    											    											
(defmethod vertex-set ((cell-complex cell-complex))					(defmethod vertex-set ((cell-complex cell-complex))											
  (let ((vert-list nil))								  (let ((vert-list nil))											
    (map-over-cells (v-cell 0) cell-complex						    (map-over-cells (v-cell 0) cell-complex											
		    (push (first (vertices-of v-cell)) vert-list))					    (push (first (vertices-of v-cell)) vert-list))											
    vert-list))										    vert-list))											
																						
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;											
;;  Simplicial-Complexes.								;;  Simplicial-Complexes.											
																						
;;  Catch bad insertions.  This avoids a nasty precedence problem:			;;  Catch bad insertions.  This avoids a nasty precedence problem:											
;;  without this, the command (insert cell simplicial-complex) can end			;;  without this, the command (insert cell simplicial-complex) can end											
;;  up at command (insert cell cell-complex) and work even when cell			;;  up at command (insert cell cell-complex) and work even when cell											
;;  is a nonsimplex.									;;  is a nonsimplex.											
(defmethod insert :before (thing (complex simplicial-complex) &rest ignore)		(defmethod insert :before (thing (complex simplicial-complex) &rest ignore)											
  (declare (ignore ignore))								  (declare (ignore ignore))											
  (unless (typep thing 'simplex)							  (unless (typep thing 'simplex)											
    (error "Illegal attempt to Insert a nonsimplex ~s into ~s" thing complex)))		    (error "Illegal attempt to Insert a nonsimplex ~s into ~s" thing complex)))											
																						
(defun make-simplicial-complex (cells)							(defun make-simplicial-complex (cells)											
  (loop with complex = (make-instance 'simplicial-complex)				  (loop with complex = (make-instance 'simplicial-complex)											
	for cell in cells									for cell in cells											
	do (insert cell complex)								do (insert cell complex)											
	finally (return complex)))								finally (return complex)))											
																						
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;											
;;  Coerce.										;;  Coerce.											
;;											;;											
;;  Coerce via the coercion-cache.  A single object can have multiple			;;  Coerce via the coercion-cache.  A single object can have multiple											
;;  representations; this allows fast access without recomputing the			;;  representations; this allows fast access without recomputing the											
;;  map.  Maps are specified via Make-Homomorphism.  It's also				;;  map.  Maps are specified via Make-Homomorphism.  It's also											
;;  possible to force a coercion to have a particular value via (setf			;;  possible to force a coercion to have a particular value via (setf											
;;  coerce).										;;  coerce).											
;;											;;											
;;  This has three advantages: (1) You can force a coercion to have a			;;  This has three advantages: (1) You can force a coercion to have a											
;;  particular value via (setf coerce).  (2) You can save time (when			;;  particular value via (setf coerce).  (2) You can save time (when											
;;  the map between spaces is slow).  (3) You can save consing				;;  the map between spaces is slow).  (3) You can save consing											
;;  (nothing new is created after the first time that the cache is			;;  (nothing new is created after the first time that the cache is											
;;  used; while a map is likely to create new objects during every			;;  used; while a map is likely to create new objects during every											
;;  use).										;;  use).											
;;											;;											
;;  FIXTHIS: This method should probably be in a different file.			;;  FIXTHIS: This method should probably be in a different file.											
;;											;;											
(defmethod coerce ((thing has-coercion-cache) (domain domain))				(defmethod coerce ((thing has-coercion-cache) (domain domain))											
																						
  ;;  Return the thing itself if it is already in the correct domain.			  ;;  Return the thing itself if it is already in the correct domain.											
  (or (if (eql (domain-of thing) domain) thing)						  (or (if (eql (domain-of thing) domain) thing)											
																						
      ;;  Use the stored value if it exists.						      ;;  Use the stored value if it exists.											
      (rest (assoc domain (%coercion-cache-of thing)))					      (rest (assoc domain (%coercion-cache-of thing)))											
																						
      ;;  Get the value, cache it, and return it.					      ;;  Get the value, cache it, and return it.											
      (let ((value (call-next-method)))							      (let ((value (call-next-method)))											
        (if value (push (cons domain value) (%coercion-cache-of thing)))		        (if value (push (cons domain value) (%coercion-cache-of thing)))											
        value)))									        value)))											
																						
(defmethod %set-coerce ((thing has-coercion-cache) (domain domain) value)		(defmethod %set-coerce ((thing has-coercion-cache) (domain domain) value)											
  (with-slots (coercion-cache) thing							  (with-slots (coercion-cache) thing											
    (when (assoc domain coercion-cache)							    (when (assoc domain coercion-cache)											
      (error "Multiple representations for a single item. ~s" thing))			      (error "Multiple representations for a single item. ~s" thing))											
    (unless (eql (domain-of value) domain)						    (unless (eql (domain-of value) domain)											
      (error "Mismatch when defining coercion. ~s ~s" domain value))			      (error "Mismatch when defining coercion. ~s ~s" domain value))											
    (push (cons domain value) coercion-cache)						    (push (cons domain value) coercion-cache)											
    value))										    value))											
																						
(defsetf coerce %set-coerce)								(defsetf coerce %set-coerce)											
																						
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;											
;; Chains										;; Chains											
;;											;;											
;; CHAINs are elements of CHAIN-MODULE domains						;; CHAINs are elements of CHAIN-MODULE domains											
;;											;;											
;;   Use GET-CHAIN-MODULE to create CHAIN-MODULE domains.				;;   Use GET-CHAIN-MODULE to create CHAIN-MODULE domains.											
;;   CHAIN representations are based upon the canonical cells returned by		;;   CHAIN representations are based upon the canonical cells returned by											
;;   GET-Canonical-Cell from the CELL-COMPLEX in the CHAIN-MODULE.			;;   GET-Canonical-Cell from the CELL-COMPLEX in the CHAIN-MODULE.											
(defmethod print-object ((cm chain-module) stream)					(defmethod print-object ((cm chain-module) stream)											
  (format stream "C[~D](~A;~A)" (dimension-of cm) (complex-of cm)			  (format stream "C[~D](~A;~A)" (dimension-of cm) (complex-of cm)											
                                (coefficient-domain-of cm)))				                                (coefficient-domain-of cm)))											
																						
 (defmethod complex-of ((chain chain))							 (defmethod complex-of ((chain chain))											
   (complex-of(domain-of chain)))							   (complex-of(domain-of chain)))											
																						
(defmethod get-chain-module ((c cell-complex) (n integer)				(defmethod get-chain-module ((c cell-complex) (n integer)											
			     &optional (ring (get-rational-integers)))						     &optional (ring (get-rational-integers)))											
  (make-instance 'chain-module								  (make-instance 'chain-module											
		 :complex c										 :complex c											
                 :dimension n								                 :dimension n											
                 :coefficient-domain ring))						                 :coefficient-domain ring))											
																						
(defmethod boundary-domain ((c chain-module))						(defmethod boundary-domain ((c chain-module))											
  (if (= (dimension-of c) 0)								  (if (= (dimension-of c) 0)											
     (error "Can not create a chain module with a less than zero dimension.")		     (error "Can not create a chain module with a less than zero dimension.")											
     (get-chain-module (complex-of c)							     (get-chain-module (complex-of c)											
                       (- (dimension-of c) 1)						                       (- (dimension-of c) 1)											
                       (coefficient-domain-of c))))					                       (coefficient-domain-of c))))											
																						
(defmethod dimension-of ((chain chain))							(defmethod dimension-of ((chain chain))											
  (dimension-of (domain-of chain)))							  (dimension-of (domain-of chain)))											
																						
(defmethod boundary-domain ((c chain))							(defmethod boundary-domain ((c chain))											
  (if (= (dimension-of (domain-of c)) 0)						  (if (= (dimension-of (domain-of c)) 0)											
      (error "Can not create boundary domain for a zero dimension chain.")		      (error "Can not create boundary domain for a zero dimension chain.")											
    (get-chain-module (complex-of c)							    (get-chain-module (complex-of c)											
		      (- (dimension-of c) 1)								      (- (dimension-of c) 1)											
		      (coefficient-domain-of (domain-of c)))))						      (coefficient-domain-of (domain-of c)))))											
																						
(defmethod boundary-domain ((s simplex))						(defmethod boundary-domain ((s simplex))											
  (get-chain-module (make-simplicial-complex (list s))					  (get-chain-module (make-simplicial-complex (list s))											
		    (- (dimension-of s) 1)								    (- (dimension-of s) 1)											
		    (get-rational-integers)))								    (get-rational-integers)))											
																						
(defmethod boundary-domain ((cc cell-complex))						(defmethod boundary-domain ((cc cell-complex))											
  (let ((dim nil))									  (let ((dim nil))											
    (maphash #'(lambda (key value)							    (maphash #'(lambda (key value)											
		 (declare (ignore key))									 (declare (ignore key))											
		 (cond ((null dim)									 (cond ((null dim)											
			(setq dim (dimension-of value)))							(setq dim (dimension-of value)))											
		       ((not (eql dim (dimension-of value)))						       ((not (eql dim (dimension-of value)))											
			(error "Not all Maximal cells of the same dimension"))))				(error "Not all Maximal cells of the same dimension"))))											
	     (maximal-cell-table-of cc))							     (maximal-cell-table-of cc))											
    (if (= dim 0)									    (if (= dim 0)											
	(error "Cannot create boundary domain of a zero dimensional cell-complex")		(error "Cannot create boundary domain of a zero dimensional cell-complex")											
      (get-chain-module cc (- dim 1) (get-rational-integers)))))			      (get-chain-module cc (- dim 1) (get-rational-integers)))))											
																						
(defmethod print-object ((c chain) stream)						(defmethod print-object ((c chain) stream)											
  (flet ((print-term (s coef)								  (flet ((print-term (s coef)											
		     (cond ((minus? coef)								     (cond ((minus? coef)											
		  (princ " - " stream)									  (princ " - " stream)											
		  (setq coef (- coef)))									  (setq coef (- coef)))											
		 (t (princ " + " stream)))								 (t (princ " + " stream)))											
	   (unless (1? coef)									   (unless (1? coef)											
	     (print-grouped coef stream))							     (print-grouped coef stream))											
	   (princ s stream)))									   (princ s stream)))											
    (let* ((terms (chain-terms-of c))							    (let* ((terms (chain-terms-of c))											
	   (s (first (first terms)))								   (s (first (first terms)))											
	   (coef (rest (first terms))))								   (coef (rest (first terms))))											
      (cond ((null terms) (princ 0 stream))						      (cond ((null terms) (princ 0 stream))											
	    (t (cond ((minus? coef)								    (t (cond ((minus? coef)											
		      (princ " - " stream)								      (princ " - " stream)											
		      (setq coef (- coef))))								      (setq coef (- coef))))											
	       (unless (1? coef)								       (unless (1? coef)											
		 (print-grouped coef stream))								 (print-grouped coef stream))											
               (princ s stream)								               (princ s stream)											
	       (loop for (cell . coef) in (rest terms)						       (loop for (cell . coef) in (rest terms)											
		     do (print-term cell coef)))))))							     do (print-term cell coef)))))))											
																						
(defun canonical (pair domain)								(defun canonical (pair domain)											
  (multiple-value-bind (cached sign)							  (multiple-value-bind (cached sign)											
		      (get-canonical-cell (complex-of domain) (first pair))				      (get-canonical-cell (complex-of domain) (first pair))											
    (cons cached (if (> sign 0) (cdr pair) (minus (cdr pair))))))			    (cons cached (if (> sign 0) (cdr pair) (minus (cdr pair))))))											
																						
 (defmethod coerce ((simplex simplex) (cm chain-module))				 (defmethod coerce ((simplex simplex) (cm chain-module))											
   (make-chain cm (list(cons simplex							   (make-chain cm (list(cons simplex											
 			    (coerce 1 (coefficient-domain-of				 			    (coerce 1 (coefficient-domain-of											
 				       cm))))))						 				       cm))))))											
																						
 (defmethod coerce ((cc simplicial-complex) (cm chain-module))				 (defmethod coerce ((cc simplicial-complex) (cm chain-module))											
   (let ((one (coerce 1 (coefficient-domain-of cm)))					   (let ((one (coerce 1 (coefficient-domain-of cm)))											
 	(dim (dimension-of cm))								 	(dim (dimension-of cm))											
 	(list nil))									 	(list nil))											
     (map-over-cells (face dim) cm							     (map-over-cells (face dim) cm											
		     (push (cons face one) list))							     (push (cons face one) list))											
     (make-chain cm list)))								     (make-chain cm list)))											
																						
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;											
;; CELL-ORDER										;; CELL-ORDER											
;;   defines a canonical ordering for cells						;;   defines a canonical ordering for cells											
;;   - used to create canonical stored and printed representations for chains		;;   - used to create canonical stored and printed representations for chains											
(defun points-order (a b)								(defun points-order (a b)											
  (loop for av in a									  (loop for av in a											
	for bv in b										for bv in b											
	do (cond ((cl:< (id-number-of av) (id-number-of bv))					do (cond ((cl:< (id-number-of av) (id-number-of bv))											
		  (return t))										  (return t))											
		 ((eql av bv) nil)									 ((eql av bv) nil)											
		 (t (return nil)))))									 (t (return nil)))))											
																						
(defmethod cell-order ((a cell) (b cell))						(defmethod cell-order ((a cell) (b cell))											
  (let ((aorder (sort (copy-list (vertices-of a)) #'cl:< :key #'id-number-of))		  (let ((aorder (sort (copy-list (vertices-of a)) #'cl:< :key #'id-number-of))											
	(border (sort (copy-list (vertices-of b)) #'cl:< :key #'id-number-of)))			(border (sort (copy-list (vertices-of b)) #'cl:< :key #'id-number-of)))											
    (or (points-order aorder border)							    (or (points-order aorder border)											
	(points-order (vertices-of a) (vertices-of b)))))					(points-order (vertices-of a) (vertices-of b)))))											
																						
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;											
;; MAKE-CHAIN										;; MAKE-CHAIN											
;;   Used to create CHAIN elements.  							;;   Used to create CHAIN elements.  											
;;   -  Currently does not verify that the simplexes given are of the proper		;;   -  Currently does not verify that the simplexes given are of the proper											
;;      dimension indicated in the CHAIN-MODULE						;;      dimension indicated in the CHAIN-MODULE											
																						
																						
;; Internally, the chains are stored as dotted pairs of simplices and			;; Internally, the chains are stored as dotted pairs of simplices and											
;; coefficients.  The argument list to make-chain is also a list of			;; coefficients.  The argument list to make-chain is also a list of											
;; dotted pairs.									;; dotted pairs.											
																						
(defun make-chain (d simplices)								(defun make-chain (d simplices)											
  (let ((simps nil))									  (let ((simps nil))											
    (flet ((insert (simp)								    (flet ((insert (simp)											
	     (loop for sim in simps								     (loop for sim in simps											
		   do (when (eq (first simp) (first sim))						   do (when (eq (first simp) (first sim))											
			(setf (rest sim) (+ (second simp) (rest sim)))						(setf (rest sim) (+ (second simp) (rest sim)))											
			(return t))										(return t))											
		   finally (push simp simps))))								   finally (push simp simps))))											
      (loop for simp in simplices							      (loop for simp in simplices											
	    do (insert (canonical simp d)))							    do (insert (canonical simp d)))											
      (make-instance 'chain								      (make-instance 'chain											
             :domain d									             :domain d											
	     :terms (sort (loop for simp in simps						     :terms (sort (loop for simp in simps											
				unless (0? (rest simp))									unless (0? (rest simp))											
				  collect simp)										  collect simp)											
			  #'(lambda (x y)									  #'(lambda (x y)											
			      (cell-order (first x) (first y))))))))						      (cell-order (first x) (first y))))))))											
																						
(defmethod zero ((d chain-module))							(defmethod zero ((d chain-module))											
  (make-chain d ()))									  (make-chain d ()))											
																						
(defmethod apply ((c chain) &rest args)							(defmethod apply ((c chain) &rest args)											
  (setq args (accum-apply-args args))							  (setq args (accum-apply-args args))											
  (cond ((typep (first args) 'simplex)							  (cond ((typep (first args) 'simplex)											
	 (loop with s = (first args)								 (loop with s = (first args)											
	       for (simplex . coef) in (chain-terms-of c)					       for (simplex . coef) in (chain-terms-of c)											
	       do (when (face? s simplex)							       do (when (face? s simplex)											
		    (return coef))))))									    (return coef))))))											
  											  											
																						
(defun free-group-plus (xt yt)								(defun free-group-plus (xt yt)											
  (pair-up-terms xt (simp1 c1) yt (simp2 c2) cell-order					  (pair-up-terms xt (simp1 c1) yt (simp2 c2) cell-order											
		 (if simp1 (if simp2 (let ((c-sum (+ c1 c2)))						 (if simp1 (if simp2 (let ((c-sum (+ c1 c2)))											
				       (if (not (0? c-sum))								       (if (not (0? c-sum))											
					   (collect-term simp1 c-sum)))								   (collect-term simp1 c-sum)))											
			     (collect-term simp1 c1))								     (collect-term simp1 c1))											
		   (collect-term simp2 c2))))								   (collect-term simp2 c2))))											
																						
(defun free-group-difference (xt yt)							(defun free-group-difference (xt yt)											
  (pair-up-terms xt (simp1 c1) yt (simp2 c2) cell-order					  (pair-up-terms xt (simp1 c1) yt (simp2 c2) cell-order											
		 (if simp1 (if simp2 (let ((c-sum (- c1 c2)))						 (if simp1 (if simp2 (let ((c-sum (- c1 c2)))											
				       (if (not (0? c-sum))								       (if (not (0? c-sum))											
					   (collect-term simp1 c-sum)))								   (collect-term simp1 c-sum)))											
			     (collect-term simp1 c1))								     (collect-term simp1 c1))											
		   (collect-term simp2 c2))))								   (collect-term simp2 c2))))											
																						
(defun free-group-minus (xt)								(defun free-group-minus (xt)											
   (free-group-difference nil xt))							   (free-group-difference nil xt))											
																						
(defun free-group-scalar-times (c terms)						(defun free-group-scalar-times (c terms)											
  (cond ((0? c) nil)									  (cond ((0? c) nil)											
	(t (loop for (simp . coef) in terms							(t (loop for (simp . coef) in terms											
		 for c1 = (* c coef)	; coefficient ring need not be an 				 for c1 = (* c coef)	; coefficient ring need not be an 											
		 unless (0? c1)		; integral domain!						 unless (0? c1)		; integral domain!											
		   collect (cons simp c1)))))								   collect (cons simp c1)))))											
																						
(defmethod-sd plus ((x chain) (y chain))						(defmethod-sd plus ((x chain) (y chain))											
  (make-chain (domain-of x)								  (make-chain (domain-of x)											
	      (free-group-plus (chain-terms-of x) (chain-terms-of y))))				      (free-group-plus (chain-terms-of x) (chain-terms-of y))))											
																						
(defmethod-sd difference ((x chain) (y chain))						(defmethod-sd difference ((x chain) (y chain))											
  (make-chain (domain-of x)								  (make-chain (domain-of x)											
	      (free-group-difference (chain-terms-of x) (chain-terms-of y))))			      (free-group-difference (chain-terms-of x) (chain-terms-of y))))											
																						
(defmethod times ((x (or number domain-element)) (y chain))				(defmethod times ((x (or number domain-element)) (y chain))											
  (make-chain  (domain-of y)								  (make-chain  (domain-of y)											
	       (free-group-scalar-times x (chain-terms-of y))))					       (free-group-scalar-times x (chain-terms-of y))))											
																						
(defmethod times ((x chain) (y (or number domain-element)))				(defmethod times ((x chain) (y (or number domain-element)))											
  (make-chain (domain-of x)								  (make-chain (domain-of x)											
	      (free-group-scalar-times y (chain-terms-of x))))					      (free-group-scalar-times y (chain-terms-of x))))											
																						
(defmethod minus ((x chain))								(defmethod minus ((x chain))											
  (make-chain (domain-of x)								  (make-chain (domain-of x)											
	      (free-group-minus (chain-terms-of x))))						      (free-group-minus (chain-terms-of x))))											
																						
(defun chain-terms-times (xt yt)							(defun chain-terms-times (xt yt)											
  (pair-up-terms xt (simp1 c1) yt (simp2 c2) cell-order					  (pair-up-terms xt (simp1 c1) yt (simp2 c2) cell-order											
    (when (and simp1 simp2)								    (when (and simp1 simp2)											
      (let ((c-prod (* c1 c2)))								      (let ((c-prod (* c1 c2)))											
	   (if (not (0? c-prod))								   (if (not (0? c-prod))											
	       (collect-term simp1 c-prod))))))							       (collect-term simp1 c-prod))))))											
																						
(defmethod-sd times ((x chain) (y chain))						(defmethod-sd times ((x chain) (y chain))											
  (make-chain domain									  (make-chain domain											
	      (chain-terms-times (chain-terms-of x) (chain-terms-of y))))			      (chain-terms-times (chain-terms-of x) (chain-terms-of y))))											
																						
;;; Note: The following is wrong. Removed by rsp.					;;; Note: The following is wrong. Removed by rsp.											
#+incorrect										#+incorrect											
(defmethod-sd inner-product ((x chain) (y chain))					(defmethod-sd inner-product ((x chain) (y chain))											
  (make-chain domain									  (make-chain domain											
	      (chain-terms-times (chain-terms-of x) (chain-terms-of y))))			      (chain-terms-times (chain-terms-of x) (chain-terms-of y))))											
																						
(defmethod boundary ((s simplex) &optional (domain (boundary-domain s)))		(defmethod boundary ((s simplex) &optional (domain (boundary-domain s)))											
  (let* ((list nil)									  (let* ((list nil)											
         (one (one (coefficient-domain-of domain)))					         (one (one (coefficient-domain-of domain)))											
	 (simplicial-complex (complex-of domain))						 (simplicial-complex (complex-of domain))											
         )										         )											
    (map-over-oriented-faces								    (map-over-oriented-faces											
     (f o s simplicial-complex)								     (f o s simplicial-complex)											
     (push (cons f (if o one (minus one))) list))					     (push (cons f (if o one (minus one))) list))											
    (make-chain domain list)))								    (make-chain domain list)))											
																						
(defmethod boundary ((cc cell-complex) &optional (domain (boundary-domain cc)))		(defmethod boundary ((cc cell-complex) &optional (domain (boundary-domain cc)))											
  (let ((bound (zero domain)))								  (let ((bound (zero domain)))											
    (maphash #'(lambda (key value)							    (maphash #'(lambda (key value)											
		 (declare (ignore key))									 (declare (ignore key))											
		 (setq bound (+ bound (boundary value domain))))					 (setq bound (+ bound (boundary value domain))))											
	     (maximal-cell-table-of cc))							     (maximal-cell-table-of cc))											
    bound))										    bound))											
  											  											
(defmethod boundary ((c chain) &optional d)						(defmethod boundary ((c chain) &optional d)											
  (let ((terms (chain-terms-of c))							  (let ((terms (chain-terms-of c))											
	(bd (if d d (boundary-domain c)))							(bd (if d d (boundary-domain c)))											
	ans)											ans)											
    (setq ans (* (rest (first terms)) (boundary (first (first terms)) bd)))		    (setq ans (* (rest (first terms)) (boundary (first (first terms)) bd)))											
    (loop for (simp . coef) in (rest terms)						    (loop for (simp . coef) in (rest terms)											
	  do (setq ans (+ ans (* coef (boundary simp bd)))))					  do (setq ans (+ ans (* coef (boundary simp bd)))))											
    ans))										    ans))											
																						
;; Takes a boundary (which is chain and returns the list of simplices			;; Takes a boundary (which is chain and returns the list of simplices											
;; that make up the boundary.								;; that make up the boundary.											
(defmethod boundary-set ((c chain))							(defmethod boundary-set ((c chain))											
  (loop for (simp . coef) in (chain-terms-of c)						  (loop for (simp . coef) in (chain-terms-of c)											
	with simps = nil									with simps = nil											
	do (unless (even? coef)									do (unless (even? coef)											
	     (push simp simps))									     (push simp simps))											
	   finally (return simps)))								   finally (return simps)))											
																						
(defmethod deriv ((ch chain) &rest vars)						(defmethod deriv ((ch chain) &rest vars)											
  (make-chain (domain-of ch)								  (make-chain (domain-of ch)											
	      (loop for (simp . coef) in (chain-terms-of ch)					      (loop for (simp . coef) in (chain-terms-of ch)											
		    for c1 = (apply #'deriv (cons coef vars))						    for c1 = (apply #'deriv (cons coef vars))											
		    unless (0? c1)									    unless (0? c1)											
		      collect (cons simp c1))))								      collect (cons simp c1))))											
Files ../simlab/weyl/src/new-topology.lisp and ../weyl/new-topology.lisp are identical
;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-		;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-
;;; ===========================================================================		;;; ===========================================================================
;;;			         Numbers						;;;			         Numbers
;;; ===========================================================================		;;; ===========================================================================
;;; (c) Copyright 1991,1993 Cornell University						;;; (c) Copyright 1991,1993 Cornell University

;;; numbers.lisp,v 1.14 1995/05/24 17:42:07 rz Exp					;;; numbers.lisp,v 1.14 1995/05/24 17:42:07 rz Exp

(in-package "WEYLI")								    |	(in-package :weyli)

(make::adjust-version-numbers Weyl "1.14")					    |	;;; DELETE (make::adjust-version-numbers Weyl "1.14")

;; The Rational Integers  (Z)								;; The Rational Integers  (Z)

(define-domain-element-classes rational-integers					(define-domain-element-classes rational-integers
    rational-integer)									    rational-integer)

(defun rational-integers-print-object (d stream)					(defun rational-integers-print-object (d stream)
  (declare (ignore d))									  (declare (ignore d))
  #+Genera										  #+Genera
  (format stream "~'bZ~")								  (format stream "~'bZ~")
  #-Genera										  #-Genera
  (princ "Z"  stream))									  (princ "Z"  stream))

(define-domain-creator rational-integers ()					    |	(eval-when (:compile-toplevel :load-toplevel)
										    >	  (define-domain-creator rational-integers ()
  (let ((d (make-instance 'rational-integers						    (let ((d (make-instance 'rational-integers
			  :print-function 'rational-integers-print-object)))		                            :print-function 'rational-integers-print-object)))
    (assert-ordered-domain d)								      (assert-ordered-domain d)
    (assert-gcd-domain d)								      (assert-gcd-domain d)
    (assert-unique-factorization-domain d)						      (assert-unique-factorization-domain d)
											      (with-slots (zero one) d
    (with-slots (zero one) d								        (setq zero (make-element d 0))
      (setq zero (make-element d 0))							        (setq one (make-element d 1)))
      (setq one (make-element d 1)))							      d)
										    (
       d)									    (
  :predicate #'(lambda (d) (eql (class-name (class-of d)) 'rational-integers)))	    |	    :predicate #'(lambda (d) (eql (class-name (class-of d)) 'rational-integers))))

(defmethod print-object ((n rational-integer) stream)					(defmethod print-object ((n rational-integer) stream)
  (princ (integer-value n) stream))							  (princ (integer-value n) stream))

											(defmethod make-element ((domain rational-integers) (x integer) &rest ignore)
(defmethod make-element ((domain rational-integers) (x integer) &rest ignore)		  (declare (ignore ignore))
  (declare (ignore ignore))								  (make-instance 'rational-integer :domain domain :value x))
  (make-instance 'rational-integer :domain domain :value x))
											(defmethod weyl:make-element ((domain rational-integers) (x integer)
(defmethod weyl:make-element ((domain rational-integers) (x integer)						      &rest args)
			      &rest args)						  (when (not (null args))
  (when (not (null args))								    (error "Too many arguments to MAKE-ELEMENT of ~S: ~S"
    (error "Too many arguments to MAKE-ELEMENT of ~S: ~S"					   domain (cons x args)))
	   domain (cons x args)))							  (make-instance 'rational-integer :domain domain :value x))
  (make-instance 'rational-integer :domain domain :value x))

											(defmethod coerce ((x integer) (domain rational-integers))
(defmethod coerce ((x integer) (domain rational-integers))				  (make-element domain x))
  (make-element domain x))
											;; The Rational numbers  (Q)
;; The Rational numbers  (Q)
											(define-domain-element-classes rational-numbers
(define-domain-element-classes rational-numbers						  rational-number rational-integer)
    rational-number rational-integer)
											(defun rational-numbers-print-object (d stream)
(defun rational-numbers-print-object (d stream)						  (declare (ignore d))
  (declare (ignore d))									  #+Genera
  #+Genera										  (format stream "~'bQ~")
  (format stream "~'bQ~")								  #-Genera
  #-Genera										  (princ "Q"  stream))
  (princ "Q"  stream))
										    (
(define-domain-creator rational-numbers ()					    |	(eval-when (:compile-toplevel :load-toplevel)
										    >	  (define-domain-creator rational-numbers ()
  (let ((domain (make-instance 'rational-numbers					    (let ((domain (make-instance 'rational-numbers
			       :print-function 'rational-numbers-print-object))		                                 :print-function 'rational-numbers-print-object))
	(Z (get-rational-integers)))							          (Z (get-rational-integers)))
    (make-homomorphism Z								      (make-homomorphism Z
		       #'(lambda (x)							                         #'(lambda (x)
			   (make-element domain (integer-value x)))			                             (make-element domain (integer-value x)))
		       domain)								                         domain)
    domain)										      domain)
  :predicate #'(lambda (d)								    :predicate #'(lambda (d)
		 (eql (class-name (class-of d)) 'rational-numbers)))		    |	                   (eql (class-name (class-of d)) 'rational-numbers))))

(define-domain-creator quotient-field ((ring rational-integers))		    |	(eval-when (:compile-toplevel :load-toplevel)
  (make-rational-numbers))							    |	  (define-domain-creator quotient-field ((ring rational-integers))
										    >	    (make-rational-numbers)))

(defmethod get-quotient-field ((ring rational-integers))				(defmethod get-quotient-field ((ring rational-integers))
  (get-rational-numbers))								  (get-rational-numbers))

											(defmethod print-object ((ratfun rational-number) stream)
(defmethod print-object ((ratfun rational-number) stream)				  (with-numerator-and-denominator (numerator denominator) ratfun
  (with-numerator-and-denominator (numerator denominator) ratfun			    (cond ((1? denominator)
    (cond ((1? denominator)									   (prin1 numerator stream))
	   (prin1 numerator stream))								  (t (prin1 numerator stream)
	  (t (prin1 numerator stream)								     (princ "/" stream)
	     (princ "/" stream)									     (prin1 denominator stream)))))
	     (prin1 denominator stream)))))
											(defmethod make-element ((qf rational-numbers) (num integer) &rest ignore)
											  (declare (ignore ignore))
(defmethod make-element ((qf rational-numbers) (num integer) &rest ignore)		  (make-instance 'rational-integer :domain qf :value num))
  (declare (ignore ignore))
  (make-instance 'rational-integer :domain qf :value num))				(defmethod weyl:make-element ((qf rational-numbers) (num integer) &rest args)
											  (when (not (null args))
(defmethod weyl:make-element ((qf rational-numbers) (num integer) &rest args)		    (error "Too many arguments to MAKE-ELEMENT of ~S: ~S"
  (when (not (null args))									   qf (cons num args)))
    (error "Too many arguments to MAKE-ELEMENT of ~S: ~S"				  (make-instance 'rational-integer :domain qf :value num))
	   qf (cons num args)))
  (make-instance 'rational-integer :domain qf :value num))				(defmethod coerce ((elt integer) (domain rational-numbers))
											  (make-element domain elt))
(defmethod coerce ((elt integer) (domain rational-numbers))
  (make-element domain elt))								(defmethod make-element ((qf rational-numbers) (num ratio) &rest ignore)
											  (declare (ignore ignore))
											  (make-instance 'rational-number :domain qf
(defmethod make-element ((qf rational-numbers) (num ratio) &rest ignore)				 :numerator (cl:numerator num)
  (declare (ignore ignore))										 :denominator (cl:denominator num)))
  (make-instance 'rational-number :domain qf
		 :numerator (cl:numerator num)						(defmethod weyl:make-element ((qf rational-numbers) (num ratio) &rest args)
		 :denominator (cl:denominator num)))					  (when (not (null args))
											    (error "Too many arguments to MAKE-ELEMENT of ~S: ~S"
(defmethod weyl:make-element ((qf rational-numbers) (num ratio) &rest args)			   qf (cons num args)))
  (when (not (null args))								  (make-instance 'rational-number :domain qf
    (error "Too many arguments to MAKE-ELEMENT of ~S: ~S"						 :numerator (cl:numerator num)
	   qf (cons num args)))										 :denominator (cl:denominator num)))
  (make-instance 'rational-number :domain qf
		 :numerator (cl:numerator num)						(defmethod coerce ((elt ratio) (domain rational-numbers))
		 :denominator (cl:denominator num)))					  (make-element domain elt))

(defmethod coerce ((elt ratio) (domain rational-numbers))				(defmethod make-quotient-element
  (make-element domain elt))								    ((qf rational-numbers) (numerator integer) (denominator integer))
											  (cond ((cl:= denominator 1)
												 (make-instance 'rational-integer :domain qf :value numerator))
(defmethod make-quotient-element								(t (make-instance 'rational-number :domain qf
    ((qf rational-numbers) (numerator integer) (denominator integer))						  :numerator numerator
  (cond ((cl:= denominator 1)											  :denominator denominator))))
	 (make-instance 'rational-integer :domain qf :value numerator))
	(t (make-instance 'rational-number :domain qf					;; The Real numbers (R)
			  :numerator numerator
			  :denominator denominator))))					(define-domain-element-classes real-numbers
											  floating-point-number bigfloat rational-integer rational-number)
;; The Real numbers (R)
											(defun real-numbers-print-object (d stream)
(define-domain-element-classes real-numbers						  (declare (ignore d))
    floating-point-number bigfloat rational-integer rational-number)			  #+Genera
											  (format stream "~'bR~")
(defun real-numbers-print-object (d stream)						  #-Genera
  (declare (ignore d))									  (princ "R"  stream))
  #+Genera
  (format stream "~'bR~")								;; For these two there is only one domain.  (We could also implement
  #-Genera										;; several integer domains if we wanted later.)
  (princ "R"  stream))
										    (
;; For these two there is only one domain.  (We could also implement		    (
;; several integer domains if we wanted later.)					    (
										    (
(define-domain-creator real-numbers ()						    |	(eval-when (:compile-toplevel :load-toplevel)
										    >	  (define-domain-creator real-numbers ()
  (let ((domain (make-instance 'real-numbers						    (let ((domain (make-instance 'real-numbers
			       :print-function 'real-numbers-print-object))		                                 :print-function 'real-numbers-print-object))
	(Q (get-rational-numbers)))							          (Q (get-rational-numbers)))
    (make-homomorphism Q								      (make-homomorphism Q
		       #'(lambda (x)							                         #'(lambda (x)
			   (make-element domain						                             (make-element domain
			     (if (typep x 'rational-integer)				                                           (if (typep x 'rational-integer)
				 (integer-value x)					                                               (integer-value x)
				 (cl:/ (qo-numerator x)					                                               (cl:/ (qo-numerator x)
				       (qo-denominator x)))))				                                                     (qo-denominator x)))))
		       domain)								                         domain)
    domain)										      domain)
  :predicate #'(lambda (d) (eql (class-name (class-of d)) 'real-numbers)))	    |	    :predicate #'(lambda (d) (eql (class-name (class-of d)) 'real-numbers))))
	
(defvar *floating-point-precision* 16.							(defvar *floating-point-precision* 16.
  "Precision below which to use the machine floating point representation")		  "Precision below which to use the machine floating point representation")

(defvar *real-precision* *floating-point-precision*					(defvar *real-precision* *floating-point-precision*
  "The default precision when creating a Real number")					  "The default precision when creating a Real number")

											(defmethod print-object ((z floating-point-number) stream)
(defmethod print-object ((z floating-point-number) stream)				  (format stream "~D" (fp-value z)))
  (format stream "~D" (fp-value z)))
											(defmethod make-element ((domain real-numbers) (x integer) &rest ignore)
											  (declare (ignore ignore))
(defmethod make-element ((domain real-numbers) (x integer) &rest ignore)		  (make-instance 'rational-integer :domain domain :value x))
  (declare (ignore ignore))
  (make-instance 'rational-integer :domain domain :value x))				(defmethod weyl:make-element ((domain real-numbers) (x integer) &rest args)
											  (when (not (null args))
(defmethod weyl:make-element ((domain real-numbers) (x integer) &rest args)		    (error "Too many arguments to MAKE-ELEMENT of ~S: ~S"
  (when (not (null args))									   domain (cons x args)))
    (error "Too many arguments to MAKE-ELEMENT of ~S: ~S"				  (make-instance 'rational-integer :domain domain :value x))
	   domain (cons x args)))
  (make-instance 'rational-integer :domain domain :value x))				(defmethod coerce ((elt integer) (domain real-numbers))
											  (make-element domain elt))
(defmethod coerce ((elt integer) (domain real-numbers))
  (make-element domain elt))								(defmethod make-element ((domain real-numbers) (x ratio) &rest ignore)
											  (declare (ignore ignore))
											  (make-instance 'rational-number :domain domain
(defmethod make-element ((domain real-numbers) (x ratio) &rest ignore)					 :numerator (cl:numerator x)
  (declare (ignore ignore))										 :denominator (cl:denominator x)))
  (make-instance 'rational-number :domain domain
		 :numerator (cl:numerator x)						(defmethod weyl:make-element ((domain real-numbers) (x ratio) &rest args)
		 :denominator (cl:denominator x)))					  (when (not (null args))
											    (error "Too many arguments to MAKE-ELEMENT of ~S: ~S"
(defmethod weyl:make-element ((domain real-numbers) (x ratio) &rest args)			   domain (cons x args)))
  (when (not (null args))								  (make-instance 'rational-number :domain domain
    (error "Too many arguments to MAKE-ELEMENT of ~S: ~S"						 :numerator (cl:numerator x)
	   domain (cons x args)))									 :denominator (cl:denominator x)))
  (make-instance 'rational-number :domain domain
		 :numerator (cl:numerator x)						(defmethod coerce ((elt ratio) (domain real-numbers))
		 :denominator (cl:denominator x)))					  (make-element domain elt))

(defmethod coerce ((elt ratio) (domain real-numbers))					;; The following method is needed so that routines that return ratios
  (make-element domain elt))								;; will work.
											(defmethod make-quotient-element
;; The following method is needed so that routines that return ratios			    ((domain real-numbers) (numerator integer) (denominator integer))
;; will work.										  (cond ((cl:= denominator 1)
(defmethod make-quotient-element								 (make-instance 'rational-integer :domain domain :value numerator))
    ((domain real-numbers) (numerator integer) (denominator integer))				(t (make-instance 'rational-number :domain domain
  (cond ((cl:= denominator 1)											  :numerator numerator
	 (make-instance 'rational-integer :domain domain :value numerator))					  :denominator denominator))))
	(t (make-instance 'rational-number :domain domain
			  :numerator numerator						(defmethod make-element ((domain real-numbers) (x float) &rest ignore)
			  :denominator denominator))))					  (declare (ignore ignore))
											  (make-instance 'floating-point-number :domain domain
													 :value x))
(defmethod make-element ((domain real-numbers) (x float) &rest ignore)
  (declare (ignore ignore))								(defmethod weyl:make-element ((domain real-numbers) (x float) &rest args)
  (make-instance 'floating-point-number :domain domain					  (when (not (null args))
		 :value x))								    (error "Too many arguments to MAKE-ELEMENT of ~S: ~S"
												   domain (cons x args)))
(defmethod weyl:make-element ((domain real-numbers) (x float) &rest args)		  (make-instance 'floating-point-number :domain domain
  (when (not (null args))										 :value x))
    (error "Too many arguments to MAKE-ELEMENT of ~S: ~S"
	   domain (cons x args)))							(defmethod coerce ((elt float) (domain real-numbers))
  (make-instance 'floating-point-number :domain domain					  (make-element domain elt))
		 :value x))
											(defmethod zero ((domain real-numbers))
(defmethod coerce ((elt float) (domain real-numbers))					  (weyl:make-element domain 0))
  (make-element domain elt))
											(defmethod one ((domain real-numbers))
											  (weyl:make-element domain 1))
(defmethod zero ((domain real-numbers))
  (weyl:make-element domain 0))								;; The Complex numbers (C)

(defmethod one ((domain real-numbers))							(define-domain-element-classes complex-numbers
  (weyl:make-element domain 1))								  complex-number)

;; The Complex numbers (C)								(defun complex-numbers-print-object (d stream)
											  (declare (ignore d))
(define-domain-element-classes complex-numbers						  #+Genera
    complex-number)									  (format stream "~'bC~")
											  #-Genera
(defun complex-numbers-print-object (d stream)						  (princ "C"  stream))
  (declare (ignore d))
  #+Genera										;; For these two there is only one domain.  (We could also implement
  (format stream "~'bC~")								;; several integer domains if we wanted later.)
  #-Genera
  (princ "C"  stream))								    (
										    (
;; For these two there is only one domain.  (We could also implement		    (
;; several integer domains if we wanted later.)					    (
										    (
(define-domain-creator complex-numbers ()					    |	(eval-when (:compile-toplevel :load-toplevel)
										    >	  (define-domain-creator complex-numbers ()
  (let ((domain (make-instance 'complex-numbers						    (let ((domain (make-instance 'complex-numbers
			       :print-function 'complex-numbers-print-object))		                                 :print-function 'complex-numbers-print-object))
	(R (get-real-numbers)))								          (R (get-real-numbers)))
    (make-homomorphism R								      (make-homomorphism R
		       #'(lambda (x)							                         #'(lambda (x)
			   (make-element domain						                             (make-element domain
			     (cond ((typep x 'rational-integer)				                                           (cond ((typep x 'rational-integer)
				    (integer-value x))					                                                  (integer-value x))
				   ((typep x 'rational-number)				                                                 ((typep x 'rational-number)
				    (cl:/ (qo-numerator x)				                                                  (cl:/ (qo-numerator x)
					  (qo-denominator x)))				                                                        (qo-denominator x)))
				   ((typep x 'floating-point-number)			                                                 ((typep x 'floating-point-number)
				    (fp-value x))					                                                  (fp-value x))
				   (t x))))						                                                 (t x))))
		       domain)								                         domain)
    domain)										      domain)
  :predicate #'(lambda (d) (eql (class-name (class-of d)) 'complex-numbers)))	    |	    :predicate #'(lambda (d) (eql (class-name (class-of d)) 'complex-numbers))))
										    <

(defmethod print-object ((z complex-number) stream)					(defmethod print-object ((z complex-number) stream)
  (with-slots ((x real) (y imag)) z							  (with-slots ((x real) (y imag)) z
    (cond ((0? y)									    (cond ((0? y)
	   (princ x stream))									   (princ x stream))
	  ((0? x)										  ((0? x)
	   (if (1? y)										   (if (1? y)
	       (format stream "i")								       (format stream "i")
	       (format stream "~S i" y)))							       (format stream "~S i" y)))
	  (t (if (1? y)										  (t (if (1? y)
		 (format stream "~S + i" x)								 (format stream "~S + i" x)
		 (format stream "~S + ~S i" x y))))))							 (format stream "~S + ~S i" x y))))))

											(defmethod make-element ((domain complex-numbers) (x integer) &rest args)
(defmethod make-element ((domain complex-numbers) (x integer) &rest args)		  (if (or (null args) (0? (first args)))
  (if (or (null args) (0? (first args)))						      (make-instance 'rational-integer :domain domain :value x)
      (make-instance 'rational-integer :domain domain :value x)				      (make-instance 'complex-number :domain domain
      (make-instance 'complex-number :domain domain							     :realpart x
		     :realpart x									     :imagpart (first args))))
		     :imagpart (first args))))
											(defmethod weyl:make-element ((domain complex-numbers) (x integer) &rest args)
(defmethod weyl:make-element ((domain complex-numbers) (x integer) &rest args)		  (cond ((or (null args)
  (cond ((or (null args)									     (and (0? (first args)) (null (rest args))))
	     (and (0? (first args)) (null (rest args))))					 (make-instance 'rational-integer :domain domain :value x))
	 (make-instance 'rational-integer :domain domain :value x))				((null (rest args))
	((null (rest args))									 (if (and (cl:numberp (first args))
	 (if (and (cl:numberp (first args))								  (not (cl:complexp (first args))))
		  (not (cl:complexp (first args))))						     (make-instance 'complex-number :domain domain
	     (make-instance 'complex-number :domain domain							    :realpart x
			    :realpart x										    :imagpart (first args))
			    :imagpart (first args))						     (error "Wrong type of arguments to MAKE-ELEMENT of ~S: ~S"
	     (error "Wrong type of arguments to MAKE-ELEMENT of ~S: ~S"					    domain (cons x args))))
		    domain (cons x args))))							(t (error "Too many arguments to MAKE-ELEMENT of ~S: ~S"
	(t (error "Too many arguments to MAKE-ELEMENT of ~S: ~S"					  domain (cons x args)))))
		  domain (cons x args)))))
  											(defmethod make-element ((domain complex-numbers) (x ratio) &rest args)
											  (if (or (null args) (0? (first args)))
(defmethod make-element ((domain complex-numbers) (x ratio) &rest args)			      (make-instance 'rational-number :domain domain
  (if (or (null args) (0? (first args)))								     :numerator (cl:numerator x)
      (make-instance 'rational-number :domain domain							     :denominator (cl:denominator x))
		     :numerator (cl:numerator x)					      (make-instance 'complex-number :domain domain
		     :denominator (cl:denominator x))							     :realpart x
      (make-instance 'complex-number :domain domain							     :imagpart (first args))))
		     :realpart x
		     :imagpart (first args))))						(defmethod weyl:make-element ((domain complex-numbers) (x ratio) &rest args)
											  (cond ((or (null args)
(defmethod weyl:make-element ((domain complex-numbers) (x ratio) &rest args)			     (and (0? (first args))
  (cond ((or (null args)										  (null (rest args))))
	     (and (0? (first args))								 (make-instance 'rational-number :domain domain
		  (null (rest args))))										:numerator (cl:numerator x)
	 (make-instance 'rational-number :domain domain								:denominator (cl:denominator x)))
			:numerator (cl:numerator x)						((null (rest args))
			:denominator (cl:denominator x)))					 (if (and (cl:numberp (first args))
	((null (rest args))										  (not (cl:complexp (first args))))
	 (if (and (cl:numberp (first args))							     (make-instance 'complex-number :domain domain
		  (not (cl:complexp (first args))))								    :realpart x
	     (make-instance 'complex-number :domain domain							    :imagpart (first args))
			    :realpart x								     (error "Wrong type of arguments to MAKE-ELEMENT of ~S: ~S"
			    :imagpart (first args))							    domain (cons x args))))
	     (error "Wrong type of arguments to MAKE-ELEMENT of ~S: ~S"				(t (error "Too many arguments to MAKE-ELEMENT of ~S: ~S"
		    domain (cons x args))))								  domain (cons x args)))))
	(t (error "Too many arguments to MAKE-ELEMENT of ~S: ~S"
		  domain (cons x args)))))						(defmethod make-element ((domain complex-numbers) (x float) &rest args)
											  (if (or (null args) (0? (first args)))
											      (make-instance 'floating-point-number :domain domain
(defmethod make-element ((domain complex-numbers) (x float) &rest args)					     :value x)
  (if (or (null args) (0? (first args)))						      (make-instance 'complex-number :domain domain
      (make-instance 'floating-point-number :domain domain						     :realpart x
		     :value x)										     :imagpart (first args))))
      (make-instance 'complex-number :domain domain
		     :realpart x							(defmethod weyl:make-element ((domain complex-numbers) (x float) &rest args)
		     :imagpart (first args))))						  (cond ((or (null args)
												     (and (0? (first args))
(defmethod weyl:make-element ((domain complex-numbers) (x float) &rest args)				  (null (rest args))))
  (cond ((or (null args)									 (make-instance 'floating-point-number :domain domain
	     (and (0? (first args))										:value x))
		  (null (rest args))))								((null (rest args))	 
	 (make-instance 'floating-point-number :domain domain					 (if (and (cl:numberp (first args))
			:value x))									  (not (cl:complexp (first args))))
	((null (rest args))	 								     (make-instance 'complex-number :domain domain
	 (if (and (cl:numberp (first args))									    :realpart x
		  (not (cl:complexp (first args))))								    :imagpart (first args))
	     (make-instance 'complex-number :domain domain					     (error "Wrong type of arguments to MAKE-ELEMENT of ~S: ~S"
			    :realpart x									    domain (cons x args))))
			    :imagpart (first args))						(t (error "Too many arguments to MAKE-ELEMENT of ~S: ~S"
	     (error "Wrong type of arguments to MAKE-ELEMENT of ~S: ~S"					  domain (cons x args)))))
		    domain (cons x args))))
	(t (error "Too many arguments to MAKE-ELEMENT of ~S: ~S"			(defmethod make-element
		  domain (cons x args)))))						    ((domain complex-numbers) (x cl:complex) &rest ignore)
											  (declare (ignore ignore))
(defmethod make-element									  (let ((real (cl:realpart x))
    ((domain complex-numbers) (x cl:complex) &rest ignore)					(imag (cl:imagpart x)))
  (declare (ignore ignore))								    (if (0? imag)
  (let ((real (cl:realpart x))									(make-element domain real)
	(imag (cl:imagpart x)))									(make-instance 'complex-number :domain domain
    (if (0? imag)											       :realpart real :imagpart imag))))
	(make-element domain real)
	(make-instance 'complex-number :domain domain					(defmethod weyl:make-element
		       :realpart real :imagpart imag))))				    ((domain complex-numbers) (x cl:complex) &rest args)
											  (cond ((null args)
(defmethod weyl:make-element									 (make-element domain x))
    ((domain complex-numbers) (x cl:complex) &rest args)					(t (error "Too many arguments to MAKE-ELEMENT of ~S: ~S"
  (cond ((null args)											  domain (cons x args)))))
	 (make-element domain x))
	(t (error "Too many arguments to MAKE-ELEMENT of ~S: ~S"			(defmethod realpart ((x number))
		  domain (cons x args)))))						  (cl:realpart x))

(defmethod realpart ((x number))							(defmethod imagpart ((x number))
  (cl:realpart x))									  (cl:imagpart x))

(defmethod imagpart ((x number))							(defmacro def-realimag-part ((x type) real-body imag-body)
  (cl:imagpart x))									  `(progn
											    (defmethod realpart ((,x ,type))
(defmacro def-realimag-part ((x type) real-body imag-body)				      (let ((domain (domain-of ,x)))
  `(progn										        (if (or (typep domain 'complex-numbers)
     (defmethod realpart ((,x ,type))							                (typep domain 'non-strict-domain))
       (let ((domain (domain-of ,x)))							            ,real-body
	 (if (or (typep domain 'complex-numbers)					            (error "Don't know what \"realpart\" means in ~S"
		 (typep domain 'non-strict-domain))					                   domain))))
	     ,real-body									    (defmethod imagpart ((,x ,type))
	   (error "Don't know what \"realpart\" means in ~S"				      (let ((domain (domain-of ,x)))
		  domain))))								        (if (or (typep domain 'complex-numbers)
     (defmethod imagpart ((,x ,type))							                (typep domain 'non-strict-domain))
       (let ((domain (domain-of ,x)))							            ,imag-body
	 (if (or (typep domain 'complex-numbers)					            (error "Don't know what \"imagpart\" means in ~S"
		 (typep domain 'non-strict-domain))					                   domain))))))
	     ,imag-body
	   (error "Don't know what \"imagpart\" means in ~S"				(def-realimag-part (x rational-integer)
		  domain))))))								    (make-element domain (integer-value x))
											  (zero domain))
(def-realimag-part (x rational-integer)
  (make-element domain (integer-value x))						(def-realimag-part (x rational-number)
  (zero domain))									    (make-element domain (cl:/ (qo-numerator x) (qo-denominator x)))
											  (zero domain))
(def-realimag-part (x rational-number)
  (make-element domain (cl:/ (qo-numerator x) (qo-denominator x)))			(def-realimag-part (x floating-point-number)
  (zero domain))									    (make-element domain (fp-value x))
											  (zero domain))
(def-realimag-part (x floating-point-number)
  (make-element domain (fp-value x))							(def-realimag-part (x bigfloat)
  (zero domain))									    (make-bigfloat domain (bigfloat-mantissa x) (bigfloat-exponent x))
											  (zero domain))
(def-realimag-part (x bigfloat)
  (make-bigfloat domain (bigfloat-mantissa x) (bigfloat-exponent x))			(defmethod realpart ((x complex-number))
  (zero domain))									  (let ((real (cn-realpart x))
												(domain (domain-of x)))
(defmethod realpart ((x complex-number))						    (cond ((typep real 'number)
  (let ((real (cn-realpart x))									   (make-element domain real))
	(domain (domain-of x)))									  (t (make-bigfloat domain
    (cond ((typep real 'number)											    (bigfloat-mantissa real)
	   (make-element domain real))										    (bigfloat-exponent real))))))
	  (t (make-bigfloat domain
			    (bigfloat-mantissa real)					(defmethod imagpart ((x complex-number))
			    (bigfloat-exponent real))))))				  (let ((imag (cn-imagpart x))
												(domain (domain-of x)))
(defmethod imagpart ((x complex-number))						    (cond ((typep imag 'number)
  (let ((imag (cn-imagpart x))									   (make-element domain imag))
	(domain (domain-of x)))									  (t (make-bigfloat domain
    (cond ((typep imag 'number)											    (bigfloat-mantissa imag)
	   (make-element domain imag))										    (bigfloat-exponent imag))))))
	  (t (make-bigfloat domain
			    (bigfloat-mantissa imag)				    (
			    (bigfloat-exponent imag))))))			    (
										    (
										    >	(defgeneric conjugate (number)
										    >	  (:documentation
										    >	   "Return the conjugate value of the number."))
										    >
(defmethod conjugate  ((x number))							(defmethod conjugate  ((x number))
  (cl:conjugate x))									  (cl:conjugate x))

(defmethod conjugate ((x rational-integer))						(defmethod conjugate ((x rational-integer))
  (cond ((or (typep (domain-of x) 'complex-numbers)					  (cond ((or (typep (domain-of x) 'complex-numbers)
	     (typep (domain-of x) 'non-strict-domain))						     (typep (domain-of x) 'non-strict-domain))
	 x)											 x)
	(t (error "Don't know what \"conjugate\" means in ~S"					(t (error "Don't know what \"conjugate\" means in ~S"
		  (domain-of x)))))									  (domain-of x)))))

(defmethod conjugate ((x rational-number))						(defmethod conjugate ((x rational-number))
  (cond ((or (typep (domain-of x) 'complex-numbers)					  (cond ((or (typep (domain-of x) 'complex-numbers)
	     (typep (domain-of x) 'non-strict-domain))						     (typep (domain-of x) 'non-strict-domain))
	 x)											 x)
	(t (error "Don't know what \"conjugate\" means in ~S"					(t (error "Don't know what \"conjugate\" means in ~S"
		  (domain-of x)))))									  (domain-of x)))))

(defmethod conjugate ((x floating-point-number))					(defmethod conjugate ((x floating-point-number))
  (cond ((or (typep (domain-of x) 'complex-numbers)					  (cond ((or (typep (domain-of x) 'complex-numbers)
	     (typep (domain-of x) 'non-strict-domain))						     (typep (domain-of x) 'non-strict-domain))
	 x)											 x)
	(t (error "Don't know what \"conjugate\" means in ~S"					(t (error "Don't know what \"conjugate\" means in ~S"
		  (domain-of x)))))									  (domain-of x)))))

(defmethod conjugate ((x bigfloat))							(defmethod conjugate ((x bigfloat))
  (cond ((or (typep (domain-of x) 'complex-numbers)					  (cond ((or (typep (domain-of x) 'complex-numbers)
	     (typep (domain-of x) 'non-strict-domain))						     (typep (domain-of x) 'non-strict-domain))
	 x)											 x)
	(t (error "Don't know what \"conjugate\" means in ~S"					(t (error "Don't know what \"conjugate\" means in ~S"
		  (domain-of x)))))									  (domain-of x)))))

(defmethod conjugate ((x complex-number))						(defmethod conjugate ((x complex-number))
  (make-instance 'complex-number :domain (domain-of x)					  (make-instance 'complex-number :domain (domain-of x)
		 :realpart (cn-realpart x)								 :realpart (cn-realpart x)
		 :imagpart (- (cn-imagpart x))))							 :imagpart (- (cn-imagpart x))))

(defmethod abs ((x number))								(defmethod abs ((x number))
  (cl:abs x))										  (cl:abs x))

(defmethod abs ((x rational-integer))							(defmethod abs ((x rational-integer))
  (make-element (domain-of x) (cl:abs (integer-value x))))				  (make-element (domain-of x) (cl:abs (integer-value x))))

(defmethod abs ((x rational-number))							(defmethod abs ((x rational-number))
  (make-instance 'rational-number							  (make-instance 'rational-number
		 :domain (domain-of x)									 :domain (domain-of x)
		 :numerator (abs (qo-numerator x))     							 :numerator (abs (qo-numerator x))     
		 :denominator (qo-denominator x)))							 :denominator (qo-denominator x)))

(defmethod abs ((z floating-point-number))						(defmethod abs ((z floating-point-number))
  (make-element (domain-of z) (cl:abs (fp-value z))))					  (make-element (domain-of z) (cl:abs (fp-value z))))

(defmethod abs ((number bigfloat))							(defmethod abs ((number bigfloat))
  (bind-domain-context (domain-of number)						  (bind-domain-context (domain-of number)
    (bf-abs number)))									    (bf-abs number)))

(defmethod abs ((z complex-number))							(defmethod abs ((z complex-number))
  (let ((x (cn-realpart z))								  (let ((x (cn-realpart z))
	(y (cn-imagpart z)))									(y (cn-imagpart z)))
    (make-element (domain-of z) (sqrt (+ (* x x) (* y y))))))			    |	    (make-element (domain-of z) (cl:sqrt (+ (* x x) (* y y))))))
										    >
										    >	(defgeneric phase (number)
										    >	  (:documentation
										    >	   "Return the phase of the number."))

(defmethod phase ((x number))								(defmethod phase ((x number))
  (cl:phase x))										  (cl:phase x))

(defmethod phase ((x rational-integer))							(defmethod phase ((x rational-integer))
  (zero (domain-of x)))									  (zero (domain-of x)))

(defmethod phase ((x rational-number))							(defmethod phase ((x rational-number))
  (zero (domain-of x)))									  (zero (domain-of x)))

(defmethod phase ((z floating-point-number))						(defmethod phase ((z floating-point-number))
  (zero (domain-of z)))									  (zero (domain-of z)))

(defmethod phase ((number bigfloat))							(defmethod phase ((number bigfloat))
  (zero (domain-of number)))								  (zero (domain-of number)))

(defmethod phase ((z complex-number))							(defmethod phase ((z complex-number))
  (let ((x (cn-realpart z))								  (let ((x (cn-realpart z))
	(y (cn-imagpart z)))									(y (cn-imagpart z)))
    (make-element (domain-of z) (atan y x))))						    (make-element (domain-of z) (atan y x))))

										    >	(defgeneric random-constant (domain &optional height)
										    >	  (:documentation
										    >	   "Return a random constant."))
										    >
(defmethod random-constant ((domain numeric-domain) &optional height)			(defmethod random-constant ((domain numeric-domain) &optional height)
  (random domain height))								  (random domain height))

(defvar *default-random-height* most-positive-fixnum)					(defvar *default-random-height* most-positive-fixnum)

(defmethod random ((domain rational-integers) 						(defmethod random ((domain rational-integers) 
                   &optional (height *default-random-height*))				                   &optional (height *default-random-height*))
  (make-element domain (cl:random height)))						  (make-element domain (cl:random height)))

(defmethod random ((domain rational-numbers) 						(defmethod random ((domain rational-numbers) 
                   &optional (height *default-random-height*))				                   &optional (height *default-random-height*))
  (make-element domain (/ (if (cl:zerop (cl:random 2))					  (make-element domain (/ (if (cl:zerop (cl:random 2))
                              (cl:random height)					                              (cl:random height)
                              (cl:- (cl:random height)					                              (cl:- (cl:random height)
                          (cl:random height))))))					                          (cl:random height))))))

(defun random-floating-number (height)							(defun random-floating-number (height)
  (let ((num (cl:+ (float (cl:random height))						  (let ((num (cl:+ (float (cl:random height))
                     (cl:/ (float (cl:random height))					                   (cl:/ (float (cl:random height))
                             (float (cl:random height))))))				                         (float (cl:random height))))))
    (if (cl:zerop (cl:random 2)) num (cl:- num))))					    (if (cl:zerop (cl:random 2)) num (cl:- num))))

(defmethod random ((domain real-numbers) 						(defmethod random ((domain real-numbers) 
                   &optional (height *default-random-height*))				                   &optional (height *default-random-height*))
  (make-element domain (random-floating-number height)))				  (make-element domain (random-floating-number height)))

(defmethod random ((domain complex-numbers)						(defmethod random ((domain complex-numbers)
                   &optional (height *default-random-height*))				                   &optional (height *default-random-height*))
  (make-instance 'complex-number :domain domain						  (make-instance 'complex-number :domain domain
                 :realpart (random-floating-number height)				                 :realpart (random-floating-number height)
                 :imagpart (random-floating-number height)))				                 :imagpart (random-floating-number height)))

(defmethod height ((x number))								(defmethod height ((x number))
  (cl:abs x))										  (cl:abs x))

(defmethod height ((x rational-integer))						(defmethod height ((x rational-integer))
  (make-element (get-real-numbers) (cl:abs (integer-value x))))				  (make-element (get-real-numbers) (cl:abs (integer-value x))))

(defmethod height ((x rational-number))							(defmethod height ((x rational-number))
  (make-element (get-real-numbers) (cl:max (cl:abs (qo-numerator x))     		  (make-element (get-real-numbers) (cl:max (cl:abs (qo-numerator x))     
                                             (qo-denominator x))))			                                           (qo-denominator x))))

(defmethod height ((z floating-point-number))						(defmethod height ((z floating-point-number))
  (make-element (get-real-numbers) (cl:abs (fp-value z))))				  (make-element (get-real-numbers) (cl:abs (fp-value z))))

;; FIXTHIS I think this is buggy!							;; FIXTHIS I think this is buggy!
(defmethod height ((number bigfloat))							(defmethod height ((number bigfloat))
  (bind-domain-context (domain-of number)						  (bind-domain-context (domain-of number)
    (bf-abs number)))									    (bf-abs number)))

(defmethod height ((z complex-number))							(defmethod height ((z complex-number))
  (let ((x (cn-realpart z))								  (let ((x (cn-realpart z))
	(y (cn-imagpart z)))									(y (cn-imagpart z)))
    (make-element (get-real-numbers) (cl:max (cl:abs x) (cl:abs y)))))			    (make-element (get-real-numbers) (cl:max (cl:abs x) (cl:abs y)))))

										    >	(defgeneric convert-to-lisp-number (number)
										    >	  (:documentation
										    >	   "Return a lisp representation of the number."))
										    >
(defmethod convert-to-lisp-number ((x number))						(defmethod convert-to-lisp-number ((x number))
  x)											  x)

										    >	(defmethod convert-to-lisp-number ((x numeric))
										    >	  x)
										    >
(defmethod convert-to-lisp-number ((x rational-integer))				(defmethod convert-to-lisp-number ((x rational-integer))
  (integer-value x))									  (integer-value x))

(defmethod convert-to-lisp-number ((x rational-number))					(defmethod convert-to-lisp-number ((x rational-number))
  (cl:/ (qo-numerator x) (qo-denominator x)))						  (cl:/ (qo-numerator x) (qo-denominator x)))

(defmethod convert-to-lisp-number ((x floating-point-number))				(defmethod convert-to-lisp-number ((x floating-point-number))
  (fp-value x))										  (fp-value x))

(defmethod convert-to-lisp-number ((x bigfloat))					(defmethod convert-to-lisp-number ((x bigfloat))
  x)											  x)

(defun parse-numeric-obj (num)								(defun parse-numeric-obj (num)
  ;;(declare (values num type domain))							  ;;(declare (values num type domain))
  (cond ((typep num 'number)								  (cond ((typep num 'number)
	 (values num										 (values num
		 (if (typep num 'integer) 'integer (cl:type-of num))					 (if (typep num 'integer) 'integer (cl:type-of num))
		 nil))											 nil))
	((typep num 'rational-integer)								((typep num 'rational-integer)
	 (values (integer-value num) 'rational-integer (domain-of num)))			 (values (integer-value num) 'rational-integer (domain-of num)))
	((typep num 'rational-number)								((typep num 'rational-number)
	 (values (cl:/ (qo-numerator num)							 (values (cl:/ (qo-numerator num)
			 (qo-denominaTor num))						                       (qo-denominaTor num))
		 'rational-number									 'rational-number
		 (domain-of num)))									 (domain-of num)))
	((typep num 'numeric)									((typep num 'numeric)
	 (values num (class-name (class-of num)) (domain-of num)))				 (values num (class-name (class-of num)) (domain-of num)))
	(t (error "~S is not a numeric object" num))))						(t (error "~S is not a numeric object" num))))

(defmethod numerator ((n rational-integer))						(defmethod numerator ((n rational-integer))
  (cond ((or (field? (domain-of n))							  (cond ((or (field? (domain-of n))
	     (typep (domain-of n) 'non-strict-domain))						     (typep (domain-of n) 'non-strict-domain))
	 n)											 n)
	(t (error "Don't know what \"numerator\" means in ~S"					(t (error "Don't know what \"numerator\" means in ~S"
		  (domain-of n)))))									  (domain-of n)))))

(defmethod denominator ((n rational-integer))						(defmethod denominator ((n rational-integer))
  (cond ((or (field? (domain-of n))							  (cond ((or (field? (domain-of n))
	     (typep (domain-of n) 'non-strict-domain))						     (typep (domain-of n) 'non-strict-domain))
	 (one (domain-of n)))									 (one (domain-of n)))
	(t (error "Don't know what \"denominator\" means in ~S"					(t (error "Don't know what \"denominator\" means in ~S"
		  (domain-of n)))))									  (domain-of n)))))

(defmethod 0? (x)									(defmethod 0? (x)
  (declare (ignore x))									  (declare (ignore x))
  nil)											  nil)

(defmethod 0? ((x number))								(defmethod 0? ((x number))
  (cl:zerop x))										  (cl:zerop x))

(defmethod 0? ((x rational-integer))							(defmethod 0? ((x rational-integer))
  (cl:zerop (integer-value x)))								  (cl:zerop (integer-value x)))

(defmethod 0? ((x rational-number))							(defmethod 0? ((x rational-number))
  nil)											  nil)

(defmethod 0? ((x floating-point-number))						(defmethod 0? ((x floating-point-number))
  (cl:zerop (fp-value x)))								  (cl:zerop (fp-value x)))

(defmethod 0? ((number bigfloat))							(defmethod 0? ((number bigfloat))
  (equal (bigfloat-mantissa number) 0))							  (equal (bigfloat-mantissa number) 0))

(defmethod 0? ((x complex-number))							(defmethod 0? ((x complex-number))
  (and (0? (realpart x)) (0? (imagpart x))))						  (and (0? (realpart x)) (0? (imagpart x))))

(defmethod 1? (x)									(defmethod 1? (x)
  (declare (ignore x))									  (declare (ignore x))
  nil)											  nil)

(defmethod 1? ((x number))  								(defmethod 1? ((x number))  
  (= x 1))										  (= x 1))

(defmethod 1? ((x rational-integer))  							(defmethod 1? ((x rational-integer))  
  (eql (integer-value x) 1))								  (eql (integer-value x) 1))

(defmethod 1? ((x rational-number))							(defmethod 1? ((x rational-number))
  nil)											  nil)

(defmethod 1? ((x floating-point-number))						(defmethod 1? ((x floating-point-number))
  (cl:= 1.0 (fp-value x)))								  (cl:= 1.0 (fp-value x)))

(defmethod 1? ((number bigfloat))							(defmethod 1? ((number bigfloat))
  (and (equal (bigfloat-mantissa number) 1)						  (and (equal (bigfloat-mantissa number) 1)
       (eql (bigfloat-exponent number) 0)))						       (eql (bigfloat-exponent number) 0)))

(defmethod 1? ((x complex-number))							(defmethod 1? ((x complex-number))
  (and (1? (realpart x)) (0? (imagpart x))))						  (and (1? (realpart x)) (0? (imagpart x))))

(defmethod minus ((x number))								(defmethod minus ((x number))
  (cl:- x))										  (cl:- x))

(defmethod minus ((x rational-integer))							(defmethod minus ((x rational-integer))
  (make-element (domain-of x) (cl:- (integer-value x))))				  (make-element (domain-of x) (cl:- (integer-value x))))

(defmethod minus ((x rational-number))							(defmethod minus ((x rational-number))
  (make-quotient-element (domain-of x)							  (make-quotient-element (domain-of x)
			 (cl:- (qo-numerator x))								 (cl:- (qo-numerator x))
			 (qo-denominator x)))									 (qo-denominator x)))

(defmethod minus ((x floating-point-number))						(defmethod minus ((x floating-point-number))
  (make-element (domain-of x) (cl:- (fp-value x))))					  (make-element (domain-of x) (cl:- (fp-value x))))

(defmethod minus ((number bigfloat))							(defmethod minus ((number bigfloat))
  (bind-domain-context (domain-of number)						  (bind-domain-context (domain-of number)
    (bf-minus number)))									    (bf-minus number)))

(defmethod minus ((x complex-number))							(defmethod minus ((x complex-number))
  (make-element (domain-of x) (- (cn-realpart x)) (- (cn-imagpart x))))			  (make-element (domain-of x) (- (cn-realpart x)) (- (cn-imagpart x))))

											(defmethod minus? ((x number))
(defmethod minus? ((x number))								  (cl:minusp x))
  (cl:minusp x))
											(defmethod minus? ((x cl:complex))
(defmethod minus? ((x cl:complex))							  nil)
  nil)
											(defmethod minus? ((x rational-integer))
(defmethod minus? ((x rational-integer))						  (cl:minusp (integer-value x)))
  (cl:minusp (integer-value x)))
											(defmethod minus? ((x rational-number))
(defmethod minus? ((x rational-number))							  (cl:minusp (qo-numerator x)))
  (cl:minusp (qo-numerator x)))
											(defmethod minus? ((x floating-point-number))
(defmethod minus? ((x floating-point-number))						  (cl:minusp (fp-value x)))
  (cl:minusp (fp-value x)))
											(defmethod minus? ((x bigfloat))
(defmethod minus? ((x bigfloat))							  (cl:minusp (bigfloat-mantissa x)))
  (cl:minusp (bigfloat-mantissa x)))
										    (
										    >	(defgeneric plus? (number)
										    >	  (:documentation
										    >	   "Return true if the number is positive."))
										    >
(defmethod plus? ((x number))								(defmethod plus? ((x number))
  (cl:plusp x))										  (cl:plusp x))

(defmethod plus? ((x cl:complex))							(defmethod plus? ((x cl:complex))
  (not (cl:zerop x)))									  (not (cl:zerop x)))

(defmethod plus? ((x rational-integer))							(defmethod plus? ((x rational-integer))
  (cl:plusp (integer-value x)))								  (cl:plusp (integer-value x)))

(defmethod plus? ((x rational-number))							(defmethod plus? ((x rational-number))
  (cl:plusp (qo-numerator x)))								  (cl:plusp (qo-numerator x)))

(defmethod plus? ((x floating-point-number))						(defmethod plus? ((x floating-point-number))
  (cl:plusp (fp-value x)))								  (cl:plusp (fp-value x)))

(defmethod plus? ((x bigfloat))								(defmethod plus? ((x bigfloat))
  (cl:plusp (bigfloat-mantissa x)))							  (cl:plusp (bigfloat-mantissa x)))

										    >	(defgeneric integer? (number)
										    >	  (:documentation
										    >	   "Return true if the number is an integer."))
										    >
(defmethod integer? ((x number))							(defmethod integer? ((x number))
  (cl:integerp x))									  (cl:integerp x))

(defmethod integer? ((x numeric))							(defmethod integer? ((x numeric))
  nil)											  nil)

(defmethod integer? ((x rational-integer))						(defmethod integer? ((x rational-integer))
  t)											  t)

(defmethod recip ((x number))								(defmethod recip ((x number))
  (cl:/ x))										  (cl:/ x))

(defmethod recip ((x rational-integer))							(defmethod recip ((x rational-integer))
  (let ((x-val (integer-value x))							  (let ((x-val (integer-value x))
	(domain (domain-of x)))									(domain (domain-of x)))
    (cond ((or (eql x-val 1) (eql x-val -1))						    (cond ((or (eql x-val 1) (eql x-val -1))
	   x)											   x)
	  ((or (field? domain)									  ((or (field? domain)
	       (typep domain 'non-strict-domain))						       (typep domain 'non-strict-domain))
	   (make-element domain (cl:/ 1 x-val)))						   (make-element domain (cl:/ 1 x-val)))
	  (t 											  (t 
	   (error "Trying to take the reciprocal of the rational integer ~S"			   (error "Trying to take the reciprocal of the rational integer ~S"
		  x)))))										  x)))))

;; recip of a rational integer is covered by QUOTIENT-ELEMENT				;; recip of a rational integer is covered by QUOTIENT-ELEMENT

(defmethod recip ((x floating-point-number))						(defmethod recip ((x floating-point-number))
  (when (0? x)										  (when (0? x)
    (error "Error: Attempt take reciprocal of zero: ~S" x))				    (error "Error: Attempt take reciprocal of zero: ~S" x))
    (make-element (domain-of x) (cl:/ (fp-value x))))					  (make-element (domain-of x) (cl:/ (fp-value x))))

(defmethod recip ((z complex-number))							(defmethod recip ((z complex-number))
  (when (0? z)										  (when (0? z)
    (error "Error: Attempt take reciprocal of zero: ~S" z))				    (error "Error: Attempt take reciprocal of zero: ~S" z))
  (let ((x (realpart z))								  (let ((x (realpart z))
	(y (imagpart z))									(y (imagpart z))
	denom)											denom)
    (setq denom (+ (* x x) (* y y)))							    (setq denom (+ (* x x) (* y y)))
    (make-element (domain-of z)								    (make-element (domain-of z)
      (convert-to-lisp-number (/ x denom))						                  (convert-to-lisp-number (/ x denom))
      (convert-to-lisp-number (/ (- y) denom)))))					                  (convert-to-lisp-number (/ (- y) denom)))))

										    >	(defgeneric sqrt (number)
										    >	  (:documentation
										    >	   "Return the square root of the number."))
										    >
(defmethod sqrt ((x number))								(defmethod sqrt ((x number))
  (cl:sqrt  x))										  (cl:sqrt  x))

(defmethod sqrt ((x integer))								(defmethod sqrt ((x integer))
  (let* ((n (cl:abs x))									  (let* ((n (cl:abs x))
	 (root (faster-isqrt n)))								 (root (faster-isqrt n)))
    (unless (cl:= n (cl:* root root))							    (unless (cl:= n (cl:* root root))
      (setq root (cl:sqrt n)))								      (setq root (cl:sqrt n)))
    (if (minus? x) (cl:complex 0 root)							    (if (minus? x) (cl:complex 0 root)
	root)))											root)))

(defmethod sqrt ((x rational-integer))							(defmethod sqrt ((x rational-integer))
  (let ((domain (domain-of x)))								  (let ((domain (domain-of x)))
    (cond ((complete-set? domain)							    (cond ((complete-set? domain)
	   (make-element domain (cl:sqrt (integer-value x))))					   (make-element domain (cl:sqrt (integer-value x))))
	  ((minus? (integer-value x))								  ((minus? (integer-value x))
	   (error "Can't take the sqrt of a negative number: ~S" x))				   (error "Can't take the sqrt of a negative number: ~S" x))
	  (t (let* ((n (integer-value x))							  (t (let* ((n (integer-value x))
		    (root (faster-isqrt n)))								    (root (faster-isqrt n)))
	       (cond ((cl:= n (cl:* root root))							       (cond ((cl:= n (cl:* root root))
		      (make-element domain root))							      (make-element domain root))
		     (t (error "~S does not have a sqrt in ~S"						     (t (error "~S does not have a sqrt in ~S"
			       x domain))))))))									       x domain))))))))

(defmethod sqrt ((x rational-number))							(defmethod sqrt ((x rational-number))
  (let ((domain (domain-of x)))								  (let ((domain (domain-of x)))
    (cond ((complete-set? domain)							    (cond ((complete-set? domain)
	   (make-element domain (cl:sqrt (cl:/ (qo-numerator x)					   (make-element domain (cl:sqrt (cl:/ (qo-numerator x)
						   (qo-denominator x)))))		                                               (qo-denominator x)))))
	  (t (let* ((n (qo-numerator x))							  (t (let* ((n (qo-numerator x))
		    (d (qo-denominator x))								    (d (qo-denominator x))
		    (n-root (faster-isqrt n))								    (n-root (faster-isqrt n))
		    (d-root (faster-isqrt d)))								    (d-root (faster-isqrt d)))
	       (cond ((and (cl:= n (cl:* n-root n-root))					       (cond ((and (cl:= n (cl:* n-root n-root))
			   (cl:= d (cl:* d-root d-root)))							   (cl:= d (cl:* d-root d-root)))
		      (make-quotient-element domain n-root d-root))					      (make-quotient-element domain n-root d-root))
		     (t (error "~S does not have a sqrt in ~S"						     (t (error "~S does not have a sqrt in ~S"
			       x domain))))))))									       x domain))))))))

(defmethod sqrt ((x floating-point-number)) 						(defmethod sqrt ((x floating-point-number)) 
  (make-element (domain-of x) (cl:sqrt (fp-value x))))					  (make-element (domain-of x) (cl:sqrt (fp-value x))))

(defmethod sqrt ((number bigfloat))							(defmethod sqrt ((number bigfloat))
  (bind-domain-context (domain-of number)						  (bind-domain-context (domain-of number)
    (bf-sqrt number *REAL-PRECISION*)))							    (bf-sqrt number *REAL-PRECISION*)))

(defmethod sqrt ((number complex-number))						(defmethod sqrt ((number complex-number))
  (let* ((x (cn-realpart number))							  (let* ((x (cn-realpart number))
	 (y (cn-imagpart number))								 (y (cn-imagpart number))
	 (mag (/ (sqrt (+ (* x x) (* y y))) 2)))						 (mag (/ (sqrt (+ (* x x) (* y y))) 2)))
    (make-element (domain-of number)							    (make-element (domain-of number)
      (sqrt (+ mag (/ x 2)))								                  (sqrt (+ mag (/ x 2)))
      (if (plus? y)									                  (if (plus? y)
	  (sqrt (- mag (/ x 2)))							                      (sqrt (- mag (/ x 2)))
	  (- (sqrt (- mag (/ x 2))))))))						                      (- (sqrt (- mag (/ x 2))))))))

;; The following idea was stolen from the Mindy implementation of Dylan.		;; The following idea was stolen from the Mindy implementation of Dylan.
(defmacro with-contagion ((x y) &body body)						(defmacro with-contagion ((x y) &body body)
  (let (x-val y-val)									  (let (x-val y-val)
    (if (atom x) (setq x-val x)								    (if (atom x) (setq x-val x)
	(setq x-val (second x)									(setq x-val (second x)
	      x (first x)))									      x (first x)))
    (if (atom y) (setq y-val y)								    (if (atom y) (setq y-val y)
	(setq y-val (second y)									(setq y-val (second y)
	      y (first y)))									      y (first y)))
    `(multiple-value-bind (,x ,y) (contagion ,x-val ,y-val)				    `(multiple-value-bind (,x ,y) (contagion ,x-val ,y-val)
       ,@body)))									      ,@body)))

;; If this changes, you should also change the numeric-numeric part of			;; If this changes, you should also change the numeric-numeric part of
;; def-binary-coercions in morphisms.lisp						;; def-binary-coercions in morphisms.lisp
(defmacro define-binary-contagions (binary-op &key (numeric-numeric? t)			(defmacro define-binary-contagions (binary-op &key (numeric-numeric? t)
					      (number-numeric? t))			                                    (number-numeric? t))
  `(progn										  `(progn
     ,@(when number-numeric?								    ,@(when number-numeric?
	`((defmethod ,binary-op ((.x. number) (.y. numeric))				            `((defmethod ,binary-op ((.x. number) (.y. numeric))
	    (with-contagion (.x. .y.) (,binary-op .x. .y.)))				                (with-contagion (.x. .y.) (,binary-op .x. .y.)))
	  (defmethod ,binary-op ((.x. numeric) (.y. number))				              (defmethod ,binary-op ((.x. numeric) (.y. number))
	    (with-contagion (.x. .y.) (,binary-op .x. .y.)))))				                (with-contagion (.x. .y.) (,binary-op .x. .y.)))))
     ,(when numeric-numeric?								    ,(when numeric-numeric?
	`(defmethod ,binary-op ((.x. numeric) (.y. numeric))				           `(defmethod ,binary-op ((.x. numeric) (.y. numeric))
	   (let ((x-domain (domain-of .x.))						             (let ((x-domain (domain-of .x.))
		 (y-domain (domain-of .y.)))						                   (y-domain (domain-of .y.)))
	     (cond ((eql x-domain y-domain)						               (cond ((eql x-domain y-domain)
		    (when (eql (class-of .x.) (class-of .y.))				                      (when (eql (class-of .x.) (class-of .y.))
		      (error "No applicable ~A method for ~S and ~S" .x. .y.))	    |	                        (error "No applicable contagion method for ~S and ~S" .x. 
		    (with-contagion (.x. .y.) (,binary-op .x. .y.)))			                      (with-contagion (.x. .y.) (,binary-op .x. .y.)))
		   ((typep (domain-of .x.) 'non-strict-domain)				                     ((typep (domain-of .x.) 'non-strict-domain)
		    (,binary-op .x. (coerce .y. (domain-of .x.))))			                      (,binary-op .x. (coerce .y. (domain-of .x.))))
		   ((typep (domain-of .y.) 'non-strict-domain)				                     ((typep (domain-of .y.) 'non-strict-domain)
		    (,binary-op (coerce .x. (domain-of .y.)) .y.))			                      (,binary-op (coerce .x. (domain-of .y.)) .y.))
		   (t (call-next-method))))))))						                     (t (call-next-method))))))))

										    >	(defgeneric contagion (number1 number2)
										    >	  (:documentation
										    >	   "The purpose of this method is unknown."))
										    >
(defmethod contagion ((x number) (y number))						(defmethod contagion ((x number) (y number))
  (values x y))										  (values x y))

(defmethod contagion ((x number) (y numeric))						(defmethod contagion ((x number) (y numeric))
  (values (coerce x (domain-of y)) y))							  (values (coerce x (domain-of y)) y))

(defmethod contagion ((x numeric) (y number))						(defmethod contagion ((x numeric) (y number))
  (values x (coerce y (domain-of x))))							  (values x (coerce y (domain-of x))))

(defmethod-sd contagion ((x numeric) (y numeric))					(defmethod-sd contagion ((x numeric) (y numeric))
  (values x y))										  (values x y))

(defmethod-sd contagion ((x rational-integer) (y rational-number))			(defmethod-sd contagion ((x rational-integer) (y rational-number))
  (values (make-instance 'rational-number :domain domain				  (values (make-instance 'rational-number :domain domain
			 :numerator (integer-value x)								 :numerator (integer-value x)
			 :denominator 1)									 :denominator 1)
	  y))											  y))

(defmethod-sd contagion ((x rational-integer) (y floating-point-number))		(defmethod-sd contagion ((x rational-integer) (y floating-point-number))
  (values (make-element domain (float (integer-value x))) y))				  (values (make-element domain (float (integer-value x))) y))

(defmethod-sd contagion ((x rational-integer) (y bigfloat))				(defmethod-sd contagion ((x rational-integer) (y bigfloat))
  (values (convert-to-bigfloat x) y))							  (values (convert-to-bigfloat x) y))

(defmethod-sd contagion ((x rational-integer) (y complex-number))			(defmethod-sd contagion ((x rational-integer) (y complex-number))
  (values (make-instance 'complex-number :domain domain					  (values (make-instance 'complex-number :domain domain
			 :realpart x										 :realpart x
			 :imagpart 0)										 :imagpart 0)
	  y))											  y))

(defmethod-sd contagion ((x rational-number) (y rational-integer))			(defmethod-sd contagion ((x rational-number) (y rational-integer))
  (values x										  (values x
	  (make-instance 'rational-number :domain domain					  (make-instance 'rational-number :domain domain
			 :numerator (integer-value y)								 :numerator (integer-value y)
			 :denominator 1)))									 :denominator 1)))

(defmethod-sd contagion ((x rational-number) (y floating-point-number))			(defmethod-sd contagion ((x rational-number) (y floating-point-number))
  (values (make-element domain (cl:/ (float (qo-numerator x))				  (values (make-element domain (cl:/ (float (qo-numerator x))
				     (qo-denominator x)))								     (qo-denominator x)))
	  y))											  y))
(defmethod-sd contagion ((x rational-number) (y bigfloat))
  (values (convert-to-bigfloat x) y))							(defmethod-sd contagion ((x rational-number) (y bigfloat))
											  (values (convert-to-bigfloat x) y))
(defmethod-sd contagion ((x rational-number) (y complex-number))
  (values (make-instance 'complex-number :domain domain					(defmethod-sd contagion ((x rational-number) (y complex-number))
			 :realpart (cl:/ (qo-denominator x)				  (values (make-instance 'complex-number :domain domain
					 (qo-numerator x))							 :realpart (cl:/ (qo-denominator x)
			 :imagpart 0)												 (qo-numerator x))
	  y))													 :imagpart 0)
												  y))
(defmethod-sd contagion ((x floating-point-number) (y rational-integer))
  (values x (make-element domain (float (integer-value y)))))				(defmethod-sd contagion ((x floating-point-number) (y rational-integer))
											  (values x (make-element domain (float (integer-value y)))))
(defmethod-sd contagion ((x floating-point-number) (y rational-number))
  (values x										(defmethod-sd contagion ((x floating-point-number) (y rational-number))
	  (make-element domain (cl:/ (float (qo-numerator y))				  (values x
				     (qo-denominator y)))))					  (make-element domain (cl:/ (float (qo-numerator y))
															     (qo-denominator y)))))
(defmethod-sd contagion ((x floating-point-number) (y bigfloat))
  (values (convert-to-bigfloat x) y))							(defmethod-sd contagion ((x floating-point-number) (y bigfloat))
											  (values (convert-to-bigfloat x) y))
(defmethod-sd contagion ((x floating-point-number) (y complex-number))
  (values (make-instance 'complex-number :domain domain					(defmethod-sd contagion ((x floating-point-number) (y complex-number))
			 :realpart (fp-value x)						  (values (make-instance 'complex-number :domain domain
			 :imagpart 0.0)										 :realpart (fp-value x)
	  y))													 :imagpart 0.0)
												  y))
(defmethod-sd contagion ((x bigfloat) (y rational-integer))
  (values x (make-element domain (float (integer-value y)))))				(defmethod-sd contagion ((x bigfloat) (y rational-integer))
											  (values x (make-element domain (float (integer-value y)))))
(defmethod-sd contagion ((x bigfloat) (y rational-number))
  (values x										(defmethod-sd contagion ((x bigfloat) (y rational-number))
	  (make-element domain (cl:/ (float (qo-numerator y))				  (values x
				     (qo-denominator y)))))					  (make-element domain (cl:/ (float (qo-numerator y))
															     (qo-denominator y)))))
(defmethod-sd contagion ((x bigfloat) (y floating-point-number))
  (values (convert-to-bigfloat x) y))							(defmethod-sd contagion ((x bigfloat) (y floating-point-number))
											  (values (convert-to-bigfloat x) y))
(defmethod-sd contagion ((x bigfloat) (y complex-number))
  (values (make-instance 'complex-number :domain domain					(defmethod-sd contagion ((x bigfloat) (y complex-number))
			 :realpart x							  (values (make-instance 'complex-number :domain domain
			 :imagpart 0.0)										 :realpart x
	  y))													 :imagpart 0.0)
												  y))
(defmethod-sd contagion ((x complex-number) (y rational-integer))
  (values x (make-instance 'complex-number :domain domain				(defmethod-sd contagion ((x complex-number) (y rational-integer))
			   :realpart (integer-value y)					  (values x (make-instance 'complex-number :domain domain
			   :imagpart 0)))									   :realpart (integer-value y)
														   :imagpart 0)))
(defmethod-sd contagion ((x complex-number) (y rational-number))
  (values x										(defmethod-sd contagion ((x complex-number) (y rational-number))
	  (make-instance 'complex-number :domain domain					  (values x
			   :realpart (cl:/ (qo-numerator y)					  (make-instance 'complex-number :domain domain
					   (qo-denominator y))				                         :realpart (cl:/ (qo-numerator y)
			   :imagpart 0)))						                                         (qo-denominator y))
											                         :imagpart 0)))
(defmethod-sd contagion ((x complex-number) (y floating-point-number))
  (values (make-instance 'complex-number :domain domain					(defmethod-sd contagion ((x complex-number) (y floating-point-number))
			 :realpart (fp-value x)						  (values (make-instance 'complex-number :domain domain
			 :imagpart 0.0)										 :realpart (fp-value x)
	  y))													 :imagpart 0.0)
												  y))
(defmethod-sd contagion ((x complex-number) (y bigfloat))
  (values (make-instance 'complex-number :domain domain					(defmethod-sd contagion ((x complex-number) (y bigfloat))
			 :realpart y							  (values (make-instance 'complex-number :domain domain
			 :imagpart 0.0)										 :realpart y
	  y))													 :imagpart 0.0)
												  y))
;; These routines don't really need the contagion tools. 
											;; These routines don't really need the contagion tools. 
(defmethod binary= ((x number) (y number))
  (cl:= x y))										(defmethod binary= ((x number) (y number))
											  (cl:= x y))
(defmethod binary= ((x number) (y numeric))
  (cl:= x (convert-to-lisp-number y)))							(defmethod binary= ((x number) (y numeric))
											  (cl:= x (convert-to-lisp-number y)))
(defmethod binary= ((x numeric) (y number))
  (cl:= (convert-to-lisp-number x) y))							(defmethod binary= ((x numeric) (y number))
											  (cl:= (convert-to-lisp-number x) y))
;; Unless otherwise, checked two number are never equal!
(defmethod binary= ((x numeric) (y numeric))						;; Unless otherwise, checked two number are never equal!
  nil)											(defmethod binary= ((x numeric) (y numeric))
											  nil)
(defmethod-sd binary= ((x rational-integer) (y rational-integer))
  (eql (integer-value x) (integer-value y)))						(defmethod-sd binary= ((x rational-integer) (y rational-integer))
											  (eql (integer-value x) (integer-value y)))
(defmethod-sd binary= ((x floating-point-number) (y floating-point-number) )
  (cl:= (fp-value x) (fp-value y)))							(defmethod-sd binary= ((x floating-point-number) (y floating-point-number) )
											  (cl:= (fp-value x) (fp-value y)))
(defmethod-sd binary= ((x bigfloat) (y bigfloat))
  (bf-binary= x y))									(defmethod-sd binary= ((x bigfloat) (y bigfloat))
											  (bf-binary= x y))
(defmethod-sd binary= ((x complex-number) (y complex-number))
  (and (= (cn-realpart x) (cn-realpart y))						(defmethod-sd binary= ((x complex-number) (y complex-number))
       (= (cn-imagpart x) (cn-imagpart y))))						  (and (= (cn-realpart x) (cn-realpart y))
											       (= (cn-imagpart x) (cn-imagpart y))))
(define-binary-contagions binary>
    :number-numeric? nil)								(define-binary-contagions binary>
											    :number-numeric? nil)
(defmethod binary> ((x number) (y number))
  (cl:> x y))										(defmethod binary> ((x number) (y number))
											  (cl:> x y))
(defmethod binary> ((x number) (y numeric))
  (cl:> x (convert-to-lisp-number y)))							(defmethod binary> ((x number) (y numeric))
											  (cl:> x (convert-to-lisp-number y)))
(defmethod binary> ((x numeric) (y number))
  (cl:> (convert-to-lisp-number x) y))							(defmethod binary> ((x numeric) (y number))
											  (cl:> (convert-to-lisp-number x) y))
(defmethod-sd binary> ((x rational-integer) (y rational-integer))
  (if (ordered-domain? domain)								(defmethod-sd binary> ((x rational-integer) (y rational-integer))
      (cl:> (integer-value x) (integer-value y))					  (if (ordered-domain? domain)
      (call-next-method)))								      (cl:> (integer-value x) (integer-value y))
											      (call-next-method)))
(defmethod-sd binary> ((x rational-number) (y rational-number))
  (if (ordered-domain? domain)								(defmethod-sd binary> ((x rational-number) (y rational-number))
      (cl:> (cl:* (qo-numerator x) (qo-denominator y))					  (if (ordered-domain? domain)
	      (cl:* (qo-numerator y) (qo-denominator x)))				      (cl:> (cl:* (qo-numerator x) (qo-denominator y))
      (call-next-method)))									      (cl:* (qo-numerator y) (qo-denominator x)))
											      (call-next-method)))
(defmethod-sd binary> ((x floating-point-number) (y floating-point-number))
  (if (ordered-domain? domain)								(defmethod-sd binary> ((x floating-point-number) (y floating-point-number))
      (cl:> (fp-value x) (fp-value y))							  (if (ordered-domain? domain)
      (call-next-method)))								      (cl:> (fp-value x) (fp-value y))
											      (call-next-method)))
(define-binary-contagions binary>=
    :number-numeric? nil)								(define-binary-contagions binary>=
											    :number-numeric? nil)
(defmethod binary>= ((x number) (y number))
  (cl:>= x y))										(defmethod binary>= ((x number) (y number))
											  (cl:>= x y))
(defmethod binary>= ((x number) (y numeric))
  (cl:>= x (convert-to-lisp-number y)))							(defmethod binary>= ((x number) (y numeric))
											  (cl:>= x (convert-to-lisp-number y)))
(defmethod binary>= ((x numeric) (y number))
  (cl:>= (convert-to-lisp-number x) y))							(defmethod binary>= ((x numeric) (y number))
											  (cl:>= (convert-to-lisp-number x) y))
(defmethod-sd binary>= ((x rational-integer) (y rational-integer))
  (if (ordered-domain? domain)								(defmethod-sd binary>= ((x rational-integer) (y rational-integer))
      (cl:>= (integer-value x) (integer-value y))					  (if (ordered-domain? domain)
      (call-next-method)))								      (cl:>= (integer-value x) (integer-value y))
											      (call-next-method)))
(defmethod-sd binary>= ((x rational-number) (y rational-number))
  (if (ordered-domain? domain)								(defmethod-sd binary>= ((x rational-number) (y rational-number))
      (cl:>= (cl:* (qo-numerator x) (qo-denominator y))					  (if (ordered-domain? domain)
	      (cl:* (qo-numerator y) (qo-denominator x)))				      (cl:>= (cl:* (qo-numerator x) (qo-denominator y))
      (call-next-method)))								             (cl:* (qo-numerator y) (qo-denominator x)))
											      (call-next-method)))
(defmethod-sd binary>= ((x floating-point-number) (y floating-point-number))
  (if (ordered-domain? domain)								(defmethod-sd binary>= ((x floating-point-number) (y floating-point-number))
      (cl:>= (fp-value x) (fp-value y))							  (if (ordered-domain? domain)
      (call-next-method)))								      (cl:>= (fp-value x) (fp-value y))
											      (call-next-method)))
(define-binary-contagions max-pair)
											(define-binary-contagions max-pair)
(defmethod max-pair ((x number) (y number))
  (if (cl:> x y) x y))									(defmethod max-pair ((x number) (y number))
											  (if (cl:> x y) x y))
;; Added the following two methods. Look at the related note for
;; min-pair.                             -- Sekhar 8/3/94				;; Added the following two methods. Look at the related note for
											;; min-pair.                             -- Sekhar 8/3/94
(defmethod max-pair :around ((x number) (y t))
  (cond ((eql x *positive-infinity*) x)							(defmethod max-pair :around ((x number) (y t))
	((eql x *negative-infinity*) y)							  (cond ((eql x *positive-infinity*) x)
	(t (call-next-method))))								((eql x *negative-infinity*) y)
												(t (call-next-method))))
(defmethod max-pair :around ((x t) (y number))
  (cond ((eql y *positive-infinity*) y)							(defmethod max-pair :around ((x t) (y number))
	((eql y *negative-infinity*) x)							  (cond ((eql y *positive-infinity*) y)
	(t (call-next-method))))								((eql y *negative-infinity*) x)
												(t (call-next-method))))
(defmethod-sd max-pair ((x rational-integer) (y rational-integer))
  (if (ordered-domain? domain)								(defmethod-sd max-pair ((x rational-integer) (y rational-integer))
      (if (cl:>= (integer-value x) (integer-value y))					  (if (ordered-domain? domain)
	  x y)										      (if (cl:>= (integer-value x) (integer-value y))
      (call-next-method)))									  x y)
											      (call-next-method)))
(defmethod-sd max-pair ((x rational-number) (y rational-number))
  (if (ordered-domain? domain)								(defmethod-sd max-pair ((x rational-number) (y rational-number))
      (if (cl:>= (cl:* (qo-numerator x) (qo-denominator y))				  (if (ordered-domain? domain)
		 (cl:* (qo-numerator y) (qo-denominator x)))				      (if (cl:>= (cl:* (qo-numerator x) (qo-denominator y))
	  x y)												 (cl:* (qo-numerator y) (qo-denominator x)))
      (call-next-method)))									  x y)
											      (call-next-method)))
(defmethod-sd max-pair ((x floating-point-number) (y floating-point-number))
  (if (ordered-domain? domain)								(defmethod-sd max-pair ((x floating-point-number) (y floating-point-number))
      (if (cl:>= (fp-value x) (fp-value y))						  (if (ordered-domain? domain)
	  x y)										      (if (cl:>= (fp-value x) (fp-value y))
      (call-next-method)))									  x y)
											      (call-next-method)))
(define-binary-contagions min-pair)
											(define-binary-contagions min-pair)
(defmethod min-pair ((x number) (y number))
  (if (cl:> x y) y x))									(defmethod min-pair ((x number) (y number))
											  (if (cl:> x y) y x))
;; Added the following two methods to fix a problem occurred while
;; while exponentiating a tpower-series by an integer. -- Sekhar 8/3/94			;; Added the following two methods to fix a problem occurred while
											;; while exponentiating a tpower-series by an integer. -- Sekhar 8/3/94
(defmethod min-pair :around ((x number) (y t))
  (cond ((eql x *positive-infinity*) y)							(defmethod min-pair :around ((x number) (y t))
	((eql x *negative-infinity*) x)							  (cond ((eql x *positive-infinity*) y)
	(t (call-next-method))))								((eql x *negative-infinity*) x)
												(t (call-next-method))))
(defmethod min-pair :around ((x t) (y number))
  (cond ((eql y *positive-infinity*) x)							(defmethod min-pair :around ((x t) (y number))
	((eql y *negative-infinity*) y)							  (cond ((eql y *positive-infinity*) x)
	(t (call-next-method))))								((eql y *negative-infinity*) y)
												(t (call-next-method))))
(defmethod-sd min-pair ((x rational-integer) (y rational-integer))
  (if (ordered-domain? domain)								(defmethod-sd min-pair ((x rational-integer) (y rational-integer))
      (if (cl:<= (integer-value x) (integer-value y))					  (if (ordered-domain? domain)
	  x y)										      (if (cl:<= (integer-value x) (integer-value y))
      (call-next-method)))									  x y)
											      (call-next-method)))
(defmethod-sd min-pair ((x rational-number) (y rational-number))
  (if (ordered-domain? domain)								(defmethod-sd min-pair ((x rational-number) (y rational-number))
      (if (cl:<= (cl:* (qo-numerator x) (qo-denominator y))				  (if (ordered-domain? domain)
		   (cl:* (qo-numerator y) (qo-denominator x)))				      (if (cl:<= (cl:* (qo-numerator x) (qo-denominator y))
	  x y)										                 (cl:* (qo-numerator y) (qo-denominator x)))
      (call-next-method)))									  x y)
											      (call-next-method)))
(defmethod-sd min-pair ((x floating-point-number) (y floating-point-number))
  (if (ordered-domain? domain)								(defmethod-sd min-pair ((x floating-point-number) (y floating-point-number))
      (if (cl:<= (fp-value x) (fp-value y))						  (if (ordered-domain? domain)
	  x y)										      (if (cl:<= (fp-value x) (fp-value y))
      (call-next-method)))									  x y)
											      (call-next-method)))
(define-binary-contagions plus)
											(define-binary-contagions plus)
(defmethod plus ((x number) (y number))
  (cl:+ x y))										(defmethod plus ((x number) (y number))
											  (cl:+ x y))
(defmethod-sd plus ((x rational-integer) (y rational-integer))
  (make-instance 'rational-integer :domain domain					(defmethod-sd plus ((x rational-integer) (y rational-integer))
		 :value (cl:+ (integer-value x) (integer-value y))))			  (make-instance 'rational-integer :domain domain
													 :value (cl:+ (integer-value x) (integer-value y))))
(defmethod-sd plus ((x rational-number) (y rational-number))
  (make-element domain									(defmethod-sd plus ((x rational-number) (y rational-number))
		(cl:+ (cl:/ (qo-numerator x) (qo-denominator x))			  (make-element domain
		      (cl:/ (qo-numerator y) (qo-denominator y)))))					(cl:+ (cl:/ (qo-numerator x) (qo-denominator x))
													      (cl:/ (qo-numerator y) (qo-denominator y)))))
(defmethod-sd plus ((x floating-point-number) (y floating-point-number))
  (make-element domain (cl:+ (fp-value x) (fp-value y))))				(defmethod-sd plus ((x floating-point-number) (y floating-point-number))
											  (make-element domain (cl:+ (fp-value x) (fp-value y))))
(defmethod-sd plus ((x bigfloat) (y bigfloat))
  (bind-domain-context domain								(defmethod-sd plus ((x bigfloat) (y bigfloat))
    (round!mt (bf-plus x y) *REAL-PRECISION*)))						  (bind-domain-context domain
											    (round!mt (bf-plus x y) *REAL-PRECISION*)))
(defmethod-sd plus ((x complex-number) (y complex-number))
  (make-element domain									(defmethod-sd plus ((x complex-number) (y complex-number))
		(+ (cn-realpart x) (cn-realpart y))					  (make-element domain
		(+ (cn-imagpart x) (cn-imagpart y))))							(+ (cn-realpart x) (cn-realpart y))
													(+ (cn-imagpart x) (cn-imagpart y))))
(define-binary-contagions difference)
											(define-binary-contagions difference)
(defmethod difference ((x number) (y number))
  (cl:- x y))										(defmethod difference ((x number) (y number))
											  (cl:- x y))
(defmethod-sd difference ((x rational-integer) (y rational-integer))
  (make-instance 'rational-integer :domain domain					(defmethod-sd difference ((x rational-integer) (y rational-integer))
		 :value (cl:- (integer-value x) (integer-value y))))			  (make-instance 'rational-integer :domain domain
													 :value (cl:- (integer-value x) (integer-value y))))
(defmethod-sd difference ((x rational-number) (y rational-number))
  (make-element domain									(defmethod-sd difference ((x rational-number) (y rational-number))
		(cl:- (cl:/ (qo-numerator x) (qo-denominator x))			  (make-element domain
		      (cl:/ (qo-numerator y) (qo-denominator y)))))					(cl:- (cl:/ (qo-numerator x) (qo-denominator x))
													      (cl:/ (qo-numerator y) (qo-denominator y)))))
(defmethod-sd difference ((x floating-point-number) (y floating-point-number))
  (make-element domain (cl:- (fp-value x) (fp-value y))))				(defmethod-sd difference ((x floating-point-number) (y floating-point-number))
											  (make-element domain (cl:- (fp-value x) (fp-value y))))
(defmethod-sd difference ((x bigfloat) (y bigfloat))
  (bind-domain-context domain								(defmethod-sd difference ((x bigfloat) (y bigfloat))
    (round!mt (bf-difference x y) *REAL-PRECISION*)))					  (bind-domain-context domain
											    (round!mt (bf-difference x y) *REAL-PRECISION*)))
(defmethod-sd difference ((x complex-number) (y complex-number))
  (make-element domain									(defmethod-sd difference ((x complex-number) (y complex-number))
		(- (cn-realpart x) (cn-realpart y))					  (make-element domain
		(- (cn-imagpart x) (cn-imagpart y))))							(- (cn-realpart x) (cn-realpart y))
													(- (cn-imagpart x) (cn-imagpart y))))
(define-binary-contagions times)
											(define-binary-contagions times)
(defmethod times ((x number) (y number))
  (cl:* x y))										(defmethod times ((x number) (y number))
											  (cl:* x y))
(defmethod-sd times ((x rational-integer) (y rational-integer))
  (make-instance 'rational-integer :domain domain					(defmethod-sd times ((x rational-integer) (y rational-integer))
		 :value (cl:* (integer-value x) (integer-value y))))			  (make-instance 'rational-integer :domain domain
													 :value (cl:* (integer-value x) (integer-value y))))
(defmethod-sd times ((x rational-number) (y rational-number))
  (make-element domain									(defmethod-sd times ((x rational-number) (y rational-number))
		(cl:* (cl:/ (qo-numerator x) (qo-denominator x))			  (make-element domain
		      (cl:/ (qo-numerator y) (qo-denominator y)))))					(cl:* (cl:/ (qo-numerator x) (qo-denominator x))
													      (cl:/ (qo-numerator y) (qo-denominator y)))))
(defmethod-sd times ((x floating-point-number) (y floating-point-number))
  (make-element domain (cl:* (fp-value x) (fp-value y))))				(defmethod-sd times ((x floating-point-number) (y floating-point-number))
											  (make-element domain (cl:* (fp-value x) (fp-value y))))
(defmethod-sd times ((x bigfloat) (y bigfloat))
  (bind-domain-context domain								(defmethod-sd times ((x bigfloat) (y bigfloat))
    (round!mt (bf-times x y) *REAL-PRECISION*)))					  (bind-domain-context domain
											    (round!mt (bf-times x y) *REAL-PRECISION*)))
(defmethod-sd times ((x complex-number) (y complex-number))
  (let ((x-real (cn-realpart x))							(defmethod-sd times ((x complex-number) (y complex-number))
	(x-imag (cn-imagpart x))							  (let ((x-real (cn-realpart x))
	(y-real (cn-realpart y))								(x-imag (cn-imagpart x))
	(y-imag (cn-imagpart y)))								(y-real (cn-realpart y))
  (make-element domain										(y-imag (cn-imagpart y)))
		(- (* x-real y-real) (* x-imag y-imag))					    (make-element domain
		(+ (* x-real y-imag) (* x-imag y-real)))))				                  (- (* x-real y-real) (* x-imag y-imag))
											                  (+ (* x-real y-imag) (* x-imag y-real)))))
(define-binary-contagions quotient)
											(define-binary-contagions quotient)
(defmethod quotient ((x number) (y number))
  (cl:/ x y))										(defmethod quotient ((x number) (y number))
											  (cl:/ x y))
;; Changed this method so that if x|y then we get an integer. Made this
;; change to fix a problem occurred while exponentiating a tpower-series		;; Changed this method so that if x|y then we get an integer. Made this
;; by an integer.                               -- Sekhar 8/3/94			;; change to fix a problem occurred while exponentiating a tpower-series
(defmethod-sd quotient ((x rational-integer) (y rational-integer))			;; by an integer.                               -- Sekhar 8/3/94
  (if (1? y) x										(defmethod-sd quotient ((x rational-integer) (y rational-integer))
    (let ((quo (cl:/ (integer-value x) (integer-value y))))				  (if (1? y) x
	     (cond ((typep quo 'integer)						      (let ((quo (cl:/ (integer-value x) (integer-value y))))
		    (make-element domain quo))						        (cond ((typep quo 'integer)
		   ((or (field? domain)							               (make-element domain quo))
			(typep domain 'non-strict-domain))				              ((or (field? domain)
		    (make-element domain quo))						                   (typep domain 'non-strict-domain))
		   (t (call-next-method))))))						               (make-element domain quo))
											              (t (call-next-method))))))
(defmethod-sd quotient ((x rational-number) (y rational-number))
  (make-element domain									(defmethod-sd quotient ((x rational-number) (y rational-number))
		(cl:/ (cl:* (qo-numerator x) (qo-denominator y))			  (make-element domain
		      (cl:* (qo-numerator y) (qo-denominator x)))))					(cl:/ (cl:* (qo-numerator x) (qo-denominator y))
													      (cl:* (qo-numerator y) (qo-denominator x)))))
(defmethod-sd quotient ((x floating-point-number) (y floating-point-number))
  (make-element domain (cl:/ (fp-value x) (fp-value y))))				(defmethod-sd quotient ((x floating-point-number) (y floating-point-number))
											  (make-element domain (cl:/ (fp-value x) (fp-value y))))
(defmethod-sd quotient ((x bigfloat) (y bigfloat))
  (bind-domain-context domain								(defmethod-sd quotient ((x bigfloat) (y bigfloat))
    (round!mt (bf-quotient x y *REAL-PRECISION*)					  (bind-domain-context domain
	      *REAL-PRECISION*)))							    (round!mt (bf-quotient x y *REAL-PRECISION*)
												      *REAL-PRECISION*)))
(defmethod-sd quotient ((x complex-number) (y complex-number))
  (let* ((x-real (cn-realpart x))							(defmethod-sd quotient ((x complex-number) (y complex-number))
	 (x-imag (cn-imagpart x))							  (let* ((x-real (cn-realpart x))
	 (y-real (cn-realpart y))								 (x-imag (cn-imagpart x))
	 (y-imag (cn-imagpart y))								 (y-real (cn-realpart y))
	 (norm (+ (* y-real y-real) (* y-imag y-imag))))					 (y-imag (cn-imagpart y))
    (make-element (domain-of x)									 (norm (+ (* y-real y-real) (* y-imag y-imag))))
		  (/ (+ (* x-real y-real) (* x-imag y-imag)) norm)			    (make-element (domain-of x)
		  (/ (- (* x-imag y-real) (* x-real y-imag)) norm))))					  (/ (+ (* x-real y-real) (* x-imag y-imag)) norm)
													  (/ (- (* x-imag y-real) (* x-real y-imag)) norm))))
(defmethod expt ((n number) (e number))
  (cl:expt n e))									(defmethod expt ((n number) (e number))
											  (cl:expt n e))
(defmethod expt ((n integer) (e ratio))
  (let* ((num (cl:numerator e))								(defmethod expt ((n integer) (e ratio))
	 (den (cl:denominator e))							  (let* ((num (cl:numerator e))
	 (nn (abs n))										 (den (cl:denominator e))
	 (root (integer-nth-root nn den)))							 (nn (abs n))
    (setq root											 (root (integer-nth-root nn den)))
	  (if (and root (cl:= nn (cl:expt root den)))					    (setq root
	      (cl:expt root num)								  (if (and root (cl:= nn (cl:expt root den)))
	      (cl:expt nn e)))									      (cl:expt root num)
    (cond ((cl:minusp n)									      (cl:expt nn e)))
	   (if (cl:evenp den)								    (cond ((cl:minusp n)
	       (cl:complex 0 root)								   (if (cl:evenp den)
	       (cl:- root)))									       (cl:complex 0 root)
	  (t root))))										       (cl:- root)))
												  (t root))))
(defmethod expt ((n ratio) (e ratio))
  (cl:/ (expt (cl:numerator n) e)							(defmethod expt ((n ratio) (e ratio))
	  (expt (cl:denominator n) e)))							  (cl:/ (expt (cl:numerator n) e)
											        (expt (cl:denominator n) e)))
(defmethod expt ((n rational-integer) (e integer))
  (let ((domain (domain-of n)))								(defmethod expt ((n rational-integer) (e integer))
    (cond ((1? n) (one domain))								  (let ((domain (domain-of n)))
	  ((cl:minusp e)								    (cond ((1? n) (one domain))
	   (if (or (field? domain)								  ((cl:minusp e)
		   (typep domain 'non-strict-domain))						   (if (or (field? domain)
	       (make-quotient-element domain 1								   (typep domain 'non-strict-domain))
				      (cl:expt (integer-value n) (cl:- e)))			       (make-quotient-element domain 1
	       (error "Raising ~D to a negative power ~D" n e)))							      (cl:expt (integer-value n) (cl:- e)))
	  (t (if (eql (integer-value n) -1)							       (error "Raising ~D to a negative power ~D" n e)))
		 (if (oddp e) (- (one domain)) (one domain))					  (t (if (eql (integer-value n) -1)
		 (make-element (domain-of n)								 (if (oddp e) (- (one domain)) (one domain))
			       (cl:expt (integer-value n) e)))))))					 (make-element (domain-of n)
														       (cl:expt (integer-value n) e)))))))
(defmethod-sd expt ((n rational-integer) (e rational-integer))
  (cond ((1? n) (one domain))								(defmethod-sd expt ((n rational-integer) (e rational-integer))
	((cl:minusp (integer-value e))							  (cond ((1? n) (one domain))
	 (if (or (field? domain)								((cl:minusp (integer-value e))
		 (typep domain 'non-strict-domain))						 (if (or (field? domain)
	     (make-quotient-element domain 1 (integer-value n))						 (typep domain 'non-strict-domain))
	     (error "Raising ~D to a negative power ~D" n e)))					     (make-quotient-element domain 1 (integer-value n))
	(t (if (eql (integer-value n) -1)							     (error "Raising ~D to a negative power ~D" n e)))
	       (if (oddp (integer-value e)) (- (one domain)) (one domain))			(t (if (eql (integer-value n) -1)
	       (make-element (domain-of n)							       (if (oddp (integer-value e)) (- (one domain)) (one domain))
		 (cl:expt (integer-value n) (integer-value e)))))))				       (make-element (domain-of n)
											                             (cl:expt (integer-value n) (integer-value e)))))))
(defmethod expt ((n rational-integer) (e ratio))
  (let* ((domain (domain-of n))								(defmethod expt ((n rational-integer) (e ratio))
	 (nn (integer-value n))								  (let* ((domain (domain-of n))
	 (abs-nn (cl:abs nn))									 (nn (integer-value n))
	 (num (cl:numerator e))									 (abs-nn (cl:abs nn))
	 (den (cl:denominator e))								 (num (cl:numerator e))
	 (root (integer-nth-root abs-nn den)))							 (den (cl:denominator e))
    (setq root 											 (root (integer-nth-root abs-nn den)))
	  (cond ((cl:= abs-nn (cl:expt root den))					    (setq root 
		 (cl:expt root num))								  (cond ((cl:= abs-nn (cl:expt root den))
		((complete-set? domain)									 (cl:expt root num))
		 (cl:expt nn e))									((complete-set? domain)
		(t (error "Can't compute ~S to the ~S power in ~S"					 (cl:expt nn e))
			  n e domain))))								(t (error "Can't compute ~S to the ~S power in ~S"
    (cond ((cl:minusp nn)											  n e domain))))
	   (cond ((cl:oddp den)								    (cond ((cl:minusp nn)
		  (make-element domain (cl:- root)))						   (cond ((cl:oddp den)
		 ((complete-set? domain)								  (make-element domain (cl:- root)))
		  (make-element domain (cl:complex 0 root)))						 ((complete-set? domain)
		 (t (error "Can't compute ~S to the ~S power in ~S"					  (make-element domain (cl:complex 0 root)))
			   n e domain))))								 (t (error "Can't compute ~S to the ~S power in ~S"
	  (t (make-element domain root)))))									   n e domain))))
												  (t (make-element domain root)))))
(defmethod expt ((n rational-integer) (e rational-number))
  (let* ((domain (domain-of n))								(defmethod expt ((n rational-integer) (e rational-number))
	 (nn (integer-value n))								  (let* ((domain (domain-of n))
	 (abs-nn (cl:abs nn))									 (nn (integer-value n))
	 (num (qo-numerator e))									 (abs-nn (cl:abs nn))
	 (den (qo-denominator e))								 (num (qo-numerator e))
	 (root (integer-nth-root abs-nn den)))							 (den (qo-denominator e))
    (setq root 											 (root (integer-nth-root abs-nn den)))
	  (cond ((cl:= abs-nn (cl:expt root den))					    (setq root 
		 (cl:expt root num))								  (cond ((cl:= abs-nn (cl:expt root den))
		((complete-set? domain)									 (cl:expt root num))
		 (cl:expt nn e))									((complete-set? domain)
		(t (error "Can't compute ~S to the ~S power in ~S"					 (cl:expt nn e))
			  n e domain))))								(t (error "Can't compute ~S to the ~S power in ~S"
    (cond ((cl:minusp nn)											  n e domain))))
	   (cond ((cl:oddp den)								    (cond ((cl:minusp nn)
		  (make-element domain (cl:- root)))						   (cond ((cl:oddp den)
		 ((complete-set? domain)								  (make-element domain (cl:- root)))
		  (make-element domain (cl:complex 0 root)))						 ((complete-set? domain)
		 (t (error "Can't compute ~S to the ~S power in ~S"					  (make-element domain (cl:complex 0 root)))
			   n e domain))))								 (t (error "Can't compute ~S to the ~S power in ~S"
	  (t (make-element domain root)))))									   n e domain))))
												  (t (make-element domain root)))))
(defmethod expt ((x rational-number) (y ratio))
  (/ (expt (numerator x) y)								(defmethod expt ((x rational-number) (y ratio))
     (expt (denominator x) y)))								  (/ (expt (numerator x) y)
											     (expt (denominator x) y)))
(defmethod expt ((x rational-number) (y rational-number))
  (/ (expt (numerator x) y)								(defmethod expt ((x rational-number) (y rational-number))
     (expt (denominator x) y)))								  (/ (expt (numerator x) y)
											     (expt (denominator x) y)))

(defmethod expt ((x floating-point-number) (y number))					(defmethod expt ((x floating-point-number) (y number))
  (make-element (domain-of x) (cl:expt (fp-value x) y)))				  (make-element (domain-of x) (cl:expt (fp-value x) y)))

(defmethod expt ((x floating-point-number) (y rational-integer))			(defmethod expt ((x floating-point-number) (y rational-integer))
  (make-element (domain-of x) (cl:expt (fp-value x) (integer-value y))))		  (make-element (domain-of x) (cl:expt (fp-value x) (integer-value y))))

(defmethod expt ((x floating-point-number) (y rational-number))				(defmethod expt ((x floating-point-number) (y rational-number))
  (make-element (domain-of x)								  (make-element (domain-of x)
		(cl:expt (fp-value x)									(cl:expt (fp-value x)
			   (cl:/ (numerator y) (denominator y)))))			                         (cl:/ (numerator y) (denominator y)))))

(defmethod expt ((x floating-point-number) (y floating-point-number))			(defmethod expt ((x floating-point-number) (y floating-point-number))
  (make-element (domain-of x) (cl:expt (fp-value x) (fp-value y))))			  (make-element (domain-of x) (cl:expt (fp-value x) (fp-value y))))

(defmethod expt ((number bigfloat) (k integer))						(defmethod expt ((number bigfloat) (k integer))
  (cond ((eql k 0) (make-bigfloat (domain-of number) 1 0))				  (cond ((eql k 0) (make-bigfloat (domain-of number) 1 0))
	((eql k 1) number)									((eql k 1) number)
	(t (let ((domain (domain-of number)))							(t (let ((domain (domain-of number)))
	     (bind-domain-context domain							     (bind-domain-context domain
	       (bf-expt number k *REAL-PRECISION*))))))						       (bf-expt number k *REAL-PRECISION*))))))

;; FIXTHIS: exponentiation of complex numbers needs to be improved 			;; FIXTHIS: exponentiation of complex numbers needs to be improved 
(defmethod expt ((x complex-number) (y integer))					(defmethod expt ((x complex-number) (y integer))
  (cond ((minusp y) (recip (expt x (- y))))						  (cond ((minusp y) (recip (expt x (- y))))
	((zerop y) (one (domain-of x)))								((zerop y) (one (domain-of x)))
	((1? y) x)										((1? y) x)
	(t (let ((half (expt x (ash y -1))))							(t (let ((half (expt x (ash y -1))))
	     (if (oddp y) (* half half x)							     (if (oddp y) (* half half x)
		 (* half half))))))									 (* half half))))))

											;; The first value returned by TRUNCATE is an integer for numbers, and
;; The first value returned by TRUNCATE is an integer for numbers, and			;; is returned in the domain of the first argument.  The second value
;; is returned in the domain of the first argument.  The second value			;; is returned in the domain of the second argument.
;; is returned in the domain of the second argument.
											(defmethod truncate1 ((a number))
(defmethod truncate1 ((a number))							  (cl:truncate a))
  (cl:truncate a))
											(defmethod truncate1 ((a rational-integer))
(defmethod truncate1 ((a rational-integer))						  (values a (zero (domain-of a))))
  (values a (zero (domain-of a))))
											(defmethod truncate1 ((a rational-number))
(defmethod truncate1 ((a rational-number))						  (multiple-value-bind (q r)
  (multiple-value-bind (q r)								      (cl:truncate (qo-numerator a) (qo-denominator a))
      (cl:truncate (qo-numerator a) (qo-denominator a))					    (values (make-element (domain-of a) q)
    (values (make-element (domain-of a) q)							    (make-element (domain-of a) r))))
	    (make-element (domain-of a) r))))
											(defmethod truncate1 ((a floating-point-number))
(defmethod truncate1 ((a floating-point-number))					  (multiple-value-bind (q r) (cl:truncate (fp-value a))
  (multiple-value-bind (q r) (cl:truncate (fp-value a))					    (values (make-element (domain-of a) q)
    (values (make-element (domain-of a) q)							    (make-element (domain-of a) r))))
	    (make-element (domain-of a) r))))
											(defmethod truncate1 ((a complex-number))
(defmethod truncate1 ((a complex-number))						  (error "Improper numeric argument"))
  (error "Improper numeric argument"))
											(defmethod truncate2 ((a number) (b number))
(defmethod truncate2 ((a number) (b number))						  (cl:truncate a b))
  (cl:truncate a b))
											(defmethod truncate2 ((a numeric) (b numeric))
(defmethod truncate2 ((a numeric) (b numeric))						  (multiple-value-bind (q r) (cl:truncate (convert-to-lisp-number a)
  (multiple-value-bind (q r) (cl:truncate (convert-to-lisp-number a)								  (convert-to-lisp-number b))
					  (convert-to-lisp-number b))			    (values (make-element (domain-of a) q)
    (values (make-element (domain-of a) q)							    (make-element (domain-of b) r))))
	    (make-element (domain-of b) r))))
											(defmethod truncate2 ((a numeric) (b complex-number))
(defmethod truncate2 ((a numeric) (b complex-number))					  (error "Improper numeric argument"))
  (error "Improper numeric argument"))
											(defmethod truncate2 ((a complex-number) (b numeric))
(defmethod truncate2 ((a complex-number) (b numeric))					  (error "Improper numeric argument"))
  (error "Improper numeric argument"))
											(defmethod floor1 ((a number))
(defmethod floor1 ((a number))								  (cl:floor a))
  (cl:floor a))
											(defmethod floor1 ((a rational-integer))
(defmethod floor1 ((a rational-integer))						  (values a (zero (domain-of a))))
  (values a (zero (domain-of a))))
											(defmethod floor1 ((a rational-number))
(defmethod floor1 ((a rational-number))							  (multiple-value-bind (q r)
  (multiple-value-bind (q r)								      (cl:floor (qo-numerator a) (qo-denominator a))
      (cl:floor (qo-numerator a) (qo-denominator a))					    (values (make-element (domain-of a) q)
    (values (make-element (domain-of a) q)							    (make-element (domain-of a) r))))
	    (make-element (domain-of a) r))))
											(defmethod floor1 ((a floating-point-number))
(defmethod floor1 ((a floating-point-number))						  (multiple-value-bind (q r) (cl:floor (fp-value a))
  (multiple-value-bind (q r) (cl:floor (fp-value a))					    (values (make-element (domain-of a) q)
    (values (make-element (domain-of a) q)							    (make-element (domain-of a) r))))
	    (make-element (domain-of a) r))))
											(defmethod floor1 ((a complex-number))
(defmethod floor1 ((a complex-number))							  (error "Improper numeric argument"))
  (error "Improper numeric argument"))
											(defmethod floor2 ((a number) (b number))
(defmethod floor2 ((a number) (b number))						  (cl:floor a b))
  (cl:floor a b))
											(defmethod floor2 ((a numeric) (b numeric))
(defmethod floor2 ((a numeric) (b numeric))						  (multiple-value-bind (q r) (cl:floor (convert-to-lisp-number a)
  (multiple-value-bind (q r) (cl:floor (convert-to-lisp-number a)			                                       (convert-to-lisp-number b))
					 (convert-to-lisp-number b))			    (values (make-element (domain-of a) q)
    (values (make-element (domain-of a) q)							    (make-element (domain-of b) r))))
	    (make-element (domain-of b) r))))
											(defmethod floor2 ((a numeric) (b complex-number))
(defmethod floor2 ((a numeric) (b complex-number))					  (error "Improper numeric argument"))
  (error "Improper numeric argument"))
											(defmethod floor2 ((a complex-number) (b numeric))
(defmethod floor2 ((a complex-number) (b numeric))					  (error "Improper numeric argument"))
  (error "Improper numeric argument"))
											(defmethod ceiling1 ((a number))
(defmethod ceiling1 ((a number))							  (cl:ceiling a))
  (cl:ceiling a))
											(defmethod ceiling1 ((a rational-integer))
(defmethod ceiling1 ((a rational-integer))						  (values a (zero (domain-of a))))
  (values a (zero (domain-of a))))
											(defmethod ceiling1 ((a rational-number))
(defmethod ceiling1 ((a rational-number))						  (multiple-value-bind (q r)
  (multiple-value-bind (q r)								      (cl:ceiling (qo-numerator a) (qo-denominator a))
      (cl:ceiling (qo-numerator a) (qo-denominator a))					    (values (make-element (domain-of a) q)
    (values (make-element (domain-of a) q)							    (make-element (domain-of a) r))))
	    (make-element (domain-of a) r))))
											(defmethod ceiling1 ((a floating-point-number))
(defmethod ceiling1 ((a floating-point-number))						  (multiple-value-bind (q r) (cl:ceiling (fp-value a))
  (multiple-value-bind (q r) (cl:ceiling (fp-value a))					    (values (make-element (domain-of a) q)
    (values (make-element (domain-of a) q)							    (make-element (domain-of a) r))))
	    (make-element (domain-of a) r))))
											(defmethod ceiling1 ((a complex-number))
(defmethod ceiling1 ((a complex-number))						  (error "Improper numeric argument"))
  (error "Improper numeric argument"))
											(defmethod ceiling2 ((a number) (b number))
(defmethod ceiling2 ((a number) (b number))						  (cl:ceiling a b))
  (cl:ceiling a b))
											(defmethod ceiling2 ((a numeric) (b numeric))
(defmethod ceiling2 ((a numeric) (b numeric))						  (multiple-value-bind (q r) (cl:ceiling (convert-to-lisp-number a)
  (multiple-value-bind (q r) (cl:ceiling (convert-to-lisp-number a)			                                         (convert-to-lisp-number b))
					   (convert-to-lisp-number b))			    (values (make-element (domain-of a) q)
    (values (make-element (domain-of a) q)							    (make-element (domain-of b) r))))
	    (make-element (domain-of b) r))))
											(defmethod ceiling2 ((a numeric) (b complex-number))
(defmethod ceiling2 ((a numeric) (b complex-number))					  (error "Improper numeric argument"))
  (error "Improper numeric argument"))
											(defmethod ceiling2 ((a complex-number) (b numeric))
(defmethod ceiling2 ((a complex-number) (b numeric))					  (error "Improper numeric argument"))
  (error "Improper numeric argument"))
											(defmethod round1 ((a number))
(defmethod round1 ((a number))								  (cl:round a))
  (cl:round a))
											(defmethod round1 ((a rational-integer))
(defmethod round1 ((a rational-integer))						  (values a (zero (domain-of a))))
  (values a (zero (domain-of a))))
											(defmethod round1 ((a rational-number))
(defmethod round1 ((a rational-number))							  (multiple-value-bind (q r)
  (multiple-value-bind (q r)								      (cl:round (qo-numerator a) (qo-denominator a))
      (cl:round (qo-numerator a) (qo-denominator a))					    (values (make-element (domain-of a) q)
    (values (make-element (domain-of a) q)							    (make-element (domain-of a) r))))
	    (make-element (domain-of a) r))))
											(defmethod round1 ((a floating-point-number))
(defmethod round1 ((a floating-point-number))						  (multiple-value-bind (q r) (cl:round (fp-value a))
  (multiple-value-bind (q r) (cl:round (fp-value a))					    (values (make-element (domain-of a) q)
    (values (make-element (domain-of a) q)							    (make-element (domain-of a) r))))
	    (make-element (domain-of a) r))))
											(defmethod round1 ((a complex-number))
(defmethod round1 ((a complex-number))							  (error "Improper numeric argument"))
  (error "Improper numeric argument"))
											(defmethod round2 ((a number) (b number))
(defmethod round2 ((a number) (b number))						  (cl:round a b))
  (cl:round a b))
											(defmethod round2 ((a numeric) (b numeric))
(defmethod round2 ((a numeric) (b numeric))						  (multiple-value-bind (q r) (cl:round (convert-to-lisp-number a)
  (multiple-value-bind (q r) (cl:round (convert-to-lisp-number a)			                                       (convert-to-lisp-number b))
					 (convert-to-lisp-number b))			    (values (make-element (domain-of a) q)
    (values (make-element (domain-of a) q)							    (make-element (domain-of b) r))))
	    (make-element (domain-of b) r))))
											(defmethod round2 ((a numeric) (b complex-number))
(defmethod round2 ((a numeric) (b complex-number))					  (error "Improper numeric argument"))
  (error "Improper numeric argument"))
											(defmethod round2 ((a complex-number) (b numeric))
(defmethod round2 ((a complex-number) (b numeric))					  (error "Improper numeric argument"))
  (error "Improper numeric argument"))
											(defmethod remainder ((a number) (b number))
(defmethod remainder ((a number) (b number))						  (cl:rem a b))
  (cl:rem a b))
											(defmethod-sd remainder ((a rational-integer) (b rational-integer))
(defmethod-sd remainder ((a rational-integer) (b rational-integer))			  (make-element domain (cl:rem (integer-value a) (integer-value b))))
  (make-element domain (cl:rem (integer-value a) (integer-value b))))
										    (
										    >	(defgeneric even? (number)
										    >	  (:documentation
										    >	   "Return true if the number is even."))
										    >
(defmethod even? ((a number))								(defmethod even? ((a number))
  (cl:evenp a))										  (cl:evenp a))

(defmethod even? ((a rational-integer))							(defmethod even? ((a rational-integer))
  (cl:evenp (integer-value a)))								  (cl:evenp (integer-value a)))

										    >	(defgeneric oddp? (number)
										    >	  (:documentation
										    >	   "Return true if the number is odd."))
										    >
(defmethod oddp? ((a number))								(defmethod oddp? ((a number))
  (cl:evenp a))										  (cl:evenp a))

(defmethod oddp? ((a rational-integer))							(defmethod oddp? ((a rational-integer))
  (cl:evenp (integer-value a)))								  (cl:evenp (integer-value a)))

(defmethod binary-gcd ((a integer) (b integer))						(defmethod binary-gcd ((a integer) (b integer))
  (cl:gcd a b))										  (cl:gcd a b))

;; Do we really need this???								;; Do we really need this???
(defmethod binary-gcd ((a float) (b float))						(defmethod binary-gcd ((a float) (b float))
  a)											  a)

;; All this extra stuff is because this method and lcm below override			;; All this extra stuff is because this method and lcm below override
;; the definitions in morphisms.lisp							;; the definitions in morphisms.lisp

(defmethod binary-gcd ((a numeric) (b numeric))						(defmethod binary-gcd ((a numeric) (b numeric))
  (let ((a-domain (domain-of a)) (b-domain (domain-of b)))				  (let ((a-domain (domain-of a)) (b-domain (domain-of b)))
       (cond ((eql a-domain b-domain) (one a-domain))					    (cond ((eql a-domain b-domain) (one a-domain))
	     ((typep (domain-of a) 'non-strict-domain)					          ((typep (domain-of a) 'non-strict-domain)
	      (gcd a (coerce b (domain-of a))))						           (gcd a (coerce b (domain-of a))))
	     ((typep (domain-of b) 'non-strict-domain)					          ((typep (domain-of b) 'non-strict-domain)
	      (gcd (coerce a (domain-of b)) b))						           (gcd (coerce a (domain-of b)) b))
	     (t (call-next-method)))))							          (t (call-next-method)))))

(defmethod-sd binary-gcd ((a rational-integer) (b rational-integer))			(defmethod-sd binary-gcd ((a rational-integer) (b rational-integer))
  (make-element domain (cl:gcd (integer-value a) (integer-value b))))			  (make-element domain (cl:gcd (integer-value a) (integer-value b))))

(defmethod binary-lcm ((a integer) (b integer))						(defmethod binary-lcm ((a integer) (b integer))
  (cl:* (cl:/ a (cl:gcd a b)) b))							  (cl:* (cl:/ a (cl:gcd a b)) b))

(defmethod binary-lcm ((a numeric) (b numeric))						(defmethod binary-lcm ((a numeric) (b numeric))
  (let ((a-domain (domain-of a)) (b-domain (domain-of b)))				  (let ((a-domain (domain-of a)) (b-domain (domain-of b)))
       (cond ((eql a-domain b-domain) (* a b))						    (cond ((eql a-domain b-domain) (* a b))
	     ((typep (domain-of a) 'non-strict-domain)					          ((typep (domain-of a) 'non-strict-domain)
	      (gcd a (coerce b (domain-of a))))						           (gcd a (coerce b (domain-of a))))
	     ((typep (domain-of b) 'non-strict-domain)					          ((typep (domain-of b) 'non-strict-domain)
	      (gcd (coerce a (domain-of b)) b))						           (gcd (coerce a (domain-of b)) b))
	     (t (call-next-method)))))							          (t (call-next-method)))))

(defmethod-sd binary-lcm ((a rational-integer) (b rational-integer))			(defmethod-sd binary-lcm ((a rational-integer) (b rational-integer))
  (let ((a (integer-value a))								  (let ((a (integer-value a))
	(b (integer-value b)))									(b (integer-value b)))
    (make-element domain (cl:* (cl:/ a (cl:gcd a b)) b))))				    (make-element domain (cl:* (cl:/ a (cl:gcd a b)) b))))

(defmethod extended-gcd ((a integer) (b integer))				    <
  (multiple-value-bind (d x y) (extended-gcd* (abs a) (abs b))			    <
    (values (cl:* (signum a) x) (cl:* (signum b) y) d)))			    <
										    <
(defun extended-gcd* (a b)								(defun extended-gcd* (a b)
  (if (= b 0)										  (if (= b 0)
      (values a 1 0)									      (values a 1 0)
      (multiple-value-bind (d x y) (extended-gcd* b (mod a b))				      (multiple-value-bind (d x y) (extended-gcd* b (mod a b))
	(values d y (cl:- x (cl:* (cl:floor a b) y))))))					(values d y (cl:- x (cl:* (cl:floor a b) y))))))

										    >	(defgeneric extended-gcd (numerator denominator)
										    >	  (:documentation
										    >	   "Return the greatest common denominator."))
										    >
										    >	(defmethod extended-gcd ((a integer) (b integer))
										    >	  (multiple-value-bind (d x y) (extended-gcd* (abs a) (abs b))
										    >	    (values (cl:* (signum a) x) (cl:* (signum b) y) d)))
										    >
;; Some single argument functions							;; Some single argument functions

(defmethod sin ((x floating-point-number))						(defmethod sin ((x floating-point-number))
  (make-element (domain-of x) (cl:sin (fp-value x))))					  (make-element (domain-of x) (cl:sin (fp-value x))))

(defmethod cos ((x floating-point-number))						(defmethod cos ((x floating-point-number))
  (make-element (domain-of x) (cl:cos (fp-value x))))					  (make-element (domain-of x) (cl:cos (fp-value x))))

(defmethod tan ((x floating-point-number))						(defmethod tan ((x floating-point-number))
  (make-element (domain-of x) (cl:tan (fp-value x))))					  (make-element (domain-of x) (cl:tan (fp-value x))))

(defmethod asin ((x floating-point-number))						(defmethod asin ((x floating-point-number))
  (make-element (domain-of x) (cl:asin (fp-value x))))					  (make-element (domain-of x) (cl:asin (fp-value x))))

(defmethod acos ((x floating-point-number))						(defmethod acos ((x floating-point-number))
  (make-element (domain-of x) (cl:acos (fp-value x))))					  (make-element (domain-of x) (cl:acos (fp-value x))))

(defmethod sinh ((x floating-point-number))						(defmethod sinh ((x floating-point-number))
  (make-element (domain-of x) (cl:sinh (fp-value x))))					  (make-element (domain-of x) (cl:sinh (fp-value x))))

(defmethod cosh ((x floating-point-number))						(defmethod cosh ((x floating-point-number))
  (make-element (domain-of x) (cl:cosh (fp-value x))))					  (make-element (domain-of x) (cl:cosh (fp-value x))))

(defmethod tanh ((x floating-point-number))						(defmethod tanh ((x floating-point-number))
  (make-element (domain-of x) (tanh (fp-value x))))					  (make-element (domain-of x) (tanh (fp-value x))))

(defmethod asinh ((x floating-point-number))						(defmethod asinh ((x floating-point-number))
  (make-element (domain-of x) (cl:asinh (fp-value x))))					  (make-element (domain-of x) (cl:asinh (fp-value x))))

(defmethod acosh ((x floating-point-number))						(defmethod acosh ((x floating-point-number))
  (make-element (domain-of x) (cl:acosh (fp-value x))))					  (make-element (domain-of x) (cl:acosh (fp-value x))))

(defmethod atanh ((x floating-point-number))						(defmethod atanh ((x floating-point-number))
  (make-element (domain-of x) (cl:atanh (fp-value x))))					  (make-element (domain-of x) (cl:atanh (fp-value x))))

(defmethod exp ((x floating-point-number))						(defmethod exp ((x floating-point-number))
  (make-element (domain-of x) (cl:exp (fp-value x))))					  (make-element (domain-of x) (cl:exp (fp-value x))))

(defmethod log ((x floating-point-number))						(defmethod log ((x floating-point-number))
  (make-element (domain-of x) (cl:log (fp-value x))))					  (make-element (domain-of x) (cl:log (fp-value x))))
;;; -*- Mode:Lisp; Package:CL-USER; Base:10; Lowercase:T; Syntax:Common-Lisp -*-	;;; -*- Mode:Lisp; Package:CL-USER; Base:10; Lowercase:T; Syntax:Common-Lisp -*-
;;; ===========================================================================		;;; ===========================================================================
;;;			    Package Definitions						;;;			    Package Definitions
;;; ===========================================================================		;;; ===========================================================================
;;; (c) Copyright 1989, 1993 Cornell University						;;; (c) Copyright 1989, 1993 Cornell University

;;; packages.lisp,v 1.19 1995/04/05 21:39:44 chew Exp					;;; packages.lisp,v 1.19 1995/04/05 21:39:44 chew Exp

(in-package #-ANSI-CL "USER" #+ANSI-CL "CL-USER")				    |	(in-package :common-lisp-user)
										    <
(make::adjust-version-numbers Weyl "1.19")					    <
										    <
										    <
;; This is really stupid.  In ANSI-CL's the name of the LISP package		    <
;; has bee renamed to COMMON-LISP.  Thus all the standard Lisp			    <
;; functions are in the CL package not the LISP package.  The purpose		    <
;; of this change is so that a Lisp system can support both the old		    <
;; style of work as well as the new style.  					    <
										    <
;; Originally we had created a LISP package and copied all the CL		    <
;; symbols into the LISP package.  Unfortunately, this conflicts with		    <
;; the idea that a Lisp could have both the old and new style			    <
;; functions.  Since we basically want the new stuff, we should use		    <
;; functions from CL, and in old lisp's create a CL package.			    <
										    <
#-ANSI-CL									    <
(unless (find-package 'CL)							    <
   (make-package "CL" :use '("LISP"))						    <
   (do-external-symbols (sym (find-package 'lisp))				    <
      (export (intern (symbol-name sym) 'cl) 'cl)))				    <
										    <
;; This should probably only be used to create the WEYL package			    <
(defun use-weyli-package (package)						    <
  (declare (special *weyli-shadowed-symbols*))					    <
  (shadowing-import (loop for sym in *weyli-shadowed-symbols*			    <
			  collect (intern (symbol-name sym) 'weyli))		    <
		    package)							    <
  (use-package (find-package 'weyli) package))					    <
										    <
(defun use-weyl-package (package)						    <
  (declare (special *weyli-shadowed-symbols*))					    <
  (shadowing-import (loop for sym in *weyli-shadowed-symbols*			    <
			  collect (intern (symbol-name sym) 'weyl))		    <
		    package)							    <
  (use-package (find-package 'weyl) package))					    <
										    <
(defun intern-in-package (package-name symbols)					    <
  (loop for sym in symbols							    <
	with  package = (find-package package-name)				    <
	collect (intern sym package)))						    <
										    <
(defvar *weyli-shadowed-symbols*						    <
    '(coerce set + - * / = > < >= <= minus expt abs random			    <
      gcd lcm floor ceiling truncate round max min				    <
      complex conjugate realpart imagpart					    <
      sqrt exp log phase signum minusp zerop plusp				    <
      sin cos tan asin acos atan sinh cosh tanh asinh acosh atanh		    <
      numerator denominator reduce 						    <
      map delete member replace substitute getf union intersection		    <
      apply funcall variable							    <
      type-of 									    <
      defmethod))								    <
										    <
(unless (find-package "WEYLI")							    <
  #-Genera									    <
  (make-package "WEYLI"								    <
		:use '(#-MCL LISP #+MCL CL					    <
                       #+PCL PCL #+(and CLOS (not MCL)) CLOS))			    <
  #+Genera									    <
  (make-package "WEYLI"								    <
		:use '(#-Rel8 LISP #+Rel8 FUTURE-COMMON-LISP 			    <
		       #+PCL PCL #+CLOS CLOS)					    <
		:colon-mode :external))						    <
										    <
(shadow *weyli-shadowed-symbols* 'weyli)					    <

(defvar *weyli-exported-symbols*							(defvar *weyli-exported-symbols*
    '("*"									    |	  '("*" "+" "-" "/" "=" ">" "<" ">=" "<=" "0?" "1?"
      "+"									    <
      "-"									    <
      "/"									    <
      "="									    <
      ">"									    <
      "<"									    <
      ">="									    <
      "<="									    <
      "0?"									    <
      "1?"									    <

      "%MAX"										    "%MAX"
      "%MIN"										    "%MIN"
      "%PLUS"										    "%PLUS"
      "%DIFFERENCE"									    "%DIFFERENCE"
      "%TIMES"										    "%TIMES"
      "%QUOTIENT"									    "%QUOTIENT"

      "*COERCE-WHERE-POSSIBLE*"								    "*COERCE-WHERE-POSSIBLE*"
      "*DEFAULT-RANDOM-HEIGHT*"								    "*DEFAULT-RANDOM-HEIGHT*"
      "*DOMAINS*"									    "*DOMAINS*"
      "*GENERAL*"									    "*GENERAL*"
      "*MORPHISMS*"									    "*MORPHISMS*"
      "*NEGATIVE-INFINITY*"								    "*NEGATIVE-INFINITY*"
      "*POSITIVE-INFINITY*"								    "*POSITIVE-INFINITY*"
      "*PRINT-MODULUS*"									    "*PRINT-MODULUS*"

      "ABELIAN-GROUP"									    "ABELIAN-GROUP"
      "ABELIAN-MONOID"									    "ABELIAN-MONOID"
      "ABELIAN-SEMIGROUP"								    "ABELIAN-SEMIGROUP"
      "ABSTRACT-POINT"									    "ABSTRACT-POINT"
      "ABSTRACT-SPACE"									    "ABSTRACT-SPACE"
      "ADD-NEW-VARIABLE"								    "ADD-NEW-VARIABLE"
      "ADD-RELATION"									    "ADD-RELATION"
      "ADD-SUBSCRIPTS"									    "ADD-SUBSCRIPTS"
      "ADJACENCIES"									    "ADJACENCIES"
      "ALGEBRA"										    "ALGEBRA"
      "ALGEBRAIC-EXTENSION"								    "ALGEBRAIC-EXTENSION"
      "ALL-NAMES"									    "ALL-NAMES"
      "ANGLES"										    "ANGLES"
      "ARGS-OF"										    "ARGS-OF"
      "ARGUMENT-OF"									    "ARGUMENT-OF"
      "BANACH-SPACE"									    "BANACH-SPACE"
      "BASE-OF"										    "BASE-OF"
      "BIGFLOAT"									    "BIGFLOAT"
      "BOUNDARY"									    "BOUNDARY"
      "BOUNDARY-COMPLEX-OF"								    "BOUNDARY-COMPLEX-OF"
      "BOUNDARY-DOMAIN"									    "BOUNDARY-DOMAIN"
      "BOUND-VARS-OF"									    "BOUND-VARS-OF"
      "CHARACTERISTIC"									    "CHARACTERISTIC"
      "CHOOSE"										    "CHOOSE"
      "COEFFICIENT"									    "COEFFICIENT"
      "COEFFICIENT-DOMAIN-OF"								    "COEFFICIENT-DOMAIN-OF"
      "COERCE"										    "COERCE"
      "COERCIBLE?"									    "COERCIBLE?"
      "COMBINATIONS"									    "COMBINATIONS"
      "COMPLEX-NUMBER"									    "COMPLEX-NUMBER"
      "COMPLEX-NUMBERS"									    "COMPLEX-NUMBERS"
      "COMPOSE"										    "COMPOSE"
      "CONVERT-TO-LISP-NUMBER"								    "CONVERT-TO-LISP-NUMBER"
      "CREATE-MESH"									    "CREATE-MESH"
      "CROSS-PRODUCT"									    "CROSS-PRODUCT"
      "DECLARE-DEPENDENCIES"								    "DECLARE-DEPENDENCIES"
      "DEFINE-OPERATIONS"								    "DEFINE-OPERATIONS"
      "DEFMETHOD"								    <
      "DEGREE"										    "DEGREE"
      "DELETE"										    "DELETE"
      "DEPENDS-ON?"									    "DEPENDS-ON?"
      "DERIV"										    "DERIV"
      "DERIVS-OF"									    "DERIVS-OF"
      "DESCRIBE-OPERATIONS"								    "DESCRIBE-OPERATIONS"
      "DIFFERENT-KERNELS"								    "DIFFERENT-KERNELS"
      "DIFFERENTIAL-RING"								    "DIFFERENTIAL-RING"
      "DIMENSION-OF"									    "DIMENSION-OF"
      "DIMENSIONAL-SPACE"								    "DIMENSIONAL-SPACE"
      "DIMENSIONS"									    "DIMENSIONS"
      "DIRECT-SUM"									    "DIRECT-SUM"
      "DISPLAY"										    "DISPLAY"
      "DOMAIN-OF"									    "DOMAIN-OF"
      "DOT-PRODUCT"									    "DOT-PRODUCT"
      "DRAW"										    "DRAW"
      "EQN="										    "EQN="
      "EQN>"										    "EQN>"
      "EQN>="										    "EQN>="
      "EVEN?"										    "EVEN?"
      "EUCLIDEAN-DOMAIN"								    "EUCLIDEAN-DOMAIN"
      "EVALUATE-AT"									    "EVALUATE-AT"
      "EXPONENT-OF"									    "EXPONENT-OF"
      "EXPR-OF"										    "EXPR-OF"
      "EXPRS-OF"									    "EXPRS-OF"
      "EXPAND"										    "EXPAND"
      "EXPT"										    "EXPT"
      "FACTOR"										    "FACTOR"
      "FACTORIAL"									    "FACTORIAL"
      "FIELD"										    "FIELD"
      "FINITE-FIELD"									    "FINITE-FIELD"
      "FINITE-SET"									    "FINITE-SET"
      "FOURIER"										    "FOURIER"
      "FUNCT"										    "FUNCT"
      "FUNCT-DOMAIN-OF"									    "FUNCT-DOMAIN-OF"
      "FUNCT-OF"									    "FUNCT-OF"
      "FUNCT-RANGE-OF"									    "FUNCT-RANGE-OF"
      "FUNCTION-SPACE"									    "FUNCTION-SPACE"
      "GCD"										    "GCD"
      "GCD-DOMAIN"									    "GCD-DOMAIN"
      "GE-ABS?"										    "GE-ABS?"
      "GE-APPLICATION?"									    "GE-APPLICATION?"
      "GE-COS?"										    "GE-COS?"
      "GE-DERIV?"									    "GE-DERIV?"
      "GE-EQN=?"       									    "GE-EQN=?"       
      "GE-EQN>?"									    "GE-EQN>?"
      "GE-EQN>=?"									    "GE-EQN>=?"
      "GE-EQUAL"									    "GE-EQUAL"
      "GE-EXPT?"									    "GE-EXPT?"
      "GE-FOURIER?"									    "GE-FOURIER?"
      "GE-FUNCTION?"									    "GE-FUNCTION?"
      "GE-FUNCTION-DERIV?"								    "GE-FUNCTION-DERIV?"
      "GE-IFOURIER?"									    "GE-IFOURIER?"
      "GE-LOG?"										    "GE-LOG?"
      "GE-NARY?"									    "GE-NARY?"
      "GE-PLUS?"									    "GE-PLUS?"
      "GE-SIN?"										    "GE-SIN?"
      "GE-TAN?"										    "GE-TAN?"
      "GE-TIMES?"									    "GE-TIMES?"
      "GE-VARIABLE?"									    "GE-VARIABLE?"
      "GENERATORS-OF"									    "GENERATORS-OF"
      "GET-ABSTRACT-SPACE"								    "GET-ABSTRACT-SPACE"
      "GET-ALGEBRAIC-EXTENSION"								    "GET-ALGEBRAIC-EXTENSION"
      "GET-AUTOMORPHISMS"								    "GET-AUTOMORPHISMS"
      "GET-CHAIN-MODULE"								    "GET-CHAIN-MODULE"
      "GET-COMPLEX-NUMBERS"								    "GET-COMPLEX-NUMBERS"
      "GET-DIFFERENTIAL-RING"								    "GET-DIFFERENTIAL-RING"
      "GET-DIRECT-SUM"									    "GET-DIRECT-SUM"
      "GET-EUCLIDEAN-SPACE"								    "GET-EUCLIDEAN-SPACE"
      "GET-FACTOR-GROUP"								    "GET-FACTOR-GROUP"
      "GET-FACTOR-MODULE"								    "GET-FACTOR-MODULE"
      "GET-FACTOR-RING"									    "GET-FACTOR-RING"
      "GET-FINITE-FIELD"								    "GET-FINITE-FIELD"
      "GET-FREE-MODULE"									    "GET-FREE-MODULE"
      "GET-FUNCTION"									    "GET-FUNCTION"
      "GET-GL-N"									    "GET-GL-N"
      "GET-HILBERT-SPACE"								    "GET-HILBERT-SPACE"
      "GET-HOMOMORPHISMS"								    "GET-HOMOMORPHISMS"
      "GET-LISP-NUMBERS"								    "GET-LISP-NUMBERS"
      "GET-MATRIX-SPACE"								    "GET-MATRIX-SPACE"
      "GET-MORPHISMS"									    "GET-MORPHISMS"
      "GET-O-N"										    "GET-O-N"
      "GET-POLYNOMIAL-RING"								    "GET-POLYNOMIAL-RING"
      "GET-PSL-N"									    "GET-PSL-N"
      "GET-QUATERNION-DOMAIN"								    "GET-QUATERNION-DOMAIN"
      "GET-QUOTIENT-FIELD"								    "GET-QUOTIENT-FIELD"
      "GET-RATIONAL-INTEGERS"								    "GET-RATIONAL-INTEGERS"
      "GET-RATIONAL-NUMBERS"								    "GET-RATIONAL-NUMBERS"
      "GET-REAL-NUMBERS"								    "GET-REAL-NUMBERS"
      "GET-SL-N"									    "GET-SL-N"
      "GET-SO-N"									    "GET-SO-N"
      "GET-TPOWER-SERIES-DOMAIN"							    "GET-TPOWER-SERIES-DOMAIN"
      "GET-UNIT-QUATERNION-DOMAIN"							    "GET-UNIT-QUATERNION-DOMAIN"
      "GET-VARIABLE-PROPERTY"								    "GET-VARIABLE-PROPERTY"
      "GET-VARIABLE-NAME"								    "GET-VARIABLE-NAME"
      "GET-VECTOR-SPACE"								    "GET-VECTOR-SPACE"
      "GREATER-FUNCTION"								    "GREATER-FUNCTION"
      "GFM"										    "GFM"
      "GFP"										    "GFP"
      "GROUP"										    "GROUP"
      "HEIGHT"										    "HEIGHT"
      "HILBERT-SPACE"									    "HILBERT-SPACE"
      "HOME-OF"										    "HOME-OF"
      "HOMOMORPHISM"									    "HOMOMORPHISM"
      "IFOURIER"									    "IFOURIER"
      "INNER-PRODUCT"									    "INNER-PRODUCT"
      "INSERT"										    "INSERT"
      "INSERT-BOUNDARY"									    "INSERT-BOUNDARY"
      "INTEGRAL"									    "INTEGRAL"
      "INTEGRAL-DOMAIN"									    "INTEGRAL-DOMAIN"
      "INTERPOLATE"									    "INTERPOLATE"
      "JACOBIAN"									    "JACOBIAN"
      "LEXICAL-<"									    "LEXICAL-<"
      "LEXICAL->"									    "LEXICAL->"
      "LHS-OF"										    "LHS-OF"
      "LIST-OF-ELEMENTS"								    "LIST-OF-ELEMENTS"
      "LIST-OF-VARIABLES"								    "LIST-OF-VARIABLES"
      "LIST-OPERATIONS"									    "LIST-OPERATIONS"
      "LOCATE"										    "LOCATE"
      "MAKE-APP-FUNCTION"								    "MAKE-APP-FUNCTION"
      "MAKE-CURVED-SEGMENT"								    "MAKE-CURVED-SEGMENT"
      "MAKE-GE-FUNCTION"								    "MAKE-GE-FUNCTION"
      "MAKE-GE-DERIV"									    "MAKE-GE-DERIV"
      "MAKE-GE-EXPT"									    "MAKE-GE-EXPT"
      "MAKE-GE-FUNCTION"								    "MAKE-GE-FUNCTION"
      "MAKE-GE-PLUS"									    "MAKE-GE-PLUS"
      "MAKE-GE-TIMES"									    "MAKE-GE-TIMES"
      "MAKE-GENERATOR"									    "MAKE-GENERATOR"
      "MAKE-IDEAL"									    "MAKE-IDEAL"
      "MAKE-MESH"									    "MAKE-MESH"
      "MAKE-MESH-FROM-FILE"								    "MAKE-MESH-FROM-FILE"
      "MAKE-POINT"									    "MAKE-POINT"
      "MAKE-SAMPLED-FUNCTION"								    "MAKE-SAMPLED-FUNCTION"
      "MAKE-SIMPLEX"									    "MAKE-SIMPLEX"
      "MAKE-UNION"									    "MAKE-UNION"
      "MAKE-UNIVERSAL-QUANTIFIED-SET"							    "MAKE-UNIVERSAL-QUANTIFIED-SET"
      "MAKE-GE-VARIABLE"								    "MAKE-GE-VARIABLE"
      "MAP"										    "MAP"
      "MAP-OVER-CELLS"									    "MAP-OVER-CELLS"
      "MAP-OVER-MAXIMAL-CELLS"								    "MAP-OVER-MAXIMAL-CELLS"
      "MAP-OVER-ELEMENTS"								    "MAP-OVER-ELEMENTS"
      "MAP-OVER-EXPRESSIONS"								    "MAP-OVER-EXPRESSIONS"
      "MAP-OVER-FACES"									    "MAP-OVER-FACES"
      "MAP-WITH-DOMAIN"									    "MAP-WITH-DOMAIN"
      "MATRIX-DIMENSIONS"								    "MATRIX-DIMENSIONS"
      "MAX"										    "MAX"
      "MEMBER"										    "MEMBER"
      "MEMOIZE"										    "MEMOIZE"
      "MESH"										    "MESH"
      "MIN"										    "MIN"
      "MINIMAL-POLYNOMIAL"								    "MINIMAL-POLYNOMIAL"
      "MINUS?"										    "MINUS?"
      "MONOID"										    "MONOID"
      "MORPHISM"									    "MORPHISM"
      "MULTIPLICATIVE-ORDER"								    "MULTIPLICATIVE-ORDER"
      "MUTABLE-SET"									    "MUTABLE-SET"
      "NAME"										    "NAME"
      "NAME-OF"										    "NAME-OF"
      "NAME-REGION"									    "NAME-REGION"
      "NARGS-OF"									    "NARGS-OF"
      "NORM"										    "NORM"
      "NUMBER-OF-ELEMENTS"								    "NUMBER-OF-ELEMENTS"
      "NUMBER?"										    "NUMBER?"
      "ODD?"										    "ODD?"
      "ONE"										    "ONE"
      "ONE-MATRIX"									    "ONE-MATRIX"
      "OPERATION-ARGUMENTS"								    "OPERATION-ARGUMENTS"
      "OPERATION-VALUES"								    "OPERATION-VALUES"
      "OPPOSITE"									    "OPPOSITE"
      "ORDERED-ABELIAN-GROUP"								    "ORDERED-ABELIAN-GROUP"
      "ORDERED-RING"									    "ORDERED-RING"
      "ORDERED-SET"									    "ORDERED-SET"
      "ORDERED-SET-OF-PAIRS"								    "ORDERED-SET-OF-PAIRS"
      "ORDERED-SIMPLE-SET"								    "ORDERED-SIMPLE-SET"
      "PARTIAL-DERIV"									    "PARTIAL-DERIV"
      "PARTITION"									    "PARTITION"
      "PERMUTE"										    "PERMUTE"
      "PLUS?"										    "PLUS?"
      "POCHHAMMER"									    "POCHHAMMER"
      "POINT"										    "POINT"
      "POLYNOMIAL"									    "POLYNOMIAL"
      "POWER-OF?"									    "POWER-OF?"
      "PRIME?"										    "PRIME?"
      "PROJECTIVE-SPACE"								    "PROJECTIVE-SPACE"
      "QUOTIENT-FIELD"									    "QUOTIENT-FIELD"
      "QUOTIENT-RING"									    "QUOTIENT-RING"
      "RATIONAL-INTEGER"								    "RATIONAL-INTEGER"
      "RATIONAL-INTEGERS"								    "RATIONAL-INTEGERS"
      "RATIONAL-NUMBER"									    "RATIONAL-NUMBER"
      "RATIONAL-NUMBERS"								    "RATIONAL-NUMBERS"
      "READ-MESH"									    "READ-MESH"
      "REAL-NUMBER"									    "REAL-NUMBER"
      "REAL-NUMBERS"									    "REAL-NUMBERS"
      "RECIP"										    "RECIP"
      "REDUCE-BASIS"									    "REDUCE-BASIS"
      "REF"										    "REF"
      "REFINE-MESH"									    "REFINE-MESH"
      "RELATIONS"									    "RELATIONS"
      "REMAINDER"									    "REMAINDER"
      "REPLACE"										    "REPLACE"
      "REQUIRED-OPERATIONS"								    "REQUIRED-OPERATIONS"
      "RESET-DOMAINS"									    "RESET-DOMAINS"
      "RESULTANT"									    "RESULTANT"
      "REVERSION"									    "REVERSION"
      "REVLEX->"									    "REVLEX->"
      "RHS-OF"										    "RHS-OF"
      "RING"										    "RING"
      "RING-VARIABLES"									    "RING-VARIABLES"
      "RNG"										    "RNG"
      "SCALAR?"										    "SCALAR?"
      "SEGMENT?"									    "SEGMENT?"
      "SEMIGROUP"									    "SEMIGROUP"
      "SET"										    "SET"
      "SET-ELEMENTS"									    "SET-ELEMENTS"
      "SET-OF-PAIRS"									    "SET-OF-PAIRS"
      "SIMPLE-FIELD-EXTENSION"								    "SIMPLE-FIELD-EXTENSION"
      "SIMPLE-RING"									    "SIMPLE-RING"
      "SIMPLE-SET"									    "SIMPLE-SET"
      "SIMPLEX"										    "SIMPLEX"
      "SIMPLEX-SIZE"									    "SIMPLEX-SIZE"
      "SIMPLICIAL-COMPLEX"								    "SIMPLICIAL-COMPLEX"
      "SIMPLIFY"									    "SIMPLIFY"
      "SKEW-FIELD"									    "SKEW-FIELD"
      "SPLIT"										    "SPLIT"
      "SQUARE-FREE"									    "SQUARE-FREE"
      "STRING-OF"									    "STRING-OF"
      "SUBFACE?"									    "SUBFACE?"
      "SUBSTITUTE"									    "SUBSTITUTE"
      "TAYLOR"										    "TAYLOR"
      "TERMS-OF"									    "TERMS-OF"
      "TETRAHEDRON?"									    "TETRAHEDRON?"
      "TILDE"										    "TILDE"
      "TOTAL->"										    "TOTAL->"
      "TOTIENT"										    "TOTIENT"
      "TRANSPOSE"									    "TRANSPOSE"
      "TRIANGLE?"									    "TRIANGLE?"
      "TRUNCATE-ORDER"									    "TRUNCATE-ORDER"
      "TUPLE"										    "TUPLE"
      "UNIQUE-FACTORIZATION-DOMAIN"							    "UNIQUE-FACTORIZATION-DOMAIN"
      "UNIVERSAL-QUANTIFIED-SET"							    "UNIVERSAL-QUANTIFIED-SET"
      "VAR-OF"										    "VAR-OF"
      "VAR-DOMAIN-OF"									    "VAR-DOMAIN-OF"
      "VARIABLE-DERIVATION"								    "VARIABLE-DERIVATION"
      "VARIABLE-INDEX"									    "VARIABLE-INDEX"
      "VARLIST-OF"									    "VARLIST-OF"
      "VECTOR-SPACE"									    "VECTOR-SPACE"
      "VERTICES-OF"									    "VERTICES-OF"
      "WITH-MATRIX-DIMENSIONS"								    "WITH-MATRIX-DIMENSIONS"
      "WITH-NUMERATOR-AND-DENOMINATOR"							    "WITH-NUMERATOR-AND-DENOMINATOR"
      "WRITE-MESH"									    "WRITE-MESH"
      "ZERO"										    "ZERO"
      "ZERO-MATRIX"								    |	    "ZERO-MATRIX")
      ))									    |	  "Symbols exported from the internal WEYL package.")

(export (intern-in-package "WEYLI" *weyli-exported-symbols*) 'weyli)		    |	(defvar *weyli-shadowed-symbols*
										    >	  '(coerce set + - * / = > < >= <= minus expt abs random
										    >	    gcd lcm floor ceiling truncate round max min
										    >	    complex conjugate realpart imagpart
										    >	    sqrt exp log phase signum minusp zerop plusp
										    >	    sin cos tan asin acos atan sinh cosh tanh asinh acosh atanh
										    >	    numerator denominator reduce 
										    >	    map delete member replace substitute getf union intersection
										    >	    apply funcall variable
										    >	    type-of)
										    >	  "Common lisp symbols shadowed in the internal WEYL package.")

(unless (find-package "WEYL")							    |	(defvar *weyl-exported-symbols*
  #-Genera									    |	  '("MAKE-ELEMENT"
  (make-package "WEYL" :use '(#-MCL LISP #+MCL CL #+PCL PCL 			    |	    "MAKE-UPOLYNOMIAL")
                              #+(and CLOS (not MCL)) CLOS))			    |	  "The WEYL package export these symbols in addition to those exported
										    >	form WEYLI.")

  #+Genera									    |	;; This should probably only be used to create the WEYL package
  (make-package "WEYL" 								    |	(defun use-weyli-package (package)
		:use '(#-Rel8 LISP #+Rel8 FUTURE-COMMON-LISP			    |	  "Shadow import the shadowed symbols in the WEYLI package and then
		       #+PCL PCL #+CLOS CLOS)					    |	use it."
		:colon-mode :external))						    |	  (declare (special *weyli-shadowed-symbols*))
										    >	  (shadowing-import (loop for sym in *weyli-shadowed-symbols*
										    >				  collect (intern (symbol-name sym) 'weyli))
										    >			    package)
										    >	  (use-package (find-package 'weyli) package))

(use-weyli-package 'weyl)							    |	(defun use-weyl-package (package)
										    >	  "Shadow import the shadowed symbols in the WEYL package and then use
										    >	it."
										    >	  (declare (special *weyli-shadowed-symbols*))
										    >	  (shadowing-import (loop for sym in *weyli-shadowed-symbols*
										    >				  collect (intern (symbol-name sym) 'weyl))
										    >			    package)
										    >	  (use-package (find-package 'weyl) package))

(defvar *weyl-exported-symbols*							    |	(defun intern-in-package (package-name symbols)
    '("MAKE-ELEMENT"								    |	  (loop for sym in symbols
      "MAKE-UPOLYNOMIAL"							    |		with  package = (find-package package-name)
      ))									    |		collect (intern sym package)))
										    >
										    >	(defpackage "WEYLI"
										    >	  (:use :common-lisp))
										    >
										    >	(shadow *weyli-shadowed-symbols* 'weyli)
										    >	(export (intern-in-package "WEYLI" *weyli-exported-symbols*) 'weyli)
										    >
										    >	(defpackage "WEYL"
										    >	  (:use :common-lisp))
										    >
										    >	(use-weyli-package 'weyl)

(export (intern-in-package "WEYL" *weyli-exported-symbols*) 'weyl)			(export (intern-in-package "WEYL" *weyli-exported-symbols*) 'weyl)
(export (intern-in-package "WEYL" *weyl-exported-symbols*) 'weyl)			(export (intern-in-package "WEYL" *weyl-exported-symbols*) 'weyl)

#+ignore   ;; The following isn't used anymore.					    <
(unless (find-package "WALKER")							    <
  (make-package "WALKER" :use '(#+MCL "CL" #-MCL "LISP")))			    <
										    <
;;  Create the basic-graphics package.  This is package is needed if			;;  Create the basic-graphics package.  This is package is needed if
;;  the system Mesh-Draw is loaded.							;;  the system Mesh-Draw is loaded.
										    >	#-(and)
(unless (find-package "BASIC-GRAPHICS")							(unless (find-package "BASIC-GRAPHICS")
  #-Genera										  #-Genera
  (make-package "BASIC-GRAPHICS" :nicknames '(BG)					  (make-package "BASIC-GRAPHICS" :nicknames '(BG)
		:use '(#-MCL LISP #+MCL CL #+PCL PCL							:use '(#-MCL LISP #+MCL CL #+PCL PCL
		       #+(and CLOS (not MCL)) CLOS))							       #+(and CLOS (not MCL)) CLOS))
  #+Genera										  #+Genera
  (make-package "BASIC-GRAPHICS" :nicknames '(BG)					  (make-package "BASIC-GRAPHICS" :nicknames '(BG)
		:use '(#-Rel8 LISP #+Rel8 FUTURE-COMMON-LISP						:use '(#-Rel8 LISP #+Rel8 FUTURE-COMMON-LISP
		       #+PCL PCL #+CLOS CLOS)								       #+PCL PCL #+CLOS CLOS)
		:colon-mode :external))									:colon-mode :external))
										    (
;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-		;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-
;;; ===========================================================================		;;; ===========================================================================
;;;			      Polynomial Domain Tools					;;;			      Polynomial Domain Tools
;;; ===========================================================================		;;; ===========================================================================
;;; (c) Copyright 1989, 1993 Cornell University						;;; (c) Copyright 1989, 1993 Cornell University

;;; poly-tools.lisp,v 1.4 1995/05/24 17:42:08 rz Exp					;;; poly-tools.lisp,v 1.4 1995/05/24 17:42:08 rz Exp

(in-package "WEYLI")								    |	(in-package :weyli)

(make::adjust-version-numbers Weyl "1.4")					    |	;;; DELETE (make::adjust-version-numbers Weyl "1.4")

;; Things conditionalized by GEHASH would require hash tables that			;; Things conditionalized by GEHASH would require hash tables that
;; work with GE-EQUAL.									;; work with GE-EQUAL.

(defmethod initialize-instance :after							(defmethod initialize-instance :after
     ((domain variable-hash-table) &rest plist)						    ((domain variable-hash-table) &rest plist)
  (declare (ignore plist))								  (declare (ignore plist))
  (with-slots (variable-hash-table variable-table variables) domain			  (with-slots (variable-hash-table variable-table variables) domain
    #+GEHASH										    #+GEHASH
    (setq variable-hash-table (make-hash-table :test #'equal))				    (setq variable-hash-table (make-hash-table :test #'equal))
    											    (setq variable-table (make-array (list (max (length variables) 1) 2)))
    (setq variable-table (make-array (list (max (length variables) 1) 2)))		    (setq variable-hash-table 
    (setq variable-hash-table 									  (loop for var in variables
	  (loop for var in variables									for i upfrom 0
		for i upfrom 0										collect (list var i)
		collect (list var i)									do (setf (aref variable-table i 0) var)))))
		do (setf (aref variable-table i 0) var)))))
										    (
										    >	(defgeneric variable-index (domain variable)
										    >	  (:documentation
										    >	   "The purpose of this method is unknown."))
										    >
(defmethod variable-index ((domain variable-hash-table) (variable symbol))		(defmethod variable-index ((domain variable-hash-table) (variable symbol))
  (setq variable (coerce variable *general*))						  (setq variable (coerce variable *general*))
  (loop for (var index) in (variable-hash-table domain)					  (loop for (var index) in (variable-hash-table domain)
	do (when (ge-equal variable var)							do (when (ge-equal variable var)
	     (return index)))									     (return index)))
  #+GEHASH										  #+GEHASH
  (gethash variable (variable-hash-table domain)))					  (gethash variable (variable-hash-table domain)))

(defmethod variable-index								(defmethod variable-index
    ((domain variable-hash-table) (variable general-expression))  			    ((domain variable-hash-table) (variable general-expression))  
  (loop for (var index) in (variable-hash-table domain)					  (loop for (var index) in (variable-hash-table domain)
	do (when (ge-equal variable var)							do (when (ge-equal variable var)
	     (return index)))									     (return index)))
  #+GEHASH										  #+GEHASH
  (gethash variable (variable-hash-table domain)))					  (gethash variable (variable-hash-table domain)))

										    >	(defgeneric variable-symbol (domain order)
										    >	  (:documentation
										    >	   "The purpose of this method is unknown."))
										    >
(defmethod variable-symbol ((domain variable-hash-table) (order-number number))		(defmethod variable-symbol ((domain variable-hash-table) (order-number number))
  (aref (variable-index-table domain) order-number 0))					  (aref (variable-index-table domain) order-number 0))

;;(defmethod variable-symbol ((domain variable-hash-table) (poly polynomial))		;;(defmethod variable-symbol ((domain variable-hash-table) (poly polynomial))
;;  (aref (variable-index-table domain) (poly-order-number (poly-form poly)) 0))	;;  (aref (variable-index-table domain) (poly-order-number (poly-form poly)) 0))

										    >	(defgeneric get-variable-number-property (domain order property)
										    >	  (:documentation
										    >	   "The purpose of this method is unknown."))
										    >
(defmethod get-variable-number-property							(defmethod get-variable-number-property
    ((domain variable-hash-table) order-number property)				    ((domain variable-hash-table) order-number property)
  (%getf (aref (variable-index-table domain) order-number 1) property))			  (%getf (aref (variable-index-table domain) order-number 1) property))

										    >	(defgeneric set-variable-number-property (domain order property value)
										    >	  (:documentation
										    >	   "The purpose of this method is unknown."))
										    >
(defmethod set-variable-number-property							(defmethod set-variable-number-property
	   ((domain variable-hash-table) order-number property value)			    ((domain variable-hash-table) order-number property value)
  (setf (%getf (aref (variable-index-table domain) order-number 1) property)		  (setf (%getf (aref (variable-index-table domain) order-number 1) property)
	value))											value))

(defsetf get-variable-number-property set-variable-number-property)			(defsetf get-variable-number-property set-variable-number-property)

(defmethod get-variable-property							(defmethod get-variable-property
    ((domain variable-hash-table) variable property)					    ((domain variable-hash-table) variable property)
  (setq variable (coerce variable *general*))						  (setq variable (coerce variable *general*))
  (get-variable-number-property domain (variable-index domain variable)			  (get-variable-number-property domain (variable-index domain variable)
				property))										property))

(defmethod set-variable-property							(defmethod set-variable-property
    ((domain variable-hash-table) variable property value)  				    ((domain variable-hash-table) variable property value)  
  (setq variable (coerce variable *general*))						  (setq variable (coerce variable *general*))
  (set-variable-number-property domain (variable-index domain variable)			  (set-variable-number-property domain (variable-index domain variable)
				property value))									property value))

;; Defined in general, which is loaded first.						;; Defined in general, which is loaded first.
;;(defsetf get-variable-property set-variable-property)					;;(defsetf get-variable-property set-variable-property)

										    >	(defgeneric add-new-variable (ring variable)
										    >	  (:documentation
										    >	   "The purpose of this method is unknown."))
										    >
(defmethod add-new-variable ((ring variable-hash-table) variable)			(defmethod add-new-variable ((ring variable-hash-table) variable)
  (with-slots (variables variable-hash-table variable-table) ring			  (with-slots (variables variable-hash-table variable-table) ring
    (let ((vars (different-kernels (coerce variable *general*)				    (let ((vars (different-kernels (coerce variable *general*)
				   variables)))										   variables)))
      (setq vars									      (setq vars
	    (loop for var in vars								    (loop for var in vars
		  unless (member var variables :test #'ge-equal)					  unless (member var variables :test #'ge-equal)
		    collect var))							                  collect var))
      (unless (null vars)								      (unless (null vars)
	(let* ((count (length variables))							(let* ((count (length variables))
	       (array (make-array (list (cl:+ count (length vars)) 2))))			       (array (make-array (list (cl:+ count (length vars)) 2))))
	  (setq variables (append variables vars))						  (setq variables (append variables vars))
	  (copy-array-contents variable-table array)						  (copy-array-contents variable-table array)
	  (setq variable-table array)								  (setq variable-table array)
	  #-GEHASH										  #-GEHASH
	  (setq variable-hash-table								  (setq variable-hash-table
		(nconc variable-hash-table								(nconc variable-hash-table
		       (loop for var in vars								       (loop for var in vars
			     for cnt upfrom count								     for cnt upfrom count
			     do (setf (aref variable-table cnt 0) var)						     do (setf (aref variable-table cnt 0) var)
			     collect (list var cnt))))								     collect (list var cnt))))
	  #+GEHASH ;; If we had General expression hash tables					  #+GEHASH ;; If we had General expression hash tables
	  (loop for var in vars									  (loop for var in vars
		for cnt upfrom count									for cnt upfrom count
		do (setf (gethash var variable-table) cnt)))))						do (setf (gethash var variable-table) cnt)))))
    ring))										    ring))

(defmethod zero ((domain caching-zero-and-one))						(defmethod zero ((domain caching-zero-and-one))
  (with-slots (zero) domain								  (with-slots (zero) domain
    zero))										    zero))

(defmethod one ((domain caching-zero-and-one))						(defmethod one ((domain caching-zero-and-one))
  (with-slots (one) domain								  (with-slots (one) domain
    one))										    one))
;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-		;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-
;;; ===========================================================================		;;; ===========================================================================
;;;				  Projective Spaces					;;;				  Projective Spaces
;;; ===========================================================================		;;; ===========================================================================
;;; (c) Copyright 1989, 1993 Cornell University						;;; (c) Copyright 1989, 1993 Cornell University

;;; projective-space.lisp,v 1.5 1995/05/24 17:42:09 rz Exp				;;; projective-space.lisp,v 1.5 1995/05/24 17:42:09 rz Exp

(in-package "WEYLI")								    |	(in-package :weyli)

(make::adjust-version-numbers Weyl "1.5")					    |	;;; DELETE (make::adjust-version-numbers Weyl "1.5")

(define-domain-creator projective-space ((domain field) dimension)		    |	(eval-when (:compile-toplevel :load-toplevel)
										    >	  (define-domain-creator projective-space ((domain field) dimension)
  (make-instance 'projective-space							    (make-instance 'projective-space
		 :coefficient-domain domain						                   :coefficient-domain domain
		 :dimension dimension							                   :dimension dimension
		 :print-function 'projective-space-print-object)			                   :print-function 'projective-space-print-object)
  :predicate #'(lambda (d)								    :predicate #'(lambda (d)
	         (and (eql (class-name (class-of d)) 'projective-space)			                   (and (eql (class-name (class-of d)) 'projective-space)
		      (eql (coefficient-domain-of d) domain)				                        (eql (coefficient-domain-of d) domain)
		      (eql (dimension-of d) dimension))))			    |	                        (eql (dimension-of d) dimension)))))

(defun projective-space-print-object (domain stream)					(defun projective-space-print-object (domain stream)
  (format stream #+Genera "P~D(~S)" #-Genera "P^~D(~S)"					  (format stream #+Genera "P~D(~S)" #-Genera "P^~D(~S)"
	  (dimension-of domain)									  (dimension-of domain)
	  (coefficient-domain-of domain)))							  (coefficient-domain-of domain)))

(defun make-projective-space-element (domain value)					(defun make-projective-space-element (domain value)
  (make-instance 'projective-space-element :domain domain :value value))		  (make-instance 'projective-space-element :domain domain :value value))

(defmethod make-element ((domain projective-space) value &rest values)			(defmethod make-element ((domain projective-space) value &rest values)
  (let ((dim (dimension-of domain))							  (let ((dim (dimension-of domain))
	(num-values (1+ (length values)))							(num-values (1+ (length values)))
	(coeff-domain (coefficient-domain-of domain))						(coeff-domain (coefficient-domain-of domain))
	array)											array)
    (setq values (cons value values))							    (setq values (cons value values))
    (cond ((eql dim num-values)								    (cond ((eql dim num-values)
	   (setq array (make-array (1+ dim)))							   (setq array (make-array (1+ dim)))
	   (loop for i below dim								   (loop for i below dim
		 for v in values do									 for v in values do
	     (setf (aref array i) (coerce v coeff-domain)))					     (setf (aref array i) (coerce v coeff-domain)))
	   (setf (aref array dim) (one coeff-domain))						   (setf (aref array dim) (one coeff-domain))
	   (make-projective-space-element domain array))					   (make-projective-space-element domain array))
	  ((eql dim (1- num-values))								  ((eql dim (1- num-values))
	   (setq array (make-array (1+ dim)))							   (setq array (make-array (1+ dim)))
	   (loop for i below dim								   (loop for i below dim
		 for v in values 									 for v in values 
		 with denom = (coerce (first (last values)) coeff-domain) do				 with denom = (coerce (first (last values)) coeff-domain) do
	     (setf (aref array i) (/ (coerce v coeff-domain) denom)))				     (setf (aref array i) (/ (coerce v coeff-domain) denom)))
	   (setf (aref array dim) (one coeff-domain))						   (setf (aref array dim) (one coeff-domain))
	   (make-projective-space-element domain array))					   (make-projective-space-element domain array))
	  (t (error "Wrong number of vector elements in ~S" domain)))))				  (t (error "Wrong number of vector elements in ~S" domain)))))

(defmethod ref ((vect projective-space-element) &rest args)				(defmethod ref ((vect projective-space-element) &rest args)
  (aref (tuple-value vect) (first args)))						  (aref (tuple-value vect) (first args)))

(defmethod vector-set-ref								(defmethod vector-set-ref
    ((vect projective-space-element) new-value &rest args)				    ((vect projective-space-element) new-value &rest args)
  (setf (aref (tuple-value vect) (first args)) new-value))				  (setf (aref (tuple-value vect) (first args)) new-value))

;; Create an affine space corresponding to 						;; Create an affine space corresponding to 
(defmethod make-affine-space ((space projective-space) &optional n)			(defmethod make-affine-space ((space projective-space) &optional n)
  (let* ((dim (dimension-of space))							  (let* ((dim (dimension-of space))
	 (range-space (make-vector-space (coefficient-domain-of space) dim))			 (range-space (make-vector-space (coefficient-domain-of space) dim))
	 homo)											 homo)
    (when (null n)									    (when (null n)
      (setf n dim))									      (setf n dim))
    (labels ((project (vector)								    (labels ((project (vector)
	       (loop with denom = (ref vector n)						       (loop with denom = (ref vector n)
		     for i below (1+ dim)								     for i below (1+ dim)
		     unless (= i n)									     unless (= i n)
		       collect (/ (ref vector i) denom)))						       collect (/ (ref vector i) denom)))
	     (map-fun (vector)									     (map-fun (vector)
	       (%apply #'make-element range-space (project vector))))				       (%apply #'make-element range-space (project vector))))
      (setq homo (make-morphism space #'map-fun range-space))				      (setq homo (make-morphism space #'map-fun range-space))
      (values (morphism-range homo)							      (values (morphism-range homo)
	      (morphism-map homo)))))								      (morphism-map homo)))))

;;; -*- Mode:Lisp; Package: WEYLI; Base:10; Lowercase:T; Syntax:Common-Lisp -*-		;;; -*- Mode:Lisp; Package: WEYLI; Base:10; Lowercase:T; Syntax:Common-Lisp -*-
;;; ===========================================================================		;;; ===========================================================================
;;;				  Quaternions						;;;				  Quaternions
;;;											;;;
;;;											;;;
;;; based on "Applications of quaternions to computations with rotation",		;;; based on "Applications of quaternions to computations with rotation",
;;;   Eugene Salamin.									;;;   Eugene Salamin.
;;; Contains quaternions over a field and unit quaternions.				;;; Contains quaternions over a field and unit quaternions.
;;;											;;;
;;; Not yet implemented: homomorphism between unit quaternions and SO(3)		;;; Not yet implemented: homomorphism between unit quaternions and SO(3)
;;;											;;;
;;; ===========================================================================		;;; ===========================================================================

;;; (c) Copyright 1989, 1993 Cornell University						;;; (c) Copyright 1989, 1993 Cornell University

;;; quaternions.lisp,v 1.9 1995/05/24 17:42:09 rz Exp					;;; quaternions.lisp,v 1.9 1995/05/24 17:42:09 rz Exp

(in-package "WEYLI")								    |	(in-package :weyli)

(make::adjust-version-numbers Weyl "1.9")					    |	;;; DELETE (make::adjust-version-numbers Weyl "1.9")

										    |	(eval-when (:compile-toplevel :load-toplevel)
(define-domain-creator quaternion-domain ((domain field))			    |	  (define-domain-creator quaternion-domain ((domain field))
  (make-instance 'quaternion-domain							    (make-instance 'quaternion-domain
		 :coefficient-domain domain						                   :coefficient-domain domain
		 :dimension 4								                   :dimension 4
		 :print-function 'quaternion-domain-print-object)			                   :print-function 'quaternion-domain-print-object)
  :predicate #'(lambda (d)								    :predicate #'(lambda (d)
	         (and (eql (class-name (class-of d)) 'quaternion-domain)		                   (and (eql (class-name (class-of d)) 'quaternion-domain)
		      (eql (coefficient-domain-of d) domain))))			    |	                        (eql (coefficient-domain-of d) domain)))))

(defun quaternion-domain-print-object (domain stream)					(defun quaternion-domain-print-object (domain stream)
  (format stream "Quat(~S)" (coefficient-domain-of domain)))				  (format stream "Quat(~S)" (coefficient-domain-of domain)))

										    |	(eval-when (:compile-toplevel :load-toplevel)
(define-domain-creator unit-quaternion-domain ((domain field))			    |	  (define-domain-creator unit-quaternion-domain ((domain field))
  (make-instance 'unit-quaternion-domain						    (make-instance 'unit-quaternion-domain
		 :coefficient-domain domain						                   :coefficient-domain domain
		 :dimension 4								                   :dimension 4
		 :print-function 'unit-quaternion-domain-print-object)			                   :print-function 'unit-quaternion-domain-print-object)
  :predicate #'(lambda (d)								    :predicate #'(lambda (d)
	         (and (eql (class-name (class-of d)) 'unit-quaternion-domain)		                   (and (eql (class-name (class-of d)) 'unit-quaternion-domain)
		      (eql (coefficient-domain-of d) domain))))			    |	                        (eql (coefficient-domain-of d) domain)))))

(defun unit-quaternion-domain-print-object (domain stream)				(defun unit-quaternion-domain-print-object (domain stream)
  (format stream "UQuat(~S)" (coefficient-domain-of domain)))				  (format stream "UQuat(~S)" (coefficient-domain-of domain)))


;;; Quaternion elements themselves							;;; Quaternion elements themselves


(define-domain-element-classes quaternion-domain					(define-domain-element-classes quaternion-domain
    quaternion-domain-element)								    quaternion-domain-element)

(define-domain-element-classes unit-quaternion-domain					(define-domain-element-classes unit-quaternion-domain
    unit-quaternion-domain-element)							    unit-quaternion-domain-element)

(defmethod make-element ((domain quaternion-domain) (value vector)			(defmethod make-element ((domain quaternion-domain) (value vector)
			 &rest values)										 &rest values)
  (unless (and (eql (array-dimension value 0) 4)					  (unless (and (eql (array-dimension value 0) 4)
	       (null values))									       (null values))
    (error "Wrong number of vector elements in ~S" domain))				    (error "Wrong number of vector elements in ~S" domain))
  (make-instance (first (domain-element-classes domain))				  (make-instance (first (domain-element-classes domain))
		 :domain domain :values value))								 :domain domain :values value))

(defmethod weyl::make-element ((domain quaternion-domain) (value vector)		(defmethod weyl::make-element ((domain quaternion-domain) (value vector)
			       &rest values)									       &rest values)
  (unless (and (eql (array-dimension value 0) 4)					  (unless (and (eql (array-dimension value 0) 4)
	       (null values))									       (null values))
    (error "Wrong number of vector elements in ~S" domain))				    (error "Wrong number of vector elements in ~S" domain))
  (let ((coef-domain (coefficient-domain-of domain))					  (let ((coef-domain (coefficient-domain-of domain))
	(vector (make-array 4)))								(vector (make-array 4)))
    (loop for i below 4 do								    (loop for i below 4 do
      (setf (aref vector i) (coerce (aref value i) coef-domain)))			      (setf (aref vector i) (coerce (aref value i) coef-domain)))
    (make-instance (first (domain-element-classes domain))				    (make-instance (first (domain-element-classes domain))
		   :domain domain :values vector)))							   :domain domain :values vector)))

(defmethod make-element ((domain quaternion-domain) value &rest values)			(defmethod make-element ((domain quaternion-domain) value &rest values)
  (unless (eql 3 (length values))							  (unless (eql 3 (length values))
    (error "Wrong number of vector elements in ~S" domain))				    (error "Wrong number of vector elements in ~S" domain))
  (make-instance (first (domain-element-classes domain))				  (make-instance (first (domain-element-classes domain))
		 :domain domain										 :domain domain
		 :values (%apply #'vector value values)))						 :values (%apply #'vector value values)))

(defmethod weyl::make-element ((domain quaternion-domain) value &rest values)		(defmethod weyl::make-element ((domain quaternion-domain) value &rest values)
  (unless (eql 3 (length values))							  (unless (eql 3 (length values))
    (error "Wrong number of vector elements in ~S" domain))				    (error "Wrong number of vector elements in ~S" domain))
  (let ((coef-domain (coefficient-domain-of domain))					  (let ((coef-domain (coefficient-domain-of domain))
	(vector (make-array 4)))								(vector (make-array 4)))
    (setf (aref vector 0) (coerce value coef-domain))					    (setf (aref vector 0) (coerce value coef-domain))
    (setf (aref vector 1) (coerce (first values) coef-domain))				    (setf (aref vector 1) (coerce (first values) coef-domain))
    (setf (aref vector 2) (coerce (second values) coef-domain))				    (setf (aref vector 2) (coerce (second values) coef-domain))
    (setf (aref vector 3) (coerce (third values) coef-domain))				    (setf (aref vector 3) (coerce (third values) coef-domain))
    (make-instance (first (domain-element-classes domain))				    (make-instance (first (domain-element-classes domain))
		   :domain domain									   :domain domain
		   :values vector)))									   :values vector)))

(defmethod make-element ((domain unit-quaternion-domain) (value vector)			(defmethod make-element ((domain unit-quaternion-domain) (value vector)
			 &rest values)  									 &rest values)  
  (unless (and (eql (array-dimension value 0) 4)					  (unless (and (eql (array-dimension value 0) 4)
	       (null values))									       (null values))
    (error "Wrong number of vector elements in ~S" domain))				    (error "Wrong number of vector elements in ~S" domain))
  (make-instance (first (domain-element-classes domain))				  (make-instance (first (domain-element-classes domain))
		 :domain domain :values value))								 :domain domain :values value))

;; FIXTHIS: Should check to make sure that quaternion is a unit				;; FIXTHIS: Should check to make sure that quaternion is a unit
(defmethod weyl::make-element ((domain unit-quaternion-domain) (value vector)		(defmethod weyl::make-element ((domain unit-quaternion-domain) (value vector)
			       &rest values)  									       &rest values)  
  (unless (and (eql (array-dimension value 0) 4)					  (unless (and (eql (array-dimension value 0) 4)
	       (null values))									       (null values))
    (error "Wrong number of vector elements in ~S" domain))				    (error "Wrong number of vector elements in ~S" domain))
  (let ((coef-domain (coefficient-domain-of domain))					  (let ((coef-domain (coefficient-domain-of domain))
	(vector (make-array 4)))								(vector (make-array 4)))
    (loop for i below 4 do								    (loop for i below 4 do
      (setf (aref vector i) (coerce (aref value i) coef-domain)))			      (setf (aref vector i) (coerce (aref value i) coef-domain)))
    (make-instance (first (domain-element-classes domain))				    (make-instance (first (domain-element-classes domain))
		   :domain domain :values vector)))							   :domain domain :values vector)))

(defmethod make-element ((domain unit-quaternion-domain) value &rest values)		(defmethod make-element ((domain unit-quaternion-domain) value &rest values)
  (unless (eql 3 (length values))							  (unless (eql 3 (length values))
    (error "Wrong number of vector elements in ~S" domain))				    (error "Wrong number of vector elements in ~S" domain))
  (make-instance (first (domain-element-classes domain))				  (make-instance (first (domain-element-classes domain))
		 :domain domain										 :domain domain
		 :values (%apply #'vector value values)))						 :values (%apply #'vector value values)))

;; FIXTHIS: Should check to make sure that quaternion is a unit				;; FIXTHIS: Should check to make sure that quaternion is a unit
(defmethod weyl::make-element ((domain unit-quaternion-domain) value			(defmethod weyl::make-element ((domain unit-quaternion-domain) value
			       &rest values)									       &rest values)
  (unless (eql 3 (length values))							  (unless (eql 3 (length values))
    (error "Wrong number of vector elements in ~S" domain))				    (error "Wrong number of vector elements in ~S" domain))
  (let ((coef-domain (coefficient-domain-of domain))					  (let ((coef-domain (coefficient-domain-of domain))
	(vector (make-array 4)))								(vector (make-array 4)))
    (setf (aref vector 0) (coerce value coef-domain))					    (setf (aref vector 0) (coerce value coef-domain))
    (setf (aref vector 1) (coerce (first values) coef-domain))				    (setf (aref vector 1) (coerce (first values) coef-domain))
    (setf (aref vector 2) (coerce (second values) coef-domain))				    (setf (aref vector 2) (coerce (second values) coef-domain))
    (setf (aref vector 3) (coerce (third values) coef-domain))				    (setf (aref vector 3) (coerce (third values) coef-domain))
    (make-instance (first (domain-element-classes domain))				    (make-instance (first (domain-element-classes domain))
		   :domain domain									   :domain domain
		   :values vector)))									   :values vector)))

(defmethod conjugate ((q quaternion-with-multiplication))				(defmethod conjugate ((q quaternion-with-multiplication))
  (let ((value (tuple-value q)))							  (let ((value (tuple-value q)))
    (make-element (domain-of q)								    (make-element (domain-of q)
      (aref value 0) (- (aref value 1))							      (aref value 0) (- (aref value 1))
      (- (aref value 2)) (- (aref value 3)))))						      (- (aref value 2)) (- (aref value 3)))))

(defmethod-sd dot-product								(defmethod-sd dot-product
    ((q1 quaternion-with-multiplication) (q2 quaternion-with-multiplication))		    ((q1 quaternion-with-multiplication) (q2 quaternion-with-multiplication))
  (loop for i upfrom 1 below 4								  (loop for i upfrom 1 below 4
	with ans = (* (ref q1 0) (ref q2 0))							with ans = (* (ref q1 0) (ref q2 0))
	do (setq ans (+ ans (* (ref q1 i) (ref q2 i))))						do (setq ans (+ ans (* (ref q1 i) (ref q2 i))))
	finally (return ans)))									finally (return ans)))

(defmethod-sd times									(defmethod-sd times
  ((p quaternion-with-multiplication) (q quaternion-with-multiplication))		  ((p quaternion-with-multiplication) (q quaternion-with-multiplication))
  (let* ((pp (tuple-value p))								  (let* ((pp (tuple-value p))
	 (p0 (aref pp 0))									 (p0 (aref pp 0))
	 (p1 (aref pp 1))									 (p1 (aref pp 1))
	 (p2 (aref pp 2))									 (p2 (aref pp 2))
	 (p3 (aref pp 3))									 (p3 (aref pp 3))
	 (qq (tuple-value q))									 (qq (tuple-value q))
	 (q0 (aref qq 0))									 (q0 (aref qq 0))
	 (q1 (aref qq 1))									 (q1 (aref qq 1))
	 (q2 (aref qq 2))									 (q2 (aref qq 2))
	 (q3 (aref qq 3))) 									 (q3 (aref qq 3))) 
    (make-element domain								    (make-element domain
		  (- (* p0 q0) (+ (+ (* p1 q1) (* p2 q2)) (* p3 q3)))					  (- (* p0 q0) (+ (+ (* p1 q1) (* p2 q2)) (* p3 q3)))
		  (- (+ (+ (* p1 q0) (* p0 q1)) (* p2 q3)) (* p3 q2))					  (- (+ (+ (* p1 q0) (* p0 q1)) (* p2 q3)) (* p3 q2))
		  (- (+ (+ (* p2 q0) (* p0 q2)) (* p3 q1)) (* p1 q3))					  (- (+ (+ (* p2 q0) (* p0 q2)) (* p3 q1)) (* p1 q3))
		  (- (+ (+ (* p3 q0) (* p0 q3)) (* p1 q2)) (* p2 q1)))))				  (- (+ (+ (* p3 q0) (* p0 q3)) (* p1 q2)) (* p2 q1)))))
	     											     
#|  For metricized fields|								#|  For metricized fields|

(defmethod norm ((q quaternion-domain-element))						(defmethod norm ((q quaternion-domain-element))
  (sqrt (dot-product q q)))								  (sqrt (dot-product q q)))

(defmethod normalize ((q quaternion-domain-element))					(defmethod normalize ((q quaternion-domain-element))
  (let ((l (norm q))									  (let ((l (norm q))
	(v (tuple-value q)))									(v (tuple-value q)))
    (make-quaternion-domain-element 							    (make-quaternion-domain-element 
     (domain-of q)									     (domain-of q)
     (make-array 4 :initial-contents (list (/ (aref v 0) l)				     (make-array 4 :initial-contents (list (/ (aref v 0) l)
					   (/ (aref v 1) l)									   (/ (aref v 1) l)
					   (/ (aref v 2) l)									   (/ (aref v 2) l)
					   (/ (aref v 3) l))))))								   (/ (aref v 3) l))))))
||#											||#

(defmethod create-unit-quaternion							(defmethod create-unit-quaternion
  ((domain unit-quaternion-domain) (v vector-space-element) (angle number))		  ((domain unit-quaternion-domain) (v vector-space-element) (angle number))
  (unless (= 3 (dimension-of (domain-of v)))						  (unless (= 3 (dimension-of (domain-of v)))
	  (error "Illegal call to create-unit-quaternion: ~S" v))				  (error "Illegal call to create-unit-quaternion: ~S" v))
  ;; must coerce domains								  ;; must coerce domains
  (make-element domain									  (make-element domain
		(cos (/ angle 2)) 									(cos (/ angle 2)) 
		(* (sin (/ angle 2)) (ref v 0))								(* (sin (/ angle 2)) (ref v 0))
		(* (sin (/ angle 2)) (ref v 1))								(* (sin (/ angle 2)) (ref v 1))
		(* (sin (/ angle 2)) (ref v 2))))							(* (sin (/ angle 2)) (ref v 2))))

;;											;;
;; homomorphism SO(3) --> Unit Quaternions						;; homomorphism SO(3) --> Unit Quaternions
;;											;;

(defmethod coerce ((Q unit-quaternion-domain-element) (domain SO-n))			(defmethod coerce ((Q unit-quaternion-domain-element) (domain SO-n))
  (if (eql (dimension-of domain) 3)							  (if (eql (dimension-of domain) 3)
      (let* ((q0 (ref Q 0))								      (let* ((q0 (ref Q 0))
	     (q1 (ref Q 1))									     (q1 (ref Q 1))
	     (q2 (ref Q 2))									     (q2 (ref Q 2))
	     (q3 (ref Q 3))									     (q3 (ref Q 3))
	     (q0q0 (* q0 q0))									     (q0q0 (* q0 q0))
	     (q0q1 (* q0 q1))									     (q0q1 (* q0 q1))
	     (q0q2 (* q0 q2))									     (q0q2 (* q0 q2))
	     (q0q3 (* q0 q3))									     (q0q3 (* q0 q3))
	     (q1q1 (* q1 q1))									     (q1q1 (* q1 q1))
	     (q1q2 (* q1 q2))		;							     (q1q2 (* q1 q2))		;
	     (q1q3 (* q1 q3))									     (q1q3 (* q1 q3))
	     (q2q2 (* q2 q2))									     (q2q2 (* q2 q2))
	     (q2q3 (* q2 q3))									     (q2q3 (* q2 q3))
	     (q3q3 (* q3 q3))									     (q3q3 (* q3 q3))
	     (mat (make-array '(3 3))))								     (mat (make-array '(3 3))))
	(setf (aref mat 0 0) (+ (* 2 q0q0) (* 2 q1q1) -1))					(setf (aref mat 0 0) (+ (* 2 q0q0) (* 2 q1q1) -1))
	(setf (aref mat 1 1) (+ (* 2 q0q0) (* 2 q2q2) -1))					(setf (aref mat 1 1) (+ (* 2 q0q0) (* 2 q2q2) -1))
	(setf (aref mat 2 2) (+ (* 2 q0q0) (* 2 q3q3) -1))					(setf (aref mat 2 2) (+ (* 2 q0q0) (* 2 q3q3) -1))
	(setf (aref mat 0 1) (* 2 (- q1q2 q0q3)))						(setf (aref mat 0 1) (* 2 (- q1q2 q0q3)))
	(setf (aref mat 0 2) (* 2 (+ q1q3 q0q2)))						(setf (aref mat 0 2) (* 2 (+ q1q3 q0q2)))
	(setf (aref mat 1 2) (* 2 (- q2q3 q0q1)))						(setf (aref mat 1 2) (* 2 (- q2q3 q0q1)))
	(setf (aref mat 1 0) (* 2 (+ q1q2 q0q3)))						(setf (aref mat 1 0) (* 2 (+ q1q2 q0q3)))
	(setf (aref mat 2 0) (* 2 (- q1q3 q0q2)))						(setf (aref mat 2 0) (* 2 (- q1q3 q0q2)))
	(setf (aref mat 2 1) (* 2 (+ q0q1 q2q3)))						(setf (aref mat 2 1) (* 2 (+ q0q1 q2q3)))
	(make-element domain mat))								(make-element domain mat))
      (error "Cannot coerce a quaternion in SO(~D)" (dimension-of domain))))		      (error "Cannot coerce a quaternion in SO(~D)" (dimension-of domain))))

;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-		;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-
;;; ===========================================================================		;;; ===========================================================================
;;;				  Quotient Field Routines				;;;				  Quotient Field Routines
;;; ===========================================================================		;;; ===========================================================================
;;; (c) Copyright 1989, 1993 Cornell University						;;; (c) Copyright 1989, 1993 Cornell University

;;; quotient-fields.lisp,v 1.10 1995/05/24 17:42:10 rz Exp				;;; quotient-fields.lisp,v 1.10 1995/05/24 17:42:10 rz Exp

(in-package "WEYLI")								    |	(in-package :weyli)

(make::adjust-version-numbers Weyl "1.10")					    |	;;; DELETE (make::adjust-version-numbers Weyl "1.10")

(defmethod make-quotient-field ((ring field))					    |	(defgeneric make-quotient-field (field)
	ring)									    |	  (:documentation
										    >	   "The purpose of this method is unknown.")
										    >	  (:method ((ring field)) ring))

(defmethod get-quotient-field ((ring field))					    |	(defgeneric get-quotient-field (field)
	ring)									    |	  (:documentation
										    >	   "The purpose of this method is unknown.")
										    >	  (:method ((ring field)) ring))

;; These two methods are actually given in rational-numbers.lisp when		    |	;;; These two methods are actually given in rational-numbers.lisp when
;; the functions they call are defined.						    |	;;; the functions they call are defined.

;;(defmethod make-quotient-field ((ring rational-integers))			    |	;;;(defmethod make-quotient-field ((ring rational-integers))
;;  (make-rational-numbers))							    |	;;;  (make-rational-numbers))

;;(defmethod get-quotient-field ((ring rational-integers))			    |	;;;(defmethod get-quotient-field ((ring rational-integers))
;;  (get-rational-numbers))							    |	;;;  (get-rational-numbers))
										    >
										    >	(defgeneric make-quotient-element (domain numerator denominator)
										    >	  (:documentation
										    >	   "The purpose of this method is unknown."))
										    >
										    >	(defmethod make-quotient-element
										    >	    ((domain quotient-field) numerator denominator)
										    >	  (make-instance 'quotient-element :domain domain
										    >			 :numerator numerator :denominator denominator))

(define-domain-creator quotient-field ((ring ring))					(define-domain-creator quotient-field ((ring ring))
  (progn										  (progn
    (unless (gcd-domain? ring)								    (unless (gcd-domain? ring)
	    (error "Can only create quotient fields of GCD domains: ~S"			      (error "Can only create quotient fields of GCD domains: ~S"
		   ring))								             ring))
    (let ((qf (make-instance 'quotient-field :ring ring					    (let ((qf (make-instance 'quotient-field :ring ring
			     :print-function 'quotient-field-print-object)))					     :print-function 'quotient-field-print-object)))
      (with-slots (zero one) qf								      (with-slots (zero one) qf
		  (setq zero (make-quotient-element qf (zero ring) (one ring)))		        (setq zero (make-quotient-element qf (zero ring) (one ring)))
		  (setq one (make-quotient-element qf (one ring) (one ring))))		        (setq one (make-quotient-element qf (one ring) (one ring))))
      (make-homomorphism ring #'(lambda (x)						      (make-homomorphism ring #'(lambda (x)
				  (make-quotient-element qf x (one ring)))						  (make-quotient-element qf x (one ring)))
			 qf)											 qf)
      qf))										      qf))
  :predicate #'(lambda (d)								  :predicate #'(lambda (d)
	         (and (typep d 'quotient-field) (eql (qf-ring d) ring))))			         (and (typep d 'quotient-field) (eql (qf-ring d) ring))))

(defun quotient-field-print-object (qf stream)						(defun quotient-field-print-object (qf stream)
  (with-slots (ring) qf									  (with-slots (ring) qf
    (format stream "QF(~S)" ring)))							    (format stream "QF(~S)" ring)))

(defmethod make-quotient-element						    <
    ((domain quotient-field) numerator denominator)				    <
  (make-instance 'quotient-element :domain domain				    <
		 :numerator numerator :denominator denominator))		    <
										    <
(defmethod coerce ((qe quotient-element) (d general-expressions))			(defmethod coerce ((qe quotient-element) (d general-expressions))
  (let ((num (coerce (numerator qe) d))							  (let ((num (coerce (numerator qe) d))
	(den (coerce (denominator qe) d)))							(den (coerce (denominator qe) d)))
    (setq den (if (number? den) (recip den)						    (setq den (if (number? den) (recip den)
		  (make-ge-expt d den (make-element d -1))))						  (make-ge-expt d den (make-element d -1))))
    (cond ((1? num) den)								    (cond ((1? num) den)
	  ((1? den) num)									  ((1? den) num)
	  (t (simplify (make-ge-times d (list num den)))))))					  (t (simplify (make-ge-times d (list num den)))))))

(defmethod print-object ((ratfun quotient-element) stream)				(defmethod print-object ((ratfun quotient-element) stream)
  (with-numerator-and-denominator (numerator denominator) ratfun			  (with-numerator-and-denominator (numerator denominator) ratfun
    (cond ((1? denominator)								    (cond ((1? denominator)
	   (prin1 numerator stream))								   (prin1 numerator stream))
	  (t (princ "(" stream)									  (t (princ "(" stream)
	     (prin1 numerator stream)								     (prin1 numerator stream)
	     (princ ")/(" stream)								     (princ ")/(" stream)
	     (prin1 denominator stream)								     (prin1 denominator stream)
	     (princ ")" stream)))))								     (princ ")" stream)))))

(defmethod numerator ((r quotient-element))						(defmethod numerator ((r quotient-element))
  (qo-numerator r))									  (qo-numerator r))

(defmethod denominator ((r quotient-element))						(defmethod denominator ((r quotient-element))
  (qo-denominator r))									  (qo-denominator r))

(defmethod zero ((qf quotient-field))							(defmethod zero ((qf quotient-field))
  (with-slots (zero) qf									  (with-slots (zero) qf
    zero))										    zero))

(defmethod one ((qf quotient-field))							(defmethod one ((qf quotient-field))
  (with-slots (one) qf									  (with-slots (one) qf
    one))										    one))

(defmethod 0? ((r quotient-element))							(defmethod 0? ((r quotient-element))
  (with-slots (numerator) r								  (with-slots (numerator) r
    (0? numerator)))									    (0? numerator)))

(defmethod 1? ((r quotient-element))							(defmethod 1? ((r quotient-element))
  (with-slots (numerator denominator) r							  (with-slots (numerator denominator) r
    (and (1? numerator)									    (and (1? numerator)
	 (1? denominator))))									 (1? denominator))))

										    >	(defgeneric height (object)
										    >	  (:documentation
										    >	   "The purpose of this method is unknown."))
										    >
(defmethod height ((r quotient-element))						(defmethod height ((r quotient-element))
  (max (height (numerator r)) (height (denominator r))))				  (max (height (numerator r)) (height (denominator r))))

(defmethod minus ((r quotient-element))							(defmethod minus ((r quotient-element))
  (let ((domain (domain-of r)))								  (let ((domain (domain-of r)))
    (with-numerator-and-denominator (numerator denominator) r				    (with-numerator-and-denominator (numerator denominator) r
      (make-quotient-element domain (minus numerator) denominator))))			      (make-quotient-element domain (minus numerator) denominator))))

										    >	(defgeneric minus? (object)
										    >	  (:documentation
										    >	   "Return true if the object is negative."))
										    >
(defmethod minus? ((r quotient-element))						(defmethod minus? ((r quotient-element))
  (minus? (qo-numerator r)))								  (minus? (qo-numerator r)))

(defmethod quotient-reduce ((qf quotient-field) num &optional den)		    <
  (with-slots (ring) qf								    <
    (when (not (eql (domain-of num) ring))					    <
      (error "The numerator's domain, ~S, is not the ring of the quotient field ~S  <
	     (domain-of num) ring))						    <
    (when (not (eql (domain-of den) ring))					    <
      (error "The denominator's domain, ~S, is not the ring of the quotient field   <
	     (domain-of den) ring))						    <
    (quotient-reduce* qf num den)))						    <
										    <
(defun quotient-reduce* (qf num &optional den)						(defun quotient-reduce* (qf num &optional den)
  (with-slots (ring) qf									  (with-slots (ring) qf
    (when (null den)									    (when (null den)
      (setq den (one ring))))								      (setq den (one ring))))
  (if (0? num) (zero qf)								  (if (0? num) (zero qf)
      (let ((common-gcd (gcd num den)))							      (let ((common-gcd (gcd num den)))
	(unless (1? common-gcd)									(unless (1? common-gcd)
	  (setq num (/ num common-gcd)								  (setq num (/ num common-gcd)
		den (/ den common-gcd)))								den (/ den common-gcd)))
	(when (minus? den)									(when (minus? den)
	  (setq num (minus num)									  (setq num (minus num)
		den (minus den)))									den (minus den)))
	(make-quotient-element qf num den))))							(make-quotient-element qf num den))))

										    >	(defgeneric quotient-reduce (field numerator &optional denominator)
										    >	  (:documentation
										    >	   "The purpose of this method is unknown."))
										    >
										    >	(defmethod quotient-reduce ((qf quotient-field) num &optional den)
										    >	  (with-slots (ring) qf
										    >	    (when (not (eql (domain-of num) ring))
										    >	      (error "The numerator's domain, ~S, is not the ring of the quotient field ~S
										    >		     (domain-of num) ring))
										    >	    (when (not (eql (domain-of den) ring))
										    >	      (error "The denominator's domain, ~S, is not the ring of the quotient field 
										    >		     (domain-of den) ring))
										    >	    (quotient-reduce* qf num den)))
										    >
(defmethod-sd plus ((r1 quotient-element) (r2 quotient-element))			(defmethod-sd plus ((r1 quotient-element) (r2 quotient-element))
  (with-numerator-and-denominator (n1 d1) r1						  (with-numerator-and-denominator (n1 d1) r1
    (with-numerator-and-denominator (n2 d2) r2						    (with-numerator-and-denominator (n2 d2) r2
      (cond ((0? n1) r2)								      (cond ((0? n1) r2)
	    ((0? n2) r1)									    ((0? n2) r1)
	    (t (quotient-reduce* domain								    (t (quotient-reduce* domain
				 (+ (* n1 d2) (* n2 d1))								 (+ (* n1 d2) (* n2 d1))
				 (* d1 d2)))))))									 (* d1 d2)))))))

(defmethod-sd difference ((r1 quotient-element) (r2 quotient-element))			(defmethod-sd difference ((r1 quotient-element) (r2 quotient-element))
  (with-numerator-and-denominator (n1 d1) r1						  (with-numerator-and-denominator (n1 d1) r1
    (with-numerator-and-denominator (n2 d2) r2						    (with-numerator-and-denominator (n2 d2) r2
      (cond ((0? n1)									      (cond ((0? n1)
	     (make-quotient-element domain (- n2) d1))						     (make-quotient-element domain (- n2) d1))
	    ((0? n2) r1)									    ((0? n2) r1)
	    (t (quotient-reduce* domain								    (t (quotient-reduce* domain
				 (- (* n1 d2) (* n2 d1))								 (- (* n1 d2) (* n2 d1))
				 (* d1 d2)))))))									 (* d1 d2)))))))

(defmethod-sd times ((r1 quotient-element) (r2 quotient-element))			(defmethod-sd times ((r1 quotient-element) (r2 quotient-element))
  (with-numerator-and-denominator (n1 d1) r1						  (with-numerator-and-denominator (n1 d1) r1
    (with-numerator-and-denominator (n2 d2) r2						    (with-numerator-and-denominator (n2 d2) r2
      (let (common-gcd)									      (let (common-gcd)
	(cond ((and (1? n1) (1? d1))								(cond ((and (1? n1) (1? d1))
	       r2)										       r2)
	      ((and (1? n2) (1? d2))								      ((and (1? n2) (1? d2))
	       r1)										       r1)
	      (t (setq common-gcd (gcd n1 d2))							      (t (setq common-gcd (gcd n1 d2))
		 (if (not (1? common-gcd))								 (if (not (1? common-gcd))
		     (setq n1 (/ n1 common-gcd)								     (setq n1 (/ n1 common-gcd)
			   d2 (/ d2 common-gcd)))								   d2 (/ d2 common-gcd)))
		 (setq common-gcd (gcd n2 d1))								 (setq common-gcd (gcd n2 d1))
		 (if (not (1? common-gcd))								 (if (not (1? common-gcd))
		     (setq n2 (/ n2 common-gcd)								     (setq n2 (/ n2 common-gcd)
			   d1 (/ d1 common-gcd)))								   d1 (/ d1 common-gcd)))
		 (setq d1 (* d1 d2)									 (setq d1 (* d1 d2)
		       n1 (* n1 n2))									       n1 (* n1 n2))
		 (if (minus? d1)									 (if (minus? d1)
		     (setq d1 (minus d1) n1 (minus n1)))						     (setq d1 (minus d1) n1 (minus n1)))
		 (make-quotient-element domain n1 d1)))))))						 (make-quotient-element domain n1 d1)))))))

(defmethod-sd quotient ((r1 quotient-element) (r2 quotient-element))			(defmethod-sd quotient ((r1 quotient-element) (r2 quotient-element))
  (with-numerator-and-denominator (n1 d1) r1						  (with-numerator-and-denominator (n1 d1) r1
    (with-numerator-and-denominator (n2 d2) r2						    (with-numerator-and-denominator (n2 d2) r2
      (let (common-gcd)									      (let (common-gcd)
	(cond ((and (1? n1) (1? d1))								(cond ((and (1? n1) (1? d1))
	       (make-quotient-element domain d2 n2))						       (make-quotient-element domain d2 n2))
	      ((and (1? n2) (1? d2))								      ((and (1? n2) (1? d2))
	       r1)										       r1)
	      (t (setq common-gcd (gcd n1 n2))							      (t (setq common-gcd (gcd n1 n2))
		 (if (not (1? common-gcd))								 (if (not (1? common-gcd))
		     (setq n1 (/ n1 common-gcd)								     (setq n1 (/ n1 common-gcd)
			   n2 (/ n2 common-gcd)))								   n2 (/ n2 common-gcd)))
		 (setq common-gcd (gcd d1 d2))								 (setq common-gcd (gcd d1 d2))
		 (if (not (1? common-gcd))								 (if (not (1? common-gcd))
		     (setq d2 (/ d2 common-gcd)								     (setq d2 (/ d2 common-gcd)
			   d1 (/ d1 common-gcd)))								   d1 (/ d1 common-gcd)))
		 (setq n1 (* n1 d2)									 (setq n1 (* n1 d2)
		       d1 (* d1 n2))									       d1 (* d1 n2))
		 (if (minus? d1)									 (if (minus? d1)
		     (setq d1 (minus d1) n1 (minus n1)))						     (setq d1 (minus d1) n1 (minus n1)))
		 (make-quotient-element domain n1 d1)))))))						 (make-quotient-element domain n1 d1)))))))

(defmethod recip ((r1 quotient-element))						(defmethod recip ((r1 quotient-element))
  (with-numerator-and-denominator (n1 d1) r1						  (with-numerator-and-denominator (n1 d1) r1
    (if (minus? n1)									    (if (minus? n1)
	(setq n1 (minus n1) d1 (minus d1)))							(setq n1 (minus n1) d1 (minus d1)))
    (make-quotient-element (domain-of r1) d1 n1)))					    (make-quotient-element (domain-of r1) d1 n1)))

(defmethod expt ((r1 quotient-element) (exp integer))				    <
  (expt-quotient (domain-of r1) r1 exp))					    <
										    <
(defmethod expt ((r1 quotient-element) (exp rational-integer))			    <
  (expt-quotient (domain-of r1) r1 (integer-value exp)))			    <
										    <
(defun expt-quotient (domain quo exp)							(defun expt-quotient (domain quo exp)
  (with-numerator-and-denominator (n1 d1) quo						  (with-numerator-and-denominator (n1 d1) quo
    (if (minus? exp)									    (if (minus? exp)
	(if (minus? n1)										(if (minus? n1)
	    	(make-quotient-element								    	(make-quotient-element
		  domain (expt (minus d1) (- exp)) (expt (minus n1) (- exp)))				  domain (expt (minus d1) (- exp)) (expt (minus n1) (- exp)))
		(make-quotient-element									(make-quotient-element
		  domain (expt d1 (- exp)) (expt n1 (- exp))))						  domain (expt d1 (- exp)) (expt n1 (- exp))))
	(make-quotient-element domain (expt n1 exp) (expt d1 exp)))))				(make-quotient-element domain (expt n1 exp) (expt d1 exp)))))

										    >	(defmethod expt ((r1 quotient-element) (exp integer))
										    >	  (expt-quotient (domain-of r1) r1 exp))
										    >
										    >	(defmethod expt ((r1 quotient-element) (exp rational-integer))
										    >	  (expt-quotient (domain-of r1) r1 (integer-value exp)))
										    >
(defmethod-sd binary-gcd ((r1 quotient-element) (r2 quotient-element))			(defmethod-sd binary-gcd ((r1 quotient-element) (r2 quotient-element))
  (with-numerator-and-denominator (n1 d1) r1						  (with-numerator-and-denominator (n1 d1) r1
    (with-numerator-and-denominator (n2 d2) r2						    (with-numerator-and-denominator (n2 d2) r2
      (make-quotient-element domain (gcd n1 n2) (lcm d1 d2)))))				      (make-quotient-element domain (gcd n1 n2) (lcm d1 d2)))))

(defmethod coerce (x (domain quotient-field))						(defmethod coerce (x (domain quotient-field))
  (let ((temp (coercible? x (qf-ring domain))))						  (let ((temp (coercible? x (qf-ring domain))))
    (if temp (make-quotient-element domain temp (one (qf-ring domain)))			    (if temp (make-quotient-element domain temp (one (qf-ring domain)))
	(call-next-method))))									(call-next-method))))

(defmethod coerce ((x quotient-element) (domain field))					(defmethod coerce ((x quotient-element) (domain field))
  (let ((num (coercible? (numerator x) domain)))					  (let ((num (coercible? (numerator x) domain)))
    (if num (/ num (coerce (denominator x) domain))					    (if num (/ num (coerce (denominator x) domain))
        (call-next-method))))								        (call-next-method))))
										    (
 										    (
										    (
;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-		;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-
;;; ===========================================================================		;;; ===========================================================================
;;;			  Rational Function Fields					;;;			  Rational Function Fields
;;; ===========================================================================		;;; ===========================================================================
;;; (c) Copyright 1989, 1993 Cornell University						;;; (c) Copyright 1989, 1993 Cornell University

;;; rational-functions.lisp,v 1.9 1995/05/24 17:42:10 rz Exp				;;; rational-functions.lisp,v 1.9 1995/05/24 17:42:10 rz Exp

(in-package "WEYLI")								    |	(in-package :weyli)

(make::adjust-version-numbers Weyl "1.9")					    |	;;; DELETE (make::adjust-version-numbers Weyl "1.9")

(defmethod initialize-instance :after ((qf rational-function-field) &rest plist)	(defmethod initialize-instance :after ((qf rational-function-field) &rest plist)
  (declare (ignore plist))								  (declare (ignore plist))
  (with-slots (print-function) qf							  (with-slots (print-function) qf
    (setf print-function 'ratfun-field-print-object))) 					    (setf print-function 'ratfun-field-print-object))) 

(defun ratfun-field-print-object (qf stream)						(defun ratfun-field-print-object (qf stream)
  (format stream "~A(" (coefficient-domain-of (QF-ring qf)))				  (format stream "~A(" (coefficient-domain-of (QF-ring qf)))
  (display-list (ring-variables (QF-ring qf)) stream)					  (display-list (ring-variables (QF-ring qf)) stream)
  (princ ")" stream))									  (princ ")" stream))

(defmethod ring-variables ((qf rational-function-field))				(defmethod ring-variables ((qf rational-function-field))
  (ring-variables (qf-ring qf)))							  (ring-variables (qf-ring qf)))

;; The general GET-Q... in quotient-field.lisp is good enough				;; The general GET-Q... in quotient-field.lisp is good enough
(define-domain-creator quotient-field ((ring multivariate-polynomial-ring))		(define-domain-creator quotient-field ((ring multivariate-polynomial-ring))
  (let* ((coefs (coefficient-domain-of ring))						  (let* ((coefs (coefficient-domain-of ring))
	 (qf (make-instance 'rational-function-field					         (qf (make-instance 'rational-function-field
			    :ring ring)))						                            :ring ring)))
    (with-slots (zero one) qf								    (with-slots (zero one) qf
      (setq zero (make-rational-function qf (zero coefs) (one coefs)))			      (setq zero (make-rational-function qf (zero coefs) (one coefs)))
      (setq one (make-rational-function qf (one coefs) (one coefs))))			      (setq one (make-rational-function qf (one coefs) (one coefs))))
    (make-homomorphism ring #'(lambda (x)						    (make-homomorphism ring #'(lambda (x)
			        (make-quotient-element qf x (one ring)))		                                (make-quotient-element qf x (one ring)))
		       qf)								                       qf)
    qf))										    qf))

(defsubst make-rational-function (domain numerator denominator)				(defsubst make-rational-function (domain numerator denominator)
  (make-instance 'rational-function :domain domain					  (make-instance 'rational-function :domain domain
		 :numerator numerator									 :numerator numerator
		 :denominator denominator))								 :denominator denominator))

										    >	(defgeneric make-rational-function* (domain num den)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod make-rational-function* (domain num den)					(defmethod make-rational-function* (domain num den)
  (let* ((poly-domain (qf-ring domain))							  (let* ((poly-domain (qf-ring domain))
	 (coef-domain (coefficient-domain-of poly-domain)))					 (coef-domain (coefficient-domain-of poly-domain)))
    (bind-domain-context poly-domain							    (bind-domain-context poly-domain
      (cond ((and (typep coef-domain 'field)						      (cond ((and (typep coef-domain 'field)
		  (poly-coef? den))									  (poly-coef? den))
	     (setq num (poly-times (recip den) num))						     (setq num (poly-times (recip den) num))
	     (setq den (one coef-domain)))							     (setq den (one coef-domain)))
	    ((poly-minus? den)									    ((poly-minus? den)
	     (setq num (poly-minus num) den (poly-minus den)))))				     (setq num (poly-minus num) den (poly-minus den)))))
    (make-rational-function domain num den)))						    (make-rational-function domain num den)))

(defmethod make-quotient-element							(defmethod make-quotient-element
    ((domain rational-function-field) numerator denominator)				    ((domain rational-function-field) numerator denominator)
  (make-rational-function domain							  (make-rational-function domain
			  (poly-form (coerce numerator (qf-ring domain)))					  (poly-form (coerce numerator (qf-ring domain)))
			  (poly-form (coerce denominator (qf-ring domain)))))					  (poly-form (coerce denominator (qf-ring domain)))))

(defmethod print-object ((ratfun rational-function) stream) 				(defmethod print-object ((ratfun rational-function) stream) 
  (with-numerator-and-denominator (numerator denominator) ratfun			  (with-numerator-and-denominator (numerator denominator) ratfun
    (cond ((poly-1? denominator)							    (cond ((poly-1? denominator)
	   (print-mpolynomial-form (QF-ring (domain-of ratfun)) numerator stream))		   (print-mpolynomial-form (QF-ring (domain-of ratfun)) numerator stream))
	  (t (princ "(" stream)									  (t (princ "(" stream)
	     (print-mpolynomial-form (QF-ring (domain-of ratfun)) numerator stream		     (print-mpolynomial-form (QF-ring (domain-of ratfun)) numerator stream
	     (princ ")/(" stream)								     (princ ")/(" stream)
	     (print-mpolynomial-form (QF-ring (domain-of ratfun)) denominator stre		     (print-mpolynomial-form (QF-ring (domain-of ratfun)) denominator stre
	     (princ ")" stream))))) 								     (princ ")" stream))))) 

(defmethod numerator ((r rational-function))						(defmethod numerator ((r rational-function))
  (let ((domain (domain-of r)))								  (let ((domain (domain-of r)))
    (make-polynomial (QF-ring domain) (qo-numerator r))))				    (make-polynomial (QF-ring domain) (qo-numerator r))))

(defmethod denominator ((r rational-function))						(defmethod denominator ((r rational-function))
  (let ((domain (domain-of r)))								  (let ((domain (domain-of r)))
    (make-polynomial (QF-ring domain) (qo-denominator r))))				    (make-polynomial (QF-ring domain) (qo-denominator r))))

(defmethod 0? ((r rational-function))							(defmethod 0? ((r rational-function))
  (poly-0? (qo-numerator r)))								  (poly-0? (qo-numerator r)))

(defmethod 1? ((r rational-function))							(defmethod 1? ((r rational-function))
    (and (poly-1? (qo-numerator r))							    (and (poly-1? (qo-numerator r))
	 (poly-1? (qo-denominator r))))								 (poly-1? (qo-denominator r))))

(defmethod minus ((r rational-function))						(defmethod minus ((r rational-function))
  (let ((domain (domain-of r)))								  (let ((domain (domain-of r)))
    (with-numerator-and-denominator (numerator denominator) r				    (with-numerator-and-denominator (numerator denominator) r
      (bind-domain-context (qf-ring domain)						      (bind-domain-context (qf-ring domain)
	(make-rational-function domain (poly-minus numerator) denominator)))))			(make-rational-function domain (poly-minus numerator) denominator)))))

(defmethod quotient-reduce ((qf rational-function-field) num &optional den)		(defmethod quotient-reduce ((qf rational-function-field) num &optional den)
  (with-slots (ring) qf									  (with-slots (ring) qf
    (when (not (eql (domain-of num) ring))						    (when (not (eql (domain-of num) ring))
      (error "The numerator's domain, ~S, is not the ring of the quotient field ~S	      (error "The numerator's domain, ~S, is not the ring of the quotient field ~S
	     (domain-of num) ring))								     (domain-of num) ring))
    (when (not (eql (domain-of den) ring))						    (when (not (eql (domain-of den) ring))
      (error "The denominator's domain, ~S, is not the ring of the quotient field 	      (error "The denominator's domain, ~S, is not the ring of the quotient field 
	     (domain-of den) ring))								     (domain-of den) ring))
    (ratfun-reduce qf (poly-form num) (poly-form den))))				    (ratfun-reduce qf (poly-form num) (poly-form den))))

;; The arguments to ratfun-reduce are poly-forms not polynomials!!!			;; The arguments to ratfun-reduce are poly-forms not polynomials!!!
(defun ratfun-reduce (qf num &optional den)						(defun ratfun-reduce (qf num &optional den)
  (when (null den)									  (when (null den)
    (setq den (one (QF-ring qf))))							    (setq den (one (QF-ring qf))))
  (if (poly-0? num) (zero qf)								  (if (poly-0? num) (zero qf)
      (let ((common-gcd (poly-gcd num den)))						      (let ((common-gcd (poly-gcd num den)))
	(unless (poly-1? common-gcd)								(unless (poly-1? common-gcd)
	  (setq num (poly-quotient num common-gcd)						  (setq num (poly-quotient num common-gcd)
		den (poly-quotient den common-gcd)))							den (poly-quotient den common-gcd)))
	(make-rational-function* qf num den))))							(make-rational-function* qf num den))))

(defmethod-sd plus ((r1 rational-function) (r2 rational-function))			(defmethod-sd plus ((r1 rational-function) (r2 rational-function))
  (with-numerator-and-denominator (n1 d1) r1						  (with-numerator-and-denominator (n1 d1) r1
    (with-numerator-and-denominator (n2 d2) r2						    (with-numerator-and-denominator (n2 d2) r2
      (bind-domain-context (qf-ring domain)						      (bind-domain-context (qf-ring domain)
	(ratfun-reduce domain									(ratfun-reduce domain
		       (poly-plus (poly-times n1 d2) (poly-times n2 d1))				       (poly-plus (poly-times n1 d2) (poly-times n2 d1))
		       (poly-times d1 d2))))))								       (poly-times d1 d2))))))

(defmethod-sd difference ((r1 rational-function) (r2 rational-function))		(defmethod-sd difference ((r1 rational-function) (r2 rational-function))
  (with-numerator-and-denominator (n1 d1) r1						  (with-numerator-and-denominator (n1 d1) r1
    (with-numerator-and-denominator (n2 d2) r2						    (with-numerator-and-denominator (n2 d2) r2
      (bind-domain-context (qf-ring domain)						      (bind-domain-context (qf-ring domain)
	(ratfun-reduce domain									(ratfun-reduce domain
		       (poly-difference (poly-times n1 d2) (poly-times n2 d1))				       (poly-difference (poly-times n1 d2) (poly-times n2 d1))
		       (poly-times d1 d2))))))								       (poly-times d1 d2))))))

(defmethod-sd times ((r1 rational-function) (r2 rational-function)) 			(defmethod-sd times ((r1 rational-function) (r2 rational-function)) 
  (with-numerator-and-denominator (n1 d1) r1						  (with-numerator-and-denominator (n1 d1) r1
    (with-numerator-and-denominator (n2 d2) r2						    (with-numerator-and-denominator (n2 d2) r2
      (bind-domain-context (qf-ring domain)						      (bind-domain-context (qf-ring domain)
	(let (common-gcd)									(let (common-gcd)
	  (setq common-gcd (poly-gcd n1 d2))							  (setq common-gcd (poly-gcd n1 d2))
	  (if (not (poly-1? common-gcd))							  (if (not (poly-1? common-gcd))
	      (setq n1 (poly-quotient n1 common-gcd)						      (setq n1 (poly-quotient n1 common-gcd)
		    d2 (poly-quotient d2 common-gcd)))							    d2 (poly-quotient d2 common-gcd)))
	  (setq common-gcd (poly-gcd n2 d1))							  (setq common-gcd (poly-gcd n2 d1))
	  (if (not (poly-1? common-gcd))							  (if (not (poly-1? common-gcd))
	      (setq n2 (poly-quotient n2 common-gcd)						      (setq n2 (poly-quotient n2 common-gcd)
		    d1 (poly-quotient d1 common-gcd)))							    d1 (poly-quotient d1 common-gcd)))
	  (setq d1 (poly-times d1 d2)								  (setq d1 (poly-times d1 d2)
		n1 (poly-times n1 n2))									n1 (poly-times n1 n2))
	  (make-rational-function* domain n1 d1))))))						  (make-rational-function* domain n1 d1))))))

(defmethod-sd quotient ((r1 rational-function) (r2 rational-function)) 			(defmethod-sd quotient ((r1 rational-function) (r2 rational-function)) 
  (with-numerator-and-denominator (n1 d1) r1						  (with-numerator-and-denominator (n1 d1) r1
    (with-numerator-and-denominator (n2 d2) r2	       					    (with-numerator-and-denominator (n2 d2) r2	       
      (bind-domain-context (qf-ring domain)						      (bind-domain-context (qf-ring domain)
	(let (common-gcd)									(let (common-gcd)
	  (setq common-gcd (poly-gcd n1 n2))							  (setq common-gcd (poly-gcd n1 n2))
	  (if (not (poly-1? common-gcd))							  (if (not (poly-1? common-gcd))
	      (setq n1 (poly-quotient n1 common-gcd)						      (setq n1 (poly-quotient n1 common-gcd)
		    n2 (poly-quotient n2 common-gcd)))							    n2 (poly-quotient n2 common-gcd)))
	  (setq common-gcd (poly-gcd d1 d2))							  (setq common-gcd (poly-gcd d1 d2))
	  (if (not (poly-1? common-gcd))							  (if (not (poly-1? common-gcd))
	      (setq d2 (poly-quotient d2 common-gcd)						      (setq d2 (poly-quotient d2 common-gcd)
		    d1 (poly-quotient d1 common-gcd)))							    d1 (poly-quotient d1 common-gcd)))
	  (setq n1 (poly-times n1 d2)								  (setq n1 (poly-times n1 d2)
		d1 (poly-times d1 n2))									d1 (poly-times d1 n2))
	  (make-rational-function* domain n1 d1))))))						  (make-rational-function* domain n1 d1))))))

(defmethod recip ((r1 rational-function))						(defmethod recip ((r1 rational-function))
    (with-numerator-and-denominator (num den) r1					    (with-numerator-and-denominator (num den) r1
      (make-rational-function* (domain-of r1) den num)))				      (make-rational-function* (domain-of r1) den num)))

(defmethod expt ((r1 rational-function) (exp integer))					(defmethod expt ((r1 rational-function) (exp integer))
  (let ((domain (domain-of r1)))							  (let ((domain (domain-of r1)))
    (with-numerator-and-denominator (n1 d1) r1						    (with-numerator-and-denominator (n1 d1) r1
      (bind-domain-context (qf-ring domain)						      (bind-domain-context (qf-ring domain)
	(if (minusp exp)									(if (minusp exp)
	    (make-rational-function domain							    (make-rational-function domain
				    (poly-expt d1 (cl:- exp))								    (poly-expt d1 (cl:- exp))
				    (poly-expt n1 (cl:- exp)))								    (poly-expt n1 (cl:- exp)))
	    (make-rational-function domain							    (make-rational-function domain
				    (poly-expt n1 exp) (poly-expt d1 exp)))))))						    (poly-expt n1 exp) (poly-expt d1 exp)))))))

(defmethod expt ((r1 rational-function) (exp rational-integer))				(defmethod expt ((r1 rational-function) (exp rational-integer))
  (expt r1 (integer-value exp)))							  (expt r1 (integer-value exp)))

(defmethod-sd binary-gcd ((r1 rational-function) (r2 rational-function))		(defmethod-sd binary-gcd ((r1 rational-function) (r2 rational-function))
  (with-numerator-and-denominator (n1 d1) r1						  (with-numerator-and-denominator (n1 d1) r1
    (with-numerator-and-denominator (n2 d2) r2						    (with-numerator-and-denominator (n2 d2) r2
      (bind-domain-context (qf-ring domain)						      (bind-domain-context (qf-ring domain)
	(make-rational-function domain (poly-gcd n1 n2) (poly-lcm d1 d2))))))			(make-rational-function domain (poly-gcd n1 n2) (poly-lcm d1 d2))))))


(defmethod list-of-variables								(defmethod list-of-variables
    ((x rational-function) &optional list-of-variables)					    ((x rational-function) &optional list-of-variables)
  (let* ((domain (domain-of x))								  (let* ((domain (domain-of x))
	 (ring-domain (qf-ring domain)))							 (ring-domain (qf-ring domain)))
    (with-numerator-and-denominator (num-x den-x) x					    (with-numerator-and-denominator (num-x den-x) x
      (loop for order-number in (poly-list-of-variables					      (loop for order-number in (poly-list-of-variables
				     den-x (poly-list-of-variables num-x))						     den-x (poly-list-of-variables num-x))
	    do (pushnew (get-variable-name order-number ring-domain)				    do (pushnew (get-variable-name order-number ring-domain)
			list-of-variables :test #'ge-equal)))							list-of-variables :test #'ge-equal)))
    list-of-variables))									    list-of-variables))

;; This is just like poly-subst, but its result is a rational function			;; This is just like poly-subst, but its result is a rational function
;; and thus the values being substituted can be rational functions. 			;; and thus the values being substituted can be rational functions. 
(defun rational-poly-subst (poly var-value)						(defun rational-poly-subst (poly var-value)
  (let ((temp nil))									  (let ((temp nil))
    (cond ((null var-value)								    (cond ((null var-value)
	   poly)										   poly)
	  ((poly-coef? poly) (coerce poly *domain*))						  ((poly-coef? poly) (coerce poly *domain*))
	  (t (setq temp (or (second (assoc (poly-order-number poly) var-value			  (t (setq temp (or (second (assoc (poly-order-number poly) var-value
				     :test #'eql))))									     :test #'eql))))
	   (when (null temp)									   (when (null temp)
	     (error "This variable can't be mapped into the domain ~S"				     (error "This variable can't be mapped into the domain ~S"
		    *domain*))										    *domain*))
	   (rational-terms-horners-rule (poly-terms poly) temp var-value)))))			   (rational-terms-horners-rule (poly-terms poly) temp var-value)))))

(defun rational-terms-horners-rule (terms value &optional var-value)			(defun rational-terms-horners-rule (terms value &optional var-value)
  (let ((old-e (le terms))								  (let ((old-e (le terms))
	(ans (rational-poly-subst (lc terms) var-value)))					(ans (rational-poly-subst (lc terms) var-value)))
    (map-over-each-term (red terms) (e c) 						    (map-over-each-term (red terms) (e c) 
      (setq ans (+ (* (expt value (e- old-e e)) ans)					      (setq ans (+ (* (expt value (e- old-e e)) ans)
		   (rational-poly-subst c var-value)))							   (rational-poly-subst c var-value)))
      (setq old-e e))									      (setq old-e e))
    (* ans (expt value old-e))))							    (* ans (expt value old-e))))

(defmethod substitute 									(defmethod substitute 
    ((value rational-function) (variable rational-function)				    ((value rational-function) (variable rational-function)
     (p rational-function) &rest ignore)						     (p rational-function) &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (substitute (list value) (list variable) p))						  (substitute (list value) (list variable) p))

(defmethod substitute ((values list) (variables list) (p rational-function)		(defmethod substitute ((values list) (variables list) (p rational-function)
		       &rest ignore)									       &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (let* ((domain (domain-of p))								  (let* ((domain (domain-of p))
	 (ring (qf-ring domain))								 (ring (qf-ring domain))
	 (new-domain (domain-of (first values)))						 (new-domain (domain-of (first values)))
	 subst-list)										 subst-list)
    (loop for var in variables								    (loop for var in variables
	  unless (eql (domain-of var) domain)							  unless (eql (domain-of var) domain)
	    do (error "Domain of ~S was expected to be ~S" var domain))				    do (error "Domain of ~S was expected to be ~S" var domain))
    (loop for val in values								    (loop for val in values
	  unless (eql (domain-of val) new-domain)						  unless (eql (domain-of val) new-domain)
	    do (error "Domain of ~S was expected to be ~S" val new-domain))			    do (error "Domain of ~S was expected to be ~S" val new-domain))
    (loop for var in (ring-variables ring)						    (loop for var in (ring-variables ring)
	  do (unless (find var variables 							  do (unless (find var variables 
			   :test #'(lambda (a b) 								   :test #'(lambda (a b) 
				     (eql a (variable-symbol								     (eql a (variable-symbol
					   ring (numerator b))))) 								   ring (numerator b))))) 
	       (push (coerce var domain) variables)						       (push (coerce var domain) variables)
	       (push (if (coercible? var new-domain)						       (push (if (coercible? var new-domain)
			 (coerce var new-domain)								 (coerce var new-domain)
			 nil)											 nil)
		     values)))										     values)))
    (setq subst-list (loop for var in variables						    (setq subst-list (loop for var in variables
			   for val in values									   for val in values
			   collect (list (variable-index ring (numerator var))					   collect (list (variable-index ring (numerator var))
					 val)))											 val)))
    (with-numerator-and-denominator (num den) p						    (with-numerator-and-denominator (num den) p
      (bind-domain-context new-domain							      (bind-domain-context new-domain
	(/ (rational-poly-subst num subst-list)							(/ (rational-poly-subst num subst-list)
	   (rational-poly-subst den subst-list))))))						   (rational-poly-subst den subst-list))))))

(defmethod partial-deriv ((p rational-function) x)					(defmethod partial-deriv ((p rational-function) x)
  (error "Don't know how to compute the partial deriv with respect to ~S"		  (error "Don't know how to compute the partial deriv with respect to ~S"
	 x))											 x))

(defmethod partial-deriv ((p rational-function) (x (or symbol list)))		    |	(defmethod partial-deriv ((p rational-function) (x symbol))
										    >	  (partial-deriv p (coerce x *general*)))
										    >
										    >	(defmethod partial-deriv ((p rational-function) (x list))
  (partial-deriv p (coerce x *general*)))						  (partial-deriv p (coerce x *general*)))

(defmethod partial-deriv ((p rational-function) (x general-expression))			(defmethod partial-deriv ((p rational-function) (x general-expression))
  (let ((domain (domain-of p)))								  (let ((domain (domain-of p)))
    (with-slots (variables) (qf-ring domain)						    (with-slots (variables) (qf-ring domain)
      (if (member x variables :test #'ge-equal)						      (if (member x variables :test #'ge-equal)
	  (partial-deriv p (coerce x domain))							  (partial-deriv p (coerce x domain))
	  (call-next-method)))))								  (call-next-method)))))

(defmethod partial-deriv ((p rational-function) (x rational-function))			(defmethod partial-deriv ((p rational-function) (x rational-function))
  (with-numerator-and-denominator (num-x den-x) x					  (with-numerator-and-denominator (num-x den-x) x
    (with-numerator-and-denominator (num-p den-p) p					    (with-numerator-and-denominator (num-p den-p) p
      (let ((domain (domain-of p))							      (let ((domain (domain-of p))
	    terms)										    terms)
	(unless (and (eql domain (domain-of x))							(unless (and (eql domain (domain-of x))
		     (1? den-x)										     (1? den-x)
		     (null (red (setq terms (poly-terms num-x))))					     (null (red (setq terms (poly-terms num-x))))
		     (e1? (le terms))									     (e1? (le terms))
		     (poly-1? (lc terms)))								     (poly-1? (lc terms)))
	  (error "~S is not a variable in ~S" x domain))					  (error "~S is not a variable in ~S" x domain))
	(bind-domain-context (qf-ring domain)							(bind-domain-context (qf-ring domain)
	  (ratfun-reduce domain									  (ratfun-reduce domain
			 (poly-difference									 (poly-difference
			  (poly-times (poly-derivative num-p num-x) den-p)					  (poly-times (poly-derivative num-p num-x) den-p)
			  (poly-times (poly-derivative den-p num-x) num-p))					  (poly-times (poly-derivative den-p num-x) num-p))
			 (poly-times den-p den-p)))))))								 (poly-times den-p den-p)))))))

(defmethod deriv ((poly rational-function) &rest vars)					(defmethod deriv ((poly rational-function) &rest vars)
  (let* ((domain (domain-of poly))							  (let* ((domain (domain-of poly))
	 deriv diff)										 deriv diff)
    (bind-domain-context domain								    (bind-domain-context domain
      (loop for var in vars do								      (loop for var in vars do
	(setq var (coerce var *general*))							(setq var (coerce var *general*))
	(setq deriv (zero domain))								(setq deriv (zero domain))
	(loop with variables = (list-of-variables poly)						(loop with variables = (list-of-variables poly)
	      for kernel in variables do							      for kernel in variables do
	  (when (depends-on? kernel var)							  (when (depends-on? kernel var)
	    (setq diff (deriv kernel var))							    (setq diff (deriv kernel var))
	    (loop for new in (different-kernels diff variables) do				    (loop for new in (different-kernels diff variables) do
	      (add-new-variable (qf-ring domain) new))						      (add-new-variable (qf-ring domain) new))
	    (setq deriv										    (setq deriv
		  (+ deriv (* (partial-deriv poly kernel)						  (+ deriv (* (partial-deriv poly kernel)
			      (coerce diff domain))))))								      (coerce diff domain))))))
	(setq poly deriv)))									(setq poly deriv)))
    poly))										    poly))

(defmethod coerce ((x ge-expt) (domain rational-function-field))			(defmethod coerce ((x ge-expt) (domain rational-function-field))
  (if (ge-minus? (exponent-of x))							  (if (ge-minus? (exponent-of x))
      (recip (coerce (expt (base-of x) (- (exponent-of x)))				      (recip (coerce (expt (base-of x) (- (exponent-of x)))
		     domain))										     domain))
      (call-next-method)))								      (call-next-method)))
;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-		;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-
;;; ===========================================================================		;;; ===========================================================================
;;;			           Sets 						;;;			           Sets 
;;; ===========================================================================		;;; ===========================================================================
;;; (c) Copyright 1989, 1991 Cornell University						;;; (c) Copyright 1989, 1991 Cornell University

;;; sets.lisp,v 1.6 1995/05/24 17:42:11 rz Exp						;;; sets.lisp,v 1.6 1995/05/24 17:42:11 rz Exp

(in-package "WEYLI")								    |	(in-package :weyli)

(make::adjust-version-numbers Weyl "1.6")					    |	;;; DELETE (make::adjust-version-numbers Weyl "1.6")

;; Tuples are just indexed lists.							;; Tuples are just indexed lists.
(defclass tuple ()									(defclass tuple ()
  ((value :initarg :values							    |	  ((value
										    >	    :initarg :values
	  :initform ()									    :initform ()
	  :reader value-of)))								    :reader value-of)))

;;;for backward compatibility							    |	;;; DELETE : This is a major update, so we're not concerned with
(defmethod tuple-value ((tuple tuple))						    |	;;; backward compatibility.
  (value-of tuple))								    |	(defgeneric tuple-value (tuple)
										    |	  (:documentation
										    >	   "A wrapper function for value-of for backward compatibility.")
										    >	  (:method ((tuple tuple)) (value-of tuple)))

(defmethod initialize-instance :after ((object tuple) &rest plist)			(defmethod initialize-instance :after ((object tuple) &rest plist)
  (declare (ignore plist))								  (declare (ignore plist))
  (with-slots (value) object								  (with-slots (value) object
    (cond ((null value)									    (cond ((null value)
	   (error "Values need to be provided for ~A"						   (error "Values need to be provided for ~A"
		  (class-name (class-of object))))							  (class-name (class-of object))))
	  ((listp value)									  ((listp value)
	   (setq value (%apply #'vector value))))))						   (setq value (%apply #'vector value))))))
	      											      
(defmethod print-object ((tuple tuple) stream)						(defmethod print-object ((tuple tuple) stream)
  (%apply #'format stream "<~S~@{, ~S~}>"						  (%apply #'format stream "<~S~@{, ~S~}>"
	 (loop with v = (value-of tuple)						          (loop with v = (value-of tuple)
	       for i below (array-dimension v 0)					                for i below (array-dimension v 0)
	       collect (aref v i))))							                collect (aref v i))))

(defmethod ref ((tuple tuple) &rest args)					    |	(defgeneric ref (tuple &rest args)
  (aref (value-of tuple) (first args)))						    |	  (:documentation
										    |	   "Refernce the item of tuple specified by the first arg.")
										    >	  (:method ((tuple tuple) &rest args)
										    >	    (aref (value-of tuple) (first args))))
										    >
										    >	;;; FIXME : Merge set-ref and (defsetf ref).
										    >	(defgeneric set-ref (tuple new-value &rest args)
										    >	  (:documentation
										    >	   "Set the element specified by args to new-value."))

(defmethod set-ref ((tuple tuple) new-value &rest args)					(defmethod set-ref ((tuple tuple) new-value &rest args)
  (setf (aref (value-of tuple) (first args)) new-value))				  (setf (aref (value-of tuple) (first args)) new-value))

(defsetf ref (vect &rest indices) (new-value)						(defsetf ref (vect &rest indices) (new-value)
  `(set-ref ,vect ,new-value ,@indices))						  `(set-ref ,vect ,new-value ,@indices))

										    >	(defgeneric list-of-elements (tuple)
										    >	  (:documentation
										    >	   "Return a list of the tuple elements."))
										    >
(defmethod list-of-elements ((tuple tuple))						(defmethod list-of-elements ((tuple tuple))
  (let ((array (value-of tuple)))							  (let ((array (value-of tuple)))
    (loop for i fixnum below (array-dimension array 0)					    (loop for i fixnum below (array-dimension array 0)
	  collect (aref array i))))								  collect (aref array i))))

(defmethod map (type function (seq tuple) &rest sequences)				(defmethod map (type function (seq tuple) &rest sequences)
  (setq type (cond ((null type) (class-of seq))						  (setq type (cond ((null type) (class-of seq))
		   ((typep type 'class) type)								   ((typep type 'class) type)
		   ((typep type 'symbol) (find-class type))						   ((typep type 'symbol) (find-class type))
		   (t (error "Bad type specifier: ~S" type))))						   (t (error "Bad type specifier: ~S" type))))
  (let ((values (loop with v = (value-of seq)						  (let ((values (loop with v = (value-of seq)
		      for i below (array-dimension v 0)							      for i below (array-dimension v 0)
		      collect (%apply function (aref v i)						      collect (%apply function (aref v i)
				      (loop for seq in sequences							      (loop for seq in sequences
					    collect (ref seq i))))))								    collect (ref seq i))))))
       (if (subclass-of? 'domain-element type)						    (if (subclass-of? 'domain-element type)
	   (if (typep seq 'domain-element)						        (if (typep seq 'domain-element)
	       (make-instance type :domain (domain-of seq)				            (make-instance type :domain (domain-of seq)
			      :values values)						                           :values values)
	       (error "Can't determine domain of resulting sequence"))			            (error "Can't determine domain of resulting sequence"))
	   (make-instance type :values values))))					        (make-instance type :values values))))

										    >	(defgeneric map-with-domain (type domain function sequence &rest sequences)
										    >	  (:documentation
										    >	   "Map the values of the sequences into the domain."))
										    >
(defmethod map-with-domain (type domain function (seq tuple) &rest sequences)		(defmethod map-with-domain (type domain function (seq tuple) &rest sequences)
  (make-instance type								    |	  (make-instance
		 :domain domain							    |	   type :domain domain
		 :values (loop with v = (value-of seq)				    |	   :values
										    >	   (loop with v = (value-of seq)
			       for i below (array-dimension v 0)			         for i below (array-dimension v 0)
			       collect (%apply function (aref v i)			         collect (%apply function (aref v i)
					       (loop for seq in sequences		                         (loop for seq in sequences
						     collect (ref seq i))))))		                               collect (ref seq i))))))

;; (empty? set)										;; (empty? set)
;; (insert key set &rest args)								;; (insert key set &rest args)
;; (delete item set &rest args)								;; (delete item set &rest args)
;; (member item set &rest args) 							;; (member item set &rest args) 
;; (map-over-elements set function)							;; (map-over-elements set function)
;; (make-generator set) -> function							;; (make-generator set) -> function

(define-operations set									(define-operations set
  (= (element self) (element self)) -> Boolean						  (= (element self) (element self)) -> Boolean
  (coerce default self) -> (element self)						  (coerce default self) -> (element self)
  (member (element self) self) -> Boolean						  (member (element self) self) -> Boolean
  (make-generator self) -> (-> (element self))						  (make-generator self) -> (-> (element self))
  (print-object (element self) stream) -> Null						  (print-object (element self) stream) -> Null
  (number-of-elements self) -> integer)							  (number-of-elements self) -> integer)

;; Default version of this...								;; Default version of this...
#+ignore										#+ignore
(defmethod binary= (x y) (equal x y))							(defmethod binary= (x y) (equal x y))

(define-operations mutable-set								(define-operations mutable-set
  (insert (element self) self) -> Null							  (insert (element self) self) -> Null
  (delete (element self) self) -> Null						    |	  (delete (element self) self) -> Null)
  )										    <

#+IGNORE										#+IGNORE
(define-operations ordered-set								(define-operations ordered-set
  (< (element self) (element self)) -> Boolean						  (< (element self) (element self)) -> Boolean
  (> (element self) (element self)) -> Boolean						  (> (element self) (element self)) -> Boolean
  (max (element self) (element self)) -> (element self)					  (max (element self) (element self)) -> (element self)
  (min (element self) (element self)) -> (element self))				  (min (element self) (element self)) -> (element self))

#+IGNORE										#+IGNORE
(defmethod initialize-method :after ((set ordered-set) &rest plist)			(defmethod initialize-method :after ((set ordered-set) &rest plist)
  (unless (%getf plist :compare-function)						  (unless (%getf plist :compare-function)
    (error "Must provide a comparison function for ordered sets")))			    (error "Must provide a comparison function for ordered sets")))

(define-operations finite-set								(define-operations finite-set
  (size self) -> Integer								  (size self) -> Integer
  (random self) -> (element self))							  (random self) -> (element self))

											;; Set elements are also objects in Weyl.  They behave like
;; Set elements are also objects in Weyl.  They behave like				;; domain-elements (they are domain-elements).  The function
;; domain-elements (they are domain-elements).  The function				;; (element-key ..) gets their key.  They are two basic types of
;; (element-key ..) gets their key.  They are two basic types of			;; set-elements.  SET-ELEMENT1 is a class where the elements are the
;; set-elements.  SET-ELEMENT1 is a class where the elements are the			;; keys themselves.  There are many applications where we want to have
;; keys themselves.  There are many applications where we want to have			;; sets of pairs (key, value).  The class SET-ELEMENT2 is used for this
;; sets of pairs (key, value).  The class SET-ELEMENT2 is used for this			;; purpose.  Set-elements can be compared with =, and > in which case
;; purpose.  Set-elements can be compared with =, and > in which case			;; the comparison will use the comparision function of the set.
;; the comparison will use the comparision function of the set.
											;;When building more complex structures, (AVL trees etc.) the nodes of
;;When building more complex structures, (AVL trees etc.) the nodes of			;;the datastructures should be built out of these classes.
;;the datastructures should be built out of these classes.
											(defmethod print-object ((element set-element) stream)
(defmethod print-object ((element set-element) stream)					  (format stream "~S" (element-key element)))
  (format stream "~S" (element-key element)))
											;; This is used for sets whose elements are associated with a value.
;; This is used for sets whose elements are associated with a value.
											(defmethod print-object ((element set-element2) stream)
(defmethod print-object ((element set-element2) stream)					  (format stream "(~S, ~S)" (element-key element) (element-value element)))
  (format stream "(~S, ~S)" (element-key element) (element-value element)))
											(defmethod-sd binary= ((e1 set-element) (e2 set-element))
(defmethod-sd binary= ((e1 set-element) (e2 set-element))				  (%funcall (equal-function-of domain) (element-key e1) (element-key e2)))
  (%funcall (equal-function-of domain) (element-key e1) (element-key e2)))
											(defmethod binary= ((e1 set-element) e2)
(defmethod binary= ((e1 set-element) e2)						  (%funcall (equal-function-of (domain-of e1)) (element-key e1) e2))
  (%funcall (equal-function-of (domain-of e1)) (element-key e1) e2))
											;; The following needs to be an around method so that it doesn't come
;; The following needs to be an around method so that it doesn't come			;; at the end of the precidence list (after (number domain-element)
;; at the end of the precidence list (after (number domain-element)			;; defined in morphisms).
;; defined in morphisms).								(defmethod binary= :around (e1 (e2 set-element))
(defmethod binary= :around (e1 (e2 set-element))					  (%funcall (equal-function-of (domain-of e2)) e1 (element-key e2)))
  (%funcall (equal-function-of (domain-of e2)) e1 (element-key e2)))
											(defmethod-sd binary> ((e1 set-element) (e2 set-element))
(defmethod-sd binary> ((e1 set-element) (e2 set-element))				  (%funcall (greater-function-of domain) (element-key e1) (element-key e2)))
  (%funcall (greater-function-of domain) (element-key e1) (element-key e2)))
											(defmethod binary> ((e1 set-element) e2)
(defmethod binary> ((e1 set-element) e2)						  (%funcall (greater-function-of (domain-of e1)) (element-key e1) e2))
  (%funcall (greater-function-of (domain-of e1)) (element-key e1) e2))
											;; The following needs to be an around method so that it doesn't come
;; The following needs to be an around method so that it doesn't come			;; at the end of the precidence list (after (number domain-element)
;; at the end of the precidence list (after (number domain-element)			;; defined in morphisms).
;; defined in morphisms).								(defmethod binary> :around (e1 (e2 set-element))
(defmethod binary> :around (e1 (e2 set-element))					  (%funcall (greater-function-of (domain-of e2)) e1 (element-key e2)))
  (%funcall (greater-function-of (domain-of e2)) e1 (element-key e2)))
											;; In building real sets one should include one of these classes to
;; In building real sets one should include one of these classes to			;; indicate how elements of the set will be represented.
;; indicate how elements of the set will be represented.
											(defmethod make-element ((set set-elements-as-singletons) key &rest rest)
(defmethod make-element ((set set-elements-as-singletons) key &rest rest)		  (declare (ignore rest))
  (declare (ignore rest))								  (make-instance 'set-element1 :domain set :key key))
  (make-instance 'set-element1 :domain set :key key))
											(defmethod make-element ((set set-elements-as-pairs) key &rest rest)
(defmethod make-element ((set set-elements-as-pairs) key &rest rest)			  (make-instance 'set-element2 :domain set
  (make-instance 'set-element2 :domain set								 :key key :value (first rest)))
		 :key key :value (first rest)))
											;; Here are some simple sets that we might use in a program.

;; Here are some simple sets that we might use in a program.			    (
										    (
(defmethod set-elements ((set set-with-element-list))				    |	(defgeneric set-elements (set)
  (rest (set-element-list set)))						    |	  (:documentation
										    >	   "The purpose of this method is unknown.")
										    >	  (:method ((set set-with-element-list))
										    >	    (rest (set-element-list set))))

(defun set-with-element-list-print-object (set stream)					(defun set-with-element-list-print-object (set stream)
  (let ((elts (set-elements set)))							  (let ((elts (set-elements set)))
    (if (null elts) (princ "{}" stream)							    (if (null elts) (princ "{}" stream)
	(format stream "{~S~{, ~S~}}" (first elts) (rest elts)))))				(format stream "{~S~{, ~S~}}" (first elts) (rest elts)))))

(defmethod initialize-instance :after ((set set-with-element-list) &rest plist)		(defmethod initialize-instance :after ((set set-with-element-list) &rest plist)
  (let ((initial-elements (loop for (item . args) in (%getf plist :initial-element	  (let ((initial-elements (loop for (item . args) in (%getf plist :initial-element
				collect (%apply #'make-element set item args))))					collect (%apply #'make-element set item args))))
    #+IGNORE										    #+IGNORE
    (if (typep set 'ordered-set)							    (if (typep set 'ordered-set)
	(setf initial-elements (sort initial-elements #'binary>)))				(setf initial-elements (sort initial-elements #'binary>)))
    (setf (rest (set-element-list set)) initial-elements)				    (setf (rest (set-element-list set)) initial-elements)
    (with-slots (print-function) set							    (with-slots (print-function) set
      (setf print-function 'set-with-element-list-print-object))))			      (setf print-function 'set-with-element-list-print-object))))

(defmethod insert (key (set mutable-set-with-element-list) &rest rest)			(defmethod insert (key (set mutable-set-with-element-list) &rest rest)
  (let ((list (set-element-list set)))							  (let ((list (set-element-list set)))
    (loop for elt in (rest list)							    (loop for elt in (rest list)
	  when (= key elt)									  when (= key elt)
	    do (return set)								          do (return set)
	  finally (push (%apply #'make-element set key rest) (rest list))			  finally (push (%apply #'make-element set key rest) (rest list))
		  (return set))))							          (return set))))

(defmethod delete (item (set mutable-set-with-element-list) &rest args)			(defmethod delete (item (set mutable-set-with-element-list) &rest args)
  (declare (ignore args))								  (declare (ignore args))
  (flet ((not-an-element ()								  (flet ((not-an-element ()
	   (error "~S is not an element of ~S" item set)))					   (error "~S is not an element of ~S" item set)))
    (loop for elts on (set-element-list set)						    (loop for elts on (set-element-list set)
          when (null (rest elts))							          when (null (rest elts))
           do (not-an-element)								          do (not-an-element)
          when (= item (second elts))							          when (= item (second elts))
          do (setf (rest elts) (rest (rest elts)))					          do (setf (rest elts) (rest (rest elts)))
	     (return set)								          (return set)
          finally (not-an-element))))							          finally (not-an-element))))

(defmethod member (key (set set-with-element-list) &rest args)				(defmethod member (key (set set-with-element-list) &rest args)
  (declare (ignore args))								  (declare (ignore args))
  (loop for elt in (set-elements set)							  (loop for elt in (set-elements set)
	when (= key elt)									when (= key elt)
	  do (return elt)								        do (return elt)
	finally (return nil)))									finally (return nil)))

										    >	(defgeneric map-over-elements (set function)
										    >	  (:documentation
										    >	   "Map over the elements of the set applying the function."))
										    >
(defmethod map-over-elements ((set set-with-element-list) function)			(defmethod map-over-elements ((set set-with-element-list) function)
  (loop for elt in (set-elements set) do						  (loop for elt in (set-elements set) do
    (%funcall function elt)))								        (%funcall function elt)))

(defmethod make-generator ((set set-with-element-list))					(defmethod make-generator ((set set-with-element-list))
  (let ((list (set-elements set)))							  (let ((list (set-elements set)))
    #'(lambda () (pop list))))							    |	    (lambda () (pop list))))

;; This is just a variant on the previous class.  The inclusion of the			;; This is just a variant on the previous class.  The inclusion of the
;; ordered-set class causes the initialize-instance method to put the			;; ordered-set class causes the initialize-instance method to put the
;; elements in the set ordered.								;; elements in the set ordered.

(defmethod insert (key (set mutable-set-with-sorted-element-list) &rest rest)		(defmethod insert (key (set mutable-set-with-sorted-element-list) &rest rest)
  (loop for elts on (set-element-list set) do						  (loop for elts on (set-element-list set) do
    (cond ((or (null (rest elts)) (> key (second elts)))				        (cond ((or (null (rest elts)) (> key (second elts)))
	   (setf (rest elts) (cons (%apply #'make-element set key rest) (rest elts	               (setf (rest elts) (cons (%apply #'make-element set key rest) (rest 
	   (return set))								               (return set))
	  ((= key (second elts))							              ((= key (second elts))
	   (return set)))))								               (return set)))))

(defmethod delete (item (set mutable-set-with-sorted-element-list) &rest args)		(defmethod delete (item (set mutable-set-with-sorted-element-list) &rest args)
  (declare (ignore args))								  (declare (ignore args))
  (flet ((not-an-element ()								  (flet ((not-an-element ()
	   (error "~S is not an element of ~S" item set)))					   (error "~S is not an element of ~S" item set)))
    (loop for elts on (set-element-list set)						    (loop for elts on (set-element-list set)
          when (null (rest elts))							          when (null (rest elts))
           do (not-an-element)								          do (not-an-element)
          when (= item (second elts))							          when (= item (second elts))
          do (setf (rest elts) (rest (rest elts)))					          do (setf (rest elts) (rest (rest elts)))
	     (return set)								          (return set)
          when (> item (second elts))							          when (> item (second elts))
           do (not-an-element)								          do (not-an-element)
          finally (not-an-element))))							          finally (not-an-element))))

(defmethod member (key (set set-with-sorted-element-list) &rest args)			(defmethod member (key (set set-with-sorted-element-list) &rest args)
  (declare (ignore args))								  (declare (ignore args))
  (loop for elt in (set-elements set)							  (loop for elt in (set-elements set)
	when (= key elt)									when (= key elt)
	  do (return elt)								        do (return elt)
	when (> key elt)									when (> key elt)
	  do (return nil)								        do (return nil)
	finally (return nil)))									finally (return nil)))

(defmethod size ((set set-with-element-list))					    |	;;; FIXME : It would be better to define this as length.
  (cl:length (set-elements set)))						    |	(defgeneric size (set)
										    >	  (:documentation
										    >	   "Return the length of the set.")
										    >	  (:method ((set set-with-element-list))
										    >	    (common-lisp:length (set-elements set))))
										    >
										    >	(defgeneric random (set &optional height)
										    >	  (:documentation
										    >	   "Return a random element of the list."))

(defmethod random ((set set-with-element-list) &optional height)			(defmethod random ((set set-with-element-list) &optional height)
  (declare (ignore height))								  (declare (ignore height))
  (let ((l (set-elements set)))								  (let ((l (set-elements set)))
    (nth (cl:random (length l)) l)))							    (nth (cl:random (length l)) l)))
;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-		;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-
;;; ===========================================================================		;;; ===========================================================================
;;;			  Space Classes							;;;			  Space Classes
;;; ===========================================================================		;;; ===========================================================================
;;; (c) Copyright 1994 Cornell University						;;; (c) Copyright 1994 Cornell University

;;; space-classes.lisp,v 1.11 1995/05/30 18:10:14 rick Exp				;;; space-classes.lisp,v 1.11 1995/05/30 18:10:14 rick Exp

(in-package "WEYLI")								    |	(in-package :weyli)
										    <
(make::adjust-version-numbers Weyl "1.11")					    <

										    >	;;; DELETE (make::adjust-version-numbers Weyl "1.11")

;; Topological Domains									;; Topological Domains

;; Abstract spaces don't necessarily have a well defined dimension			;; Abstract spaces don't necessarily have a well defined dimension
(defclass abstract-space (domain) ())							(defclass abstract-space (domain) ())

(defclass dimensional-space (abstract-space dimensional-domain) ())			(defclass dimensional-space (abstract-space dimensional-domain) ())

(defclass euclidean-space (vector-space dimensional-space) ())				(defclass euclidean-space (vector-space dimensional-space) ())

											;;  FIXTHIS: This class should probably be in a different file.
;;  FIXTHIS: This class should probably be in a different file.				;;  Saves any results of coercions in a coercion cache accessible via
;;  Saves any results of coercions in a coercion cache accessible via			;;  Coerce.
;;  Coerce.										(defclass has-coercion-cache ()
(defclass has-coercion-cache ()							    (
     ((coercion-cache :initform nil :accessor %coercion-cache-of)))		    |	  ((coercion-cache
										    >	    :initform nil
										    >	    :accessor %coercion-cache-of)))

;;  Associates a unique id-number with each instance.					;;  Associates a unique id-number with each instance.
(defclass has-id-number ()								(defclass has-id-number ()
  ((global-counter :initform 0 :allocation :class				    |	  ((global-counter
										    >	    :initform 0
										    >	    :allocation :class
		   :accessor %global-id-counter-of)					    :accessor %global-id-counter-of)
   (id-number :reader id-number-of)))						    |	   (id-number
										    >	    :reader id-number-of)))

(defclass has-name ()									(defclass has-name ()
  ((name :initarg :name :accessor name-of)))						  ((name :initarg :name :accessor name-of)))

(defmethod initialize-instance :after ((obj has-id-number) &rest ignore)		(defmethod initialize-instance :after ((obj has-id-number) &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (with-slots (id-number) obj								  (with-slots (id-number) obj
	      (setf id-number (incf (%global-id-counter-of obj)))))			    (setf id-number (incf (%global-id-counter-of obj)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Points.										;;  Points.

;;  Base class of different types of points. 						;;  Base class of different types of points. 
(defclass abstract-point (has-id-number domain-element) ())				(defclass abstract-point (has-id-number domain-element) ())

;; An abstract point with a name.  Points with the same name in the			;; An abstract point with a name.  Points with the same name in the
;; same space are identical.								;; same space are identical.
(defclass named-point (has-name abstract-point) ())					(defclass named-point (has-name abstract-point) ())

;;  A point may have different coordinates in different spaces.  The			;;  A point may have different coordinates in different spaces.  The
;;  appropriate coordinates of a point are found using Coerce.				;;  appropriate coordinates of a point are found using Coerce.
;;  General-Point is for point in possibly non-euclidean coordinate			;;  General-Point is for point in possibly non-euclidean coordinate
;;  systems (polar, spherical, etc.)							;;  systems (polar, spherical, etc.)
(defclass general-point (tuple has-coercion-cache abstract-point) ())			(defclass general-point (tuple has-coercion-cache abstract-point) ())

(defclass point (vector-space-element general-point) ())				(defclass point (vector-space-element general-point) ())

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Cells and Cell-Complex.								;;  Cells and Cell-Complex.

;;  To fit within a complex, each cell class must have the following			;;  To fit within a complex, each cell class must have the following
;;  functions: cell-id, facets, and dimension-of.  Function cell-id			;;  functions: cell-id, facets, and dimension-of.  Function cell-id
;;  returns something (it doesn't really matter what) so that two			;;  returns something (it doesn't really matter what) so that two
;;  cell-ids are #'equal iff the two cells are equivalent.  [It also			;;  cell-ids are #'equal iff the two cells are equivalent.  [It also
;;  has to hash efficiently, so for Lucid, we have to use id-numbers			;;  has to hash efficiently, so for Lucid, we have to use id-numbers
;;  instead of points because all points hash to the same location.]			;;  instead of points because all points hash to the same location.]
;;  Function facets returns all the subcells that are one dimension			;;  Function facets returns all the subcells that are one dimension
;;  lower than the cell.  Function dimension-of does what you'd				;;  lower than the cell.  Function dimension-of does what you'd
;;  expect.										;;  expect.
(defclass cell (has-id-number)								(defclass cell (has-id-number)
  ((orient :initform t :initarg :orient :accessor orient-of)))				  ((orient :initform t :initarg :orient :accessor orient-of)))

(defclass simplex (cell)								(defclass simplex (cell)
  (;;  Maintained in order of id-number.						  (;;  Maintained in order of id-number.
   (vertices :initform nil :initarg :vertices :reader vertices-of)))			   (vertices :initform nil :initarg :vertices :reader vertices-of)))


;;;there must be a better place for ORIENTED-SORT				    |	;;; there must be a better place for ORIENTED-SORT
(defun oriented-sort (list)								(defun oriented-sort (list)
  "Sort keeping track of the number of swaps"						  "Sort keeping track of the number of swaps"
  ;bubble sort									    |	  ;; bubble sort
  (loop with orient = t									  (loop with orient = t
	for l1 on list do									for l1 on list do
	(loop for l2 on (rest l1) do								(loop for l2 on (rest l1) do
	      (when (cl:< (id-number-of (first l2)) (id-number-of (first l1)))			      (when (cl:< (id-number-of (first l2)) (id-number-of (first l1)))
		(setf orient (null orient))								(setf orient (null orient))
		(psetf (first l1) (first l2)								(psetf (first l1) (first l2)
		       (first l2) (first l1))))								       (first l2) (first l1))))
	finally (return (values list orient))))							finally (return (values list orient))))

(defmethod initialize-instance :after ((simplex simplex)				(defmethod initialize-instance :after ((simplex simplex)
				       &rest ignore &key home)								       &rest ignore &key home)
  (declare (ignore ignore home))							  (declare (ignore ignore home))
  (with-slots (vertices orient) simplex							  (with-slots (vertices orient) simplex
	      (multiple-value-bind (v o)						    (multiple-value-bind (v o)
		  (oriented-sort (copy-list vertices))					        (oriented-sort (copy-list vertices))
		(setf vertices v							      (setf vertices v
		      orient o))))							            orient o))))

(defclass polygon (cell)								(defclass polygon (cell)
     (;;  Maintained with smallest id-number first, then adjacent		    |	  ( ;;  Maintained with smallest id-number first, then adjacent
      ;;  vertex with smaller id-number, followed by other vertices in			   ;;  vertex with smaller id-number, followed by other vertices in
      ;;  order around the polygon.							   ;;  order around the polygon.
      (vertices :initform nil :initarg :vertices :reader vertices-of)))			   (vertices :initform nil :initarg :vertices :reader vertices-of)))

(defmethod initialize-instance :after ((polygon polygon) &rest ignore)			(defmethod initialize-instance :after ((polygon polygon) &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (warn "Polygons are not completely implemented."))					  (warn "Polygons are not completely implemented."))

(defclass cell-complex ()								(defclass cell-complex ()
     (;;  Used to recognize cells that are equivalent.				    |	  ( ;;  Used to recognize cells that are equivalent.
      (cell-table :initform (make-hash-table :test #'equal)				   (cell-table :initform (make-hash-table :test #'equal)
		  :reader cell-table-of)						               :reader cell-table-of)
      (facet-table :initform (make-hash-table) :reader facet-table-of)			   (facet-table :initform (make-hash-table) :reader facet-table-of)
      (cofacet-table :initform (make-hash-table) :reader cofacet-table-of)))		   (cofacet-table :initform (make-hash-table) :reader cofacet-table-of)))

(defclass simplicial-complex (cell-complex) ())						(defclass simplicial-complex (cell-complex) ())

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Chains.										;;  Chains.

(defclass chain-module (module)								(defclass chain-module (module)
     ((complex :initarg :complex :reader complex-of)					  ((complex :initarg :complex :reader complex-of)
      (dim :initform 0 :initarg :dimension :reader dimension-of)))			   (dim :initform 0 :initarg :dimension :reader dimension-of)))

(defclass cochain-module (module)							(defclass cochain-module (module)
  ((complex :initarg :complex :reader complex-of)					  ((complex :initarg :complex :reader complex-of)
   (dim :initform 0 :initarg :dimension :reader dimension-of)))				   (dim :initform 0 :initarg :dimension :reader dimension-of)))

;; Chains are elements of chain-modules							;; Chains are elements of chain-modules
(defclass chain (domain-element)							(defclass chain (domain-element)
  ((terms :initarg :terms :accessor chain-terms-of)))					  ((terms :initarg :terms :accessor chain-terms-of)))

;; Mathematically, cochains would probably not inherit from chains.			;; Mathematically, cochains would probably not inherit from chains.
;; This is done to simplify implemention -- since chains and cochains			;; This is done to simplify implemention -- since chains and cochains
;; are structurally identical, we'll inherit all functionality from			;; are structurally identical, we'll inherit all functionality from
;; chains.  Fix this later???								;; chains.  Fix this later???
(defclass cochain (chain)								(defclass cochain (chain)
  ())											  ())

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function Spaces									;; Function Spaces

(defclass function-space (vector-space dimensional-space ring)				(defclass function-space (vector-space dimensional-space ring)
  ((funct-domain :initarg :domain :reader funct-domain-of)				  ((funct-domain :initarg :domain :reader funct-domain-of)
   (funct-range :initarg :range :reader funct-range-of)))				   (funct-range :initarg :range :reader funct-range-of)))

(defclass function-space-element (domain-element)					(defclass function-space-element (domain-element)
  ())											  ())

(defmethod initialize-instance :after ((h function-space) &rest plist)			(defmethod initialize-instance :after ((h function-space) &rest plist)
  (declare (ignore plist))								  (declare (ignore plist))
  (with-slots (print-function) h							  (with-slots (print-function) h
    (setf print-function 'function-space-print-function)))				    (setf print-function 'function-space-print-function)))

(defun function-space-print-object (h  stream)						(defun function-space-print-object (h  stream)
  (format stream "C(~S->~S)" (funct-domain-of h) (funct-range-of h)))			  (format stream "C(~S->~S)" (funct-domain-of h) (funct-range-of h)))

;; The domain and range for a Banach space should both be geometric domains		;; The domain and range for a Banach space should both be geometric domains
(defclass Banach-space (function-space)							(defclass Banach-space (function-space)
  ())											  ())

;;Both Banach and Hilbert spaces are supposed to be complete under the			;;Both Banach and Hilbert spaces are supposed to be complete under the
;;norm.  I wonder how that is defined.							;;norm.  I wonder how that is defined.

(define-operations Banach-space								(define-operations Banach-space
  (norm (element self)) -> REAL-NUMBERS)						  (norm (element self)) -> REAL-NUMBERS)

(defclass Hilbert-space (Banach-space)							(defclass Hilbert-space (Banach-space)
     ())										  ())

(define-operations Hilbert-space							(define-operations Hilbert-space
  (inner-product (element self) (element self)) -> REAL-NUMBERS)			  (inner-product (element self) (element self)) -> REAL-NUMBERS)

(defclass hilbert-space-element (function-space-element)				(defclass hilbert-space-element (function-space-element)
     ())										  ())

(defmethod initialize-instance :after ((h hilbert-space) &rest plist)			(defmethod initialize-instance :after ((h hilbert-space) &rest plist)
  (declare (ignore plist))								  (declare (ignore plist))
  (with-slots (print-function) h							  (with-slots (print-function) h
    (setf print-function 'hilbert-space-print-function)))				    (setf print-function 'hilbert-space-print-function)))

(defun hilbert-space-print-object (h stream)						(defun hilbert-space-print-object (h stream)
  (format stream "Hilb(~S, ~S)" (funct-domain-of h) (funct-range-of h)))		  (format stream "Hilb(~S, ~S)" (funct-domain-of h) (funct-range-of h)))
;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-		;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-
;;; ===========================================================================		;;; ===========================================================================
;;;		      Sparse Polynomial Routines for GCD				;;;		      Sparse Polynomial Routines for GCD
;;; ===========================================================================		;;; ===========================================================================
;;; (c) Copyright 1989, 1993 Cornell University						;;; (c) Copyright 1989, 1993 Cornell University

;;; sparsegcd.lisp,v 1.5 1995/03/13 22:36:50 rz Exp					;;; sparsegcd.lisp,v 1.5 1995/03/13 22:36:50 rz Exp

(in-package "WEYLI")								    |	(in-package :weyli)

(make::adjust-version-numbers Weyl "1.5")					    |	;;; DELETE (make::adjust-version-numbers Weyl "1.5")

;; The linear-form macro makes sure that the linear polynomials we			;; The linear-form macro makes sure that the linear polynomials we
;; generate are well formed.								;; generate are well formed.
										    >	;;; FIXME : Generates defined but never used warnings for zero in some cases.
(defmacro with-linear-support (&body body)						(defmacro with-linear-support (&body body)
  `(let ((zero (zero *coefficient-domain*))						  `(let ((zero (zero *coefficient-domain*))
	 (one (one *coefficient-domain*)))							 (one (one *coefficient-domain*)))
     (macrolet ((linear-form (pt)							     (macrolet ((linear-form (pt)
		  `(if (0? ,pt) (make-terms (e1) one)							  `(if (0? ,pt) (make-terms (e1) one)
		      (make-terms (e1) one (make-terms (e0) (- ,pt))))))				      (make-terms (e1) one (make-terms (e0) (- ,pt))))))
       ,@body)))									       ,@body)))

;; This is a general interpolation routine.  Given the value of a			;; This is a general interpolation routine.  Given the value of a
;; univariate polynomial at several points it determines the polynomial.		;; univariate polynomial at several points it determines the polynomial.
(defun terms-interpolate (pts vals)							(defun terms-interpolate (pts vals)
  (with-linear-support									  (with-linear-support
      (do ((u (make-terms (e0) (car vals))						      (do ((u (make-terms (e0) (car vals))
	      (terms-plus									      (terms-plus
	       u (terms-mon-times qk (e0)							       u (terms-mon-times qk (e0)
				  (/ (- (car uk)									  (/ (- (car uk)
					(terms-horners-rule u (car xk)))							(terms-horners-rule u (car xk)))
				     denom))))										     denom))))
	   (qk (linear-form (first pts))							   (qk (linear-form (first pts))
	       (terms-times qk (linear-form (first xk))))					       (terms-times qk (linear-form (first xk))))
	   (uk (cdr vals) (cdr uk))								   (uk (cdr vals) (cdr uk))
	   (xk (cdr pts) (cdr xk))								   (xk (cdr pts) (cdr xk))
	   (denom))										   (denom))
	  ((null xk) u)										  ((null xk) u)
	(when (poly-0? (setq denom (terms-horners-rule qk (first xk))))				(when (poly-0? (setq denom (terms-horners-rule qk (first xk))))
	  (error "~S occurs twice in list of evaluation points: ~S"				  (error "~S occurs twice in list of evaluation points: ~S"
		 (first xk) pts)))))									 (first xk) pts)))))

(defun poly-interpolate (var pts vals)							(defun poly-interpolate (var pts vals)
  (poly-simp var (terms-interpolate pts vals)))						  (poly-simp var (terms-interpolate pts vals)))

										    >	(defgeneric interpolate (vars pts vals &key degrees)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod interpolate ((x polynomial) pts vals &rest ignore)				(defmethod interpolate ((x polynomial) pts vals &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (let ((domain (domain-of x)))								  (let ((domain (domain-of x)))
    (bind-domain-context domain								    (bind-domain-context domain
      (make-polynomial domain								      (make-polynomial domain
        (poly-interpolate (poly-form x) pts						        (poly-interpolate (poly-form x) pts
			  (loop for v in vals									  (loop for v in vals
				collect (if (and (typep v 'mpolynomial)							collect (if (and (typep v 'mpolynomial)
						 (eql (domain-of v) domain))								 (eql (domain-of v) domain))
					    (poly-form v)									    (poly-form v)
					    v)))))))										    v)))))))

(defmethod interpolate ((vars list) pts vals &key (degrees :total))			(defmethod interpolate ((vars list) pts vals &key (degrees :total))
  (let ((var-cnt (length vars))								  (let ((var-cnt (length vars))
	ring array)										ring array)
    (cond ((typep (first vars) 'domain-element)						    (cond ((typep (first vars) 'domain-element)
	   (setq ring (domain-of (first vars))))						   (setq ring (domain-of (first vars))))
	  (t (setq ring *general*)))								  (t (setq ring *general*)))
    (setq vars										    (setq vars
	  (loop for v in vars									  (loop for v in vars
		collect (cond ((symbolp v)								collect (cond ((symbolp v)
			       (coerce v ring))									       (coerce v ring))
			      ((eql ring (domain-of v))								      ((eql ring (domain-of v))
			       v)										       v)
			      (t (error										      (t (error
				   "Variables are not of the same domain: ~S"						   "Variables are not of the same domain: ~S"
				   vars)))))										   vars)))))
    (loop for pt in pts									    (loop for pt in pts
	  do (unless (eql (length pt) var-cnt)							  do (unless (eql (length pt) var-cnt)
	       (error "Point ~S does not have ~D components"					       (error "Point ~S does not have ~D components"
		      pt var-cnt))) 									      pt var-cnt))) 
    (unless (eql (length pts) (length vals))						    (unless (eql (length pts) (length vals))
      (error "Points (~D) and values (~D) are of different lengths"			      (error "Points (~D) and values (~D) are of different lengths"
	     (length pts) (length vals)))							     (length pts) (length vals)))

    (when (or (eql degrees :total)							    (when (or (eql degrees :total)
	      (eql degrees :maximum))								      (eql degrees :maximum))
      (setq degrees									      (setq degrees
	    (mapcar #'rest									    (mapcar #'rest
		    (degree-partition									    (degree-partition
		      (1+ var-cnt)									      (1+ var-cnt)
		      (bound-degree-term-count var-cnt							      (bound-degree-term-count var-cnt
					       (length pts)									       (length pts)
					       :type degrees)))))								       :type degrees)))))
    (setq array (make-degree-matrix ring degrees pts))					    (setq array (make-degree-matrix ring degrees pts))
    (loop for i below (length pts)							    (loop for i below (length pts)
	  with poly = (zero ring)								  with poly = (zero ring)
	  for expt in degrees									  for expt in degrees
	  do (setq poly										  do (setq poly
		   (+ poly										   (+ poly
		     (* (expt-list vars expt)								     (* (expt-list vars expt)
			(loop for j below (length pts)								(loop for j below (length pts)
			      for v in vals									      for v in vals
			      with c = (zero ring)								      with c = (zero ring)
			      do (setq c (+ c (* v (aref array i j))))						      do (setq c (+ c (* v (aref array i j))))
			      finally (return c)))))								      finally (return c)))))
	  finally (return poly))))								  finally (return poly))))

	     											     
(defun expt-list (base expt)								(defun expt-list (base expt)
  (loop with ans = (one (domain-of (first base)))					  (loop with ans = (one (domain-of (first base)))
	for b in base										for b in base
	for e in expt										for e in expt
	do (setq ans (* ans (expt b e)))							do (setq ans (* ans (expt b e)))
	finally (return ans)))									finally (return ans)))

#|  The following is often useful for debugging |					#|  The following is often useful for debugging |
(defun display-array (arr)								(defun display-array (arr)
  (let ((dims (array-dimensions arr)))							  (let ((dims (array-dimensions arr)))
    (loop for i below (first dims)							    (loop for i below (first dims)
	  do (loop for j below (second dims)							  do (loop for j below (second dims)
		   do (format t "~S " (aref arr i j)))							   do (format t "~S " (aref arr i j)))
	     (fresh-line))))									     (fresh-line))))
||#											||#	

(defun bound-degree-term-count (num-vars term-count &key (type :total))			(defun bound-degree-term-count (num-vars term-count &key (type :total))
  (cond ((eql type :total)								  (cond ((eql type :total)
	 (loop for i upfrom 0									 (loop for i upfrom 0
	       do (when (> (combinations (+ i num-vars) i) term-count)				       do (when (> (combinations (+ i num-vars) i) term-count)
		    (return (1- i)))))									    (return (1- i)))))
	((eql type :maximum)									((eql type :maximum)
	 (1- (truncate (integer-nth-root term-count num-vars))))				 (1- (truncate (integer-nth-root term-count num-vars))))
	(t (error "Degree bound must be either :total or :maximum: ~S"				(t (error "Degree bound must be either :total or :maximum: ~S"
		  type))))										  type))))

;; The following routine returns a list of all the exponent vectors			;; The following routine returns a list of all the exponent vectors
;; for monomials in v variables of total degree equal to d.  If one			;; for monomials in v variables of total degree equal to d.  If one
;; wants all the monomials of total degree less than or equal to d,			;; wants all the monomials of total degree less than or equal to d,
;; incrase n by one and drop the first component of every list.				;; incrase n by one and drop the first component of every list.
(defun degree-partition (v d)								(defun degree-partition (v d)
  (cond ((1? v) `((,d)))								  (cond ((1? v) `((,d)))
	((0? d)											((0? d)
	 (loop for part in (degree-partition (1- v) d)						 (loop for part in (degree-partition (1- v) d)
	       collect (cons 0 part)))								       collect (cons 0 part)))
	(t (loop for u below (1+ d)								(t (loop for u below (1+ d)
		 append (loop for part in (degree-partition (1- v) (- d u))				 append (loop for part in (degree-partition (1- v) (- d u))
			      collect (cons u part))))))							      collect (cons u part))))))

;; This routine takes a list of exponent vectors and points (values)			;; This routine takes a list of exponent vectors and points (values)
;; for the variables and returns the inverse of the matrix where			;; for the variables and returns the inverse of the matrix where
;; each row consists of one of the vals raised to each of the exponent			;; each row consists of one of the vals raised to each of the exponent
;; vectors.										;; vectors.
(defun make-degree-matrix (domain expt-vects pts)					(defun make-degree-matrix (domain expt-vects pts)
  (let ((array (make-array (list (length pts) (length expt-vects)))))			  (let ((array (make-array (list (length pts) (length expt-vects)))))
    (loop for i upfrom 0								    (loop for i upfrom 0
	  for pt in pts										  for pt in pts
	  do (loop for j upfrom 0								  do (loop for j upfrom 0
		   for expt-vect in expt-vects								   for expt-vect in expt-vects
		   for temp = (one domain)								   for temp = (one domain)
		   do (setf (aref array i j)								   do (setf (aref array i j)
			    (loop for e in expt-vect								    (loop for e in expt-vect
				  for p in pt										  for p in pt
				  do (setq temp (* temp (expt p e)))							  do (setq temp (* temp (expt p e)))
				  finally (return temp)))))								  finally (return temp)))))
    (invert-array domain array)))							    (invert-array domain array)))

;; This routine could be sped up by computing Q in place.  Theoretical			;; This routine could be sped up by computing Q in place.  Theoretical
;; speedups are possible (Kaltofen&Yagati), but they are impractical.			;; speedups are possible (Kaltofen&Yagati), but they are impractical.
(defun compute-vandermonde-Q (pts)							(defun compute-vandermonde-Q (pts)
  (with-linear-support									  (with-linear-support
      (let ((ans (make-terms (e1) (one *coefficient-domain*)				      (let ((ans (make-terms (e1) (one *coefficient-domain*)
			     (make-terms (e0) (- (first pts))))))						     (make-terms (e0) (- (first pts))))))
	(loop for pt in (rest pts)								(loop for pt in (rest pts)
	      do (setq ans (terms-times ans (linear-form pt))))					      do (setq ans (terms-times ans (linear-form pt))))
	ans)))											ans)))

(defun solve-vandermonde (pts vals &optional Q)						(defun solve-vandermonde (pts vals &optional Q)
  (unless Q										  (unless Q
    (setq Q (compute-vandermonde-Q pts)))						    (setq Q (compute-vandermonde-Q pts)))
  (with-linear-support									  (with-linear-support
    (let* ((sols (make-array (length vals) :initial-element zero))			    (let* ((sols (make-array (length vals) :initial-element zero))
	   qi)											   qi)
      (loop for pt in pts								      (loop for pt in pts
	    for val in vals									    for val in vals
	    do (setq qi (terms-quotient q (linear-form pt)))					    do (setq qi (terms-quotient q (linear-form pt)))
	       (map-over-each-term								       (map-over-each-term
		    (terms-cquotient qi (terms-horners-rule qi pt))					    (terms-cquotient qi (terms-horners-rule qi pt))
		    (e c)										    (e c)
		 (setf (aref sols e) (+ (aref sols e) (* c val)))))					 (setf (aref sols e) (+ (aref sols e) (* c val)))))
      (loop for i below (array-dimension sols 0)					      (loop for i below (array-dimension sols 0)
	    collect (aref sols i)))))								    collect (aref sols i)))))

(defun solve-vandermondeT (pts vals &optional Q)					(defun solve-vandermondeT (pts vals &optional Q)
  (unless Q										  (unless Q
    (setq Q (compute-vandermonde-Q pts)))						    (setq Q (compute-vandermonde-Q pts)))
  (with-linear-support									  (with-linear-support
    (let ((k (make-array (length vals) :initial-contents vals))				    (let ((k (make-array (length vals) :initial-contents vals))
	  qi x sols)										  qi x sols)
      (loop for pt in pts do								      (loop for pt in pts do
	(setq qi (terms-quotient q (linear-form pt)))						(setq qi (terms-quotient q (linear-form pt)))
	(setq x zero)										(setq x zero)
	(map-over-each-term (terms-cquotient qi (terms-horners-rule qi pt))			(map-over-each-term (terms-cquotient qi (terms-horners-rule qi pt))
			    (e c)										    (e c)
          (setq x (+ x (* c (aref k e)))))						          (setq x (+ x (* c (aref k e)))))
	(push x sols))										(push x sols))
      sols)))										      sols)))

(defun solve-vandermondeTD (pts vals &optional Q)					(defun solve-vandermondeTD (pts vals &optional Q)
  (unless Q										  (unless Q
    (setq Q (compute-vandermonde-Q pts)))						    (setq Q (compute-vandermonde-Q pts)))
  (with-linear-support									  (with-linear-support
    (let ((k (make-array (length vals) :initial-contents vals))				    (let ((k (make-array (length vals) :initial-contents vals))
	  qi x sols)										  qi x sols)
      (loop for pt in pts do								      (loop for pt in pts do
	(setq qi (terms-quotient q (linear-form pt)))						(setq qi (terms-quotient q (linear-form pt)))
	(setq x zero)										(setq x zero)
	(map-over-each-term (terms-cquotient qi (terms-horners-rule qi pt))			(map-over-each-term (terms-cquotient qi (terms-horners-rule qi pt))
			    (e c)										    (e c)
          (setq x (+ x (* c (aref k e)))))						          (setq x (+ x (* c (aref k e)))))
	(push x sols))										(push x sols))
      (loop for sol in (nreverse sols)							      (loop for sol in (nreverse sols)
	    for pt in pts									    for pt in pts
	    collect (/ sol pt)))))								    collect (/ sol pt)))))

(defun poly-skeleton (poly vars)							(defun poly-skeleton (poly vars)
  (cond ((poly-coef? poly)								  (cond ((poly-coef? poly)
	 (list (loop for i in vars collect 0)))							 (list (loop for i in vars collect 0)))
	((same-variable? poly (first vars))							((same-variable? poly (first vars))
	 (let ((skeleton ()))									 (let ((skeleton ()))
	   (map-over-each-term (poly-terms poly) (e c)						   (map-over-each-term (poly-terms poly) (e c)
	     (loop for skel in (poly-skeleton c (rest vars))					     (loop for skel in (poly-skeleton c (rest vars))
		   do (push (cons e skel) skeleton)))							   do (push (cons e skel) skeleton)))
	   (nreverse skeleton)))								   (nreverse skeleton)))
	((more-main? poly (first vars))								((more-main? poly (first vars))
	 (error "Involves a variable that it shouldn't"))					 (error "Involves a variable that it shouldn't"))
	(t (loop for skel in (poly-skeleton poly (rest vars))					(t (loop for skel in (poly-skeleton poly (rest vars))
		 collect (cons 0 skel)))))								 collect (cons 0 skel)))))

										    >	(defgeneric pskeleton (poly vars)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod pskeleton ((p mpolynomial) vars)						(defmethod pskeleton ((p mpolynomial) vars)
  (let ((vars (mapcar									  (let ((vars (mapcar
		#'(lambda (x) (poly-form (coerce x (domain-of p))))					#'(lambda (x) (poly-form (coerce x (domain-of p))))
		      vars)))										      vars)))
       (poly-skeleton (poly-form p) vars)))						       (poly-skeleton (poly-form p) vars)))

										    >	(defgeneric sparseinterpstage (poly bp d k)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
;; Sparse multivariate Interpolation.							;; Sparse multivariate Interpolation.
(defmethod SparseInterpStage ((Pkminus1 mpolynomial) Bp D k)				(defmethod SparseInterpStage ((Pkminus1 mpolynomial) Bp D k)
  (SparseInterpStagei (coefficient-domain-of (domain-of Pkminus1))			  (SparseInterpStagei (coefficient-domain-of (domain-of Pkminus1))
		      Pkminus1 Bp D k))									      Pkminus1 Bp D k))

										    >	(defgeneric sparseinterpstagei (coef-domain pkminus1 bp d k &optional coef-bound)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
;; If the polynomial ring is over integers then we can compute over Zp			;; If the polynomial ring is over integers then we can compute over Zp
;; and use Chinese Remainder Theorem.							;; and use Chinese Remainder Theorem.
(defmethod SparseInterpStagei ((coef-domain rational-integers)				(defmethod SparseInterpStagei ((coef-domain rational-integers)
			       (Pkminus1 mpolynomial) Bp D k							       (Pkminus1 mpolynomial) Bp D k
			       &optional (coef-bound most-positive-fixnum))					       &optional (coef-bound most-positive-fixnum))
  (let* ((domain (domain-of Pkminus1))							  (let* ((domain (domain-of Pkminus1))
	 (vars (list-coerce (list-of-variables Pkminus1) domain))				 (vars (list-coerce (list-of-variables Pkminus1) domain))
	 (Skel (pskeleton Pkminus1 vars))							 (Skel (pskeleton Pkminus1 vars))
	 (l (length Skel))									 (l (length Skel))
	 (S (make-array (list l (1- k)) :initial-contents (reverse Skel)))			 (S (make-array (list l (1- k)) :initial-contents (reverse Skel)))
	 (primes (choice-primes (* 2 coef-bound)))						 (primes (choice-primes (* 2 coef-bound)))
	 (gfp nil)										 (gfp nil)
	 (gfp-domain nil)									 (gfp-domain nil)
	 (Y '())										 (Y '())
	 (m '())										 (m '())
	 (cur-pt 0)										 (cur-pt 0)
	 (X '())										 (X '())
	 (vals '())	 									 (vals '())	 
	 (B '())										 (B '())
	 (EQ (make-array (list D l)))								 (EQ (make-array (list D l)))
	 (poly (make-array (list (length primes) l)))						 (poly (make-array (list (length primes) l)))
	 (Pprime '())										 (Pprime '())
	 (factor (one domain))									 (factor (one domain))
	 (temp-poly (zero domain))								 (temp-poly (zero domain))
	 (Pk (zero domain)))									 (Pk (zero domain)))
	(loop for ip upfrom 0 as p in primes do							(loop for ip upfrom 0 as p in primes do
	  (setq X '())										  (setq X '())
	  (setq gfp (get-finite-field p))							  (setq gfp (get-finite-field p))
	  (setq gfp-domain (get-polynomial-ring gfp (ring-variables domain)))			  (setq gfp-domain (get-polynomial-ring gfp (ring-variables domain)))
	  (setq *coefficient-domain* gfp)							  (setq *coefficient-domain* gfp)
	  (setq vals (loop for i below (- (length (ring-variables domain)) k)			  (setq vals (loop for i below (- (length (ring-variables domain)) k)
			   collect (random gfp)))								   collect (random gfp)))
	  (multiple-value-setq (Y m) (InitY gfp S k l))						  (multiple-value-setq (Y m) (InitY gfp S k l))
	  (loop for i below D do								  (loop for i below D do
	    (loop while (member (setq cur-pt (random gfp))					    (loop while (member (setq cur-pt (random gfp))
				X))											X))
	    (setq X (append X (list cur-pt)))							    (setq X (append X (list cur-pt)))
	    (setq B (loop for j below l								    (setq B (loop for j below l
			  collect (%funcall Bp (append								  collect (%funcall Bp (append
						 (loop for pt in Y									 (loop for pt in Y
						       collect (expt pt j))								       collect (expt pt j))
						 (list cur-pt)										 (list cur-pt)
						 vals))))										 vals))))
	    (setq Pprime (Solve-vandermondeT m B))						    (setq Pprime (Solve-vandermondeT m B))
	    (loop for j upfrom 0 as eqn in Pprime do						    (loop for j upfrom 0 as eqn in Pprime do
	      (setf (aref EQ i j) eqn)))							      (setf (aref EQ i j) eqn)))
	  (loop for j below l do								  (loop for j below l do
	    (setf (aref poly ip j)								    (setf (aref poly ip j)
		  (interpolate										  (interpolate
		    (coerce (nth (1- k) (ring-variables domain))					    (coerce (nth (1- k) (ring-variables domain))
			    gfp-domain)										    gfp-domain)
		    X											    X
		    (loop for i below D 								    (loop for i below D 
			  collect (aref EQ i j))))))								  collect (aref EQ i j))))))
	(loop for j below l do									(loop for j below l do
	  (setq temp-poly (zero domain))							  (setq temp-poly (zero domain))
	  (loop for i below D do								  (loop for i below D do
	    (setq temp-poly (+ temp-poly							    (setq temp-poly (+ temp-poly
			       (* (expt (coerce									       (* (expt (coerce
					  (nth (1- k) (ring-variables domain))							  (nth (1- k) (ring-variables domain))
					  domain) i)										  domain) i)
		    (compute-result									    (compute-result
		      (use-chinese-remainder								      (use-chinese-remainder
			(loop for ip below (length primes)							(loop for ip below (length primes)
			  collect (poly-form (coefficient (aref poly ip j)					  collect (poly-form (coefficient (aref poly ip j)
			       (nth (1- k) (ring-variables domain))						       (nth (1- k) (ring-variables domain))
					       i)))))))))									       i)))))))))
	  (setf (aref poly 0 j) temp-poly))							  (setf (aref poly 0 j) temp-poly))
	(loop for j below l do									(loop for j below l do
	  (setq factor (one domain))								  (setq factor (one domain))
	  (loop for k upfrom 0									  (loop for k upfrom 0
		as var in (list-of-variables Pkminus1) do						as var in (list-of-variables Pkminus1) do
		  (setq factor (* factor (expt (coerce var domain)					  (setq factor (* factor (expt (coerce var domain)
					       (aref S j k)))))									       (aref S j k)))))
	  (setq Pk (+ Pk (* factor (aref poly 0 j)))))						  (setq Pk (+ Pk (* factor (aref poly 0 j)))))
	Pk))											Pk))

										    >	(defgeneric inity (coef-domain s k l)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod InitY ((coef-domain field) S k l)						(defmethod InitY ((coef-domain field) S k l)
  (let ((Y '())										  (let ((Y '())
	(m '())											(m '())
	(f 1))											(f 1))
       (loop while (< (length m) l) do							       (loop while (< (length m) l) do
	 (setq m '())										 (setq m '())
	 (setq Y (loop for i below (1- k)							 (setq Y (loop for i below (1- k)
		       collect (random coef-domain)))							       collect (random coef-domain)))
	 (loop for j below l do									 (loop for j below l do
	   (setq f 1)										   (setq f 1)
	   (loop for k upfrom 0									   (loop for k upfrom 0
		 as pt in Y do										 as pt in Y do
		   (setq f (* f (expt pt (aref S j k)))))						   (setq f (* f (expt pt (aref S j k)))))
	   (pushnew f m))									   (pushnew f m))
	 finally										 finally
      (return (values Y m)))))								      (return (values Y m)))))

;; Bp is the function name representing the black box, i.e, the				;; Bp is the function name representing the black box, i.e, the
;; function should return the value of the polynomial at the				;; function should return the value of the polynomial at the
;; requested point.									;; requested point.
(defmethod interpolate ((domain multivariate-polynomial-ring)				(defmethod interpolate ((domain multivariate-polynomial-ring)
			Bp degree-bounds &rest ignore)								Bp degree-bounds &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
;  (setq *cur-poly* (coerce (coerce *cur-poly* *general*) domain))			;  (setq *cur-poly* (coerce (coerce *cur-poly* *general*) domain))
  (let* ((vars (list-coerce (ring-variables domain) domain))				  (let* ((vars (list-coerce (ring-variables domain) domain))
	 (var (first vars))									 (var (first vars))
	 (coef-domain (coefficient-domain-of domain))						 (coef-domain (coefficient-domain-of domain))
	 (pts (loop for i from 1 below (length vars)						 (pts (loop for i from 1 below (length vars)
	            collect (coerce i coef-domain)))						            collect (coerce i coef-domain)))
	 (p (interpolate var (loop for i upto (first degree-bounds)				 (p (interpolate var (loop for i upto (first degree-bounds)
				   collect i)										   collect i)
		(loop for i upto (first degree-bounds)							(loop for i upto (first degree-bounds)
		      collect (%funcall									      collect (%funcall
				Bp											Bp
				(cons (coerce i coef-domain) pts))))))							(cons (coerce i coef-domain) pts))))))
	(setq *coefficient-domain* (coefficient-domain-of domain))				(setq *coefficient-domain* (coefficient-domain-of domain))
	(loop for k from 2 to (length vars) do							(loop for k from 2 to (length vars) do
	  (setq p (SparseInterpStage								  (setq p (SparseInterpStage
		    p											    p
		    Bp											    Bp
		    (1+ (nth (1- k) degree-bounds))							    (1+ (nth (1- k) degree-bounds))
		    k)))										    k)))
	p))											p))

										    >	(defgeneric list-coerce (list domain)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod list-coerce ((l list) domain)						(defmethod list-coerce ((l list) domain)
  (loop for x in l 									  (loop for x in l 
    collect (coerce x domain)))								    collect (coerce x domain)))

;; Implementation of the algorithm given in the book by Zippel in			;; Implementation of the algorithm given in the book by Zippel in
;; the chapter on Multivariate Interpolation.						;; the chapter on Multivariate Interpolation.
(defmethod SparseInterpStagei ((coef-domain field)					(defmethod SparseInterpStagei ((coef-domain field)
			       (Pkminus1 mpolynomial) Bp D k							       (Pkminus1 mpolynomial) Bp D k
			       &optional ignore)								       &optional ignore)
  (ignore (ignore ignore))							    |	  (declare (ignore ignore))
  (let* ((domain (domain-of Pkminus1))							  (let* ((domain (domain-of Pkminus1))
	 (vars (list-coerce (list-of-variables Pkminus1) domain))				 (vars (list-coerce (list-of-variables Pkminus1) domain))
	 (Skel (pskeleton Pkminus1 vars))							 (Skel (pskeleton Pkminus1 vars))
	 (l (length Skel))									 (l (length Skel))
	 (S (make-array (list l (1- k)) :initial-contents (reverse Skel)))			 (S (make-array (list l (1- k)) :initial-contents (reverse Skel)))
	 (Y '())										 (Y '())
	 (m '())										 (m '())
	 (cur-pt 0)										 (cur-pt 0)
	 (X '())										 (X '())
	 (vals '())	 									 (vals '())	 
	 (B '())										 (B '())
	 (EQ (make-array (list D l)))								 (EQ (make-array (list D l)))
	 (Pprime '())										 (Pprime '())
	 (factor (one domain))									 (factor (one domain))
	 (Pk (zero domain)))									 (Pk (zero domain)))
	(setq vals (loop for i below (- (length (ring-variables domain)) k)			(setq vals (loop for i below (- (length (ring-variables domain)) k)
			 collect (random coef-domain)))								 collect (random coef-domain)))
	(multiple-value-setq (Y m) (InitY coef-domain S k l))					(multiple-value-setq (Y m) (InitY coef-domain S k l))
	(loop for i below D do									(loop for i below D do
	  (loop while (member (setq cur-pt (random coef-domain))				  (loop while (member (setq cur-pt (random coef-domain))
			      X))										      X))
	  (setq X (append X (list cur-pt)))							  (setq X (append X (list cur-pt)))
	  (setq B (loop for j below l								  (setq B (loop for j below l
			collect (%funcall Bp (append								collect (%funcall Bp (append
					       (loop for pt in Y								       (loop for pt in Y
						     collect (expt pt j))								     collect (expt pt j))
					       (list cur-pt)									       (list cur-pt)
					       vals))))										       vals))))
	  (setq Pprime (Solve-vandermondeT m B))						  (setq Pprime (Solve-vandermondeT m B))
	  (loop for j upfrom 0 as eqn in Pprime do						  (loop for j upfrom 0 as eqn in Pprime do
	    (setf (aref EQ i j) eqn)))								    (setf (aref EQ i j) eqn)))
	(loop for j below l do									(loop for j below l do
	  (setq factor (one domain))								  (setq factor (one domain))
	  (loop for k upfrom 0									  (loop for k upfrom 0
		as var in (list-of-variables Pkminus1) do						as var in (list-of-variables Pkminus1) do
		  (setq factor (* factor (expt (coerce var domain)					  (setq factor (* factor (expt (coerce var domain)
					       (aref S j k)))))									       (aref S j k)))))
	  (setq Pk (+ Pk (* factor								  (setq Pk (+ Pk (* factor
			    (interpolate									    (interpolate
			      (coerce (nth (1- k) (ring-variables domain))					      (coerce (nth (1- k) (ring-variables domain))
				      domain)										      domain)
			      X											      X
			      (loop for i below D 								      (loop for i below D 
				    collect (aref EQ i j)))))))								    collect (aref EQ i j)))))))
	Pk))											Pk))

;;SPMOD-GCD takes two polynomials over the integers and computes their GCD		;;SPMOD-GCD takes two polynomials over the integers and computes their GCD
;;SPMOD-GCD1 takes two polynomials over a field and computes their GCD.			;;SPMOD-GCD1 takes two polynomials over a field and computes their GCD.

(defun spmod-gcd (p q)									(defun spmod-gcd (p q)
  (let ((b (min (poly-factor-cbound p) (poly-factor-cbound q)))				  (let ((b (min (poly-factor-cbound p) (poly-factor-cbound q)))
        (primes (list (newprime))))							        (primes (list (newprime))))
    (loop for prod = (first primes) then (* prod (first primes))			    (loop for prod = (first primes) then (* prod (first primes))
          while (> (+ (* 4 b) 2) prod)							          while (> (+ (* 4 b) 2) prod)
          do (push (newprime (first primes)) primes))					          do (push (newprime (first primes)) primes))
    (print b)))										    (print b)))

;; Vars is a list var-number and value, so the entries themselves can			;; Vars is a list var-number and value, so the entries themselves can
;; be used as polynomials representing the variable.					;; be used as polynomials representing the variable.
(defun spmod-gcd1 (p q)									(defun spmod-gcd1 (p q)
  (multiple-value-bind (pc pp) (poly-content-and-prim-part p)				  (multiple-value-bind (pc pp) (poly-content-and-prim-part p)
    (multiple-value-bind (qc qp) (poly-content-and-prim-part q)				    (multiple-value-bind (qc qp) (poly-content-and-prim-part q)
      (let ((vars (sort (union (poly-list-of-variables pp)				      (let ((vars (sort (union (poly-list-of-variables pp)
			   (poly-list-of-variables qp))								   (poly-list-of-variables qp))
		    #'cl:<))										    #'cl:<))
	    (plc (lc (poly-terms pp)))								    (plc (lc (poly-terms pp)))
	    (qlc (lc (poly-terms qp)))								    (qlc (lc (poly-terms qp)))
	    start-point lc)									    start-point lc)

	(unless (and (eql (poly-order-number p)							(unless (and (eql (poly-order-number p)
			  (poly-order-number q))								  (poly-order-number q))
		     (eql (poly-order-number p) (first vars)))						     (eql (poly-order-number p) (first vars)))
	  (error "Polynomials do not involve the same variables -- SPMOD-GCD"))			  (error "Polynomials do not involve the same variables -- SPMOD-GCD"))

    ;; Assuming p and q are primitive							    ;; Assuming p and q are primitive

    (setq vars (loop for var on (rest vars)						    (setq vars (loop for var on (rest vars)
		     collect (list (first var))))							     collect (list (first var))))

    (setq lc (poly-gcd plc qlc))							    (setq lc (poly-gcd plc qlc))

    (setq start-point									    (setq start-point
	  (loop for var in vars									  (loop for var in vars
		collect (list (first var) (random *coefficient-domain*))))				collect (list (first var) (random *coefficient-domain*))))

    (poly-times (poly-gcd pc qc)							    (poly-times (poly-gcd pc qc)
		(poly-prim-part										(poly-prim-part
		 (spmod-gcd2 lc										 (spmod-gcd2 lc
			     (poly-times pp (poly-quotient (lc (poly-terms qp)) lc				     (poly-times pp (poly-quotient (lc (poly-terms qp)) lc
			     (poly-times qp (poly-quotient (lc (poly-terms pp)) lc				     (poly-times qp (poly-quotient (lc (poly-terms pp)) lc
			     start-point)))))))									     start-point)))))))

(defun spmod-gcd2 (lc p q vars)								(defun spmod-gcd2 (lc p q vars)
  (cond ((null vars)									  (cond ((null vars)
	 (poly-times lc (poly-gcdu p q)))							 (poly-times lc (poly-gcdu p q)))
	(t (let ((image (spmod-gcd2 (poly-subst lc (list (first vars)))				(t (let ((image (spmod-gcd2 (poly-subst lc (list (first vars)))
				    (poly-subst p (list (first vars)))							    (poly-subst p (list (first vars)))
				    (poly-subst q (list (first vars)))							    (poly-subst q (list (first vars)))
				    (rest vars)))									    (rest vars)))
		 (max-terms 0)										 (max-terms 0)
		 skel skels rand-vals gcds subst ans) 							 skel skels rand-vals gcds subst ans) 
	     (map-over-each-term (poly-terms image) (e c)					     (map-over-each-term (poly-terms image) (e c)
	       (setq skel (poly-skeleton c (rest vars)))					       (setq skel (poly-skeleton c (rest vars)))
	       (push (list e skel) skels)							       (push (list e skel) skels)
	       (setq max-terms (cl:max max-terms (length skel))))				       (setq max-terms (cl:max max-terms (length skel))))

	     (setq skels (nreverse skels))							     (setq skels (nreverse skels))

	     (push image gcds)									     (push image gcds)
	     (push (second (first vars)) rand-vals)						     (push (second (first vars)) rand-vals)

	     (loop for i below (min (poly-degree p (first vars))				     (loop for i below (min (poly-degree p (first vars))
				    (poly-degree q (first vars)))							    (poly-degree q (first vars)))
		   for rand = (random *coefficient-domain*)						   for rand = (random *coefficient-domain*)
		   do (setq subst (list (list (first (first vars)) rand)))				   do (setq subst (list (list (first (first vars)) rand)))
		      (push rand rand-vals)								      (push rand rand-vals)
		      (push (spmod-gcd3 skels								      (push (spmod-gcd3 skels
					(poly-subst lc subst)									(poly-subst lc subst)
					(poly-subst p subst)									(poly-subst p subst)
					(poly-subst q subst)									(poly-subst q subst)
					(rest vars)										(rest vars)
				  max-terms)										  max-terms)
			    gcds)										    gcds)
		   #+Testing										   #+Testing
		    (print (list 'GCD2 (first subst) (first gcds))))					    (print (list 'GCD2 (first subst) (first gcds))))
	     (setq ans 										     (setq ans 
		   (dense-interpolate-coefficients gcds rand-vals					   (dense-interpolate-coefficients gcds rand-vals
						   (first vars)))									   (first vars)))
	     (cond ((and (poly-test-quotient p ans)						     (cond ((and (poly-test-quotient p ans)
			 (poly-test-quotient q ans))								 (poly-test-quotient q ans))
		    ans)		   								    ans)		   
		   (t (error "Test divide failed: ~S" ans)))))))					   (t (error "Test divide failed: ~S" ans)))))))

(defun non-zero-random (domain)								(defun non-zero-random (domain)
  (loop for rand = (random domain)							  (loop for rand = (random domain)
	do (when (not (0? rand))								do (when (not (0? rand))
	     (return rand))))									     (return rand))))
		      											      
(defun spmod-gcd3 (skels lc p q vars max-terms)						(defun spmod-gcd3 (skels lc p q vars max-terms)
  (flet ((check-degree (ans)								  (flet ((check-degree (ans)
	   (when (e> (le ans) (first (first skels)))						   (when (e> (le ans) (first (first skels)))
	     (error "Degree of skeleton is too large"))						     (error "Degree of skeleton is too large"))
	   (when (e> (first (first skels)) (le ans))						   (when (e> (first (first skels)) (le ans))
	     (error "Leading coefficient of GCD vanished"))					     (error "Leading coefficient of GCD vanished"))
	   (cons (first p) ans)))								   (cons (first p) ans)))
    (if (null vars)									    (if (null vars)
	(check-degree (terms-gcdu+ lc (poly-terms p) (poly-terms q)))				(check-degree (terms-gcdu+ lc (poly-terms p) (poly-terms q)))
	(let ((rand-vars									(let ((rand-vars
	       (loop for (var-num) in vars							       (loop for (var-num) in vars
		     collect (list var-num								     collect (list var-num
				   (non-zero-random *coefficient-domain*))))						   (non-zero-random *coefficient-domain*))))
	      subst init-pt gcds coef ans)							      subst init-pt gcds coef ans)
	  (setq init-pt (loop for (nil xi) in rand-vars						  (setq init-pt (loop for (nil xi) in rand-vars
			      collect xi))									      collect xi))

	  (loop for i upfrom 1 below (cl:1+ max-terms) do					  (loop for i upfrom 1 below (cl:1+ max-terms) do
	    (setq subst (loop for (var-num xi) in rand-vars					    (setq subst (loop for (var-num xi) in rand-vars
			      collect (list var-num (expt xi i))))						      collect (list var-num (expt xi i))))
	    (push (terms-gcdu+ (poly-subst lc subst)						    (push (terms-gcdu+ (poly-subst lc subst)
			       (poly-terms (poly-subst p subst))						       (poly-terms (poly-subst p subst))
			       (poly-terms (poly-subst q subst)))						       (poly-terms (poly-subst q subst)))
		  gcds)											  gcds)
	    #+Testing										    #+Testing
	    (print (list 'GCD3 subst (first gcds))))						    (print (list 'GCD3 subst (first gcds))))
	  (setq gcds (reverse gcds))								  (setq gcds (reverse gcds))
	  (loop for (e skel) in skels								  (loop for (e skel) in skels
		for vals = ()										for vals = ()
		do (loop for g on gcds do								do (loop for g on gcds do
		  (cond ((e> e (le (first g)))								  (cond ((e> e (le (first g)))
			 (push (zero *coefficient-domain*) vals))						 (push (zero *coefficient-domain*) vals))
			(t (push (lc (first g)) vals)								(t (push (lc (first g)) vals)
			   (setf (first g) (red (first g))))))							   (setf (first g) (red (first g))))))
		   (setq coef (interpolate-from-skel skel init-pt					   (setq coef (interpolate-from-skel skel init-pt
							  (reverse vals) vars))									  (reverse vals) vars))
		   (unless (poly-0? coef)								   (unless (poly-0? coef)
		     (push (cons e coef) ans)))								     (push (cons e coef) ans)))
	  (check-degree (nreverse ans))))))							  (check-degree (nreverse ans))))))
													
(defun eval-monomial (exps vals)							(defun eval-monomial (exps vals)
  (let ((ans (expt (first vals) (first exps))))						  (let ((ans (expt (first vals) (first exps))))
    (loop for e in (rest exps)								    (loop for e in (rest exps)
	  for val in (rest vals)								  for val in (rest vals)
	  do (setq ans (* ans (expt val e))))							  do (setq ans (* ans (expt val e))))
    ans))										    ans))

(defun interpolate-from-skel (skel init-pt vals vars)					(defun interpolate-from-skel (skel init-pt vals vars)
  (let* ((pts (loop for term in skel							  (let* ((pts (loop for term in skel
		    collect (eval-monomial term init-pt)))						    collect (eval-monomial term init-pt)))
	 (coefs (solve-vandermondetd pts vals))							 (coefs (solve-vandermondetd pts vals))
	 (ans (zero *coefficient-domain*))							 (ans (zero *coefficient-domain*))
	 (one (one *coefficient-domain*)))							 (one (one *coefficient-domain*)))
    (labels ((make-monomial (c exp vars)						    (labels ((make-monomial (c exp vars)
	       (cond ((null exp)								       (cond ((null exp)
		      c)										      c)
		     ((null vars)									     ((null vars)
		      (error "Not enough variables"))							      (error "Not enough variables"))
		     ((e0? (first exp))									     ((e0? (first exp))
		      (make-monomial c (rest exp) (rest vars)))						      (make-monomial c (rest exp) (rest vars)))
		     (t (poly-times (poly-simp (first vars)						     (t (poly-times (poly-simp (first vars)
					       (make-terms (first exp) one))							       (make-terms (first exp) one))
				    (make-monomial c (rest exp) (rest vars)))))))					    (make-monomial c (rest exp) (rest vars)))))))
      (loop for exps in skel								      (loop for exps in skel
	    for c in coefs									    for c in coefs
	    do (unless (poly-0? c)								    do (unless (poly-0? c)
		 (setq ans (poly-plus ans (make-monomial c exps vars)))))				 (setq ans (poly-plus ans (make-monomial c exps vars)))))
      ans)))										      ans)))


(defun dense-interpolate-coefficients (poly-list vals var)				(defun dense-interpolate-coefficients (poly-list vals var)
  (with-linear-support									  (with-linear-support
    (let ((ans zero) this-var terms-list degree)					    (let ((ans zero) this-var terms-list degree)
      (loop for poly in poly-list do							      (loop for poly in poly-list do
	(cond ((poly-coef? poly))								(cond ((poly-coef? poly))
	      ((or (null this-var)								      ((or (null this-var)
		   (more-main? poly this-var))								   (more-main? poly this-var))
	       (setq this-var poly))))								       (setq this-var poly))))
      (cond ((null this-var)    							      (cond ((null this-var)    
	     ;; Everything is constant at this point, so we can do the dense			     ;; Everything is constant at this point, so we can do the dense
	     ;; interpolation and return							     ;; interpolation and return
	     (poly-interpolate var vals poly-list))						     (poly-interpolate var vals poly-list))
	    (t 											    (t 
	     ;; Find the maximum degree that appears and turn everything into a 		     ;; Find the maximum degree that appears and turn everything into a 
	     ;; list of terms									     ;; list of terms
	     (loop for poly in poly-list							     (loop for poly in poly-list
		   do (push (cond ((poly-coef? poly)							   do (push (cond ((poly-coef? poly)
				   (make-terms (e0) poly))								   (make-terms (e0) poly))
				  ((null degree)									  ((null degree)
				   (setq degree (le (poly-terms poly)))							   (setq degree (le (poly-terms poly)))
				   (setq this-var poly)									   (setq this-var poly)
				   (poly-terms poly))									   (poly-terms poly))
				  ((same-variable? this-var poly)							  ((same-variable? this-var poly)
				   (setq degree (max degree (le (poly-terms poly))					   (setq degree (max degree (le (poly-terms poly))
				   (poly-terms poly)))									   (poly-terms poly)))
			    terms-list))									    terms-list))
	     (setq terms-list (reverse terms-list))						     (setq terms-list (reverse terms-list))

	     ;; Now work down the list of terms and recurse					     ;; Now work down the list of terms and recurse
	     (loop for deg downfrom degree							     (loop for deg downfrom degree
		   with sub-polys									   with sub-polys
		   while (not (eminus? deg))								   while (not (eminus? deg))
		   do (setq sub-polys nil) 								   do (setq sub-polys nil) 
		      (loop for terms on terms-list do							      (loop for terms on terms-list do
			(cond ((null (first terms))								(cond ((null (first terms))
			       (push zero sub-polys))								       (push zero sub-polys))
			      ((e= (le (first terms)) deg)							      ((e= (le (first terms)) deg)
			       (push (lc (first terms)) sub-polys)						       (push (lc (first terms)) sub-polys)
			       (setf (first terms) (red (first terms))))					       (setf (first terms) (red (first terms))))
			      (t (push zero sub-polys))))							      (t (push zero sub-polys))))
		      (setq ans (poly-plus								      (setq ans (poly-plus
				 (poly-times (dense-interpolate-coefficients						 (poly-times (dense-interpolate-coefficients
					      (reverse sub-polys) vals var)							      (reverse sub-polys) vals var)
					     (poly-simp this-var (make-terms deg o						     (poly-simp this-var (make-terms deg o
				     ans)))										     ans)))
	     ans)))))										     ans)))))

    											    
;;; GCD of univariate polynomials over a finite field.					;;; GCD of univariate polynomials over a finite field.
(defun poly-gcdu (p q)									(defun poly-gcdu (p q)
  (cond ((or (poly-coef? p) (poly-coef? q))						  (cond ((or (poly-coef? p) (poly-coef? q))
	 (one *coefficient-domain*))								 (one *coefficient-domain*))
	((same-variable? p q)									((same-variable? p q)
	 (poly-simp p (terms-gcdu (poly-terms p) (poly-terms q))))				 (poly-simp p (terms-gcdu (poly-terms p) (poly-terms q))))
	(t (error "Must be same main variable"))))						(t (error "Must be same main variable"))))

(defun terms-gcdu (pt qt)								(defun terms-gcdu (pt qt)
  (do ()										  (do ()
      ((terms0? qt)									      ((terms0? qt)
       (if (e0? (le pt))								       (if (e0? (le pt))
	   (make-terms (e0) (one *coefficient-domain*))						   (make-terms (e0) (one *coefficient-domain*))
	   (terms-monicize pt)))								   (terms-monicize pt)))
    (psetq pt qt									    (psetq pt qt
	   qt (terms-pseudo-remainder pt qt))))							   qt (terms-pseudo-remainder pt qt))))

(defun terms-gcdu+ (lc pt qt)								(defun terms-gcdu+ (lc pt qt)
  (terms-mon-times (terms-gcdu pt qt) (e0) lc))						  (terms-mon-times (terms-gcdu pt qt) (e0) lc))

;;;  Testing functions									;;;  Testing functions

#+Testing										#+Testing
(defun random-poly (domain degree vars)							(defun random-poly (domain degree vars)
  (labels ((random-poly1 (vars)								  (labels ((random-poly1 (vars)
	     (if (null vars) (random domain)							     (if (null vars) (random domain)
		 (poly-simp vars									 (poly-simp vars
		   (loop for i downfrom degree								   (loop for i downfrom degree
			 with c											 with c
			 while (not (cl:minusp i))								 while (not (cl:minusp i))
			 when (and (cl:zerop (cl:random 2))							 when (and (cl:zerop (cl:random 2))
				   (not (poly-0?									   (not (poly-0?
					 (setq c (random-poly1 (rest vars))))))							 (setq c (random-poly1 (rest vars))))))
			   collect (cons i c))))))								   collect (cons i c))))))
    (random-poly1 vars)))								    (random-poly1 vars)))

#+Testing										#+Testing
(defun random-poly (degree vars terms)							(defun random-poly (degree vars terms)
  (let ((one (one *coefficient-domain*))						  (let ((one (one *coefficient-domain*))
	(ans (zero *coefficient-domain*)))							(ans (zero *coefficient-domain*)))
    (labels ((random-monomial (vars)							    (labels ((random-monomial (vars)
	       (if (null vars) (one *coefficient-domain*)					       (if (null vars) (one *coefficient-domain*)
		                ;; (random *coefficient-domain*)					                ;; (random *coefficient-domain*)
		   (poly-times										   (poly-times
		    (random-monomial (rest vars))							    (random-monomial (rest vars))
		    (poly-simp vars									    (poly-simp vars
			       (make-terms (cl:random degree) one))))))						       (make-terms (cl:random degree) one))))))
      (loop for i below terms								      (loop for i below terms
	    do (setq ans (poly-plus ans (random-monomial vars))))				    do (setq ans (poly-plus ans (random-monomial vars))))
      ans)))										      ans)))

#+Testing										#+Testing
(defun initialize-pq (n deg terms)							(defun initialize-pq (n deg terms)
  (let ((vars (loop for i below n collect i)))						  (let ((vars (loop for i below n collect i)))
    (flet ((rand-poly ()								    (flet ((rand-poly ()
	     (random-poly deg vars terms)							     (random-poly deg vars terms)
	     #+Ignore										     #+Ignore
	     (poly-plus `(0 (,(+ 1 deg) . ,(one *coefficient-domain*)))				     (poly-plus `(0 (,(+ 1 deg) . ,(one *coefficient-domain*)))
			(random-poly deg vars terms))))								(random-poly deg vars terms))))
      (setq g (rand-poly))								      (setq g (rand-poly))
      (setq p (poly-times g (rand-poly)))						      (setq p (poly-times g (rand-poly)))
      (setq q (poly-times g (rand-poly))))))						      (setq q (poly-times g (rand-poly))))))


;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-		;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-
;;; ===========================================================================		;;; ===========================================================================
;;;		       Taylor Expansions						;;;		       Taylor Expansions
;;; ===========================================================================		;;; ===========================================================================
;;; (c) Copyright 1994 Cornell University						;;; (c) Copyright 1994 Cornell University

 											 
(in-package "WEYLI")								    |	(in-package :weyli)

(make::adjust-version-numbers Weyl "1.7")					    |	;;; DELETE (make::adjust-version-numbers Weyl "1.7")

(defmacro define-taylor-expansion-fun (name (domain order) &body body)			(defmacro define-taylor-expansion-fun (name (domain order) &body body)
  (let ((maker-name (intern (format nil "TAYLOR-~A" name))))				  (let ((maker-name (intern (format nil "TAYLOR-~A" name))))
       `(progn										       `(progn
	  (defun ,maker-name (,domain ,order) ,@body)						  (defun ,maker-name (,domain ,order) ,@body)
	  (setf (getf (get-function nil ',name) 'taylor-expansion-fun)				  (setf (getf (get-function nil ',name) 'taylor-expansion-fun)
		',maker-name))))									',maker-name))))

(define-taylor-expansion-fun SIN (domain order)						(define-taylor-expansion-fun SIN (domain order)
  (let ((coeffs))									  (let ((coeffs))
       (loop for i from 1 to order							       (loop for i from 1 to order
	     if (evenp i) do (setq coeffs (append coeffs (list 0)))				     if (evenp i) do (setq coeffs (append coeffs (list 0)))
	       else do (setq coeffs								       else do (setq coeffs
			     (append coeffs									     (append coeffs
				     (list (cl:* (cl:expt -1 (cl:/ (cl:- i 1) 2))					     (list (cl:* (cl:expt -1 (cl:/ (cl:- i 1) 2))
						 (cl:/ 1 (factorial i))))))								 (cl:/ 1 (factorial i))))))
	     finally										     finally
	  (return (make-tpower-series domain coeffs :valence 1 :order order)))))		  (return (make-tpower-series domain coeffs :valence 1 :order order)))))

(define-taylor-expansion-fun COS (domain order)						(define-taylor-expansion-fun COS (domain order)
  (let ((coeffs))									  (let ((coeffs))
       (loop for i from 0 to order       						       (loop for i from 0 to order       
	     if (oddp i) do (setq coeffs (append coeffs (list 0)))				     if (oddp i) do (setq coeffs (append coeffs (list 0)))
	       else do (setq coeffs (append coeffs						       else do (setq coeffs (append coeffs
					    (list (cl:* (cl:expt -1 (cl:/ i 2))							    (list (cl:* (cl:expt -1 (cl:/ i 2))
							(cl:/ 1 (factorial i))))))								(cl:/ 1 (factorial i))))))
	     finally										     finally
	  (return (make-tpower-series domain coeffs :order order)))))				  (return (make-tpower-series domain coeffs :order order)))))
	    											    
(define-taylor-expansion-fun TAN (domain order)						(define-taylor-expansion-fun TAN (domain order)
  (taylor (/ (sin (ring-variables domain))						  (taylor (/ (sin (ring-variables domain))
	     (cos (ring-variables domain)))							     (cos (ring-variables domain)))
	  domain order))									  domain order))

(define-taylor-expansion-fun LOG (domain order)						(define-taylor-expansion-fun LOG (domain order)
  (let ((coeffs))									  (let ((coeffs))
       (loop for i from 1 to order       						       (loop for i from 1 to order       
	     do (setq coeffs (append coeffs							     do (setq coeffs (append coeffs
				     (list (cl:* (cl:expt -1 (cl:- i 1))						     (list (cl:* (cl:expt -1 (cl:- i 1))
						 (cl:/ 1 i)))))										 (cl:/ 1 i)))))
	     finally										     finally
	  (return (make-tpower-series domain coeffs :valence 1 :order order)))))		  (return (make-tpower-series domain coeffs :valence 1 :order order)))))

(define-taylor-expansion-fun ASIN (domain order)					(define-taylor-expansion-fun ASIN (domain order)
  (let ((coeffs))									  (let ((coeffs))
       (loop for i from 1 to order              					       (loop for i from 1 to order              
	     if (evenp i) do (setq coeffs (append coeffs (list 0)))				     if (evenp i) do (setq coeffs (append coeffs (list 0)))
	       else do (let ((temp-coeff 1))							       else do (let ((temp-coeff 1))
			    (loop for j from 1 below i								    (loop for j from 1 below i
				  if (oddp j) do									  if (oddp j) do
				    (setq temp-coeff (cl:* temp-coeff j))						    (setq temp-coeff (cl:* temp-coeff j))
				  else do										  else do
				    (setq temp-coeff (cl:/ temp-coeff j))						    (setq temp-coeff (cl:/ temp-coeff j))
				  finally										  finally
			       (setq coeffs (append coeffs (list (cl:* temp-coeff				       (setq coeffs (append coeffs (list (cl:* temp-coeff
								    (cl:/ 1 i)))))									    (cl:/ 1 i)))))
	     finally										     finally
	  (return (make-tpower-series domain coeffs :valence 1 :order order)))))		  (return (make-tpower-series domain coeffs :valence 1 :order order)))))
		     											     
(define-taylor-expansion-fun SINH (domain order)					(define-taylor-expansion-fun SINH (domain order)
  (let ((coeffs))									  (let ((coeffs))
       (loop for i from 1 to order							       (loop for i from 1 to order
	     if (evenp i) do (setq coeffs (append coeffs (list 0)))				     if (evenp i) do (setq coeffs (append coeffs (list 0)))
	       else do (setq coeffs (append coeffs (list (cl:/ 1 (factorial i)))))		       else do (setq coeffs (append coeffs (list (cl:/ 1 (factorial i)))))
	     finally										     finally
	  (return (make-tpower-series domain coeffs :valence 1 :order order)))))		  (return (make-tpower-series domain coeffs :valence 1 :order order)))))

(define-taylor-expansion-fun COSH (domain order)					(define-taylor-expansion-fun COSH (domain order)
  (let ((coeffs))									  (let ((coeffs))
       (loop for i from 0 to order							       (loop for i from 0 to order
	     if (oddp i) do (setq coeffs (append coeffs (list 0)))				     if (oddp i) do (setq coeffs (append coeffs (list 0)))
	       else do (setq coeffs (append coeffs (list (cl:/ 1 (factorial i)))))		       else do (setq coeffs (append coeffs (list (cl:/ 1 (factorial i)))))
	  finally										  finally
       (return (make-tpower-series domain coeffs :order order)))))			       (return (make-tpower-series domain coeffs :order order)))))

(define-taylor-expansion-fun TANH (domain order)					(define-taylor-expansion-fun TANH (domain order)
  (taylor (/ (sinh (ring-variables domain))						  (taylor (/ (sinh (ring-variables domain))
	     (cosh (ring-variables domain)))							     (cosh (ring-variables domain)))
	  domain order))									  domain order))

(define-taylor-expansion-fun ASINH (domain order)					(define-taylor-expansion-fun ASINH (domain order)
  (let ((coeffs))									  (let ((coeffs))
       (loop for i from 1 to order              					       (loop for i from 1 to order              
	     if (evenp i) do									     if (evenp i) do
	       (setq coeffs (append coeffs (list 0)))						       (setq coeffs (append coeffs (list 0)))
	     else do										     else do
	       (let ((temp-coeff 1))								       (let ((temp-coeff 1))
		    (loop for j from 1 below i								    (loop for j from 1 below i
			  if (oddp j) do									  if (oddp j) do
			    (setq temp-coeff (cl:* temp-coeff j))						    (setq temp-coeff (cl:* temp-coeff j))
			  else do										  else do
			    (setq temp-coeff (cl:/ temp-coeff j))						    (setq temp-coeff (cl:/ temp-coeff j))
			  finally										  finally
		       (setq coeffs									       (setq coeffs
			     (append coeffs									     (append coeffs
				     (list (cl:* (cl:expt -1 (cl:/ (cl:- i 1) 2))					     (list (cl:* (cl:expt -1 (cl:/ (cl:- i 1) 2))
						 (cl:* temp-coeff									 (cl:* temp-coeff
						       (cl:/ 1 i))))))))								       (cl:/ 1 i))))))))
	     finally										     finally
	  (return (make-tpower-series domain coeffs :valence 1 :order order)))))		  (return (make-tpower-series domain coeffs :valence 1 :order order)))))

(defun TAYLOR-EXP (domain order)							(defun TAYLOR-EXP (domain order)
  (let ((coeffs))									  (let ((coeffs))
       (loop for i from 0 to order							       (loop for i from 0 to order
	     do (setq coeffs (append coeffs (list (cl:/ 1 (factorial i)))))			     do (setq coeffs (append coeffs (list (cl:/ 1 (factorial i)))))
	     finally										     finally
	  (return (make-tpower-series domain coeffs :order order)))))				  (return (make-tpower-series domain coeffs :order order)))))

(defmethod substitute (value (variable symbol) (tp tpower-series)			(defmethod substitute (value (variable symbol) (tp tpower-series)
			     &rest ignore)									     &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (substitute value (coerce variable *general*) tp))					  (substitute value (coerce variable *general*) tp))

(defmethod substitute ((value tpower-series) (variable ge-variable)			(defmethod substitute ((value tpower-series) (variable ge-variable)
		       (tp tpower-series) &rest ignore)							       (tp tpower-series) &rest ignore)
  (declare (ignore ignore))  								  (declare (ignore ignore))  
  (cond ((not (ge-equal variable (ring-variables (domain-of tp))))			  (cond ((not (ge-equal variable (ring-variables (domain-of tp))))
	 (error "Can not substitute for ~A in ~A." variable (domain-of tp)))			 (error "Can not substitute for ~A in ~A." variable (domain-of tp)))
	((not (plusp (valence value)))								((not (plusp (valence value)))
	 (error "Can not substitute ~S for ~A in ~A." value variable tp))			 (error "Can not substitute ~S for ~A in ~A." value variable tp))
	(t (let ((result (zero (domain-of value)))						(t (let ((result (zero (domain-of value)))
		 (one (one (domain-of value))))								 (one (one (domain-of value))))
	     (with-tpower-series ((tp tp))							     (with-tpower-series ((tp tp))
	       (declare (ignore tp-bo tp-order))						       (declare (ignore tp-bo tp-order))
	       (loop for exp from (valence tp)							       (loop for exp from (valence tp)
		     until (>= (- exp tp-val)								     until (>= (- exp tp-val)
				      (array-dimension tp-coeffs 0))							      (array-dimension tp-coeffs 0))
		     do (setq result (+ result								     do (setq result (+ result
				       (* (coerce (aref tp-coeffs							       (* (coerce (aref tp-coeffs
							(- exp tp-val))										(- exp tp-val))
						  (domain-of value))									  (domain-of value))
					  (if (= exp 0) one									  (if (= exp 0) one
					      (expt value exp)))))))								      (expt value exp)))))))
		result))))										result))))

										    >	(defgeneric taylor (exp domain order)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod taylor (exp (domain tpower-series-domain) order)				(defmethod taylor (exp (domain tpower-series-domain) order)
  (taylor1 (coerce exp *general*) domain order))					  (taylor1 (coerce exp *general*) domain order))
										    >
										    >	(defgeneric taylor1 (exp domain order)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))

(defmethod taylor1 ((exp ge-variable) (domain tpower-series-domain) order)		(defmethod taylor1 ((exp ge-variable) (domain tpower-series-domain) order)
  (cond ((ge-equal exp (ring-variables domain))						  (cond ((ge-equal exp (ring-variables domain))
	 (make-tpower-series domain 1 :valence 1 :order order))					 (make-tpower-series domain 1 :valence 1 :order order))
	(t (make-tpower-series domain (coerce exp (coefficient-domain-of domain))		(t (make-tpower-series domain (coerce exp (coefficient-domain-of domain))
					    :order order))))									    :order order))))

(defmethod taylor1 ((exp ge-plus) (domain tpower-series-domain) order)			(defmethod taylor1 ((exp ge-plus) (domain tpower-series-domain) order)
  (let ((sum (zero domain)))								  (let ((sum (zero domain)))
       (loop for x in (terms-of exp)							       (loop for x in (terms-of exp)
	     do (setq sum (+ sum (taylor1 x domain order))))					     do (setq sum (+ sum (taylor1 x domain order))))
       sum))										       sum))

(defmethod taylor1 ((exp ge-times) (domain tpower-series-domain) order)			(defmethod taylor1 ((exp ge-times) (domain tpower-series-domain) order)
  (let ((new-valence 0)									  (let ((new-valence 0)
	(max-valence 0)										(max-valence 0)
	(new-order order)									(new-order order)
	(prod (taylor1 1 domain order))								(prod (taylor1 1 domain order))
	(temp))											(temp))
       (loop for x in (terms-of exp)							       (loop for x in (terms-of exp)
	     do (setq temp (taylor1 x domain order))						     do (setq temp (taylor1 x domain order))
		(setq prod (* prod temp))								(setq prod (* prod temp))
		(if (> (valence temp) max-valence)							(if (> (valence temp) max-valence)
		    (setq max-valence (valence temp)))							    (setq max-valence (valence temp)))
		(setq new-valence (+ new-valence (valence temp))))					(setq new-valence (+ new-valence (valence temp))))
       (setq new-order (+ new-order (- max-valence new-valence)))			       (setq new-order (+ new-order (- max-valence new-valence)))
       (if (= new-order order)								       (if (= new-order order)
	   prod											   prod
	   (let ((prod (taylor1 1 domain new-order)))						   (let ((prod (taylor1 1 domain new-order)))
		(loop for x in (terms-of exp)								(loop for x in (terms-of exp)
		      do (setq prod (* prod (taylor1 x domain new-order))))				      do (setq prod (* prod (taylor1 x domain new-order))))
		prod))))										prod))))

(defmethod taylor1 ((exp ge-expt) (domain tpower-series-domain) order)			(defmethod taylor1 ((exp ge-expt) (domain tpower-series-domain) order)
  (let ((temp (taylor1 (base-of exp) domain order))					  (let ((temp (taylor1 (base-of exp) domain order))
	(exponent (coerce (exponent-of exp) *general*)))					(exponent (coerce (exponent-of exp) *general*)))
       (if (= (valence temp) 0)								       (if (= (valence temp) 0)
	   (expt temp exponent)									   (expt temp exponent)
	   (let ((new-order))									   (let ((new-order))
		(cond											(cond
		  ((typep exponent 'rational-integer)							  ((typep exponent 'rational-integer)
		   (setq new-order (+ order (* (- 1 (integer-value exponent))				   (setq new-order (+ order (* (- 1 (integer-value exponent))
						  (valence temp)))))									  (valence temp)))))
		  ((typep exponent 'rational-number)							  ((typep exponent 'rational-number)
		   (let* ((new-br (lcm (denominator exponent)						   (let* ((new-br (lcm (denominator exponent)
				       (branch-order temp)))								       (branch-order temp)))
			  (factor-old (/ new-br (branch-order temp)))						  (factor-old (/ new-br (branch-order temp)))
			  (factor-new (/ new-br (denominator exponent))))					  (factor-new (/ new-br (denominator exponent))))
			 (setq new-order (+ (ceiling								 (setq new-order (+ (ceiling
					      (/ (- (* order new-br)								      (/ (- (* order new-br)
						    (* factor-new									    (* factor-new
						       (numerator exponent)								       (numerator exponent)
						       (valence temp)))									       (valence temp)))
						 factor-old))										 factor-old))
					      (valence temp)))))								      (valence temp)))))
		  (t (error "can not raise ~s to ~s" (base-of exp) exponent)))				  (t (error "can not raise ~s to ~s" (base-of exp) exponent)))
		(expt (taylor1 (base-of exp) domain new-order) exponent)))))				(expt (taylor1 (base-of exp) domain new-order) exponent)))))

(defmethod taylor1 ((exp ge-application) (domain tpower-series-domain) order)		(defmethod taylor1 ((exp ge-application) (domain tpower-series-domain) order)
  (if (get-function nil (name-of (funct-of exp)))					  (if (get-function nil (name-of (funct-of exp)))
      (let ((arg (car (args-of exp))))							      (let ((arg (car (args-of exp))))
	   (if (string= (name-of (funct-of exp)) "log")						   (if (string= (name-of (funct-of exp)) "log")
	       (setq arg (- arg 1)))								       (setq arg (- arg 1)))
	   (if (ge-equal arg (ring-variables domain))						   (if (ge-equal arg (ring-variables domain))
	       (apply (getf (funct-of exp) 'taylor-expansion-fun)				       (apply (getf (funct-of exp) 'taylor-expansion-fun)
		      (list domain order))								      (list domain order))
	       (substitute (taylor1 arg domain order)						       (substitute (taylor1 arg domain order)
			   (ring-variables domain)								   (ring-variables domain)
			   (apply (getf (funct-of exp) 'taylor-expansion-fun)					   (apply (getf (funct-of exp) 'taylor-expansion-fun)
				  (list domain order)))))								  (list domain order)))))
      (let ((tp (get-default-taylor-expansion domain)))					      (let ((tp (get-default-taylor-expansion domain)))
	   (if (typep (funct-of exp) 'ge-function-deriv)					   (if (typep (funct-of exp) 'ge-function-deriv)
	       (loop for i in (derivs-of (funct-of exp))					       (loop for i in (derivs-of (funct-of exp))
		     do (setq tp (deriv tp (nth i (args-of exp))))))					     do (setq tp (deriv tp (nth i (args-of exp))))))
	   tp)))										   tp)))

(defmethod taylor1 (exp (domain tpower-series-domain) order)				(defmethod taylor1 (exp (domain tpower-series-domain) order)
  (let ((value (coercible? exp (coefficient-domain-of domain))))			  (let ((value (coercible? exp (coefficient-domain-of domain))))
    (cond ((not (null value))								    (cond ((not (null value))
	   (make-tpower-series domain value :order order))					   (make-tpower-series domain value :order order))
	  (t (error "don't know how to coerce ~s to be an element of ~s"			  (t (error "don't know how to coerce ~s to be an element of ~s"
		    exp domain)))))									    exp domain)))))

(defmethod plus ((tp tpower-series) (exp general-expression))				(defmethod plus ((tp tpower-series) (exp general-expression))
  (+ tp (taylor1 exp (domain-of tp) (order tp))))					  (+ tp (taylor1 exp (domain-of tp) (order tp))))

(defmethod plus ((exp general-expression) (tp tpower-series))				(defmethod plus ((exp general-expression) (tp tpower-series))
  (+ tp exp))										  (+ tp exp))

(defmethod difference ((tp tpower-series) (exp general-expression))			(defmethod difference ((tp tpower-series) (exp general-expression))
  (- tp (taylor1 exp (domain-of tp) (order tp))))					  (- tp (taylor1 exp (domain-of tp) (order tp))))

(defmethod difference ((exp general-expression) (tp tpower-series))			(defmethod difference ((exp general-expression) (tp tpower-series))
  (- (taylor1 exp (domain-of tp) (order tp)) tp))					  (- (taylor1 exp (domain-of tp) (order tp)) tp))

(defmethod times ((tp tpower-series) (exp general-expression))				(defmethod times ((tp tpower-series) (exp general-expression))
  (let ((temp (taylor1 exp (domain-of tp) (order tp))))					  (let ((temp (taylor1 exp (domain-of tp) (order tp))))
       (if (= (- (valence temp) (valence tp)) 0)					       (if (= (- (valence temp) (valence tp)) 0)
	   (* tp temp)										   (* tp temp)
	   (* tp (taylor1 exp (domain-of tp) (+ (- (order tp) (valence tp))			   (* tp (taylor1 exp (domain-of tp) (+ (- (order tp) (valence tp))
						(valence temp)))))))									(valence temp)))))))

(defmethod times ((exp general-expression) (tp tpower-series))				(defmethod times ((exp general-expression) (tp tpower-series))
  (* tp exp))										  (* tp exp))

(defmethod quotient ((tp tpower-series) (exp general-expression))			(defmethod quotient ((tp tpower-series) (exp general-expression))
  (* tp (expt exp -1)))									  (* tp (expt exp -1)))

(defmethod quotient ((exp general-expression) (tp tpower-series))			(defmethod quotient ((exp general-expression) (tp tpower-series))
  (* (expt exp -1) tp))									  (* (expt exp -1) tp))
(in-package :weyli)									(in-package :weyli)

(defun get-default-taylor-expansion (power-series-domain)				(defun get-default-taylor-expansion (power-series-domain)
    (let* ((temp-ring (coefficient-domain-of power-series-domain))			    (let* ((temp-ring (coefficient-domain-of power-series-domain))
	   (coef-ring (if (typep temp-ring 'rational-function-field)				   (coef-ring (if (typep temp-ring 'rational-function-field)
			      (QF-ring temp-ring)								      (QF-ring temp-ring)
			      temp-ring))   									      temp-ring))   
	   (ring-vars (ring-variables coef-ring)))						   (ring-vars (ring-variables coef-ring)))
	  (make-tpower-series power-series-domain						  (make-tpower-series power-series-domain
			      (mapcar #'(lambda (x) (coerce x coef-ring))					      (mapcar #'(lambda (x) (coerce x coef-ring))
				      ring-vars)									      ring-vars)
			      :order (length ring-vars))))							      :order (length ring-vars))))

(defmethod deriv ((tp tpower-series) &rest vars)					(defmethod deriv ((tp tpower-series) &rest vars)
  (loop for v in vars									  (loop for v in vars
	with tp-var = (ring-variables (domain-of tp))						with tp-var = (ring-variables (domain-of tp))
	do (setq tp (if (ge-equal (coerce v *general*) tp-var)					do (setq tp (if (ge-equal (coerce v *general*) tp-var)
			(tps-deriv1 tp)										(tps-deriv1 tp)
			(tps-deriv2 tp v))))									(tps-deriv2 tp v))))
  tp)											  tp)


;; Computes the derivative with respect to the power series variable.			;; Computes the derivative with respect to the power series variable.
(defun tps-deriv1 (a)									(defun tps-deriv1 (a)
  (with-tpower-series ((a a))								  (with-tpower-series ((a a))
    (let* ((domain (domain-of a))							    (let* ((domain (domain-of a))
	   (zero (zero (coefficient-domain-of domain)))						   (zero (zero (coefficient-domain-of domain)))
	   (n-terms (cl:- a-order a-val -1))							   (n-terms (cl:- a-order a-val -1))
	   coeffs)										   coeffs)

      (setq coeffs (make-array n-terms :initial-element zero))				      (setq coeffs (make-array n-terms :initial-element zero))

      (loop for i below n-terms								      (loop for i below n-terms
	    do (setf (svref coeffs i)								    do (setf (svref coeffs i)
		     (* (svref a-coeffs i) (+ a-val (/ i a-bo)))))					     (* (svref a-coeffs i) (+ a-val (/ i a-bo)))))
      (multiple-value-bind (ncoeffs shift) (trim-zeroes coeffs)				      (multiple-value-bind (ncoeffs shift) (trim-zeroes coeffs)
	(make-tpower-series domain ncoeffs							(make-tpower-series domain ncoeffs
			    :valence (cl:+ a-val shift (cl:- a-bo))						    :valence (cl:+ a-val shift (cl:- a-bo))
			    :order (cl:- a-order a-bo)								    :order (cl:- a-order a-bo)
			    :branch-order a-bo)))))								    :branch-order a-bo)))))

;; The coefficients are to be differentiated						;; The coefficients are to be differentiated
(defun tps-deriv2 (a var)								(defun tps-deriv2 (a var)
  (with-tpower-series ((a a))								  (with-tpower-series ((a a))
    (let* ((domain (domain-of a))							    (let* ((domain (domain-of a))
	   (zero (zero (coefficient-domain-of domain)))						   (zero (zero (coefficient-domain-of domain)))
	   (n-terms (cl:- a-order a-val -1))							   (n-terms (cl:- a-order a-val -1))
	   coeffs)										   coeffs)

      (setq coeffs (make-array n-terms :initial-element zero))				      (setq coeffs (make-array n-terms :initial-element zero))

      (loop for i below n-terms								      (loop for i below n-terms
	    do (setf (svref coeffs i) (deriv (svref a-coeffs i) var)))				    do (setf (svref coeffs i) (deriv (svref a-coeffs i) var)))
      (multiple-value-bind (ncoeffs shift) (trim-zeroes coeffs)				      (multiple-value-bind (ncoeffs shift) (trim-zeroes coeffs)
	(make-tpower-series domain ncoeffs							(make-tpower-series domain ncoeffs
			    :valence (cl:+ a-val shift -1)							    :valence (cl:+ a-val shift -1)
			    :order a-order									    :order a-order
			    :branch-order a-bo)))))								    :branch-order a-bo)))))

(defmethod reversion ((tp tpower-series))						(defmethod reversion ((tp tpower-series))
  (if (/= 1 (valence tp))								  (if (/= 1 (valence tp))
      (error "Can't compute reversion if valence is not 1")				      (error "Can't compute reversion if valence is not 1")
      (let* ((domain (get-matrix-space (coefficient-domain-of (domain-of tp))))		      (let* ((domain (get-matrix-space (coefficient-domain-of (domain-of tp))))
	    (rank (length (coeffs tp)))								    (rank (length (coeffs tp)))
	    (array (make-array (list rank rank)))						    (array (make-array (list rank rank)))
	    (zero (zero (coefficient-domain-of (domain-of tp))))				    (zero (zero (coefficient-domain-of (domain-of tp))))
	    (temp-tp tp))									    (temp-tp tp))
	   (loop for i from 0 below rank do							   (loop for i from 0 below rank do
	     (loop for k from 0 below i do							     (loop for k from 0 below i do
	       (setf (aref array i k) zero))							       (setf (aref array i k) zero))
	     (loop for j from i below rank do							     (loop for j from i below rank do
	       (setf (aref array i j) (aref (coeffs temp-tp) (- j i))))				       (setf (aref array i j) (aref (coeffs temp-tp) (- j i))))
	     (setq temp-tp (* temp-tp tp)))							     (setq temp-tp (* temp-tp tp)))
	   (setq array (make-element domain array))						   (setq array (make-element domain array))
	   (setq array (recip array))								   (setq array (recip array))
	   (make-tpower-series (domain-of tp)							   (make-tpower-series (domain-of tp)
			       (loop for j from 0 below rank							       (loop for j from 0 below rank
				     collect (ref array 0 j))								     collect (ref array 0 j))
			       :valence 1									       :valence 1
			       :order (order tp)))))								       :order (order tp)))))

(defmethod solve-for-coeffs (coef-poly (domain rational-function-field)			(defmethod solve-for-coeffs (coef-poly (domain rational-function-field)
				       coef-list value-list)								       coef-list value-list)
  (let ((cur-var (nth (length value-list) coef-list)))					  (let ((cur-var (nth (length value-list) coef-list)))
       (quotient-reduce									       (quotient-reduce
	  domain										  domain
	  (- (coefficient (numerator coef-poly) (numerator cur-var) 0))				  (- (coefficient (numerator coef-poly) (numerator cur-var) 0))
	  (coefficient (numerator coef-poly) (numerator cur-var) 1))))				  (coefficient (numerator coef-poly) (numerator cur-var) 1))))

(defmethod solve-for-coeffs (coef-poly domain coef-list value-list)			(defmethod solve-for-coeffs (coef-poly domain coef-list value-list)
  (declare (ignore domain))								  (declare (ignore domain))
  (let ((cur-var (nth (length value-list) coef-list)))					  (let ((cur-var (nth (length value-list) coef-list)))
	  (/ (- (coefficient coef-poly cur-var 0))						  (/ (- (coefficient coef-poly cur-var 0))
	     (coefficient coef-poly cur-var 1))))						     (coefficient coef-poly cur-var 1))))

;; diff-eqn is a differential-equation given as a general-expression			;; diff-eqn is a differential-equation given as a general-expression
;; The solution of diff-eqn is assumed to be of the form				;; The solution of diff-eqn is assumed to be of the form
;;   a0 + a1 t + a2 t^2 + ... + an t^n							;;   a0 + a1 t + a2 t^2 + ... + an t^n
;; where "ai" are in the coef-ring, 't' is the variable and 'n' is the			;; where "ai" are in the coef-ring, 't' is the variable and 'n' is the
;; order. The ai's are obtained using the initial value list "init-list"		;; order. The ai's are obtained using the initial value list "init-list"
;; containing (a0, a1, ..., aj) where 'j' is the order of the				;; containing (a0, a1, ..., aj) where 'j' is the order of the
;; differential equation.								;; differential equation.
#+ignore										#+ignore
(defmethod solve-diff-eqn ((diff-eqn general-expression)				(defmethod solve-diff-eqn ((diff-eqn general-expression)
			   coef-ring variable order init-list)							   coef-ring variable order init-list)
  (let* ((order (+ order 1))								  (let* ((order (+ order 1))
	 (new-coefs (loop for i in init-list							 (new-coefs (loop for i in init-list
			  if (not (coercible? i coef-ring)) collect i))						  if (not (coercible? i coef-ring)) collect i))
	 (coef-ring (if (null new-coefs) coef-ring						 (coef-ring (if (null new-coefs) coef-ring
			  (get-polynomial-ring coef-ring new-coefs)))						  (get-polynomial-ring coef-ring new-coefs)))
	 (domain (get-quotient-field								 (domain (get-quotient-field
		   (get-polynomial-ring coef-ring							   (get-polynomial-ring coef-ring
			 (loop for i from 0 below order								 (loop for i from 0 below order
			       collect (intern (format nil ".a~A" i))))))					       collect (intern (format nil ".a~A" i))))))
	 (power-series-domain (get-tpower-series-domain domain variable))			 (power-series-domain (get-tpower-series-domain domain variable))
	 (coef-list (mapcar #'(lambda (x) (coerce x domain)) init-list))			 (coef-list (mapcar #'(lambda (x) (coerce x domain)) init-list))
	 (var-list  (mapcar #'(lambda (x) (coerce x domain))					 (var-list  (mapcar #'(lambda (x) (coerce x domain))
			    (ring-variables (QF-ring domain)))))						    (ring-variables (QF-ring domain)))))	
	(setq diff-eqn (taylor diff-eqn power-series-domain order))				(setq diff-eqn (taylor diff-eqn power-series-domain order))
	(loop for i from 0 below (- (length var-list) (length coef-list)) do			(loop for i from 0 below (- (length var-list) (length coef-list)) do
	  (setq coef-list									  (setq coef-list
		(append coef-list									(append coef-list
			(list (solve-for-coeffs									(list (solve-for-coeffs
				(substitute coef-list									(substitute coef-list
					    (subseq var-list 0 (length coef-list))						    (subseq var-list 0 (length coef-list))
					    (get-coeff diff-eqn i))								    (get-coeff diff-eqn i))
				domain var-list coef-list)))))								domain var-list coef-list)))))
	(make-tpower-series power-series-domain							(make-tpower-series power-series-domain
			    (simp-zeros coef-list)								    (simp-zeros coef-list)
			    :valence (num-leading-zeros coef-list)						    :valence (num-leading-zeros coef-list)
			    :order (- (length coef-list) 1))))							    :order (- (length coef-list) 1))))
;;; -*- Base: 10; Mode: Lisp; Syntax: Common-lisp; Lowercase: T -*-			;;; -*- Base: 10; Mode: Lisp; Syntax: Common-lisp; Lowercase: T -*-

;;; ===========================================================================		;;; ===========================================================================
;;;			 Topology and the Basics of Geometry				;;;			 Topology and the Basics of Geometry
;;; ===========================================================================		;;; ===========================================================================
;;; (c) Copyright 1994 Cornell University						;;; (c) Copyright 1994 Cornell University

;;; topology.lisp,v 1.37 1995/06/05 20:24:49 rick Exp					;;; topology.lisp,v 1.37 1995/06/05 20:24:49 rick Exp

(in-package :WEYLI)									(in-package :weyli)

(make::adjust-version-numbers Weyl "1.37")					    |	;;; DELETE (make::adjust-version-numbers Weyl "1.37")

;; The following declaration causes all elements of euclidean spaces			;; The following declaration causes all elements of euclidean spaces
;; to be points.									;; to be points.
(define-domain-element-classes euclidean-space point)					(define-domain-element-classes euclidean-space point)

;; This is needed to avoid a precedence problem. 					;; This is needed to avoid a precedence problem. 
(defmethod make-element ((domain euclidean-space) (value vector) &rest values)		(defmethod make-element ((domain euclidean-space) (value vector) &rest values)
  (declare (ignore values))								  (declare (ignore values))
  (make-element-free-module-vector domain value))					  (make-element-free-module-vector domain value))

#+ignore										#+ignore
(defmethod print-object ((elt euclidean-space-element) stream)				(defmethod print-object ((elt euclidean-space-element) stream)
  (print-free-module-element elt stream))						  (print-free-module-element elt stream))

(define-domain-creator euclidean-space (dimension &optional (domain *general*))	    |	(eval-when (:compile-toplevel :load-toplevel)
										    >	  (define-domain-creator euclidean-space (dimension &optional (domain *general*))
  (make-instance 'euclidean-space 							    (make-instance 'euclidean-space 
		 :coefficient-domain domain						                   :coefficient-domain domain
		 :dimension dimension							                   :dimension dimension
		 :print-function 'euclidean-space-print-object)				                   :print-function 'euclidean-space-print-object)
  :predicate #'(lambda (d)								    :predicate #'(lambda (d)
		 (and (eql (class-name (class-of d)) 'euclidean-space)			                   (and (eql (class-name (class-of d)) 'euclidean-space)
		      (eql (coefficient-domain-of d) domain)				                        (eql (coefficient-domain-of d) domain)
		      (eql (dimension-of d) dimension))))			    |	                        (eql (dimension-of d) dimension)))))

(defun euclidean-space-print-object (domain stream)					(defun euclidean-space-print-object (domain stream)
  (format stream #+Genera "E~D" #-Genera "E^~D"						  (format stream #+Genera "E~D" #-Genera "E^~D"
	  (dimension-of domain)))								  (dimension-of domain)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Points.										;;  Points.
;;											;;
(defmethod-sd binary= ((p1 abstract-point) (p2 abstract-point))				(defmethod-sd binary= ((p1 abstract-point) (p2 abstract-point))
  (cl:= (id-number-of p1) (id-number-of p2)))						  (cl:= (id-number-of p1) (id-number-of p2)))

(defmethod-sd binary= ((p1 point) (p2 point))						(defmethod-sd binary= ((p1 point) (p2 point))
  (let ((p1-tuple (tuple-value p1))							  (let ((p1-tuple (tuple-value p1))
	(p2-tuple (tuple-value p2)))								(p2-tuple (tuple-value p2)))
    (loop for i fixnum below (array-dimension p1-tuple 0)				    (loop for i fixnum below (array-dimension p1-tuple 0)
	  do (unless (= (svref p1-tuple i) (svref p2-tuple i))					  do (unless (= (svref p1-tuple i) (svref p2-tuple i))
	       (return nil))									       (return nil))
	     finally (return t))))								     finally (return t))))

										    >	(defgeneric make-point (domain value &rest values)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod make-point ((domain vector-space) (value vector) &rest values)		(defmethod make-point ((domain vector-space) (value vector) &rest values)
  (let ((coef-domain (coefficient-domain-of domain)))					  (let ((coef-domain (coefficient-domain-of domain)))
    (unless (and (eql (array-dimension value 0) (dimension-of domain))			    (unless (and (eql (array-dimension value 0) (dimension-of domain))
    	     (null values))								    	     (null values))
      (error "Wrong number of vector elements in ~S" domain))				      (error "Wrong number of vector elements in ~S" domain))
    (make-instance 'point :domain domain						    (make-instance 'point :domain domain
    	       :values (%apply #'vector							    	       :values (%apply #'vector
    			       (loop for i fixnum below (length value)			    			       (loop for i fixnum below (length value)
    				     collect (coerce (aref value i)			    				     collect (coerce (aref value i)
    						     coef-domain))))))			    						     coef-domain))))))

(defmethod make-point ((domain vector-space) value &rest values)			(defmethod make-point ((domain vector-space) value &rest values)
  (let ((coef-domain (coefficient-domain-of domain)))					  (let ((coef-domain (coefficient-domain-of domain)))
    (unless (eql (1- (dimension-of domain)) (length values))				    (unless (eql (1- (dimension-of domain)) (length values))
      (error "Wrong number of vector elements in ~S" domain))				      (error "Wrong number of vector elements in ~S" domain))
    (make-instance 'point :domain domain						    (make-instance 'point :domain domain
    	       :values (%apply #'vector							    	       :values (%apply #'vector
    			       (coerce value coef-domain)				    			       (coerce value coef-domain)
    			       (loop for v in values					    			       (loop for v in values
    				     collect (coerce v coef-domain))))))		    				     collect (coerce v coef-domain))))))

(defmethod make-point ((domain vector-space) (value vector-space-element)		(defmethod make-point ((domain vector-space) (value vector-space-element)
    		   &rest values)							    		   &rest values)
  (apply #'make-point domain (tuple-value value) values))				  (apply #'make-point domain (tuple-value value) values))

(defmethod make-point ((domain abstract-space) value &rest values)			(defmethod make-point ((domain abstract-space) value &rest values)
  (declare (ignore values))								  (declare (ignore values))
  (if (null value)									  (if (null value)
      (make-instance 'abstract-point :domain domain)					      (make-instance 'abstract-point :domain domain)
      (make-instance 'named-point :domain domain :name value)))				      (make-instance 'named-point :domain domain :name value)))

(defmethod print-object ((point named-point) stream)					(defmethod print-object ((point named-point) stream)
  (format stream "<~A>" (name-of point)))						  (format stream "<~A>" (name-of point)))

(defmethod print-object ((point abstract-point) stream)					(defmethod print-object ((point abstract-point) stream)
  (format stream "<~S>" (id-number-of point)))						  (format stream "<~S>" (id-number-of point)))

;;  #P appears before coordinates of points.						;;  #P appears before coordinates of points.
(defmethod print-object ((point point) stream)						(defmethod print-object ((point point) stream)
  (format stream "#P") (call-next-method))						  (format stream "#P") (call-next-method))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Cells.										;;  Cells.

;;  Had to use defmethod instead of defmethod-sd.  The -sd version			;;  Had to use defmethod instead of defmethod-sd.  The -sd version
;;  checks domains and cells don't have domains.					;;  checks domains and cells don't have domains.
(defmethod binary= ((cell1 cell) (cell2 cell))						(defmethod binary= ((cell1 cell) (cell2 cell))
  (equal (cell-id cell1) (cell-id cell2)))						  (equal (cell-id cell1) (cell-id cell2)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Simplices.										;;  Simplices.

										    >	(defgeneric make-simplex (point &rest rest)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod make-simplex ((point abstract-point) &rest rest)				(defmethod make-simplex ((point abstract-point) &rest rest)
  (loop with domain = (domain-of point)							  (loop with domain = (domain-of point)
	for other in rest									for other in rest
	if (not (eql domain (domain-of other)))							if (not (eql domain (domain-of other)))
	  do											  do
       (error "Cannot make simplex with points from differing domains. ~s"		       (error "Cannot make simplex with points from differing domains. ~s"
	      (cons point rest)))								      (cons point rest)))
  (make-instance 'simplex :vertices (cons point (copy-list rest))))			  (make-instance 'simplex :vertices (cons point (copy-list rest))))

(defmethod print-object ((simplex simplex) stream)					(defmethod print-object ((simplex simplex) stream)
  (format stream "[~S~{, ~S~}]"								  (format stream "[~S~{, ~S~}]"
	  (first (vertices-of simplex)) (rest (vertices-of simplex))))				  (first (vertices-of simplex)) (rest (vertices-of simplex))))

										    >	(defgeneric cell-id (simplex)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod cell-id ((simplex simplex))							(defmethod cell-id ((simplex simplex))
  (mapcar #'id-number-of (vertices-of simplex)))					  (mapcar #'id-number-of (vertices-of simplex)))

(defmethod facets ((simplex simplex) (complex (eql nil)))				(defmethod facets ((simplex simplex) (complex (eql nil)))
  (with-slots (vertices) simplex							  (with-slots (vertices) simplex
    (if (rest vertices)									    (if (rest vertices)
	(let ((f-list nil))									(let ((f-list nil))
	  (choose (vertices-of simplex) (facet (dimension-of simplex))				  (choose (vertices-of simplex) (facet (dimension-of simplex))
		  (push (apply #'make-simplex facet) f-list))						  (push (apply #'make-simplex facet) f-list))
	  f-list))))										  f-list))))

(defmethod dimension-of ((s simplex))							(defmethod dimension-of ((s simplex))
  (- (length (vertices-of s)) 1))							  (- (length (vertices-of s)) 1))

;;  Return the list of vertices opposite the given face of the				;;  Return the list of vertices opposite the given face of the
;;  simplex.  The input face can be a simplex, a list of vertices, or			;;  simplex.  The input face can be a simplex, a list of vertices, or
;;  a single point.									;;  a single point.
(defmethod opposite ((face simplex) (simplex simplex))					(defmethod opposite ((face simplex) (simplex simplex))
  (set-difference (vertices-of simplex) (vertices-of face)))				  (set-difference (vertices-of simplex) (vertices-of face)))

(defmethod opposite ((face list) (simplex simplex))					(defmethod opposite ((face list) (simplex simplex))
  (set-difference (vertices-of simplex) face))						  (set-difference (vertices-of simplex) face))

(defmethod opposite ((face point) (simplex simplex))					(defmethod opposite ((face point) (simplex simplex))
  (remove face (vertices-of simplex)))							  (remove face (vertices-of simplex)))

										    >	(defgeneric face? (points simplex)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod face? ((points list) (simplex simplex))					(defmethod face? ((points list) (simplex simplex))
  (subsetp points (vertices-of simplex)))						  (subsetp points (vertices-of simplex)))

(defmethod face? ((simplex1 simplex) (simplex2 simplex))				(defmethod face? ((simplex1 simplex) (simplex2 simplex))
  (subsetp (vertices-of simplex1) (vertices-of simplex2)))				  (subsetp (vertices-of simplex1) (vertices-of simplex2)))

(defun segment? (thing)									(defun segment? (thing)
  (and (typep thing 'simplex) (= (length (vertices-of thing)) 2)))			  (and (typep thing 'simplex) (= (length (vertices-of thing)) 2)))

(defun triangle? (thing)								(defun triangle? (thing)
  (and (or (typep thing 'simplex) (typep thing 'polygon))				  (and (or (typep thing 'simplex) (typep thing 'polygon))
       (= (length (vertices-of thing)) 3)))						       (= (length (vertices-of thing)) 3)))

(defun tetrahedron? (thing)								(defun tetrahedron? (thing)
  (and (typep thing 'simplex) (= (length (vertices-of thing)) 4)))			  (and (typep thing 'simplex) (= (length (vertices-of thing)) 4)))

(defun sign-of-permutation (lista listb)						(defun sign-of-permutation (lista listb)
  (cond ((and (null lista) (null listb)) 1)						  (cond ((and (null lista) (null listb)) 1)
	((eql (first lista) (first listb))							((eql (first lista) (first listb))
	 (sign-of-permutation (rest lista) (rest listb)))					 (sign-of-permutation (rest lista) (rest listb)))
	((member (first lista) (rest listb))							((member (first lista) (rest listb))
	 (* -1 (sign-of-permutation								 (* -1 (sign-of-permutation
		(rest lista)										(rest lista)
		(substitute (first listb) (first lista) (rest listb)))))				(substitute (first listb) (first lista) (rest listb)))))
	(t 0)))											(t 0)))

(defmacro map-over-oriented-facets ((facet orientation simplex complex)			(defmacro map-over-oriented-facets ((facet orientation simplex complex)
				    &rest body)										    &rest body)
  "Map over the faces of SIMPLEX, taking ORIENTATION into account"			  "Map over the faces of SIMPLEX, taking ORIENTATION into account"
  `(loop  										  `(loop  
    for ,facet in (facets ,simplex ,complex)						    for ,facet in (facets ,simplex ,complex)
    for ,orientation in (if (orient-of ,simplex)					    for ,orientation in (if (orient-of ,simplex)
			    '(t nil t nil)									    '(t nil t nil)
			  '(nil t nil t))									  '(nil t nil t))
    do											    do
    ,@body))										    ,@body))

(defmacro map-over-oriented-cofacets ((cofacet orientation simplex complex)		(defmacro map-over-oriented-cofacets ((cofacet orientation simplex complex)
				      &rest body)									      &rest body)
  "Map over the faces of SIMPLEX, taking ORIENTATION into account"			  "Map over the faces of SIMPLEX, taking ORIENTATION into account"
  ;;; this is pretty ugly.  Could be fixed either by keeping				  ;;; this is pretty ugly.  Could be fixed either by keeping
  ;;; orientation info with cofacets, or by iterating over the cells			  ;;; orientation info with cofacets, or by iterating over the cells
  ;;; of 1 higher dimension higher up in the calling seequence				  ;;; of 1 higher dimension higher up in the calling seequence
  (let ((facet (gensym)))								  (let ((facet (gensym)))
    `(loop  										    `(loop  
      for ,cofacet in (cofacets ,simplex ,complex)					      for ,cofacet in (cofacets ,simplex ,complex)
      for ,orientation = (map-over-oriented-facets					      for ,orientation = (map-over-oriented-facets
			  (,facet ,orientation ,cofacet ,complex)						  (,facet ,orientation ,cofacet ,complex)
			  (if (eql ,facet ,simplex)								  (if (eql ,facet ,simplex)
			      (return ,orientation)))								      (return ,orientation)))
      do										      do
      ,@body)))										      ,@body)))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Polygons.										;;  Polygons.

(defmethod cell-id ((polygon polygon))							(defmethod cell-id ((polygon polygon))
  (let ((id-list (mapcar #'id-number-of (vertices-of polygon))))			  (let ((id-list (mapcar #'id-number-of (vertices-of polygon))))
    (if (= 3 (length (vertices-of polygon)))						    (if (= 3 (length (vertices-of polygon)))
	id-list											id-list
	(cons :p id-list))))	       ; Uses :p to distinguish from simplices.			(cons :p id-list))))	       ; Uses :p to distinguish from simplices.

(defmethod facets ((polygon polygon) (complex (eql nil)))				(defmethod facets ((polygon polygon) (complex (eql nil)))
  (loop with vertices = (vertices-of polygon)						  (loop with vertices = (vertices-of polygon)
	for a in (cons (first (last vertices)) vertices) and b in vertices			for a in (cons (first (last vertices)) vertices) and b in vertices
	collect (make-simplex a b)))								collect (make-simplex a b)))

(defmethod dimension-of ((polygon polygon))						(defmethod dimension-of ((polygon polygon))
  2)											  2)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Cell-Complexes.									;;  Cell-Complexes.

										    >	(defgeneric get-cell (cell complex)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod get-cell ((cell cell) (complex cell-complex))				(defmethod get-cell ((cell cell) (complex cell-complex))
  (if (member cell complex) cell							  (if (member cell complex) cell
      (gethash (cell-id cell) (cell-table-of complex))))				      (gethash (cell-id cell) (cell-table-of complex))))

;;  Allow get-cell to take a list of vertices (representing a simplex).			;;  Allow get-cell to take a list of vertices (representing a simplex).
(defmethod get-cell ((vertex-list list) (complex cell-complex))				(defmethod get-cell ((vertex-list list) (complex cell-complex))
  (gethash (sort (mapcar #'id-number-of vertex-list) #'cl:<)				  (gethash (sort (mapcar #'id-number-of vertex-list) #'cl:<)
	   (cell-table-of complex)))								   (cell-table-of complex)))

(defmethod member ((cell cell) (complex cell-complex) &rest ignore)			(defmethod member ((cell cell) (complex cell-complex) &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (second (multiple-value-list (gethash (id-number-of cell)				  (second (multiple-value-list (gethash (id-number-of cell)
					(facet-table-of complex)))))								(facet-table-of complex)))))

										    >	(defgeneric facets (cell complex)
										    >	  (:documentation
										    >	   "The purpose of this method is unknown."))
										    >
(defmethod facets ((cell cell) (complex cell-complex))					(defmethod facets ((cell cell) (complex cell-complex))
  (gethash (id-number-of cell) (facet-table-of complex)))				  (gethash (id-number-of cell) (facet-table-of complex)))

(defmethod facets ((cells list) (complex cell-complex))					(defmethod facets ((cells list) (complex cell-complex))
  (loop for cell in cells								  (loop for cell in cells
	append (facets cell complex) into facet-list						append (facets cell complex) into facet-list
	finally (return (remove-duplicates facet-list))))					finally (return (remove-duplicates facet-list))))

										    >	(defgeneric cofacets (cell complex)
										    >	  (:documentation
										    >	   "The purpose of this method is unknown."))
										    >
(defmethod cofacets ((cell cell) (complex cell-complex))				(defmethod cofacets ((cell cell) (complex cell-complex))
  (gethash (id-number-of cell) (cofacet-table-of complex)))				  (gethash (id-number-of cell) (cofacet-table-of complex)))

(defmethod cofacets ((cells list) (complex cell-complex))				(defmethod cofacets ((cells list) (complex cell-complex))
  (loop for cell in cells								  (loop for cell in cells
	append (cofacets cell complex) into cofacet-list					append (cofacets cell complex) into cofacet-list
	finally (return (remove-duplicates cofacet-list))))					finally (return (remove-duplicates cofacet-list))))

										    >	(defgeneric maximal-cell? (cell complex)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod maximal-cell? ((cell cell) (complex cell-complex))				(defmethod maximal-cell? ((cell cell) (complex cell-complex))
  (and (member cell complex) (null (cofacets cell complex))))				  (and (member cell complex) (null (cofacets cell complex))))

;;  Destructive modification of cell-complex.						;;  Destructive modification of cell-complex.
(defmethod insert ((cell cell) (complex cell-complex) &rest ignore)			(defmethod insert ((cell cell) (complex cell-complex) &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (with-slots (cell-table facet-table cofacet-table) complex				  (with-slots (cell-table facet-table cofacet-table) complex
    ;;  Internal insert.  Checking only needs to be done on insert;			    ;;  Internal insert.  Checking only needs to be done on insert;
    ;;  %insert does no checking.  Implements distinction between			    ;;  %insert does no checking.  Implements distinction between
    ;;  user-level insert and internal insert; nice for triangulations			    ;;  user-level insert and internal insert; nice for triangulations
    ;;  where user-level inserts only triangles, while internal				    ;;  where user-level inserts only triangles, while internal
    ;;  inserts can do 1- and 0-simplices.  If there is already an			    ;;  inserts can do 1- and 0-simplices.  If there is already an
    ;;  equivalent cell in the complex then we return the equivalent			    ;;  equivalent cell in the complex then we return the equivalent
    ;;  cell (and do no insertion); otherwise we return the newly			    ;;  cell (and do no insertion); otherwise we return the newly
    ;;  inserted cell.  [May want to make %insert a method on its own			    ;;  inserted cell.  [May want to make %insert a method on its own
    ;;  at some point.]									    ;;  at some point.]
    (labels ((%insert (cell complex)							    (labels ((%insert (cell complex)
	       (or (get-cell cell complex)							       (or (get-cell cell complex)
		   (loop with facets-list								   (loop with facets-list
			 for facet in (facets cell nil)								 for facet in (facets cell nil)
			 do (setf facet (%insert facet complex))						 do (setf facet (%insert facet complex))
			    (push facet facets-list)								    (push facet facets-list)
			    (push cell (gethash (id-number-of facet)						    (push cell (gethash (id-number-of facet)
						cofacet-table))										cofacet-table))
			 finally										 finally
		      (setf (gethash (cell-id cell) cell-table) cell)					      (setf (gethash (cell-id cell) cell-table) cell)
		      (setf (gethash (id-number-of cell) facet-table)					      (setf (gethash (id-number-of cell) facet-table)
			    facets-list)									    facets-list)
		      (return cell)))))									      (return cell)))))
      (%insert cell complex))))								      (%insert cell complex))))

;;  Destructive modification.  Can only delete a maximal cell.				;;  Destructive modification.  Can only delete a maximal cell.
(defmethod delete-maximal-cell ((cell cell) (complex cell-complex))			(defmethod delete-maximal-cell ((cell cell) (complex cell-complex))
  (unless (member cell complex)								  (unless (member cell complex)
    (error "Cannot delete ~s from ~s.  It is not a member." cell complex))		    (error "Cannot delete ~s from ~s.  It is not a member." cell complex))
  (when (cofacets cell complex)								  (when (cofacets cell complex)
    (error "Cannot delete a cell that is not maximal. ~s" cell))			    (error "Cannot delete a cell that is not maximal. ~s" cell))
  (with-slots (cell-table facet-table cofacet-table) complex				  (with-slots (cell-table facet-table cofacet-table) complex
    (labels ((%delete (cell complex)							    (labels ((%delete (cell complex)
	       (loop with cofacets								       (loop with cofacets
		     for facet in (facets cell complex) do						     for facet in (facets cell complex) do
		       (setf cofacets (remove cell (cofacets facet complex)))				       (setf cofacets (remove cell (cofacets facet complex)))
		       (cond										       (cond
			 (cofacets (setf (gethash (id-number-of facet)						 (cofacets (setf (gethash (id-number-of facet)
						  cofacet-table)									  cofacet-table)
					 cofacets))										 cofacets))
			 (t (remhash (id-number-of facet) cofacet-table)					 (t (remhash (id-number-of facet) cofacet-table)
			    (%delete facet complex))))								    (%delete facet complex))))
	       (remhash (cell-id cell) cell-table)						       (remhash (cell-id cell) cell-table)
	       (remhash (id-number-of cell) facet-table)))					       (remhash (id-number-of cell) facet-table)))
      (%delete cell complex))))								      (%delete cell complex))))

										    >	(defgeneric %map-over-cells (function complex dimension)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
;;  Use function on all cells of complex that have the given				;;  Use function on all cells of complex that have the given
;;  dimension.  If dimension is null then use function on all cells.			;;  dimension.  If dimension is null then use function on all cells.
(defmethod %map-over-cells ((function function) (complex cell-complex)			(defmethod %map-over-cells ((function function) (complex cell-complex)
			    dimension)										    dimension)
  (maphash #'(lambda (cell-id cell)							  (maphash #'(lambda (cell-id cell)
	       (declare (ignore cell-id))							       (declare (ignore cell-id))
	       (when (or (null dimension) (= dimension (dimension-of cell)))			       (when (or (null dimension) (= dimension (dimension-of cell)))
		 (funcall function cell)))								 (funcall function cell)))
	   (cell-table-of complex)))								   (cell-table-of complex)))

;;  Syntactic sugar.									;;  Syntactic sugar.
(defmacro map-over-cells ((cell &optional (dimension nil)) structure			(defmacro map-over-cells ((cell &optional (dimension nil)) structure
			  &body body)										  &body body)
  `(%map-over-cells #'(lambda (,cell) ,@body) ,structure ,dimension))			  `(%map-over-cells #'(lambda (,cell) ,@body) ,structure ,dimension))

;;  More syntactic sugar.								;;  More syntactic sugar.
(defmacro map-over-maximal-cells ((cell) complex &body body)			    |	(eval-when (:compile-toplevel :load-toplevel)
										    >	  (defmacro map-over-maximal-cells ((cell) complex &body body)
  `(map-over-cells (,cell) ,complex							    `(map-over-cells (,cell) ,complex
     (when (maximal-cell? ,cell ,complex)						      (when (maximal-cell? ,cell ,complex)
       ,@body)))								    |	        ,@body))))

(defmethod union ((complex1 cell-complex) (complex2 cell-complex) &rest rest)		(defmethod union ((complex1 cell-complex) (complex2 cell-complex) &rest rest)
  (when rest										  (when rest
    (error "Too many arguments to Union."))						    (error "Too many arguments to Union."))
  (unless (eql (class-of complex1) (class-of complex2))					  (unless (eql (class-of complex1) (class-of complex2))
    (error "~s and ~s are not of the same class." complex1 complex2))			    (error "~s and ~s are not of the same class." complex1 complex2))
  (let ((new (make-instance (class-of complex1))))					  (let ((new (make-instance (class-of complex1))))
    (map-over-maximal-cells (cell) complex1 (insert cell new))				    (map-over-maximal-cells (cell) complex1 (insert cell new))
    (map-over-maximal-cells (cell) complex2 (insert cell new))				    (map-over-maximal-cells (cell) complex2 (insert cell new))
    new))										    new))

(defmethod intersection ((complex1 cell-complex) (complex2 cell-complex)		(defmethod intersection ((complex1 cell-complex) (complex2 cell-complex)
			 &rest rest)										 &rest rest)
  (when rest										  (when rest
    (error "Too many arguments to Intersection."))					    (error "Too many arguments to Intersection."))
  (unless (eql (class-of complex1) (class-of complex2))					  (unless (eql (class-of complex1) (class-of complex2))
    (error "~s and ~s are not of the same class." complex1 complex2))			    (error "~s and ~s are not of the same class." complex1 complex2))
  (let ((new (make-instance (class-of complex1))))					  (let ((new (make-instance (class-of complex1))))
    (map-over-cells (cell) complex1							    (map-over-cells (cell) complex1
      (when (get-cell cell complex2) (insert cell new)))				      (when (get-cell cell complex2) (insert cell new)))
    new))										    new))
		    											    
(defmethod vertex-set ((cell-complex cell-complex))					(defmethod vertex-set ((cell-complex cell-complex))
  (let ((vert-list nil))								  (let ((vert-list nil))
    (map-over-cells (v-cell 0) cell-complex						    (map-over-cells (v-cell 0) cell-complex
		    (push (first (vertices-of v-cell)) vert-list))					    (push (first (vertices-of v-cell)) vert-list))
    vert-list))										    vert-list))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Simplicial-Complexes.								;;  Simplicial-Complexes.

;;  Catch bad insertions.  This avoids a nasty precedence problem:			;;  Catch bad insertions.  This avoids a nasty precedence problem:
;;  without this, the command (insert cell simplicial-complex) can end			;;  without this, the command (insert cell simplicial-complex) can end
;;  up at command (insert cell cell-complex) and work even when cell			;;  up at command (insert cell cell-complex) and work even when cell
;;  is a nonsimplex.									;;  is a nonsimplex.
(defmethod insert :before (thing (complex simplicial-complex) &rest ignore)		(defmethod insert :before (thing (complex simplicial-complex) &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (unless (typep thing 'simplex)							  (unless (typep thing 'simplex)
    (error "Illegal attempt to Insert a nonsimplex ~s into ~s" thing complex)))		    (error "Illegal attempt to Insert a nonsimplex ~s into ~s" thing complex)))

(defun make-simplicial-complex (cells)							(defun make-simplicial-complex (cells)
  (loop with complex = (make-instance 'simplicial-complex)				  (loop with complex = (make-instance 'simplicial-complex)
	for cell in cells do									for cell in cells do
	(insert cell complex) 									(insert cell complex) 
	finally (return complex)))								finally (return complex)))

										    >	(defgeneric max-dimension-of (cell)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod max-dimension-of ((cm cell-complex))						(defmethod max-dimension-of ((cm cell-complex))
  (let ((max 0))									  (let ((max 0))
    (map-over-cells(cell) cm								    (map-over-cells(cell) cm
		   (setf max (max max (dimension-of cell))))						   (setf max (max max (dimension-of cell))))
    max))										    max))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Coerce.										;;  Coerce.
;;											;;
;;  Coerce via the coercion-cache.  A single object can have multiple			;;  Coerce via the coercion-cache.  A single object can have multiple
;;  representations; this allows fast access without recomputing the			;;  representations; this allows fast access without recomputing the
;;  map.  Maps are specified via Make-Homomorphism.  It's also				;;  map.  Maps are specified via Make-Homomorphism.  It's also
;;  possible to force a coercion to have a particular value via (setf			;;  possible to force a coercion to have a particular value via (setf
;;  coerce).										;;  coerce).
;;											;;
;;  This has three advantages: (1) You can force a coercion to have a			;;  This has three advantages: (1) You can force a coercion to have a
;;  particular value via (setf coerce).  (2) You can save time (when			;;  particular value via (setf coerce).  (2) You can save time (when
;;  the map between spaces is slow).  (3) You can save consing				;;  the map between spaces is slow).  (3) You can save consing
;;  (nothing new is created after the first time that the cache is			;;  (nothing new is created after the first time that the cache is
;;  used; while a map is likely to create new objects during every			;;  used; while a map is likely to create new objects during every
;;  use).										;;  use).
;;											;;
;;  FIXTHIS: This method should probably be in a different file.			;;  FIXTHIS: This method should probably be in a different file.
;;											;;
(defmethod coerce ((thing has-coercion-cache) (domain domain))				(defmethod coerce ((thing has-coercion-cache) (domain domain))

  ;;  Return the thing itself if it is already in the correct domain.			  ;;  Return the thing itself if it is already in the correct domain.
  (or (if (eql (domain-of thing) domain) thing)						  (or (if (eql (domain-of thing) domain) thing)

      ;;  Use the stored value if it exists.						      ;;  Use the stored value if it exists.
      (rest (assoc domain (%coercion-cache-of thing)))					      (rest (assoc domain (%coercion-cache-of thing)))

      ;;  Get the value, cache it, and return it.					      ;;  Get the value, cache it, and return it.
      (let ((value (call-next-method)))							      (let ((value (call-next-method)))
        (if value (push (cons domain value) (%coercion-cache-of thing)))		        (if value (push (cons domain value) (%coercion-cache-of thing)))
        value)))									        value)))

(defmethod %set-coerce ((thing has-coercion-cache) (domain domain) value)		(defmethod %set-coerce ((thing has-coercion-cache) (domain domain) value)
  (with-slots (coercion-cache) thing							  (with-slots (coercion-cache) thing
    (when (assoc domain coercion-cache)							    (when (assoc domain coercion-cache)
      (error "Multiple representations for a single item. ~s" thing))			      (error "Multiple representations for a single item. ~s" thing))
    (unless (eql (domain-of value) domain)						    (unless (eql (domain-of value) domain)
      (error "Mismatch when defining coercion. ~s ~s" domain value))			      (error "Mismatch when defining coercion. ~s ~s" domain value))
    (push (cons domain value) coercion-cache)						    (push (cons domain value) coercion-cache)
    value))										    value))

(defsetf coerce %set-coerce)								(defsetf coerce %set-coerce)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Chains										;; Chains
;;											;;
;; CHAINs are elements of CHAIN-MODULE domains						;; CHAINs are elements of CHAIN-MODULE domains
;;											;;
;;   Use GET-CHAIN-MODULE to create CHAIN-MODULE domains.				;;   Use GET-CHAIN-MODULE to create CHAIN-MODULE domains.
;;   CHAIN representations are based upon the canonical cells returned by		;;   CHAIN representations are based upon the canonical cells returned by
;;   GET-Canonical-Cell from the CELL-COMPLEX in the CHAIN-MODULE.			;;   GET-Canonical-Cell from the CELL-COMPLEX in the CHAIN-MODULE.

(defun chain-module-print-object (cm stream)						(defun chain-module-print-object (cm stream)
  (format stream "C_~D(~A;~A)" (dimension-of cm) (complex-of cm)			  (format stream "C_~D(~A;~A)" (dimension-of cm) (complex-of cm)
	  (coefficient-domain-of cm)))								  (coefficient-domain-of cm)))

(defun cochain-module-print-object (cm stream)						(defun cochain-module-print-object (cm stream)
  (format stream "C^~D(~A;~A)" (dimension-of cm) (complex-of cm)			  (format stream "C^~D(~A;~A)" (dimension-of cm) (complex-of cm)
	  (coefficient-domain-of cm)))								  (coefficient-domain-of cm)))

(defmethod complex-of ((chain chain))							(defmethod complex-of ((chain chain))
  (complex-of(domain-of chain)))							  (complex-of(domain-of chain)))

										    >	(defgeneric get-chain-module (cell integer &optional ring)
										    >	  (:documentation
										    >	   "The purpose of this function is unkown."))
										    >
(defmethod get-chain-module ((c cell-complex) (n integer)				(defmethod get-chain-module ((c cell-complex) (n integer)
			     &optional (ring (get-rational-integers)))						     &optional (ring (get-rational-integers)))
  (make-instance 'chain-module								  (make-instance 'chain-module
		 :complex c										 :complex c
                 :dimension n								                 :dimension n
                 :coefficient-domain ring						                 :coefficient-domain ring
		 :print-function 'chain-module-print-object))						 :print-function 'chain-module-print-object))

										    >	(defgeneric get-cochain-module (cell integer &optional ring)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod get-cochain-module ((c cell-complex) (n integer)				(defmethod get-cochain-module ((c cell-complex) (n integer)
			       &optional (ring (get-rational-integers)))					       &optional (ring (get-rational-integers)))
  (make-instance 'cochain-module							  (make-instance 'cochain-module
		 :complex c										 :complex c
                 :dimension n								                 :dimension n
                 :coefficient-domain ring						                 :coefficient-domain ring
		 :print-function 'cochain-module-print-object						 :print-function 'cochain-module-print-object
		 ))											 ))

										    >	(defgeneric boundary-domain (chain)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod boundary-domain ((c chain-module))						(defmethod boundary-domain ((c chain-module))
  (if (= (dimension-of c) 0)								  (if (= (dimension-of c) 0)
     (error "Can not create a chain module with a less than zero dimension.")		     (error "Can not create a chain module with a less than zero dimension.")
     (get-chain-module (complex-of c)							     (get-chain-module (complex-of c)
                       (- (dimension-of c) 1)						                       (- (dimension-of c) 1)
                       (coefficient-domain-of c))))					                       (coefficient-domain-of c))))

(defmethod dimension-of ((chain chain))							(defmethod dimension-of ((chain chain))
  (dimension-of (domain-of chain)))							  (dimension-of (domain-of chain)))

(defmethod boundary-domain ((c chain))							(defmethod boundary-domain ((c chain))
  (if (= (dimension-of (domain-of c)) 0)						  (if (= (dimension-of (domain-of c)) 0)
      (error "Can not create boundary domain for a zero dimension chain.")		      (error "Can not create boundary domain for a zero dimension chain.")
    (get-chain-module (complex-of c)							    (get-chain-module (complex-of c)
		      (- (dimension-of c) 1)								      (- (dimension-of c) 1)
		      (coefficient-domain-of (domain-of c)))))						      (coefficient-domain-of (domain-of c)))))

(defmethod boundary-domain ((s simplex))						(defmethod boundary-domain ((s simplex))
  (get-chain-module (make-simplicial-complex (list s))					  (get-chain-module (make-simplicial-complex (list s))
		    (- (dimension-of s) 1)								    (- (dimension-of s) 1)
		    (get-rational-integers)))								    (get-rational-integers)))

(defmethod boundary-domain ((cc cell-complex))						(defmethod boundary-domain ((cc cell-complex))
  (get-chain-module cc (1- (max-dimension-of cc))					  (get-chain-module cc (1- (max-dimension-of cc))
		    (get-rational-integers)))								    (get-rational-integers)))

										    >	(defgeneric coboundary-domain (cochain)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod coboundary-domain ((c cochain))						(defmethod coboundary-domain ((c cochain))
  (if (= (dimension-of (domain-of c)) (max-dimension-of (complex-of c)))		  (if (= (dimension-of (domain-of c)) (max-dimension-of (complex-of c)))
      (error "Can not create coboundary domain for a maximal dimensional cochain."	      (error "Can not create coboundary domain for a maximal dimensional cochain."
    (get-cochain-module (complex-of c)							    (get-cochain-module (complex-of c)
			(+ (dimension-of c) 1)									(+ (dimension-of c) 1)
			(coefficient-domain-of (domain-of c)))))						(coefficient-domain-of (domain-of c)))))

(defmethod coboundary-domain ((s simplex))						(defmethod coboundary-domain ((s simplex))
  (get-cochain-module (make-simplicial-complex (list s))				  (get-cochain-module (make-simplicial-complex (list s))
		      (+ (dimension-of s) 1)								      (+ (dimension-of s) 1)
		      (get-rational-integers)))								      (get-rational-integers)))


(defmethod print-object ((c chain) stream)						(defmethod print-object ((c chain) stream)
  (flet ((print-term (s coef)								  (flet ((print-term (s coef)
		     (cond ((minus? coef)								     (cond ((minus? coef)
		  (princ " - " stream)									  (princ " - " stream)
		  (setq coef (- coef)))									  (setq coef (- coef)))
		 (t (princ " + " stream)))								 (t (princ " + " stream)))
	   (unless (1? coef)									   (unless (1? coef)
	     (print-grouped coef stream))							     (print-grouped coef stream))
	   (princ s stream)))									   (princ s stream)))
    (let* ((terms (chain-terms-of c))							    (let* ((terms (chain-terms-of c))
	   (s (first (first terms)))								   (s (first (first terms)))
	   (coef (rest (first terms))))								   (coef (rest (first terms))))
      (cond ((null terms) (princ 0 stream))						      (cond ((null terms) (princ 0 stream))
	    (t (cond ((minus? coef)								    (t (cond ((minus? coef)
		      (princ " - " stream)								      (princ " - " stream)
		      (setq coef (- coef))))								      (setq coef (- coef))))
	       (unless (1? coef)								       (unless (1? coef)
		 (print-grouped coef stream))								 (print-grouped coef stream))
               (princ s stream)								               (princ s stream)
	       (loop for (cell . coef) in (rest terms)						       (loop for (cell . coef) in (rest terms)
		     do (print-term cell coef)))))))							     do (print-term cell coef)))))))

(defun canonical (pair domain)								(defun canonical (pair domain)
  (multiple-value-bind (cached sign)							  (multiple-value-bind (cached sign)
      (get-cell (complex-of domain) (first pair))					      (get-cell (complex-of domain) (first pair))
    (cons cached (if (> sign 0) (cdr pair) (minus (cdr pair))))))			    (cons cached (if (> sign 0) (cdr pair) (minus (cdr pair))))))

(defmethod coerce ((simplex simplex) (cm chain-module))					(defmethod coerce ((simplex simplex) (cm chain-module))
  (make-chain cm (list(cons simplex							  (make-chain cm (list(cons simplex
 			    (coerce 1 (coefficient-domain-of				 			    (coerce 1 (coefficient-domain-of
 				       cm))))))						 				       cm))))))

(defmethod coerce ((cc simplicial-complex) (cm chain-module))				(defmethod coerce ((cc simplicial-complex) (cm chain-module))
  (let ((one (coerce 1 (coefficient-domain-of cm)))					  (let ((one (coerce 1 (coefficient-domain-of cm)))
 	(dim (dimension-of cm))								 	(dim (dimension-of cm))
 	(list nil))									 	(list nil))
    (map-over-cells (face dim) cm							    (map-over-cells (face dim) cm
		    (push (cons face one) list))							    (push (cons face one) list))
    (make-chain cm list)))								    (make-chain cm list)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CELL-ORDER										;; CELL-ORDER
;;   defines a canonical ordering for cells						;;   defines a canonical ordering for cells
;;   - used to create canonical stored and printed representations for chains		;;   - used to create canonical stored and printed representations for chains
(defun points-order (a b)								(defun points-order (a b)
  (loop for av in a									  (loop for av in a
	for bv in b										for bv in b
	do (cond ((cl:< (id-number-of av) (id-number-of bv))					do (cond ((cl:< (id-number-of av) (id-number-of bv))
		  (return t))										  (return t))
		 ((eql av bv) nil)									 ((eql av bv) nil)
		 (t (return nil)))))									 (t (return nil)))))

										    >	(defgeneric cell-order (cell1 cell2)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod cell-order ((a cell) (b cell))						(defmethod cell-order ((a cell) (b cell))
  (let ((aorder (sort (copy-list (vertices-of a)) #'cl:< :key #'id-number-of))		  (let ((aorder (sort (copy-list (vertices-of a)) #'cl:< :key #'id-number-of))
	(border (sort (copy-list (vertices-of b)) #'cl:< :key #'id-number-of)))			(border (sort (copy-list (vertices-of b)) #'cl:< :key #'id-number-of)))
    (or (points-order aorder border)							    (or (points-order aorder border)
	(points-order (vertices-of a) (vertices-of b)))))					(points-order (vertices-of a) (vertices-of b)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MAKE-CHAIN										;; MAKE-CHAIN
;;   Used to create CHAIN elements.  							;;   Used to create CHAIN elements.  
;;   -  Currently does not verify that the simplexes given are of the proper		;;   -  Currently does not verify that the simplexes given are of the proper
;;      dimension indicated in the CHAIN-MODULE						;;      dimension indicated in the CHAIN-MODULE


;; Internally, the chains are stored as dotted pairs of simplices and			;; Internally, the chains are stored as dotted pairs of simplices and
;; coefficients.  The argument list to make-chain is also a list of			;; coefficients.  The argument list to make-chain is also a list of
;; dotted pairs.									;; dotted pairs.

(defun make-chain-or-cochain (d simplices chain-or-cochain)				(defun make-chain-or-cochain (d simplices chain-or-cochain)
  (let ((simps nil))									  (let ((simps nil))
    (loop for simp on 									    (loop for simp on 
	  (sort simplices									  (sort simplices
		#'(lambda (x y)										#'(lambda (x y)
		    (cell-order (car y) (car x))))							    (cell-order (car y) (car x))))
	  do											  do
	  (cond											  (cond
	   ((eq (first simp) (second simp))							   ((eq (first simp) (second simp))
	    (setf (cdr (second simp))								    (setf (cdr (second simp))
		  (+ (cdr (second simp))								  (+ (cdr (second simp))
		     (cdr (first simp)))))								     (cdr (first simp)))))
	   ((0? (cdr (first simp)))nil)								   ((0? (cdr (first simp)))nil)
	   (t (push (first simp) simps))))							   (t (push (first simp) simps))))
    (make-instance chain-or-cochain							    (make-instance chain-or-cochain
		   :domain d										   :domain d
		   :terms simps)))									   :terms simps)))

(defun make-chain (d simplices)								(defun make-chain (d simplices)
  (make-chain-or-cochain d simplices 'chain))						  (make-chain-or-cochain d simplices 'chain))

(defun make-cochain (d simplices)							(defun make-cochain (d simplices)
  (make-chain-or-cochain d simplices 'cochain))						  (make-chain-or-cochain d simplices 'cochain))

(defmethod zero ((d chain-module))							(defmethod zero ((d chain-module))
  (make-chain d ()))									  (make-chain d ()))

(defmethod apply ((c chain) &rest args)							(defmethod apply ((c chain) &rest args)
  (setq args (accum-apply-args args))							  (setq args (accum-apply-args args))
  (cond ((typep (first args) 'simplex)							  (cond ((typep (first args) 'simplex)
	 (loop with s = (first args)								 (loop with s = (first args)
	       for (simplex . coef) in (chain-terms-of c)					       for (simplex . coef) in (chain-terms-of c)
	       do (when (face? s simplex)							       do (when (face? s simplex)
		    (return coef))))))									    (return coef))))))
  											  

(defun free-group-plus (xt yt)								(defun free-group-plus (xt yt)
  (pair-up-terms xt (simp1 c1) yt (simp2 c2) cell-order					  (pair-up-terms xt (simp1 c1) yt (simp2 c2) cell-order
		 (if simp1 (if simp2 (let ((c-sum (+ c1 c2)))						 (if simp1 (if simp2 (let ((c-sum (+ c1 c2)))
				       (if (not (0? c-sum))								       (if (not (0? c-sum))
					   (collect-term simp1 c-sum)))								   (collect-term simp1 c-sum)))
			     (collect-term simp1 c1))								     (collect-term simp1 c1))
		   (collect-term simp2 c2))))								   (collect-term simp2 c2))))

(defun free-group-difference (xt yt)							(defun free-group-difference (xt yt)
  (pair-up-terms xt (simp1 c1) yt (simp2 c2) cell-order					  (pair-up-terms xt (simp1 c1) yt (simp2 c2) cell-order
		 (if simp1 (if simp2 (let ((c-sum (- c1 c2)))						 (if simp1 (if simp2 (let ((c-sum (- c1 c2)))
				       (if (not (0? c-sum))								       (if (not (0? c-sum))
					   (collect-term simp1 c-sum)))								   (collect-term simp1 c-sum)))
			     (collect-term simp1 c1))								     (collect-term simp1 c1))
		   (collect-term simp2 c2))))								   (collect-term simp2 c2))))

(defun free-group-minus (xt)								(defun free-group-minus (xt)
   (free-group-difference nil xt))							   (free-group-difference nil xt))

(defun free-group-scalar-times (c terms)						(defun free-group-scalar-times (c terms)
  (cond ((0? c) nil)									  (cond ((0? c) nil)
	(t (loop for (simp . coef) in terms							(t (loop for (simp . coef) in terms
		 for c1 = (* c coef)	; coefficient ring need not be an 				 for c1 = (* c coef)	; coefficient ring need not be an 
		 unless (0? c1)		; integral domain!						 unless (0? c1)		; integral domain!
		   collect (cons simp c1)))))								   collect (cons simp c1)))))

(defmethod-sd plus ((x chain) (y chain))						(defmethod-sd plus ((x chain) (y chain))
  (make-chain (domain-of x)								  (make-chain (domain-of x)
	      (free-group-plus (chain-terms-of x) (chain-terms-of y))))				      (free-group-plus (chain-terms-of x) (chain-terms-of y))))

(defmethod-sd difference ((x chain) (y chain))						(defmethod-sd difference ((x chain) (y chain))
  (make-chain (domain-of x)								  (make-chain (domain-of x)
	      (free-group-difference (chain-terms-of x) (chain-terms-of y))))			      (free-group-difference (chain-terms-of x) (chain-terms-of y))))

(defmethod times ((x (or number domain-element)) (y chain))			    |	(defmethod times ((x number) (y chain))
  (make-chain  (domain-of y)								  (make-chain  (domain-of y)
	       (free-group-scalar-times x (chain-terms-of y))))					       (free-group-scalar-times x (chain-terms-of y))))

(defmethod times ((x chain) (y (or number domain-element)))			    |	(defmethod times ((x domain-element) (y chain))
										    >	  (make-chain  (domain-of y)
										    >		       (free-group-scalar-times x (chain-terms-of y))))
										    >
										    >	(defmethod times ((x chain) (y number))
										    >	  (make-chain (domain-of x)
										    >		      (free-group-scalar-times y (chain-terms-of x))))
										    >
										    >	(defmethod times ((x chain) (y number))
  (make-chain (domain-of x)								  (make-chain (domain-of x)
	      (free-group-scalar-times y (chain-terms-of x))))					      (free-group-scalar-times y (chain-terms-of x))))

(defmethod minus ((x chain))								(defmethod minus ((x chain))
  (make-chain (domain-of x)								  (make-chain (domain-of x)
	      (free-group-minus (chain-terms-of x))))						      (free-group-minus (chain-terms-of x))))

(defun chain-terms-times (xt yt)							(defun chain-terms-times (xt yt)
  (pair-up-terms xt (simp1 c1) yt (simp2 c2) cell-order					  (pair-up-terms xt (simp1 c1) yt (simp2 c2) cell-order
    (when (and simp1 simp2)								    (when (and simp1 simp2)
      (let ((c-prod (* c1 c2)))								      (let ((c-prod (* c1 c2)))
	   (if (not (0? c-prod))								   (if (not (0? c-prod))
	       (collect-term simp1 c-prod))))))							       (collect-term simp1 c-prod))))))

(defmethod-sd times ((x chain) (y chain))						(defmethod-sd times ((x chain) (y chain))
  (make-chain domain									  (make-chain domain
	      (chain-terms-times (chain-terms-of x) (chain-terms-of y))))			      (chain-terms-times (chain-terms-of x) (chain-terms-of y))))
										    >
										    >	(defgeneric boundary (simplex &optional domain)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))

(defmethod boundary ((s simplex) &optional (domain (boundary-domain s)))		(defmethod boundary ((s simplex) &optional (domain (boundary-domain s)))
  (let* ((list nil)									  (let* ((list nil)
         (one (one (coefficient-domain-of domain)))					         (one (one (coefficient-domain-of domain)))
	 (simplicial-complex (complex-of domain))						 (simplicial-complex (complex-of domain))
         )										         )
    (map-over-oriented-facets								    (map-over-oriented-facets
     (f o s simplicial-complex)								     (f o s simplicial-complex)
     (push (cons f (if o  one (minus one))) list))					     (push (cons f (if o  one (minus one))) list))
    (make-chain domain list)))								    (make-chain domain list)))

(defmethod boundary ((cc cell-complex) &optional (domain (boundary-domain cc)))		(defmethod boundary ((cc cell-complex) &optional (domain (boundary-domain cc)))
  (let ((bound (zero domain)))								  (let ((bound (zero domain)))
    (map-over-cells									    (map-over-cells
     (cell (1+(dimension-of domain))) cc						     (cell (1+(dimension-of domain))) cc
     (setf bound (+ bound (boundary cell domain))))					     (setf bound (+ bound (boundary cell domain))))
    bound))										    bound))

(defmethod boundary ((c chain) &optional d)						(defmethod boundary ((c chain) &optional d)
  (let((pairs nil)									  (let((pairs nil)
       (bd  (if d d (boundary-domain c)))						       (bd  (if d d (boundary-domain c)))
       (zero nil)									       (zero nil)
       (ht (make-hash-table))								       (ht (make-hash-table))
       (complex (complex-of c)))							       (complex (complex-of c)))
    											    
    (setf zero (zero(coefficient-domain-of bd)))					    (setf zero (zero(coefficient-domain-of bd)))
    (loop for term in (chain-terms-of c) do						    (loop for term in (chain-terms-of c) do
	  (map-over-oriented-facets								  (map-over-oriented-facets
	   (facet orientation (car term) complex)						   (facet orientation (car term) complex)
	   (setf (gethash facet ht)								   (setf (gethash facet ht)
		 (if orientation									 (if orientation
		     (+ (gethash facet ht zero) (cdr term))						     (+ (gethash facet ht zero) (cdr term))
		   (- (gethash facet ht zero) (cdr term))))))						   (- (gethash facet ht zero) (cdr term))))))
    (maphash #'(lambda(x y) (push (cons x y) pairs)) ht)				    (maphash #'(lambda(x y) (push (cons x y) pairs)) ht)
    (make-chain bd pairs)))								    (make-chain bd pairs)))


;; Takes a boundary (which is chain and returns the list of simplices			;; Takes a boundary (which is chain and returns the list of simplices
;; that make up the boundary.								;; that make up the boundary.
(defmethod boundary-set ((c chain))							(defmethod boundary-set ((c chain))
  (loop for (simp . coef) in (chain-terms-of c)						  (loop for (simp . coef) in (chain-terms-of c)
	with simps = nil									with simps = nil
	do (unless (even? coef)									do (unless (even? coef)
	     (push simp simps))									     (push simp simps))
	   finally (return simps)))								   finally (return simps)))

(defmethod deriv ((ch chain) &rest vars)						(defmethod deriv ((ch chain) &rest vars)
  (make-chain (domain-of ch)								  (make-chain (domain-of ch)
	      (loop for (simp . coef) in (chain-terms-of ch)					      (loop for (simp . coef) in (chain-terms-of ch)
		    for c1 = (apply #'deriv (cons coef vars))						    for c1 = (apply #'deriv (cons coef vars))
		    unless (0? c1)									    unless (0? c1)
		      collect (cons simp c1))))								      collect (cons simp c1))))



;;;COBOUNDARY										;;;COBOUNDARY
(defmethod coboundary ((c cochain) &optional d)						(defmethod coboundary ((c cochain) &optional d)
  (let((pairs nil)									  (let((pairs nil)
       (bd  (if d d (coboundary-domain c)))						       (bd  (if d d (coboundary-domain c)))
       (zero nil)									       (zero nil)
       (ht (make-hash-table))								       (ht (make-hash-table))
       (complex (complex-of c)))							       (complex (complex-of c)))
    											    
    (setf zero (zero(coefficient-domain-of bd)))					    (setf zero (zero(coefficient-domain-of bd)))
	  ;;; use chain-terms-of to take advantage of structural				  ;;; use chain-terms-of to take advantage of structural
	  ;;; isomorphism between finite chains and cochains					  ;;; isomorphism between finite chains and cochains
    (loop for (simp . coef)  in (chain-terms-of c) do					    (loop for (simp . coef)  in (chain-terms-of c) do
	  (map-over-oriented-cofacets								  (map-over-oriented-cofacets
	   (cofacet orientation simp complex)							   (cofacet orientation simp complex)
	   (setf (gethash cofacet ht)								   (setf (gethash cofacet ht)
		 (if orientation									 (if orientation
		     (+ (gethash cofacet ht zero) coef)							     (+ (gethash cofacet ht zero) coef)
		   (- (gethash cofacet ht zero) coef)))))						   (- (gethash cofacet ht zero) coef)))))
    (maphash #'(lambda(x y) (push (cons x y) pairs)) ht)				    (maphash #'(lambda(x y) (push (cons x y) pairs)) ht)
    (make-cochain bd pairs)))								    (make-cochain bd pairs)))


;;;Eventually the duality relationship between chains and cochains			;;;Eventually the duality relationship between chains and cochains
;;;should be taken into account.  For now -- these coersions				;;;should be taken into account.  For now -- these coersions

(defmethod coerce ((chain chain)  (cocm cochain-module))				(defmethod coerce ((chain chain)  (cocm cochain-module))
  (make-cochain cocm (copy-tree (chain-terms-of chain))))				  (make-cochain cocm (copy-tree (chain-terms-of chain))))

(defmethod coerce ((cochain cochain)  (cm chain-module))				(defmethod coerce ((cochain cochain)  (cm chain-module))
  (make-chain cm (copy-tree (chain-terms-of cochain))))					  (make-chain cm (copy-tree (chain-terms-of cochain))))
;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-		;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-
;;; ===========================================================================		;;; ===========================================================================
;;;		       Truncated Power Series Domain					;;;		       Truncated Power Series Domain
;;; ===========================================================================		;;; ===========================================================================
;;; (c) Copyright 1994 Cornell University						;;; (c) Copyright 1994 Cornell University

 											 
(in-package "WEYLI")								    |	(in-package :weyli)

(make::adjust-version-numbers Weyl "1.16")					    |	;;; DELETE (make::adjust-version-numbers Weyl "1.16")

(define-domain-creator tpower-series-ring					    |	(eval-when (:compile-toplevel :load-toplevel)
										    >	  (define-domain-creator tpower-series-ring
		       ((coefficient-domain domain) variable)				      ((coefficient-domain domain) variable)
  (let* ((field? (field? coefficiet-domain))					    |	    (let* ((field? (field? coefficient-domain))
	 (domain									           (domain
	   (make-instance (if field? 'tpower-series-field				            (make-instance (if field? 'tpower-series-field
			      'tpower-series-ring)					                               'tpower-series-ring)
			  :variables (coerce variable *general*)			                           :variables (coerce variable *general*)
			  :coefficient-domain coefficient-domain			                           :coefficient-domain coefficient-domain
			  :print-function (if field? 'tp-field-print-object		                           :print-function (if field? 'tp-field-print-object
					      'tp-ring-print-object))))			                                               'tp-ring-print-object))))
    (make-homomorphism coefficient-domain						      (make-homomorphism coefficient-domain
		       #'(lambda (c) (make-tpower-series domain c))			                         #'(lambda (c) (make-tpower-series domain c))
		       domain)								                         domain)
    domain))									    |	      domain)))

(define-domain-element-classes tpower-series-ring				    |	(eval-when (:compile-toplevel :load-toplevel)
    tpower-series)								    |	  (define-domain-element-classes tpower-series-ring
										    |	    tpower-series))
(define-domain-element-classes tpower-series-field				    |
    tpower-series)								    |	(eval-when (:compile-toplevel :load-toplevel)
										    >	  (define-domain-element-classes tpower-series-field
										    >	    tpower-series))

(defun tp-field-print-object (d stream)							(defun tp-field-print-object (d stream)
  (with-slots (coefficient-domain) d							  (with-slots (coefficient-domain) d
    (format stream "~A((" coefficient-domain)						    (format stream "~A((" coefficient-domain)
    (display (ring-variables d) stream)							    (display (ring-variables d) stream)
    (princ "))" stream)))								    (princ "))" stream)))

(defun tp-ring-print-object (d stream)							(defun tp-ring-print-object (d stream)
  (with-slots (coefficient-domain) d							  (with-slots (coefficient-domain) d
    (format stream "~A[[" coefficient-domain)						    (format stream "~A[[" coefficient-domain)
    (display (ring-variables d) stream)							    (display (ring-variables d) stream)
    (princ "]]" stream)))								    (princ "]]" stream)))

;; GET-TPOWER-SERIES-DOMAIN								;; GET-TPOWER-SERIES-DOMAIN
;;											;;
;; If the coefficient domain is a ring, then construct a TPS which is			;; If the coefficient domain is a ring, then construct a TPS which is
;; also a ring.  If the coefficient domain is a field, construct a TPS			;; also a ring.  If the coefficient domain is a field, construct a TPS
;; which is also a field.								;; which is also a field.
(defun get-tpower-series-domain (cdom variable)						(defun get-tpower-series-domain (cdom variable)
  (let ((gvariable (coerce variable *general*)))					  (let ((gvariable (coerce variable *general*)))
    (cond ((ring? cdom)									    (cond ((ring? cdom)
	   (add-domain #'(lambda (d)								   (add-domain #'(lambda (d)
			   (and (typep d 'tpower-series-ring)							   (and (typep d 'tpower-series-ring)
				(eql (coefficient-domain-of d) cdom)							(eql (coefficient-domain-of d) cdom)
				(equal (ring-variables d) (list gvariable))))						(equal (ring-variables d) (list gvariable))))
	     (make-tpower-series-ring* cdom gvariable)))					     (make-tpower-series-ring* cdom gvariable)))
	  ((field? cdom)									  ((field? cdom)
	   (add-domain #'(lambda (d)								   (add-domain #'(lambda (d)
			   (and (typep d 'tpower-series-ring)							   (and (typep d 'tpower-series-ring)
				(eql (coefficient-domain-of d) cdom)							(eql (coefficient-domain-of d) cdom)
				(equal (ring-variables d) (list gvariable))))						(equal (ring-variables d) (list gvariable))))
	     (make-tpower-series-ring* cdom gvariable)))					     (make-tpower-series-ring* cdom gvariable)))
	  (t (error "~S must be at least a ring" cdom)))))					  (t (error "~S must be at least a ring" cdom)))))

										    >	(defgeneric make-tpower-series (domain series &key &allow-other-keys)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))

;; This is a copy constructor.  It creates a new TPS like the one given as		;; This is a copy constructor.  It creates a new TPS like the one given as
;; a parameter with modifications as indicated by keyword parameters			;; a parameter with modifications as indicated by keyword parameters
(defmethod make-tpower-series ((domain tpower-series-domain) (tp tpower-series)		(defmethod make-tpower-series ((domain tpower-series-domain) (tp tpower-series)
			       &key (valence (valence tp))							       &key (valence (valence tp))
			            (order (order tp))								            (order (order tp))
			            (branch-order (branch-order tp))						            (branch-order (branch-order tp))
			            (coeffs (coeffs tp))							            (coeffs (coeffs tp))
                                    &allow-other-keys)					                                    &allow-other-keys)
  (make-instance 'tpower-series								  (make-instance 'tpower-series
		 :domain domain										 :domain domain
		 :valence valence									 :valence valence
		 :order (max valence order)								 :order (max valence order)
		 :branch-order branch-order								 :branch-order branch-order
		 :coeffs coeffs))									 :coeffs coeffs))

;; Construct a TPS.  Assume the 2nd parameter is a constant and can			;; Construct a TPS.  Assume the 2nd parameter is a constant and can
;; be coerced into the coefficient domain						;; be coerced into the coefficient domain
(defmethod make-tpower-series ((domain tpower-series-domain) coef			(defmethod make-tpower-series ((domain tpower-series-domain) coef
			       &rest options &key &allow-other-keys)						       &rest options &key &allow-other-keys)
  (apply #'make-instance 'tpower-series							  (apply #'make-instance 'tpower-series
		 :domain domain										 :domain domain
		 :coeffs (vector (coerce coef (coefficient-domain-of domain)))				 :coeffs (vector (coerce coef (coefficient-domain-of domain)))
		 options))										 options))

;; Construct a zero valence unit branching order TPS from a list			;; Construct a zero valence unit branching order TPS from a list
;; of coefficients.									;; of coefficients.
(defmethod make-tpower-series ((domain tpower-series-domain) (plist list)		(defmethod make-tpower-series ((domain tpower-series-domain) (plist list)
			       &rest options &key &allow-other-keys)						       &rest options &key &allow-other-keys)
  (let ((coef-domain (coefficient-domain-of domain)))					  (let ((coef-domain (coefficient-domain-of domain)))
    (apply #'make-tpower-series								    (apply #'make-tpower-series
	   domain										   domain
	   (map 'array #'(lambda (e) (coerce e coef-domain))			    |		   (map 'vector #'(lambda (e) (coerce e coef-domain))
		plist)											plist)
	   options)))										   options)))

(defun trim-zeroes (coeffs)								(defun trim-zeroes (coeffs)
  (let ((lead 0)									  (let ((lead 0)
	(trail (length coeffs)))								(trail (length coeffs)))
    (loop for i fixnum below trail							    (loop for i fixnum below trail
	  do (if (0? (svref coeffs i)) (incf lead)						  do (if (0? (svref coeffs i)) (incf lead)
		 (return t)))										 (return t)))
    #+ignore										    #+ignore
    (loop for i fixnum downfrom trail above (1- lead)					    (loop for i fixnum downfrom trail above (1- lead)
	  do (if (0? (svref coeffs i)) (decf trail)						  do (if (0? (svref coeffs i)) (decf trail)
		 (return t))) 										 (return t))) 
    (if (cl:= lead trail) (values (vector (svref coeffs 0)) nil)			    (if (cl:= lead trail) (values (vector (svref coeffs 0)) nil)
	(loop with vect = (make-array (cl:- trail lead))					(loop with vect = (make-array (cl:- trail lead))
	      for i upfrom lead below trail							      for i upfrom lead below trail
	      do (setf (svref vect (cl:- i lead)) (svref coeffs i))				      do (setf (svref vect (cl:- i lead)) (svref coeffs i))
	      finally (return (values vect lead))))))						      finally (return (values vect lead))))))

;; The argument is an array then, the we assume the arguments are			;; The argument is an array then, the we assume the arguments are
;; already coerced into the proper domain.						;; already coerced into the proper domain.
(defmethod make-tpower-series ((domain tpower-series-domain) (terms array) 		(defmethod make-tpower-series ((domain tpower-series-domain) (terms array) 
                                &key (valence 0) (order *positive-infinity*)		                                &key (valence 0) (order *positive-infinity*)
			       (branch-order 1))								       (branch-order 1))
  (multiple-value-bind (ncoeffs shift) (trim-zeroes terms)				  (multiple-value-bind (ncoeffs shift) (trim-zeroes terms)
    (make-instance 'tpower-series							    (make-instance 'tpower-series
		   :domain domain :coeffs ncoeffs							   :domain domain :coeffs ncoeffs
		   :valence (if shift (cl:+ valence shift) 0)						   :valence (if shift (cl:+ valence shift) 0)
		   :order order :branch-order branch-order)))						   :order order :branch-order branch-order)))

(defmethod initialize-instance :after ((d power-series-domain)				(defmethod initialize-instance :after ((d power-series-domain)
				       &rest plist)									       &rest plist)
  (declare (ignore plist))								  (declare (ignore plist))
  (with-slots (zero one coefficient-domain) d						  (with-slots (zero one coefficient-domain) d
    (setq zero (make-tpower-series d (zero coefficient-domain)))			    (setq zero (make-tpower-series d (zero coefficient-domain)))
    (setq one (make-tpower-series d (one coefficient-domain)))))			    (setq one (make-tpower-series d (one coefficient-domain)))))

;;											;;
;; Printing functions									;; Printing functions

;; PRINT-GROUPED									;; PRINT-GROUPED
;; Print n to the stream and parenthesize it if is contains any non-			;; Print n to the stream and parenthesize it if is contains any non-
;; alphanumeric characters.  This seem to be a good heuristic for a			;; alphanumeric characters.  This seem to be a good heuristic for a
;; human comprehensible output form.							;; human comprehensible output form.
(defun print-grouped (n stream)								(defun print-grouped (n stream)
  (let ((str (format nil "~A" n)))							  (let ((str (format nil "~A" n)))
    (if (or (every #'alphanumericp str)							    (if (or (every #'alphanumericp str)
	    (grouped? str #\( #\) )								    (grouped? str #\( #\) )
	    (grouped? str #\[ #\] )								    (grouped? str #\[ #\] )
	    (grouped? str #\{ #\} ))								    (grouped? str #\{ #\} ))
	(princ str stream)									(princ str stream)
	(format stream "(~A)" str))))								(format stream "(~A)" str))))

(defun grouped? (str a b)								(defun grouped? (str a b)
  (let ((last (- (length str) 1)))							  (let ((last (- (length str) 1)))
  (and (char= (char str 0) a )								  (and (char= (char str 0) a )
       (char= (char str (- (length str) 1)) b)						       (char= (char str (- (length str) 1)) b)
       (loop for i from 1 to (- last 1)							       (loop for i from 1 to (- last 1)
	     with depth = 1									     with depth = 1
	     do (cond ((char= (char str i) a) (incf depth))					     do (cond ((char= (char str i) a) (incf depth))
		      ((char= (char str i) b) (decf depth))						      ((char= (char str i) b) (decf depth))
		      (t))										      (t))
		never (= depth 0)))))									never (= depth 0)))))
		     											     

(defun print-exponent (e br stream)							(defun print-exponent (e br stream)
  (if (not (1? (/ e br)))								  (if (not (1? (/ e br)))
      (progn										      (progn
	(princ "^" stream)									(princ "^" stream)
	(print-grouped (/ e br) stream))))							(print-grouped (/ e br) stream))))
        										        
(defun print-tpower-series (var tp stream)						(defun print-tpower-series (var tp stream)
  (labels ((print-term (e c)								  (labels ((print-term (e c)
		       (cond ((0? c)									       (cond ((0? c)
			      (print-object c stream))								      (print-object c stream))
			     ((0? e)										     ((0? e)
			      (print-object c stream))								      (print-object c stream))
			     (t											     (t
			       (if (not (1? c))									       (if (not (1? c))
				   (print-grouped c stream))								   (print-grouped c stream))
			       #+Genera										       #+Genera
			       (format stream "~'i~A~" var)							       (format stream "~'i~A~" var)
			       #-Genera										       #-Genera
			       (display var stream)								       (display var stream)
			       (print-exponent e (branch-order tp) stream)))))					       (print-exponent e (branch-order tp) stream)))))
	  (progn										  (progn
	    (print-term (valence tp) (aref (coeffs tp) 0))					    (print-term (valence tp) (aref (coeffs tp) 0))
	    (loop for exp from (+ (valence tp) 1)						    (loop for exp from (+ (valence tp) 1)
		  with coef										  with coef
		  until (>= (- exp (valence tp))							  until (>= (- exp (valence tp))
				   (array-dimension (coeffs tp) 0)) do							   (array-dimension (coeffs tp) 0)) do
				     (setq coef (aref (coeffs tp)							     (setq coef (aref (coeffs tp)
							  (- exp (valence tp))))								  (- exp (valence tp))))
					 (cond ((0? coef) nil)									 (cond ((0? coef) nil)
					       ((minus? coef) (princ " - " stream)						       ((minus? coef) (princ " - " stream)
						(print-term exp (minus coef)))								(print-term exp (minus coef)))
					       (t (princ " + " stream)								       (t (princ " + " stream)
						  (print-term exp coef))))								  (print-term exp coef))))
	    (if (/= (order tp) *positive-infinity*)						    (if (/= (order tp) *positive-infinity*)
		(progn											(progn
		  (princ " + o(" stream)								  (princ " + o(" stream)
		  (print-term (order tp) 1)								  (print-term (order tp) 1)
		  (princ ")" stream ) )))))								  (princ ")" stream ) )))))

(defmethod print-object ((p tpower-series) stream)					(defmethod print-object ((p tpower-series) stream)
  (print-tpower-series									  (print-tpower-series
     (ring-variables (domain-of p))							     (ring-variables (domain-of p))
     p											     p
     stream))										     stream))

											
;; SPREAD-COEFFS									;; SPREAD-COEFFS
;;											;;
;; Construct a list of coefficients from a TPS but place (b-1) zeros			;; Construct a list of coefficients from a TPS but place (b-1) zeros
;; in between each coefficient of the given TPS.  This is used to			;; in between each coefficient of the given TPS.  This is used to
;; construct a new TPS with a larger branching order from an old TPS.			;; construct a new TPS with a larger branching order from an old TPS.
(defun tps-spread-coeffs (coeffs b)							(defun tps-spread-coeffs (coeffs b)
  (let* ((len (length coeffs))								  (let* ((len (length coeffs))
	 (zed (zero (domain-of (aref coeffs 0))))						 (zed (zero (domain-of (aref coeffs 0))))
	 (rval (make-array (cl:+ (cl:* b (cl:- len 1)) 1))))					 (rval (make-array (cl:+ (cl:* b (cl:- len 1)) 1))))
    (loop for i fixnum from 0 below len							    (loop for i fixnum from 0 below len
	  do (setf (aref rval (cl:* b i)) (aref coeffs i))					  do (setf (aref rval (cl:* b i)) (aref coeffs i))
	     (if (cl:< (1+ i) len)								     (if (cl:< (1+ i) len)
		 (loop for j fixnum from 1 to b								 (loop for j fixnum from 1 to b
		       do (setf (aref rval (cl:+ (cl:* b i) j)) zed)))					       do (setf (aref rval (cl:+ (cl:* b i) j)) zed)))
	  finally (return rval))))								  finally (return rval))))

(eval-when (compile load eval)							    |	(eval-when (:compile-toplevel :load-toplevel :execute)
  (defun tps-var-val (v)								  (defun tps-var-val (v)
    (intern (format nil "~A-VAL" v) (symbol-package v)))				    (intern (format nil "~A-VAL" v) (symbol-package v)))
  											  
  (defun tps-var-bo (v)									  (defun tps-var-bo (v)
    (intern (format nil "~A-BO" v) (symbol-package v)))					    (intern (format nil "~A-BO" v) (symbol-package v)))

  (defun tps-var-order (v)								  (defun tps-var-order (v)
    (intern (format nil "~A-ORDER" v) (symbol-package v)))				    (intern (format nil "~A-ORDER" v) (symbol-package v)))

  (defun tps-var-coeffs (v)								  (defun tps-var-coeffs (v)
    (intern (format nil "~A-COEFFS" v) (symbol-package v)))			    |	    (intern (format nil "~A-COEFFS" v) (symbol-package v))))
  )										    <

(defmacro with-tpower-series (vars-and-tps &body body)					(defmacro with-tpower-series (vars-and-tps &body body)
  (let ((decls nil)									  (let ((decls nil)
	(new-body body))									(new-body body))
    (loop for (form . rest) on body							    (loop for (form . rest) on body
	  while (and (not (atom form))								  while (and (not (atom form))
		     (eql (first form) 'declare))							     (eql (first form) 'declare))
	  do (setq decls (append decls (rest form)))						  do (setq decls (append decls (rest form)))
	     (setq new-body rest))								     (setq new-body rest))
  (setq body new-body)									  (setq body new-body)
  `(let (,@(loop for (var tps) in vars-and-tps 						  `(let (,@(loop for (var tps) in vars-and-tps 
		 append `((,(tps-var-val var) (valence ,tps))						 append `((,(tps-var-val var) (valence ,tps))
			  (,(tps-var-bo var) (branch-order ,tps))						  (,(tps-var-bo var) (branch-order ,tps))
			  (,(tps-var-order var) (order ,tps))							  (,(tps-var-order var) (order ,tps))
			  (,(tps-var-coeffs var) (coeffs ,tps)))))						  (,(tps-var-coeffs var) (coeffs ,tps)))))
     ,@(when decls `((declare ,@decls)))						     ,@(when decls `((declare ,@decls)))
     (macrolet ((set-branch-order (var ord)						     (macrolet ((set-branch-order (var ord)
		  `(progn										  `(progn
		     (setf ,(tps-var-coeffs var)							     (setf ,(tps-var-coeffs var)
			   (tps-spread-coeffs ,(tps-var-coeffs var) ,ord))					   (tps-spread-coeffs ,(tps-var-coeffs var) ,ord))
		     (setf ,(tps-var-order var)								     (setf ,(tps-var-order var)
			   (cl:* ,(tps-var-order var) ,ord))							   (cl:* ,(tps-var-order var) ,ord))
		     (setf ,(tps-var-val var) (cl:* ,(tps-var-val var) ,ord))				     (setf ,(tps-var-val var) (cl:* ,(tps-var-val var) ,ord))
		     (setf ,(tps-var-bo var) (cl:* ,(tps-var-bo var) ,ord))))				     (setf ,(tps-var-bo var) (cl:* ,(tps-var-bo var) ,ord))))
		(tps-rotatef (x y)									(tps-rotatef (x y)
		  `(progn										  `(progn
		     (rotatef ,(tps-var-val x) ,(tps-var-val y))					     (rotatef ,(tps-var-val x) ,(tps-var-val y))
		     (rotatef ,(tps-var-bo x) ,(tps-var-bo y))						     (rotatef ,(tps-var-bo x) ,(tps-var-bo y))
		     (rotatef ,(tps-var-order x) ,(tps-var-order y))					     (rotatef ,(tps-var-order x) ,(tps-var-order y))
		     (rotatef ,(tps-var-coeffs x) ,(tps-var-coeffs y)))))				     (rotatef ,(tps-var-coeffs x) ,(tps-var-coeffs y)))))
       ,@body))))									       ,@body))))


;; MODIFY-BRANCH-ORDER									;; MODIFY-BRANCH-ORDER
										    >
										    >	(defgeneric modify-branch-order (series factor)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
;;											;;
;; Create a new TPS equivalent to the given TPS but with a branchorder			;; Create a new TPS equivalent to the given TPS but with a branchorder
;; larger by a factor.  This is similar to TEMP-MODIFY-BR but the result		;; larger by a factor.  This is similar to TEMP-MODIFY-BR but the result
;; is a "genuine" TPOWER-SERIES whose use need not be temporary.			;; is a "genuine" TPOWER-SERIES whose use need not be temporary.
(defmethod modify-branch-order ((a tpower-series) (factor integer))			(defmethod modify-branch-order ((a tpower-series) (factor integer))
  (if (1? factor)									  (if (1? factor)
      a											      a
      (make-tpower-series (domain-of a)							      (make-tpower-series (domain-of a)
			  (tps-spread-coeffs (coeffs a) factor)							  (tps-spread-coeffs (coeffs a) factor)
			  :valence (* factor (valence a))							  :valence (* factor (valence a))
			  :order (* factor (order a))								  :order (* factor (order a))
			  :branch-order (* factor (branch-order a)))))						  :branch-order (* factor (branch-order a)))))

(defmethod set-branch-order ((a tpower-series) (bo integer))  				(defmethod set-branch-order ((a tpower-series) (bo integer))  
  (cond ((cl:= (branch-order a) bo) 							  (cond ((cl:= (branch-order a) bo) 
	 a)											 a)
	((zerop (rem bo (branch-order a)))							((zerop (rem bo (branch-order a)))
	 (modify-branch-order a (cl:/ bo (branch-order a))))					 (modify-branch-order a (cl:/ bo (branch-order a))))
	(t (error "New branch order must a multiple of old: ~S does not divide ~S"		(t (error "New branch order must a multiple of old: ~S does not divide ~S"
		  (branch-order a) bo))))								  (branch-order a) bo))))

(defsetf branch-order set-branch-order)							(defsetf branch-order set-branch-order)

;; MAP-TPOWER-SERIES									;; MAP-TPOWER-SERIES
;;											;;
;; Create a new TPS by mapping a function onto all the coefficient of			;; Create a new TPS by mapping a function onto all the coefficient of
;; an existing TPS.  This is convenient for computing minus.				;; an existing TPS.  This is convenient for computing minus.
(defun map-tpower-series (tp f)								(defun map-tpower-series (tp f)
  (make-tpower-series (domain-of tp) tp							  (make-tpower-series (domain-of tp) tp
		      :coeffs (map 'array f (coeffs tp))))			    |			      :coeffs (map 'vector f (coeffs tp))))

;; Coercions 										;; Coercions 
(defmethod coerce (elt (domain tpower-series-domain))					(defmethod coerce (elt (domain tpower-series-domain))
  (let ((value (coercible? elt (coefficient-domain-of domain))))			  (let ((value (coercible? elt (coefficient-domain-of domain))))
    (cond ((not (null value))								    (cond ((not (null value))
	   (make-tpower-series domain (vector value)))						   (make-tpower-series domain (vector value)))
	  (t (call-next-method)))))								  (t (call-next-method)))))

(defmethod coerce ((exp (or symbol list)) (domain tpower-series-domain))	    |	(defmethod coerce ((exp symbol) (domain tpower-series-domain))
										    >	  (coerce (coerce exp *general*) domain))
										    >
										    >	(defmethod coerce ((exp list) (domain tpower-series-domain))
  (coerce (coerce exp *general*) domain))						  (coerce (coerce exp *general*) domain))

;; INCOMPLETE!!!									;; INCOMPLETE!!!
#+ignore										#+ignore
(defmethod coerce ((p tpower-series) (d general-expressions))				(defmethod coerce ((p tpower-series) (d general-expressions))
  )											  )

(defmethod coerce ((exp general-expression) (domain tpower-series-domain)) 		(defmethod coerce ((exp general-expression) (domain tpower-series-domain)) 
  (with-slots (variables) domain 							  (with-slots (variables) domain 
    (cond ((ge-equal exp variables)							    (cond ((ge-equal exp variables)
	   (make-tpower-series domain								   (make-tpower-series domain
			       (vector (zero (coefficient-domain-of domain))					       (vector (zero (coefficient-domain-of domain))
				       (one (coefficient-domain-of domain)))))						       (one (coefficient-domain-of domain)))))
	  ((and (ge-atom? exp)									  ((and (ge-atom? exp)
		(let ((var (coercible? exp (coefficient-domain-of domain))))				(let ((var (coercible? exp (coefficient-domain-of domain))))
		  (and var  (make-tpower-series domain (vector var))))))				  (and var  (make-tpower-series domain (vector var))))))
	  ((ge-plus? exp)									  ((ge-plus? exp)
	   (let ((sum (zero domain)))								   (let ((sum (zero domain)))
	     (loop for x in (terms-of exp)							     (loop for x in (terms-of exp)
		   do (setq sum (+ sum (coerce x domain))))						   do (setq sum (+ sum (coerce x domain))))
	     sum))										     sum))
	  ((ge-times? exp)									  ((ge-times? exp)
	   (let ((prod (one domain)))								   (let ((prod (one domain)))
	     (loop for x in (terms-of exp)							     (loop for x in (terms-of exp)
		   do (setq prod (* prod (coerce x domain))))						   do (setq prod (* prod (coerce x domain))))
	     prod))										     prod))
	  ((and (ge-expt? exp)									  ((and (ge-expt? exp)
		(integer? (exponent-of exp)))								(integer? (exponent-of exp)))
	   (expt (coerce (base-of exp) domain) (exponent-of exp)))				   (expt (coerce (base-of exp) domain) (exponent-of exp)))
	  (t (coerce exp (coefficient-domain-of domain))))))					  (t (coerce exp (coefficient-domain-of domain))))))

;; Polynomial coercions									;; Polynomial coercions
;;											;;
;; Since the TPS can represent any polynomial, there is an obvious mapping		;; Since the TPS can represent any polynomial, there is an obvious mapping
;; from a polynomial domain to the power series domain when the variables		;; from a polynomial domain to the power series domain when the variables
;; of the domains are the same.								;; of the domains are the same.
;;											;;
;; The coercion is successful only for upolynomials and univariate			;; The coercion is successful only for upolynomials and univariate
;; mpolyomials										;; mpolyomials
(defmethod coerce ((a upolynomial) (domain tpower-series-domain))			(defmethod coerce ((a upolynomial) (domain tpower-series-domain))
  (if (coercible? a (coefficient-domain-of domain)) (call-next-method)  		  (if (coercible? a (coefficient-domain-of domain)) (call-next-method)  
      (if (not										      (if (not
	    (equal (ring-variables (domain-of a)) (list (ring-variables domain))))		    (equal (ring-variables (domain-of a)) (list (ring-variables domain))))
	  (error "Can't coerce element of ~A into domain ~A." (domain-of a)			  (error "Can't coerce element of ~A into domain ~A." (domain-of a)
		 domain)										 domain)
	  (make-instance 'tpower-series :domain domain						  (make-instance 'tpower-series :domain domain
			 :coeffs (copy-seq (poly-form a))))))							 :coeffs (copy-seq (poly-form a))))))

(defmethod coerce ((a mpolynomial) (domain tpower-series-domain))			(defmethod coerce ((a mpolynomial) (domain tpower-series-domain))
  (if (coercible? a (coefficient-domain-of domain)) (call-next-method)			  (if (coercible? a (coefficient-domain-of domain)) (call-next-method)
      (if (not										      (if (not
	    (equal (ring-variables (domain-of a)) (list (ring-variables domain))))		    (equal (ring-variables (domain-of a)) (list (ring-variables domain))))
	  (error "Can't coerce element of ~A into domain ~A." (domain-of a)			  (error "Can't coerce element of ~A into domain ~A." (domain-of a)
		 domain)										 domain)
	  (let* ((ord (clist-degree (poly-form a)))						  (let* ((ord (clist-degree (poly-form a)))
		 (val (reduce #'(lambda (a b) (min (car a) (car b)))					 (val (reduce #'(lambda (a b) (min (car a) (car b)))
			      (poly-terms (poly-form a))))							      (poly-terms (poly-form a))))
		 (arr (make-array (+ (- ord val) 1) :initial-element					 (arr (make-array (+ (- ord val) 1) :initial-element
				  (zero (coefficient-domain-of domain)))))						  (zero (coefficient-domain-of domain)))))
		(map 'array #'(lambda (a)					    |			(map 'vector #'(lambda (a)
				      (setf (aref arr (- (car a) val)) (cdr a)))					      (setf (aref arr (- (car a) val)) (cdr a)))
		     (poly-terms (poly-form a)))							     (poly-terms (poly-form a)))
		(make-instance 'tpower-series :domain domain						(make-instance 'tpower-series :domain domain
			       :coeffs arr									       :coeffs arr
			       :valence val)))))								       :valence val)))))

;; LARGEST-STORED-COEFF									;; LARGEST-STORED-COEFF
;;											;;
;; Computes the numerator of the largest exponent for which a coefficient		;; Computes the numerator of the largest exponent for which a coefficient
;; is stored in (coeffs tp).								;; is stored in (coeffs tp).
(defmethod largest-stored-coeff ((tp tpower-series))					(defmethod largest-stored-coeff ((tp tpower-series))
  (+ (valence tp)									  (+ (valence tp)
     (- (array-dimension (coeffs tp) 0) 1)))						     (- (array-dimension (coeffs tp) 0) 1)))

;; TRUNCATE-ORDER									;; TRUNCATE-ORDER
;;											;;
;; Truncates the order of a TPS to an integer.  All coefficients with			;; Truncates the order of a TPS to an integer.  All coefficients with
;; exponents greater than the new order are discarded.					;; exponents greater than the new order are discarded.
(defmethod truncate-order ((tp tpower-series) (torder integer))				(defmethod truncate-order ((tp tpower-series) (torder integer))
  (let ((mtorder (* (branch-order tp) torder)))						  (let ((mtorder (* (branch-order tp) torder)))
    (cond ((< mtorder (valence tp))							    (cond ((< mtorder (valence tp))
	   (make-tpower-series (domain-of tp) tp						   (make-tpower-series (domain-of tp) tp
			       :valence mtorder									       :valence mtorder
			       :order mtorder									       :order mtorder
			       :coeffs (vector (zero (coefficient-domain-of					       :coeffs (vector (zero (coefficient-domain-of
						       (domain-of tp))))))								       (domain-of tp))))))
	  ((>= mtorder (order tp)) tp)								  ((>= mtorder (order tp)) tp)
	  ((>= (+ 1 (- mtorder (valence tp)))							  ((>= (+ 1 (- mtorder (valence tp)))
	       (array-dimension (coeffs tp) 0))							       (array-dimension (coeffs tp) 0))
	   (make-tpower-series (domain-of tp) tp						   (make-tpower-series (domain-of tp) tp
			       :order mtorder))									       :order mtorder))
	  (t (make-tpower-series (domain-of tp) tp						  (t (make-tpower-series (domain-of tp) tp
				 :order mtorder										 :order mtorder
				 :coeffs (subseq (coeffs tp)								 :coeffs (subseq (coeffs tp)
						 0											 0
						 (+ 1 (- mtorder (valence tp))))))							 (+ 1 (- mtorder (valence tp))))))

#+ignore										#+ignore
(defsetf order truncate-order)								(defsetf order truncate-order)


;; unary MINUS										;; unary MINUS
;;											;;
(defmethod minus ((tp tpower-series))							(defmethod minus ((tp tpower-series))
  (map-tpower-series tp #'minus))							  (map-tpower-series tp #'minus))

;; PLUS											;; PLUS
;; 											;; 
;; Computes the sum of two TPS.								;; Computes the sum of two TPS.
;; General procedure									;; General procedure
;;    1) make branching orders equal							;;    1) make branching orders equal
;;    2) compute coefficients								;;    2) compute coefficients
;;    3) simplify out zeros								;;    3) simplify out zeros
;;    4) package result									;;    4) package result
(defmethod-sd plus ((a tpower-series) (b tpower-series))				(defmethod-sd plus ((a tpower-series) (b tpower-series))
  (with-tpower-series ((a a) (b b))							  (with-tpower-series ((a a) (b b))
    (let* ((bo (lcm a-bo b-bo))								    (let* ((bo (lcm a-bo b-bo))
	   (zero (zero (coefficient-domain-of domain)))						   (zero (zero (coefficient-domain-of domain)))
	    a-lim b-lim valence order coeffs com)						    a-lim b-lim valence order coeffs com)

      (unless (= a-bo b-bo)								      (unless (= a-bo b-bo)
	(set-branch-order a (/ bo a-bo))							(set-branch-order a (/ bo a-bo))
	(set-branch-order b (/ bo b-bo))) 							(set-branch-order b (/ bo b-bo))) 

      (setq valence (cl:min a-val b-val))						      (setq valence (cl:min a-val b-val))
      (setq order (min a-order b-order))						      (setq order (min a-order b-order))

      (when (< b-val a-val)								      (when (< b-val a-val)
	(tps-rotatef a b))									(tps-rotatef a b))

      (setq com (cl:- b-val a-val))							      (setq com (cl:- b-val a-val))
      											      
      (setq a-lim (length a-coeffs)							      (setq a-lim (length a-coeffs)
	    b-lim (cl:+ com (length b-coeffs)))							    b-lim (cl:+ com (length b-coeffs)))

      (setq coeffs (make-array								      (setq coeffs (make-array
		     (if (integerp order) (cl:- order valence -1)					     (if (integerp order) (cl:- order valence -1)
			 (max (+ a-val (length a-coeffs))							 (max (+ a-val (length a-coeffs))
			      (+ b-val (length b-coeffs))))							      (+ b-val (length b-coeffs))))
		     :initial-element zero))								     :initial-element zero))

      (loop for i fixnum below com							      (loop for i fixnum below com
	    do (setf (svref coeffs i)								    do (setf (svref coeffs i)
		     (if (cl:< i a-lim) (svref a-coeffs i) zero)))					     (if (cl:< i a-lim) (svref a-coeffs i) zero)))

      (loop for i upfrom com below (array-dimension coeffs 0)				      (loop for i upfrom com below (array-dimension coeffs 0)
	    do (setf (svref coeffs i)								    do (setf (svref coeffs i)
		     (+ (if (cl:< i a-lim) (svref a-coeffs i) zero)					     (+ (if (cl:< i a-lim) (svref a-coeffs i) zero)
			(if (cl:< i b-lim) (svref b-coeffs (cl:- i com))					(if (cl:< i b-lim) (svref b-coeffs (cl:- i com))
			    zero))))										    zero))))
      (make-tpower-series domain coeffs							      (make-tpower-series domain coeffs
			  :valence valence :order order :branch-order bo))))					  :valence valence :order order :branch-order bo))))

;; DIFFERENCE										;; DIFFERENCE
;;											;;
;; Use PLUS										;; Use PLUS
(defmethod-sd difference ((a tpower-series) (b tpower-series))				(defmethod-sd difference ((a tpower-series) (b tpower-series))
  (plus a (minus b)))									  (plus a (minus b)))

;; TIMES										;; TIMES
;; 											;; 
;; Computes the product of two TPS.							;; Computes the product of two TPS.
;; General procedure									;; General procedure
;;    1) make branching orders equal							;;    1) make branching orders equal
;;    2) compute coefficients								;;    2) compute coefficients
;;    3) simplify out zeros								;;    3) simplify out zeros
;;    4) package result									;;    4) package result
(defmethod-sd times ((a tpower-series) (b tpower-series))				(defmethod-sd times ((a tpower-series) (b tpower-series))
  (with-tpower-series ((a a) (b b))							  (with-tpower-series ((a a) (b b))
    (let* ((bo (lcm a-bo b-bo)) 							    (let* ((bo (lcm a-bo b-bo)) 
	   (zero (zero (coefficient-domain-of domain)))						   (zero (zero (coefficient-domain-of domain)))
	   valence order coeffs)								   valence order coeffs)

      (unless (= a-bo b-bo)								      (unless (= a-bo b-bo)
	(set-branch-order a (/ bo a-bo))							(set-branch-order a (/ bo a-bo))
	(set-branch-order b (/ bo b-bo)))							(set-branch-order b (/ bo b-bo)))

      (setq valence (cl:+ a-val b-val))							      (setq valence (cl:+ a-val b-val))
      (setq order (cl:+ (min (cl:- a-order a-val)					      (setq order (cl:+ (min (cl:- a-order a-val)
                             (cl:- b-order b-val))					                             (cl:- b-order b-val))
                        valence))							                        valence))
            										            
      (setq coeffs (make-array								      (setq coeffs (make-array
		     (if (integerp order) (cl:- order valence -1)					     (if (integerp order) (cl:- order valence -1)
			 (cl:+ (length a-coeffs) (length b-coeffs) -1))						 (cl:+ (length a-coeffs) (length b-coeffs) -1))
		     :initial-element zero))								     :initial-element zero))

      (loop with n-terms = (array-dimension coeffs 0)					      (loop with n-terms = (array-dimension coeffs 0)
            for i below n-terms								            for i below n-terms
	    with a-lim = (min (length a-coeffs) n-terms)					    with a-lim = (min (length a-coeffs) n-terms)
            and b-lim = (min (length b-coeffs) n-terms)					            and b-lim = (min (length b-coeffs) n-terms)
	    do (loop for j below (1+ i)								    do (loop for j below (1+ i)
                     do (when (and (cl:< j a-lim)					                     do (when (and (cl:< j a-lim)
                                   (cl:< (cl:- i j) b-lim))				                                   (cl:< (cl:- i j) b-lim))
                          (setf (svref coeffs i)					                          (setf (svref coeffs i)
		                (+ (svref coeffs i)							                (+ (svref coeffs i)
                                   (* (svref a-coeffs j)				                                   (* (svref a-coeffs j)
                                      (svref b-coeffs (cl:- i j))))))))			                                      (svref b-coeffs (cl:- i j))))))))
      (make-tpower-series domain coeffs							      (make-tpower-series domain coeffs
			  :valence valence :order order :branch-order bo))))					  :valence valence :order order :branch-order bo))))
;; EXPT											;; EXPT
;;											;;
;; Compute tp^s for a TPS.  The exponent may be a rational-integer, a			;; Compute tp^s for a TPS.  The exponent may be a rational-integer, a
;; rational-number, or a element of the coefficient domain.				;; rational-number, or a element of the coefficient domain.
;;											;;
(defmethod expt ((a tpower-series) k) 							(defmethod expt ((a tpower-series) k) 
  (if (not (or (integerp k) (typep k 'rational-integer)					  (if (not (or (integerp k) (typep k 'rational-integer)
	       (typep k 'ratio) (typep k 'rational-number)					       (typep k 'ratio) (typep k 'rational-number)
               (0? (valence a))))							               (0? (valence a))))
      (call-next-method)								      (call-next-method)
      (with-tpower-series ((a a))							      (with-tpower-series ((a a))
        (let* ((domain (domain-of a))							        (let* ((domain (domain-of a))
               (zero (zero (coefficient-domain-of domain)))				               (zero (zero (coefficient-domain-of domain)))
	       valence order coeffs)								       valence order coeffs)

	  (setq k (convert-to-lisp-number k))							  (setq k (convert-to-lisp-number k))
	      											      
	  (cond ((zerop a-val)									  (cond ((zerop a-val)
		 (setq valence a-val)									 (setq valence a-val)
		 (setq order (cl:+ (cl:- a-order a-val) valence)))					 (setq order (cl:+ (cl:- a-order a-val) valence)))
		((integerp k)										((integerp k)
		 (setq valence (cl:* k a-val))								 (setq valence (cl:* k a-val))
		 (setq order (cl:+ (cl:- a-order a-val) valence)))					 (setq order (cl:+ (cl:- a-order a-val) valence)))
		((typep k 'ratio)									((typep k 'ratio)
		 (set-branch-order a (denominator k))							 (set-branch-order a (denominator k))
		 (setq valence (cl:/ (cl:* (numerator k) a-val)						 (setq valence (cl:/ (cl:* (numerator k) a-val)
				     (denominator k)))									     (denominator k)))
		 (setq order (cl:+ (cl:- a-order a-val) valence)))					 (setq order (cl:+ (cl:- a-order a-val) valence)))
		(t (error "Internal error")))								(t (error "Internal error")))

	  (setq coeffs (make-array								  (setq coeffs (make-array
			 (cond ((integerp order) (cl:- order valence -1))					 (cond ((integerp order) (cl:- order valence -1))
			       ((not (integerp k))								       ((not (integerp k))
				(error "Can't compute ~S ^ ~S"								(error "Can't compute ~S ^ ~S"
				       a k))										       a k))
			       (t (1+ (cl:* k (1- (length a-coeffs))))))					       (t (1+ (cl:* k (1- (length a-coeffs))))))
			 :initial-element zero))								 :initial-element zero))

	  (setf (svref coeffs 0) (expt (svref a-coeffs 0) k))					  (setf (svref coeffs 0) (expt (svref a-coeffs 0) k))

	  (loop with n-terms = (array-dimension coeffs 0)					  (loop with n-terms = (array-dimension coeffs 0)
		and a-lim = (array-dimension a-coeffs 0)						and a-lim = (array-dimension a-coeffs 0)
		for i upfrom 1 below n-terms								for i upfrom 1 below n-terms
		do (loop for j below (1+ i)								do (loop for j below (1+ i)
			 do (setf (svref coeffs i)								 do (setf (svref coeffs i)
				  (+ (svref coeffs i)									  (+ (svref coeffs i)
				     (* (- (* (+ k 1) j) i)								     (* (- (* (+ k 1) j) i)
					(if (cl:< j a-lim) (svref a-coeffs j)							(if (cl:< j a-lim) (svref a-coeffs j)
					    zero)										    zero)
					(svref coeffs (cl:- i j)))))								(svref coeffs (cl:- i j)))))
			 finally (setf (svref coeffs i) 							 finally (setf (svref coeffs i) 
				       (/ (svref coeffs i)								       (/ (svref coeffs i)
					  (* i (svref a-coeffs 0))))))								  (* i (svref a-coeffs 0))))))
	  (make-tpower-series domain coeffs							  (make-tpower-series domain coeffs
			      :valence valence									      :valence valence
			      :order order									      :order order
			      :branch-order a-bo)))))								      :branch-order a-bo)))))

;; QUOTIENT										;; QUOTIENT
;;											;;
;; This is the easy way.  There may be a more efficient way.				;; This is the easy way.  There may be a more efficient way.
(defmethod quotient ((a tpower-series) (b tpower-series))				(defmethod quotient ((a tpower-series) (b tpower-series))
  (* a (expt b -1)))									  (* a (expt b -1)))
;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-		;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-
;;; ===========================================================================		;;; ===========================================================================
;;;			      Univariate Polynomial Domain				;;;			      Univariate Polynomial Domain
;;; ===========================================================================		;;; ===========================================================================
;;; (c) Copyright 1989, 1993 Cornell University						;;; (c) Copyright 1989, 1993 Cornell University

;;; upolynomial.lisp,v 1.6 1994/12/20 22:43:27 sekhar Exp				;;; upolynomial.lisp,v 1.6 1994/12/20 22:43:27 sekhar Exp

(in-package "WEYLI")								    |	(in-package :weyli)
										    <
(make::adjust-version-numbers Weyl "1.6")					    <

										    >	;;; DELETE (make::adjust-version-numbers Weyl "1.6")

;;; ===========================================================================		;;; ===========================================================================
;;;			       Univariate Polynomial Elements				;;;			       Univariate Polynomial Elements
;;; ===========================================================================		;;; ===========================================================================

;;; Univariate polynomials are a vector of coefficients, with the degree		;;; Univariate polynomials are a vector of coefficients, with the degree
;;; of the term equal to the index in the vector.  (I.e. the leftmost			;;; of the term equal to the index in the vector.  (I.e. the leftmost
;;; coefficient is for the x^0 term, and the rightmost for the x^n term).		;;; coefficient is for the x^0 term, and the rightmost for the x^n term).
;;; We explicitly assume that the rightmost coefficient is non-zero,			;;; We explicitly assume that the rightmost coefficient is non-zero,
;;; unless it is a zero-degree polynomial.						;;; unless it is a zero-degree polynomial.
;;; Unlike multivariate polynomials, even a zero-degree polynomial will			;;; Unlike multivariate polynomials, even a zero-degree polynomial will
;;; be represented as a (singleton) vector.  Right now I can't see any			;;; be represented as a (singleton) vector.  Right now I can't see any
;;; reason to allow a coefficient as a polynomial.					;;; reason to allow a coefficient as a polynomial.
;;; The coef-list vector should never have length 0.					;;; The coef-list vector should never have length 0.

;;; In many places this code assumes that the coefficient domain is an			;;; In many places this code assumes that the coefficient domain is an
;;; integral domain.  In the remainder code it assumes the coefficient			;;; integral domain.  In the remainder code it assumes the coefficient
;;; domain is a field.									;;; domain is a field.

(defmethod scalar? ((x upolynomial))							(defmethod scalar? ((x upolynomial))
  (= 1 (length (poly-form x))))								  (= 1 (length (poly-form x))))

(defmethod 0? ((x upolynomial))								(defmethod 0? ((x upolynomial))
  (coef-list0? (poly-form x)))								  (coef-list0? (poly-form x)))
  											  
(defsubst coef-list0? (c)								(defsubst coef-list0? (c)
  (and (= 1 (length c))									  (and (= 1 (length c))
       (0? (svref c 0))))								       (0? (svref c 0))))

(defmacro coef-list0 (coefficient-domain)						(defmacro coef-list0 (coefficient-domain)
  `(vector (zero ,coefficient-domain)))							  `(vector (zero ,coefficient-domain)))

(defmethod 1? ((x upolynomial))								(defmethod 1? ((x upolynomial))
  (coef-list1? (poly-form x)))								  (coef-list1? (poly-form x)))

(defsubst coef-list1? (c)								(defsubst coef-list1? (c)
  (and (= 1 (length c))									  (and (= 1 (length c))
       (1? (svref c 0))))								       (1? (svref c 0))))

(defmacro coef-list1 (coefficient-domain)						(defmacro coef-list1 (coefficient-domain)
  `(vector (one ,coefficient-domain)))    						  `(vector (one ,coefficient-domain)))    

;; This produces the polynomial 'x+0' where x is the variable of the ring		;; This produces the polynomial 'x+0' where x is the variable of the ring
(defmacro clist-x (coefficient-domain)							(defmacro clist-x (coefficient-domain)
  `(vector (zero ,coefficient-domain) (one ,coefficient-domain)))			  `(vector (zero ,coefficient-domain) (one ,coefficient-domain)))

(defmacro copy-clist (c)								(defmacro copy-clist (c)
  `(make-array (length ,c) :initial-contents ,c))					  `(make-array (length ,c) :initial-contents ,c))

(defmacro clist-degree (c)								(defmacro clist-degree (c)
  `(cl:- (length ,c) 1))								  `(cl:- (length ,c) 1))

;; Need the variable argument here because all degree methods need the			;; Need the variable argument here because all degree methods need the
;; same number of required arguments.							;; same number of required arguments.
(defmethod degree ((x upolynomial) variable &rest other-variables)			(defmethod degree ((x upolynomial) variable &rest other-variables)
  (declare (ignore variable other-variables))						  (declare (ignore variable other-variables))
  (clist-degree (poly-form x)))								  (clist-degree (poly-form x)))

(defmacro clist-zero-deg? (c)								(defmacro clist-zero-deg? (c)
  `(cl:= (length ,c) 1))								  `(cl:= (length ,c) 1))

(defmacro clist-length (c)     ; Always 1 more than clist-degree, of course.		(defmacro clist-length (c)     ; Always 1 more than clist-degree, of course.
  `(length ,c))										  `(length ,c))

(defmacro make-clist (length &rest args)						(defmacro make-clist (length &rest args)
  `(make-array ,length ,@args))								  `(make-array ,length ,@args))

(defmacro clist-get (cl exp)								(defmacro clist-get (cl exp)
  `(svref ,cl ,exp))									  `(svref ,cl ,exp))

(defmacro clist-subseq (cl beg end)							(defmacro clist-subseq (cl beg end)
  `(subseq ,cl ,beg ,end))								  `(subseq ,cl ,beg ,end))

										    >	(defgeneric weyl::make-upolynomial (domain coef-list)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod weyl::make-upolynomial							(defmethod weyl::make-upolynomial
    ((domain multivariate-polynomial-ring) (coef-list array))				    ((domain multivariate-polynomial-ring) (coef-list array))
  (unless (null (rest (ring-variables domain)))						  (unless (null (rest (ring-variables domain)))
    (error "Cannot create a univariate polynomial in ~S" domain))			    (error "Cannot create a univariate polynomial in ~S" domain))
  (let ((coef-domain (coefficient-domain-of domain)))					  (let ((coef-domain (coefficient-domain-of domain)))
    (loop for i fixnum below (array-dimension coef-list 0)				    (loop for i fixnum below (array-dimension coef-list 0)
	  do (setf (svref coef-list i)								  do (setf (svref coef-list i)
		   (coerce (svref coef-list i) coef-domain)))						   (coerce (svref coef-list i) coef-domain)))
    (make-instance 'upolynomial :domain domain 						    (make-instance 'upolynomial :domain domain 
		   :form (clist-simplify coef-list))))							   :form (clist-simplify coef-list))))

										    >	(defgeneric make-upolynomial (domain coef-list)
										    >	  (:documentation
										    >	   "The purpose of this function is unknown."))
										    >
(defmethod make-upolynomial								(defmethod make-upolynomial
    ((domain multivariate-polynomial-ring) (coef-list array))				    ((domain multivariate-polynomial-ring) (coef-list array))
  (unless (null (rest (ring-variables domain)))						  (unless (null (rest (ring-variables domain)))
    (error "Cannot create a univariate polynomial in ~S" domain))			    (error "Cannot create a univariate polynomial in ~S" domain))
  (make-instance 'upolynomial :domain domain 						  (make-instance 'upolynomial :domain domain 
		 :form (clist-simplify coef-list)))							 :form (clist-simplify coef-list)))

(defmethod weyl::make-upolynomial							(defmethod weyl::make-upolynomial
    ((domain multivariate-polynomial-ring) (coef-list list))				    ((domain multivariate-polynomial-ring) (coef-list list))
  (unless (null (rest (ring-variables domain)))						  (unless (null (rest (ring-variables domain)))
    (error "Cannot create a univariate polynomial in ~S" domain))			    (error "Cannot create a univariate polynomial in ~S" domain))
  (let* ((len (length coef-list))							  (let* ((len (length coef-list))
	 (array (make-array len))								 (array (make-array len))
	 (coef-domain (coefficient-domain-of domain)))						 (coef-domain (coefficient-domain-of domain)))
    (loop for i downfrom (1- len)							    (loop for i downfrom (1- len)
	  and #-ANSI-CL for c in coef-list							  and #-ANSI-CL for c in coef-list
	  do (setf (svref array i) (coerce c coef-domain)))					  do (setf (svref array i) (coerce c coef-domain)))
    (make-instance 'upolynomial :domain domain 						    (make-instance 'upolynomial :domain domain 
		   :form array)))									   :form array)))

(defmethod make-upolynomial								(defmethod make-upolynomial
    ((domain multivariate-polynomial-ring) (coef-list list))				    ((domain multivariate-polynomial-ring) (coef-list list))
  (unless (null (rest (ring-variables domain)))						  (unless (null (rest (ring-variables domain)))
    (error "Cannot create a univariate polynomial in ~S" domain))			    (error "Cannot create a univariate polynomial in ~S" domain))
  (make-instance 'upolynomial :domain domain 						  (make-instance 'upolynomial :domain domain 
                 :form (clist-simplify							                 :form (clist-simplify
			(make-array (length coef-list)								(make-array (length coef-list)
				    :initial-contents (reverse coef-list)))))						    :initial-contents (reverse coef-list)))))

(defmethod make-upolynomial ((domain multivariate-polynomial-ring) coef-list)		(defmethod make-upolynomial ((domain multivariate-polynomial-ring) coef-list)
  (unless (null (rest (ring-variables domain)))						  (unless (null (rest (ring-variables domain)))
    (error "Cannot create a univariate polynomial in ~S" domain))			    (error "Cannot create a univariate polynomial in ~S" domain))
  (make-instance 'upolynomial :domain domain 						  (make-instance 'upolynomial :domain domain 
                 :form (clist-simplify coef-list)))					                 :form (clist-simplify coef-list)))

(defmethod make-upolynomial								(defmethod make-upolynomial
    ((domain multivariate-polynomial-ring) (poly mpolynomial))				    ((domain multivariate-polynomial-ring) (poly mpolynomial))
  (let* ((var (car (ring-variables (domain-of poly))))					  (let* ((var (car (ring-variables (domain-of poly))))
	 (form (poly-form poly))								 (form (poly-form poly))
	 (coef-list (make-array (1+ (degree poly var))						 (coef-list (make-array (1+ (degree poly var))
				:initial-element									:initial-element
				(zero (coefficient-domain-of domain)))))						(zero (coefficient-domain-of domain)))))
	(if (poly-coef? form)									(if (poly-coef? form)
	    (setf (svref coef-list 0) form)							    (setf (svref coef-list 0) form)
	    (map-over-each-term (poly-terms form) (e c)						    (map-over-each-term (poly-terms form) (e c)
	      (setf (svref coef-list e) c)))							      (setf (svref coef-list e) c)))
       (make-upolynomial domain coef-list)))						       (make-upolynomial domain coef-list)))

											
(defmethod print-object ((p upolynomial) stream)					(defmethod print-object ((p upolynomial) stream)
  (print-upolynomial 									  (print-upolynomial 
     (first (ring-variables (domain-of p)))						     (first (ring-variables (domain-of p)))
     (poly-form p)									     (poly-form p)
     stream))										     stream))

;; This is still rough with spacing, parenthesis, etc.					;; This is still rough with spacing, parenthesis, etc.
(defun print-upolynomial (var clist stream)						(defun print-upolynomial (var clist stream)
  (labels ((print-term (e c)								  (labels ((print-term (e c)
             (cond ((cl:= e 0)								             (cond ((cl:= e 0)
                    (print-object c stream))						                    (print-object c stream))
                   (t									                   (t
		    (if (not (1? c))									    (if (not (1? c))
			(print-object c stream))								(print-object c stream))
		    #+Genera										    #+Genera
		    (format stream "~'i~A~" var)							    (format stream "~'i~A~" var)
		    #-Genera										    #-Genera
		    (display var stream)								    (display var stream)
		    (if (cl:> e 1)									    (if (cl:> e 1)
			#+Genera										#+Genera
			(format stream "~S" e)									(format stream "~S" e)
			#-Genera										#-Genera
			(format stream "^~S" e))))))								(format stream "^~S" e))))))
    (let ((exp (clist-degree clist))							    (let ((exp (clist-degree clist))
          coef)										          coef)
      (print-term exp (clist-get clist exp))						      (print-term exp (clist-get clist exp))
      (loop until (cl:zerop exp) do							      (loop until (cl:zerop exp) do
	(setq exp (- exp 1))									(setq exp (- exp 1))
	(setq coef (clist-get clist exp))							(setq coef (clist-get clist exp))
	(cond ((0? coef) nil)									(cond ((0? coef) nil)
	      ((minus? coef)									      ((minus? coef)
	       (princ " - " stream)								       (princ " - " stream)
	       (print-term exp (minus coef)))							       (print-term exp (minus coef)))
	      (t (princ " + " stream)								      (t (princ " + " stream)
		 (print-term exp coef)))))))								 (print-term exp coef)))))))
											
;;; ===========================================================================		;;; ===========================================================================
;;;				    POLYNOMIAL ARITHMETIC				;;;				    POLYNOMIAL ARITHMETIC
;;; ===========================================================================		;;; ===========================================================================

(defmethod coerce ((poly upolynomial) (domain general-expressions))			(defmethod coerce ((poly upolynomial) (domain general-expressions))
  (let* ((var (car (ring-variables (domain-of poly))))					  (let* ((var (car (ring-variables (domain-of poly))))
	 (form (poly-form poly)))								 (form (poly-form poly)))
	(loop for i below (length form) with exp = 0						(loop for i below (length form) with exp = 0
	      unless (0? (svref form i))							      unless (0? (svref form i))
		do (setq exp (+ exp (* (svref form i)							do (setq exp (+ exp (* (svref form i)
				       (make-ge-expt domain var i))))							       (make-ge-expt domain var i))))
	      finally										      finally
	   (return exp))))									   (return exp))))

;; Make sure the highest degree coefficient is non-zero					;; Make sure the highest degree coefficient is non-zero
(defun clist-simplify (c)								(defun clist-simplify (c)
  (let ((end (clist-degree c)))								  (let ((end (clist-degree c)))
    (if (or (cl:= end 0)								    (if (or (cl:= end 0)
            (not (0? (clist-get c end))))						            (not (0? (clist-get c end))))
        c										        c
        (loop										        (loop
          (setq end (- end 1))								          (setq end (- end 1))
          (if (or (not (0? (clist-get c end)))						          (if (or (not (0? (clist-get c end)))
                  (cl:= end 0))								                  (cl:= end 0))
              (return (clist-subseq c 0 (+ end 1)))					              (return (clist-subseq c 0 (+ end 1)))
              nil)))))									              nil)))))

(defmethod-sd plus ((x upolynomial) (y upolynomial))					(defmethod-sd plus ((x upolynomial) (y upolynomial))
  (make-upolynomial (domain-of x)							  (make-upolynomial (domain-of x)
		    (clist-plus (poly-form x) (poly-form y))))				                    (clist-plus (poly-form x) (poly-form y))))

(defun clist-plus (x y)									(defun clist-plus (x y)
  (declare (type simple-array x y)						    <
	   (optimize (safety 0)))						    <
  (let ((x-deg (clist-degree x))							  (let ((x-deg (clist-degree x))
	(y-deg (clist-degree y))								(y-deg (clist-degree y))
	array											array
	exp)											exp)
    (declare (fixnum x-deg y-deg)						    <
	     (type simple-array array))						    <
    (flet ((zipper-sum ()								    (flet ((zipper-sum ()
	     (loop for i downfrom exp								     (loop for i downfrom exp
		   while (not (cl:minusp i))								   while (not (cl:minusp i))
		   do (setf (svref array i) (+ (svref x i) (svref y i))))))				   do (setf (svref array i) (+ (svref x i) (svref y i))))))

      (cond ((cl:> x-deg y-deg)								      (cond ((cl:> x-deg y-deg)
	     (setq array (make-array (cl:1+ x-deg)))						     (setq array (make-array (cl:1+ x-deg)))
	     (setq exp y-deg)									     (setq exp y-deg)
	     (loop for i fixnum downfrom x-deg							     (loop for i fixnum downfrom x-deg
		   while (cl:>= i y-deg)								   while (cl:>= i y-deg)
		   do (setf (svref array i) (svref x i)))						   do (setf (svref array i) (svref x i)))
	     (zipper-sum))									     (zipper-sum))
	    ((cl:> y-deg x-deg)									    ((cl:> y-deg x-deg)
	     (setq array (make-array (cl:1+ y-deg)))						     (setq array (make-array (cl:1+ y-deg)))
	     (setq exp x-deg)									     (setq exp x-deg)
	     (loop for i downfrom y-deg								     (loop for i downfrom y-deg
		   while (cl:>= i x-deg)								   while (cl:>= i x-deg)
		   do (setf (svref array i) (svref y i)))						   do (setf (svref array i) (svref y i)))
	     (zipper-sum))									     (zipper-sum))
	    (t (loop for i fixnum downfrom x-deg						    (t (loop for i fixnum downfrom x-deg
		     do 										     do 
		      (cond ((cl:minusp i)								      (cond ((cl:minusp i)
			     (setq array (make-array 1))							     (setq array (make-array 1))
			     (setf (svref array 0)								     (setf (svref array 0)
				   (zero *coefficient-domain*)))							   (zero *coefficient-domain*)))
			    ((not (0? (+ (svref x i) (svref y i))))						    ((not (0? (+ (svref x i) (svref y i))))
			     (setq exp i)									     (setq exp i)
			     (setq array (make-array (cl:1+ exp)))						     (setq array (make-array (cl:1+ exp)))
			     (zipper-sum)									     (zipper-sum)
			     (return t))))))									     (return t))))))
      array)))										      array)))

(defmethod minus ((x upolynomial))							(defmethod minus ((x upolynomial))
  (make-upolynomial (domain-of x) (clist-minus (poly-form x))))				  (make-upolynomial (domain-of x) (clist-minus (poly-form x))))

(defun clist-minus (x)									(defun clist-minus (x)
  (do ((anslist (make-clist (clist-length x)))						  (do ((anslist (make-clist (clist-length x)))
       (exp 0 (+ exp 1)))								       (exp 0 (+ exp 1)))
      ((cl:= exp (clist-length x)) 							      ((cl:= exp (clist-length x)) 
       anslist)										       anslist)
    (setf (clist-get anslist exp) (minus (clist-get x exp)))))				    (setf (clist-get anslist exp) (minus (clist-get x exp)))))

(defmethod minus? ((x upolynomial))							(defmethod minus? ((x upolynomial))
    (clist-minus? (poly-form x)))							    (clist-minus? (poly-form x)))

(defun clist-minus? (x)									(defun clist-minus? (x)
  (minus? (clist-get x (clist-degree x))))						  (minus? (clist-get x (clist-degree x))))

(defmethod-sd difference ((x upolynomial) (y upolynomial))				(defmethod-sd difference ((x upolynomial) (y upolynomial))
  (bind-domain-context (domain-of x)							  (bind-domain-context (domain-of x)
    (make-upolynomial (domain-of x) 							    (make-upolynomial (domain-of x) 
		      (clist-difference (poly-form x) (poly-form y)))))					      (clist-difference (poly-form x) (poly-form y)))))
                                                  					                                                  
(defun clist-difference (x y)								(defun clist-difference (x y)
  (declare (type simple-array x y)						    <
	   (optimize (safety 0)))						    <
  (let ((x-deg (clist-degree x))							  (let ((x-deg (clist-degree x))
	(y-deg (clist-degree y))								(y-deg (clist-degree y))
	array											array
	exp)											exp)
    (declare (fixnum x-deg y-deg)						    <
	     (type simple-array array))						    <
    (flet ((zipper-sum ()								    (flet ((zipper-sum ()
	     (loop for i downfrom exp								     (loop for i downfrom exp
		   while (not (cl:minusp i))								   while (not (cl:minusp i))
		   do (setf (svref array i) (- (svref x i) (svref y i))))))				   do (setf (svref array i) (- (svref x i) (svref y i))))))

      (cond ((cl:> x-deg y-deg)								      (cond ((cl:> x-deg y-deg)
	     (setq array (make-array (cl:1+ x-deg)))						     (setq array (make-array (cl:1+ x-deg)))
	     (setq exp y-deg)									     (setq exp y-deg)
	     (loop for i fixnum downfrom x-deg							     (loop for i fixnum downfrom x-deg
		   while (cl:>= i y-deg)								   while (cl:>= i y-deg)
		   do (setf (svref array i) (svref x i)))						   do (setf (svref array i) (svref x i)))
	     (zipper-sum))									     (zipper-sum))
	    ((cl:> y-deg x-deg)									    ((cl:> y-deg x-deg)
	     (setq array (make-array (cl:1+ y-deg)))						     (setq array (make-array (cl:1+ y-deg)))
	     (setq exp x-deg)									     (setq exp x-deg)
	     (loop for i downfrom y-deg								     (loop for i downfrom y-deg
		   while (cl:>= i x-deg)								   while (cl:>= i x-deg)
		   do (setf (svref array i) (- (svref y i))))						   do (setf (svref array i) (- (svref y i))))
	     (zipper-sum))									     (zipper-sum))
	    (t (loop for i fixnum downfrom x-deg do 						    (t (loop for i fixnum downfrom x-deg do 
	         (cond ((cl:minusp i)								         (cond ((cl:minusp i)
			(setq array (make-array 1))								(setq array (make-array 1))
			(setf (svref array 0)									(setf (svref array 0)
			      (zero *coefficient-domain*))							      (zero *coefficient-domain*))
			(return t))										(return t))
		       ((not (0? (- (svref x i) (svref y i))))						       ((not (0? (- (svref x i) (svref y i))))
			(setq exp i)										(setq exp i)
			(setq array (make-array (cl:1+ exp)))							(setq array (make-array (cl:1+ exp)))
			(zipper-sum)										(zipper-sum)
			(return t))))))										(return t))))))
      array)))										      array)))

(defmethod-sd times ((x upolynomial) (y upolynomial))					(defmethod-sd times ((x upolynomial) (y upolynomial))
  (make-upolynomial (domain-of x) 							  (make-upolynomial (domain-of x) 
		    (clist-times (poly-form x) (poly-form y))))						    (clist-times (poly-form x) (poly-form y))))

(defun clist-times (x y)								(defun clist-times (x y)
  (declare (type simple-array x y)							  (declare (type simple-array x y)
	   (optimize (safety 0)))								   (optimize (safety 0)))
  (let* ((xlen (clist-length x))							  (let* ((xlen (clist-length x))
         (ylen (clist-length y))							         (ylen (clist-length y))
         (anslist (make-array (cl:- (the fixnum (cl:+ xlen ylen)) 1)			         (anslist (make-array (cl:- (the fixnum (cl:+ xlen ylen)) 1)
			      :initial-element (zero *coefficient-domain*))))					      :initial-element (zero *coefficient-domain*))))
    (declare (fixnum xlen ylen)								    (declare (fixnum xlen ylen)
	     (type simple-array anslist))							     (type simple-array anslist))
    (do ((xexp 0 (cl:+ xexp 1)))							    (do ((xexp 0 (cl:+ xexp 1)))
        ((cl:= xexp xlen)								        ((cl:= xexp xlen)
         anslist)                        ; return this when done			         anslist)                        ; return this when done
      (declare (fixnum xexp))								      (declare (fixnum xexp))
      (do ((xelt (clist-get x xexp) )							      (do ((xelt (clist-get x xexp) )
           (yexp 0 (cl:+ yexp 1))							           (yexp 0 (cl:+ yexp 1))
           (ansexp xexp (cl:+ ansexp 1)))						           (ansexp xexp (cl:+ ansexp 1)))
          ((cl:= yexp ylen))								          ((cl:= yexp ylen))
	(declare (fixnum yexp ansexp))								(declare (fixnum yexp ansexp))
        (setf (clist-get anslist ansexp)						        (setf (clist-get anslist ansexp)
              (+ (clist-get anslist ansexp)						              (+ (clist-get anslist ansexp)
		 (* xelt (clist-get y yexp))))))))							 (* xelt (clist-get y yexp))))))))

;;; In CLIST-EXPT the second argument is a repetition count, and thus			;;; In CLIST-EXPT the second argument is a repetition count, and thus
;;; is actually an integer.								;;; is actually an integer.

(defmethod expt ((base upolynomial) (expt integer))					(defmethod expt ((base upolynomial) (expt integer))
  (bind-domain-context (domain-of base)							  (bind-domain-context (domain-of base)
    (make-upolynomial (domain-of base)							    (make-upolynomial (domain-of base)
		      (clist-exptsq (poly-form base) expt))))						      (clist-exptsq (poly-form base) expt))))

(defun clist-exptsq (c n)								(defun clist-exptsq (c n)
  (%funcall (repeated-squaring #'clist-times (coef-list1 *coefficient-domain*))		  (%funcall (repeated-squaring #'clist-times (coef-list1 *coefficient-domain*))
           c n))									           c n))

;; This assumes the coefficient domain is a field					;; This assumes the coefficient domain is a field
(defmethod-sd quotient ((x upolynomial) (y upolynomial))				(defmethod-sd quotient ((x upolynomial) (y upolynomial))
  (bind-domain-context (domain-of x)							  (bind-domain-context (domain-of x)
    (make-upolynomial (domain-of x)							    (make-upolynomial (domain-of x)
		      (clist-quotient (poly-form x) (poly-form y)))))					      (clist-quotient (poly-form x) (poly-form y)))))

(defun clist-quotient (x y)								(defun clist-quotient (x y)
  (cond ((coef-list0? y)								  (cond ((coef-list0? y)
         (error "Attempt to divide ~S by zero univariate polynomial ~S" x y))		         (error "Attempt to divide ~S by zero univariate polynomial ~S" x y))
        ((cl:> (clist-degree y) (clist-degree x))					        ((cl:> (clist-degree y) (clist-degree x))
         (error "Attempt to divide ~S by uni. poly. of higher degree ~S" x y))		         (error "Attempt to divide ~S by uni. poly. of higher degree ~S" x y))
        (t										        (t
         (multiple-value-bind (q r) (clist-divide x y)					         (multiple-value-bind (q r) (clist-divide x y)
           (if (coef-list0? r) 								           (if (coef-list0? r) 
               q									               q
               (error "Quotient of ~S, and ~S not exact" x y))))))			               (error "Quotient of ~S, and ~S not exact" x y))))))

(defmethod-sd remainder ((x upolynomial) (y upolynomial))				(defmethod-sd remainder ((x upolynomial) (y upolynomial))
  (bind-domain-context (domain-of x)							  (bind-domain-context (domain-of x)
    (make-upolynomial (domain-of x)							    (make-upolynomial (domain-of x)
		      (clist-remainder (poly-form x) (poly-form y)))))					      (clist-remainder (poly-form x) (poly-form y)))))

(defun clist-remainder (x y)								(defun clist-remainder (x y)
  (cond ((coef-list0? y)								  (cond ((coef-list0? y)
         (error "Attempt to divide ~S by zero univariate polynomial ~S" x y))		         (error "Attempt to divide ~S by zero univariate polynomial ~S" x y))
        (t										        (t
         (multiple-value-bind (q r) (clist-divide x y)					         (multiple-value-bind (q r) (clist-divide x y)
	   (declare (ignore q))									   (declare (ignore q))
           r))))									           r))))
         										         
;; This could be improved.  clist-divide should be merged with				;; This could be improved.  clist-divide should be merged with
;; clist-remainder and clist-quotient.  That way we wouldn't be				;; clist-remainder and clist-quotient.  That way we wouldn't be
;; generating a remainder whe we only want a quotient and vice versa.			;; generating a remainder whe we only want a quotient and vice versa.
;; --RZ (FIXTHIS)									;; --RZ (FIXTHIS)

(defun clist-divide (x y)								(defun clist-divide (x y)
  (cond ((coef-list0? y)								  (cond ((coef-list0? y)
         (error "Attempt to divide by zero univariate polynomial ~S" y))		         (error "Attempt to divide by zero univariate polynomial ~S" y))
        ((coef-list1? y)								        ((coef-list1? y)
         (values x (coef-list0 *coefficient-domain*)))					         (values x (coef-list0 *coefficient-domain*)))
        ((cl:> (clist-degree y) (clist-degree x))					        ((cl:> (clist-degree y) (clist-degree x))
         (values (coef-list0 *coefficient-domain*) x))					         (values (coef-list0 *coefficient-domain*) x))
        (t										        (t
         (let* ((xdeg (clist-degree x))							         (let* ((xdeg (clist-degree x))
                (ydeg (clist-degree y))							                (ydeg (clist-degree y))
                (yhigh (clist-get y ydeg))						                (yhigh (clist-get y ydeg))
                (qdeg (cl:- xdeg ydeg))							                (qdeg (cl:- xdeg ydeg))
                (rem (copy-clist x))							                (rem (copy-clist x))
                (quot (make-clist (cl:+ qdeg 1))))					                (quot (make-clist (cl:+ qdeg 1))))
           (do* ((qexp qdeg (cl:- qexp 1)))						           (do* ((qexp qdeg (cl:- qexp 1)))
                ((cl:= qexp -1)								                ((cl:= qexp -1)
                 (values quot (clist-simplify rem)))					                 (values quot (clist-simplify rem)))
             (let ((c (/ (clist-get rem (cl:+ ydeg qexp)) yhigh)))			             (let ((c (/ (clist-get rem (cl:+ ydeg qexp)) yhigh)))
               (setf (clist-get quot qexp) c)						               (setf (clist-get quot qexp) c)
               (do ((yexp ydeg (- yexp 1)))						               (do ((yexp ydeg (- yexp 1)))
                   ((cl:= yexp -1))							                   ((cl:= yexp -1))
                 (setf (clist-get rem (+ yexp qexp))					                 (setf (clist-get rem (+ yexp qexp))
                            (- (clist-get rem (+ yexp qexp))				                            (- (clist-get rem (+ yexp qexp))
			       (* c (clist-get y yexp)))))))))))						       (* c (clist-get y yexp)))))))))))

;;; This gcd uses Euclid's algorithm and the above remainder function.			;;; This gcd uses Euclid's algorithm and the above remainder function.
(defmethod-sd binary-gcd ((x upolynomial) (y upolynomial))				(defmethod-sd binary-gcd ((x upolynomial) (y upolynomial))
  (bind-domain-context (domain-of x)							  (bind-domain-context (domain-of x)
    (make-upolynomial (domain-of x)							    (make-upolynomial (domain-of x)
		      (clist-gcd (poly-form x) (poly-form y)))))					      (clist-gcd (poly-form x) (poly-form y)))))

(defun clist-gcd (x y)									(defun clist-gcd (x y)
  (do ((a x b)										  (do ((a x b)
       (b y (clist-remainder a b)))							       (b y (clist-remainder a b)))
      ((coef-list0? b)									      ((coef-list0? b)
       a)										       a)
    ))											    ))

(defmethod-sd binary-lcm ((x upolynomial) (y upolynomial))				(defmethod-sd binary-lcm ((x upolynomial) (y upolynomial))
  (bind-domain-context (domain-of x)							  (bind-domain-context (domain-of x)
    (make-upolynomial (domain-of x)							    (make-upolynomial (domain-of x)
		      (clist-lcm (poly-form x) (poly-form y)))))					      (clist-lcm (poly-form x) (poly-form y)))))

(defun clist-lcm (x y)									(defun clist-lcm (x y)
  (clist-times (clist-quotient x (clist-gcd x y)) y))					  (clist-times (clist-quotient x (clist-gcd x y)) y))

;; Compute the gcd d of a,b and upolynomials x,y such that ax + by = d.			;; Compute the gcd d of a,b and upolynomials x,y such that ax + by = d.
;; This method works for univariate polynomial ring over a field.			;; This method works for univariate polynomial ring over a field.
(defmethod extended-gcd ((a upolynomial) (b upolynomial))				(defmethod extended-gcd ((a upolynomial) (b upolynomial))
  (let ((domain (domain-of a)))								  (let ((domain (domain-of a)))
       (setq *coefficient-domain* (coefficient-domain-of domain))       		       (setq *coefficient-domain* (coefficient-domain-of domain))       
       (multiple-value-bind								       (multiple-value-bind
	   (d x y) (clist-extended-gcd (poly-form a) (poly-form b))				   (d x y) (clist-extended-gcd (poly-form a) (poly-form b))
	 (values (make-upolynomial domain d)							 (values (make-upolynomial domain d)
		 (make-upolynomial domain x)								 (make-upolynomial domain x)
		 (make-upolynomial domain y)))))							 (make-upolynomial domain y)))))

(defun clist-extended-gcd (a b)								(defun clist-extended-gcd (a b)
  (if (coef-list0? b)									  (if (coef-list0? b)
      (values a (make-array 1 :initial-element 1)					      (values a (make-array 1 :initial-element 1)
	      (make-array 1 :initial-element 0))						      (make-array 1 :initial-element 0))
      (multiple-value-bind (q r) (clist-divide a b)					      (multiple-value-bind (q r) (clist-divide a b)
	(multiple-value-bind (d x y) (clist-extended-gcd b r)					(multiple-value-bind (d x y) (clist-extended-gcd b r)
	  (values d y (clist-difference x (clist-times q y)))))))				  (values d y (clist-difference x (clist-times q y)))))))

;; I don't know why this routines was ever here (but there's a similar			;; I don't know why this routines was ever here (but there's a similar
;; routine in mpolynomial).  --RZ (FIXTHIS)						;; routine in mpolynomial).  --RZ (FIXTHIS)
#+ignore										#+ignore
(defmethod-sd binary> ((x upolynomial) (y upolynomial))					(defmethod-sd binary> ((x upolynomial) (y upolynomial))
  (let ((cl-x (poly-form x))								  (let ((cl-x (poly-form x))
	(cl-y (poly-form y)))									(cl-y (poly-form y)))
    (cond ((and (clist-zero-deg? cl-x) (clist-zero-deg? cl-y))				    (cond ((and (clist-zero-deg? cl-x) (clist-zero-deg? cl-y))
           (> (clist-get cl-x 0) (clist-get cl-y 0)))					           (> (clist-get cl-x 0) (clist-get cl-y 0)))
          (t nil))))									          (t nil))))

(defmethod-sd binary= ((x upolynomial) (y upolynomial))					(defmethod-sd binary= ((x upolynomial) (y upolynomial))
  (bind-domain-context (domain-of x)							  (bind-domain-context (domain-of x)
    (coef-list0? (clist-difference (poly-form x) (poly-form y)))))			    (coef-list0? (clist-difference (poly-form x) (poly-form y)))))

;; this should return a list of (polynomial . power) pairs				;; this should return a list of (polynomial . power) pairs
(defmethod factor ((poly upolynomial))							(defmethod factor ((poly upolynomial))
  (bind-domain-context (domain-of poly)							  (bind-domain-context (domain-of poly)
    (if (typep *coefficient-domain* 'gfp)						    (if (typep *coefficient-domain* 'gfp)
	(if (cl:< 2 (characteristic *coefficient-domain*))					(if (cl:< 2 (characteristic *coefficient-domain*))
	    (mapcar #'(lambda (pair)								    (mapcar #'(lambda (pair)
		        (cons (make-upolynomial *domain* (car pair))					        (cons (make-upolynomial *domain* (car pair))
			      (cdr pair)))									      (cdr pair)))
		    (clist-factor (poly-form poly)))							    (clist-factor (poly-form poly)))
	    (error "Can't factor univariate polynomials over GF(2) yet"))			    (error "Can't factor univariate polynomials over GF(2) yet"))
	(error "Can't factor unless coefficients domain is GF(p)"))))				(error "Can't factor unless coefficients domain is GF(p)"))))

(defmethod cfactor ((poly upolynomial))							(defmethod cfactor ((poly upolynomial))
  (let* ((factlist (factor poly))							  (let* ((factlist (factor poly))
         (prod (one (domain-of poly))))							         (prod (one (domain-of poly))))
    (mapcar #'(lambda (fact) 								    (mapcar #'(lambda (fact) 
	        (setq prod (* prod (expt (car fact) (cdr fact))))				        (setq prod (* prod (expt (car fact) (cdr fact))))
	      t)										      t)
            factlist)									            factlist)
    (if (= prod poly)									    (if (= prod poly)
        factlist									        factlist
        (error "Factor didn't work.  Prod ~S not = ~S" factlist poly))))		        (error "Factor didn't work.  Prod ~S not = ~S" factlist poly))))


;; This should return a list of (clist . power) pairs					;; This should return a list of (clist . power) pairs
(defun clist-factor (poly)								(defun clist-factor (poly)
  (if (coef-list0? (clist-deriv poly))							  (if (coef-list0? (clist-deriv poly))
      (if (cl:= (clist-degree poly) 0)							      (if (cl:= (clist-degree poly) 0)
          (list (cons poly 1))								          (list (cons poly 1))
          (let ((p (characteristic *coefficient-domain*)))				          (let ((p (characteristic *coefficient-domain*)))
            (mapcar #'(lambda (fact)							            (mapcar #'(lambda (fact)
                        (cons (car fact) (cl:* p (cdr fact))))				                        (cons (car fact) (cl:* p (cdr fact))))
                    (clist-factor (clist-pth-root poly)))))				                    (clist-factor (clist-pth-root poly)))))
      (loop for (pp . degree) in (clist-sqfr-decompose poly)				      (loop for (pp . degree) in (clist-sqfr-decompose poly)
	    append (loop for p in (clist-factor-squarefree pp)					    append (loop for p in (clist-factor-squarefree pp)
			 collect (cons p degree)))))								 collect (cons p degree)))))

;; The exclamation point indicatest that this routine modifies its			;; The exclamation point indicatest that this routine modifies its
;; argument.										;; argument.
(defun clist-primitive-part! (poly)							(defun clist-primitive-part! (poly)
  (let* ((deg (clist-degree poly))							  (let* ((deg (clist-degree poly))
	 (lc (clist-get poly deg)))								 (lc (clist-get poly deg)))
    (unless (1? lc)									    (unless (1? lc)
      (loop for i fixnum below deg							      (loop for i fixnum below deg
	    do (setf (clist-get poly i) (/ (clist-get poly i) lc)))				    do (setf (clist-get poly i) (/ (clist-get poly i) lc)))
      (setf (clist-get poly deg) (one *coefficient-domain*)))				      (setf (clist-get poly deg) (one *coefficient-domain*)))
    poly))										    poly))
	     											     
	  											  
;; As currently constituted this routine first monicizes the				;; As currently constituted this routine first monicizes the
;; polynomial and then computes the primitive part.  It should just			;; polynomial and then computes the primitive part.  It should just
;; multiply it into the square free terms.  --RZ (FIXTHIS)				;; multiply it into the square free terms.  --RZ (FIXTHIS)
(defmethod square-free ((poly upolynomial))						(defmethod square-free ((poly upolynomial))
  (bind-domain-context (domain-of poly)							  (bind-domain-context (domain-of poly)
    (mapcar #'(lambda (pair)								    (mapcar #'(lambda (pair)
	        (cons (make-upolynomial *domain* (car pair))					        (cons (make-upolynomial *domain* (car pair))
		      (cdr pair)))									      (cdr pair)))
	    (clist-sqfr-decompose (poly-form poly)))))						    (clist-sqfr-decompose (poly-form poly)))))

(defun clist-sqfr-decompose (poly)							(defun clist-sqfr-decompose (poly)
  (loop for f1 = poly then f2								  (loop for f1 = poly then f2
	for n upfrom 0										for n upfrom 0
	for prod1 = nil then prod2								for prod1 = nil then prod2
	with factor and factors and deriv and f2 and prod2 and					with factor and factors and deriv and f2 and prod2 and
	p = (characteristic *coefficient-domain*)						p = (characteristic *coefficient-domain*)
	do (when (coef-list0? (setq deriv (clist-deriv f1)))					do (when (coef-list0? (setq deriv (clist-deriv f1)))
	     (push (cons (clist-primitive-part! prod1) n) factors)				     (push (cons (clist-primitive-part! prod1) n) factors)
	     (unless (cl:= (clist-degree f1) 0)							     (unless (cl:= (clist-degree f1) 0)
	       (push (cons (clist-primitive-part! (clist-pth-root f1)) p)			       (push (cons (clist-primitive-part! (clist-pth-root f1)) p)
		     factors))										     factors))
	     (return (reverse factors)))							     (return (reverse factors)))
	   (setq f2 (clist-gcd deriv f1))							   (setq f2 (clist-gcd deriv f1))
	   (setq prod2 (if (cl:> (clist-degree f2) 0)						   (setq prod2 (if (cl:> (clist-degree f2) 0)
			    (clist-quotient f1 f2)								    (clist-quotient f1 f2)
			    f1))										    f1))
	   (when prod1										   (when prod1
	     (setq factor (clist-quotient prod1 prod2)))					     (setq factor (clist-quotient prod1 prod2)))
	   (when (cl:plusp (clist-degree factor))						   (when (cl:plusp (clist-degree factor))
	     (push (cons (clist-primitive-part! factor) n) factors))))				     (push (cons (clist-primitive-part! factor) n) factors))))

(defun clist-deriv (f)									(defun clist-deriv (f)
  (if (cl:= (clist-degree f) 0)								  (if (cl:= (clist-degree f) 0)
      (coef-list0 *coefficient-domain*)							      (coef-list0 *coefficient-domain*)
      (let ((deriv (make-clist (cl:- (clist-length f) 1))))				      (let ((deriv (make-clist (cl:- (clist-length f) 1))))
        (do ((exp (clist-degree f) (- exp 1)))						        (do ((exp (clist-degree f) (- exp 1)))
            ((cl:= exp 0)								            ((cl:= exp 0)
             (clist-simplify deriv))							             (clist-simplify deriv))
          (setf (clist-get deriv (- exp 1))						          (setf (clist-get deriv (- exp 1))
                (* (coerce exp *coefficient-domain*)					                (* (coerce exp *coefficient-domain*)
		   (clist-get f exp)))))))								   (clist-get f exp)))))))

(defmethod derivation ((f upolynomial))							(defmethod derivation ((f upolynomial))
  (bind-domain-context (domain-of f)							  (bind-domain-context (domain-of f)
    (make-upolynomial (domain-of f)							    (make-upolynomial (domain-of f)
		      (clist-deriv (poly-form f)))))							      (clist-deriv (poly-form f)))))

;; this assumes that poly is a proper pth power -- i.e. that its 			;; this assumes that poly is a proper pth power -- i.e. that its 
;; degree is a multiple of p, and all non-zero terms have degree			;; degree is a multiple of p, and all non-zero terms have degree
;; a multiple of p.  in this case, the pth root is just the polynomial			;; a multiple of p.  in this case, the pth root is just the polynomial
;; generated by dividing all the exponents by p.					;; generated by dividing all the exponents by p.
(defun clist-pth-root (poly)								(defun clist-pth-root (poly)
  (let* ((p (characteristic *coefficient-domain*))					  (let* ((p (characteristic *coefficient-domain*))
         (rootdegree (cl:/ (clist-degree poly) p))					         (rootdegree (cl:/ (clist-degree poly) p))
         (root (make-clist (cl:+ rootdegree 1))))					         (root (make-clist (cl:+ rootdegree 1))))
    (do ((pexp (clist-degree poly) (cl:- pexp p))					    (do ((pexp (clist-degree poly) (cl:- pexp p))
         (rexp rootdegree (cl:- rexp 1)))						         (rexp rootdegree (cl:- rexp 1)))
        ((cl:= rexp -1)									        ((cl:= rexp -1)
         root)										         root)
      (setf (clist-get root rexp) (clist-get poly pexp)))))				      (setf (clist-get root rexp) (clist-get poly pexp)))))

;; this assumes that poly is square-free, and returns a list of factors			;; this assumes that poly is square-free, and returns a list of factors
;; (as clists).										;; (as clists).
(defun clist-factor-squarefree (poly)							(defun clist-factor-squarefree (poly)
  (if (cl:= (clist-degree poly) 0)							  (if (cl:= (clist-degree poly) 0)
      (list poly)									      (list poly)
      (let ((factlist nil)								      (let ((factlist nil)
            (x (clist-x *coefficient-domain*))    ; the poly 'x'			            (x (clist-x *coefficient-domain*))    ; the poly 'x'
            (p (characteristic *coefficient-domain*))					            (p (characteristic *coefficient-domain*))
            dpoly)									            dpoly)
        (when (0? (clist-get poly 0))							        (when (0? (clist-get poly 0))
	  (setq factlist (append (list x) factlist))						  (setq factlist (append (list x) factlist))
	  (setq poly (clist-quotient poly x)))							  (setq poly (clist-quotient poly x)))
        (do ((n 1 (+ n 1))								        (do ((n 1 (+ n 1))
             (power p (* power p))    ; always equals p^n				             (power p (* power p))    ; always equals p^n
             (f poly (cond ((cl:= (clist-degree dpoly) 0) f)				             (f poly (cond ((cl:= (clist-degree dpoly) 0) f)
                           ((cl:= (clist-degree dpoly) (clist-degree f))		                           ((cl:= (clist-degree dpoly) (clist-degree f))
                            (coef-list1 *coefficient-domain*))				                            (coef-list1 *coefficient-domain*))
                           (t (clist-quotient f dpoly)))))				                           (t (clist-quotient f dpoly)))))
            ((cl:= (clist-degree f) 0)							            ((cl:= (clist-degree f) 0)
             factlist)									             factlist)
          (cond ((cl:< (clist-degree f) (cl:* 2 n))					          (cond ((cl:< (clist-degree f) (cl:* 2 n))
		 (setq n (clist-degree f))								 (setq n (clist-degree f))
		 (setq dpoly f))									 (setq dpoly f))
		(t (setq dpoly (clist-gcd f (clist-difference 						(t (setq dpoly (clist-gcd f (clist-difference 
					     (clist-expt-mod-poly x power f)							     (clist-expt-mod-poly x power f)
					     x)))))										     x)))))
          (if (cl:> (clist-degree dpoly) 0)						          (if (cl:> (clist-degree dpoly) 0)
              (setq factlist 								              (setq factlist 
                    (append factlist							                    (append factlist
                            (clist-factor-product-nth-degrees dpoly n))))))))		                            (clist-factor-product-nth-degrees dpoly n))))))))
          										          
;; this evaluates (x)^n mod poly by repeated squaring					;; this evaluates (x)^n mod poly by repeated squaring
(defun clist-expt-mod-poly (x n poly)							(defun clist-expt-mod-poly (x n poly)
  (%funcall (repeated-squaring								  (%funcall (repeated-squaring
	      #'(lambda (a b) (clist-remainder (clist-times a b) poly))				      #'(lambda (a b) (clist-remainder (clist-times a b) poly))
	      (coef-list1 *coefficient-domain*))						      (coef-list1 *coefficient-domain*))
	    x n))										    x n))

;; this assumes that poly is a product of nth degree irreducible factors.		;; this assumes that poly is a product of nth degree irreducible factors.
;; it returns a list of factors (as clists, of course)					;; it returns a list of factors (as clists, of course)
(defun clist-factor-product-nth-degrees (poly n)					(defun clist-factor-product-nth-degrees (poly n)
  (if (cl:= (clist-degree poly) n)							  (if (cl:= (clist-degree poly) n)
      (list poly)									      (list poly)
      (let ((exp (/ (- (expt (characteristic *coefficient-domain*) n) 1) 2))		      (let ((exp (/ (- (expt (characteristic *coefficient-domain*) n) 1) 2))
            (factlist nil)								            (factlist nil)
            (base (clist-x *coefficient-domain*)))  ; the poly 'x+0'			            (base (clist-x *coefficient-domain*)))  ; the poly 'x+0'
        (do ((reducibles (list poly) newreducibles)					        (do ((reducibles (list poly) newreducibles)
             (newreducibles nil nil))							             (newreducibles nil nil))
            ((null reducibles)								            ((null reducibles)
             factlist)									             factlist)
          (dolist (f reducibles)							          (dolist (f reducibles)
            (let* ((q1 (clist-gcd f							            (let* ((q1 (clist-gcd f
                           (clist-plus (clist-expt-mod-poly base exp f)			                           (clist-plus (clist-expt-mod-poly base exp f)
                                       (coef-list1 *coefficient-domain*))))		                                       (coef-list1 *coefficient-domain*))))
                   (q2 (if (cl:= (clist-degree q1) 0)					                   (q2 (if (cl:= (clist-degree q1) 0)
                           f								                           f
                           (clist-quotient f q1))))					                           (clist-quotient f q1))))
              (cond ((cl:> (clist-degree q1) n) (push q1 newreducibles))		              (cond ((cl:> (clist-degree q1) n) (push q1 newreducibles))
                    ((cl:= (clist-degree q1) n) (push q1 factlist)))			                    ((cl:= (clist-degree q1) n) (push q1 factlist)))
              (cond ((cl:> (clist-degree q2) n) (push q2 newreducibles))		              (cond ((cl:> (clist-degree q2) n) (push q2 newreducibles))
                    ((cl:= (clist-degree q2) n) (push q2 factlist)))))			                    ((cl:= (clist-degree q2) n) (push q2 factlist)))))
          (setf (clist-get base 0)							          (setf (clist-get base 0)
                     (random *coefficient-domain*)))))) ; reset base to 'x+a'		                     (random *coefficient-domain*)))))) ; reset base to 'x+a'



;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-		;;; -*- Mode:Lisp; Package:Weyli; Base:10; Lowercase:T; Syntax:Common-Lisp -*-
;;; ===========================================================================		;;; ===========================================================================
;;;				    Vector Space					;;;				    Vector Space
;;; ===========================================================================		;;; ===========================================================================
;;; (c) Copyright 1989, 1993 Cornell University						;;; (c) Copyright 1989, 1993 Cornell University

;;; vector.lisp,v 1.11 1995/06/05 20:38:00 rick Exp					;;; vector.lisp,v 1.11 1995/06/05 20:38:00 rick Exp

(in-package "WEYLI")								    |	(in-package :weyli)

(make::adjust-version-numbers Weyl "1.11")					    |	;;; DELETE (make::adjust-version-numbers Weyl "1.11")

;; Useful macro until everything is ANSI compliant					;; Useful macro until everything is ANSI compliant
(defmacro loop-vector-bind (index vars-vectors &body body)				(defmacro loop-vector-bind (index vars-vectors &body body)
  (let ((cnt 0) vectors limit var-bindings)						  (let ((cnt 0) vectors limit var-bindings)
    (setq var-bindings									    (setq var-bindings
	  (loop for (var vect) in vars-vectors							  (loop for (var vect) in vars-vectors
		for vector = (intern (format nil ".VV~D." (incf cnt)))					for vector = (intern (format nil ".VV~D." (incf cnt)))
		do (push (list var vector) vectors)							do (push (list var vector) vectors)
		collect `(,vector ,vect)								collect `(,vector ,vect)
		finally (setq vectors (nreverse vectors))))						finally (setq vectors (nreverse vectors))))
    (cond ((atom index)									    (cond ((atom index)
	   (when (null index)									   (when (null index)
	     (setq index '.I.))									     (setq index '.I.))
	   (setq limit `(min ,@(loop for (nil vect) in vectors					   (setq limit `(min ,@(loop for (nil vect) in vectors
				     collect `(array-dimension ,vect 0)))))						     collect `(array-dimension ,vect 0)))))
	  (t (setq limit (second index))							  (t (setq limit (second index))
	     (setq index (first index))))	  						     (setq index (first index))))	  
    `(let ,var-bindings									    `(let ,var-bindings
       (declare (optimize (safety 1)))							       (declare (optimize (safety 1)))
       (loop for ,index fixnum below ,limit						       (loop for ,index fixnum below ,limit
	     ,@(loop for (var vect) in vectors							     ,@(loop for (var vect) in vectors
		     append `(for ,var = (svref ,vect ,index)))						     append `(for ,var = (svref ,vect ,index)))
	     do ,@body))))									     do ,@body))))

(define-domain-creator free-module ((domain ring) dimension)			    |	(eval-when (:compile-toplevel :load-toplevel)
										    >	  (define-domain-creator free-module ((domain ring) dimension)
  (make-instance 'free-module								    (make-instance 'free-module
		 :coefficient-domain domain						                   :coefficient-domain domain
		 :dimension dimension							                   :dimension dimension
		 :print-function 'free-module-print-object)				                   :print-function 'free-module-print-object)
  :predicate #'(lambda (d)								    :predicate #'(lambda (d)
	         (and (eql (class-name (class-of d)) 'free-module)			                   (and (eql (class-name (class-of d)) 'free-module)
		      (eql (coefficient-domain-of d) domain)				                        (eql (coefficient-domain-of d) domain)
		      (eql (dimension-of d) dimension))))			    |	                        (eql (dimension-of d) dimension)))))

(define-domain-creator vector-space ((domain field) dimension)			    |	(eval-when (:compile-toplevel :load-toplevel)
										    >	  (define-domain-creator vector-space ((domain field) dimension)
  (make-instance 'vector-space								    (make-instance 'vector-space
		 :coefficient-domain domain						                   :coefficient-domain domain
		 :dimension dimension							                   :dimension dimension
		 :print-function 'free-module-print-object)				                   :print-function 'free-module-print-object)
  :predicate #'(lambda (d)								    :predicate #'(lambda (d)
	         (and (eql (class-name (class-of d)) 'vector-space)			                   (and (eql (class-name (class-of d)) 'vector-space)
		      (eql (coefficient-domain-of d) domain)				                        (eql (coefficient-domain-of d) domain)
		      (eql (dimension-of d) dimension))))			    |	                        (eql (dimension-of d) dimension)))))

(defun free-module-print-object (domain stream)						(defun free-module-print-object (domain stream)
  (format stream #+Genera "~S~D" #-Genera "~S^~D"					  (format stream #+Genera "~S~D" #-Genera "~S^~D"
	  (coefficient-domain-of domain)							  (coefficient-domain-of domain)
	  (dimension-of domain)))								  (dimension-of domain)))

(define-domain-element-classes free-module free-module-element)				(define-domain-element-classes free-module free-module-element)
(define-domain-element-classes vector-space vector-space-element)			(define-domain-element-classes vector-space vector-space-element)

(defmethod make-element ((domain free-module) (value vector) &rest values)		(defmethod make-element ((domain free-module) (value vector) &rest values)
  (declare (ignore values))								  (declare (ignore values))
  (make-element-free-module-vector domain value))					  (make-element-free-module-vector domain value))

(defun make-element-free-module-vector (domain value)					(defun make-element-free-module-vector (domain value)
  (let ((dim (dimension-of domain)))							  (let ((dim (dimension-of domain)))
    (unless (eql (array-dimension value 0) dim)						    (unless (eql (array-dimension value 0) dim)
      (error "Wrong number of vector elements in ~S" domain))				      (error "Wrong number of vector elements in ~S" domain))
    (make-instance (first (domain-element-classes domain))				    (make-instance (first (domain-element-classes domain))
		   :domain domain :values value)))							   :domain domain :values value)))

(defmethod make-element ((domain free-module) value &rest values)			(defmethod make-element ((domain free-module) value &rest values)
  (let ((dim (dimension-of domain)))							  (let ((dim (dimension-of domain)))
    (unless (eql (1- dim) (length values))						    (unless (eql (1- dim) (length values))
      (error "Wrong number of vector elements in ~S" domain))				      (error "Wrong number of vector elements in ~S" domain))
    (make-instance (first (domain-element-classes domain))				    (make-instance (first (domain-element-classes domain))
		   :domain domain									   :domain domain
		   :values (%apply #'vector value values))))						   :values (%apply #'vector value values))))

(defmethod weyl::make-element ((domain free-module) value &rest values)			(defmethod weyl::make-element ((domain free-module) value &rest values)
  (let ((dim (dimension-of domain))							  (let ((dim (dimension-of domain))
	(coef-domain (coefficient-domain-of domain)))						(coef-domain (coefficient-domain-of domain)))
    (cond ((typep value 'vector)							    (cond ((typep value 'vector)
	   (unless (and (eql (array-dimension value 0) dim)					   (unless (and (eql (array-dimension value 0) dim)
			(null values))										(null values))
	     (error "Wrong number of vector elements in ~S" domain))				     (error "Wrong number of vector elements in ~S" domain))
	   (make-instance (first (domain-element-classes domain))				   (make-instance (first (domain-element-classes domain))
	     :domain domain									     :domain domain
	     :values (%apply #'vector								     :values (%apply #'vector
			    (loop for i fixnum below (length value)						    (loop for i fixnum below (length value)
				  collect (coerce (aref value i) coef-domain)))))					  collect (coerce (aref value i) coef-domain)))))
	  (t (unless (eql (1- dim) (length values))						  (t (unless (eql (1- dim) (length values))
	       (error "Wrong number of vector elements in ~S" domain))				       (error "Wrong number of vector elements in ~S" domain))
	     (make-instance (first (domain-element-classes domain)) 				     (make-instance (first (domain-element-classes domain)) 
	       :domain domain									       :domain domain
	       :values (%apply #'vector								       :values (%apply #'vector
			      (coerce value coef-domain)							      (coerce value coef-domain)
			      (loop for v in values								      (loop for v in values
				    collect (coerce v coef-domain))))))))						    collect (coerce v coef-domain))))))))

(defmethod print-object ((elt free-module-element) stream)				(defmethod print-object ((elt free-module-element) stream)
  (print-free-module-element elt stream))						  (print-free-module-element elt stream))

(defun print-free-module-element (elt stream)						(defun print-free-module-element (elt stream)
  (let* ((domain (domain-of elt))							  (let* ((domain (domain-of elt))
	(dim (if (typep domain 'dimensional-domain)						(dim (if (typep domain 'dimensional-domain)
		 (dimension-of (domain-of elt))								 (dimension-of (domain-of elt))
		 (array-dimension (tuple-value elt) 0))))						 (array-dimension (tuple-value elt) 0))))
    (write-char #\< stream)								    (write-char #\< stream)
    (unless (0? dim)									    (unless (0? dim)
      (print-object (ref elt 0) stream)							      (print-object (ref elt 0) stream)
      (loop for i upfrom 1 below dim							      (loop for i upfrom 1 below dim
	    do (princ ", " stream)								    do (princ ", " stream)
	       (print-object (ref elt i) stream)))						       (print-object (ref elt i) stream)))
    (write-char #\> stream)))								    (write-char #\> stream)))

(defmethod dimensions ((v vector-space-element))					(defmethod dimensions ((v vector-space-element))
  (list (dimension-of (domain-of v))))							  (list (dimension-of (domain-of v))))

(defmethod 0? ((v free-module-element))							(defmethod 0? ((v free-module-element))
  (loop for i fixnum below (dimension-of (domain-of v))					  (loop for i fixnum below (dimension-of (domain-of v))
	do (unless (0? (ref v i))								do (unless (0? (ref v i))
	     (return nil))									     (return nil))
	finally (return t)))									finally (return t)))


(defmethod zero ((domain free-module))							(defmethod zero ((domain free-module))
  (let ((dim (dimension-of domain))							  (let ((dim (dimension-of domain))
	(zero (zero (coefficient-domain-of domain))))						(zero (zero (coefficient-domain-of domain))))
    (make-instance (first (domain-element-classes domain))				    (make-instance (first (domain-element-classes domain))
		   :domain domain									   :domain domain
		   :values (make-array dim :initial-element zero))))					   :values (make-array dim :initial-element zero))))

(defmethod list-of-variables ((v free-module-element) &optional ignore)			(defmethod list-of-variables ((v free-module-element) &optional ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (loop for i fixnum below (dimension-of (domain-of v))					  (loop for i fixnum below (dimension-of (domain-of v))
	with list										with list
	do (setq list (list-of-variables (ref v i) list))					do (setq list (list-of-variables (ref v i) list))
	finally (return list)))									finally (return list)))

(defmethod-sd max-pair ((v1 free-module-element) (v2 free-module-element))		(defmethod-sd max-pair ((v1 free-module-element) (v2 free-module-element))
  (let* ((dim (dimension-of domain))							  (let* ((dim (dimension-of domain))
	 (ans (make-array dim)))								 (ans (make-array dim)))
    (loop-vector-bind (i dim) ((e1 (tuple-value v1)) 					    (loop-vector-bind (i dim) ((e1 (tuple-value v1)) 
			       (e2 (tuple-value v2)))								       (e2 (tuple-value v2)))
      (setf (svref ans i) (max e1 e2)))							      (setf (svref ans i) (max e1 e2)))
    (make-element domain ans)))								    (make-element domain ans)))

(defmethod-sd min-pair ((v1 free-module-element) (v2 free-module-element))		(defmethod-sd min-pair ((v1 free-module-element) (v2 free-module-element))
  (let* ((dim (dimension-of domain))							  (let* ((dim (dimension-of domain))
	 (ans (make-array dim)))								 (ans (make-array dim)))
    (loop-vector-bind (i dim) ((e1 (tuple-value v1))					    (loop-vector-bind (i dim) ((e1 (tuple-value v1))
			       (e2 (tuple-value v2)))								       (e2 (tuple-value v2)))
      (setf (svref ans i) (min e1 e2)))							      (setf (svref ans i) (min e1 e2)))
    (make-element domain ans)))								    (make-element domain ans)))

(defmethod-sd plus ((v1 free-module-element) (v2 free-module-element))			(defmethod-sd plus ((v1 free-module-element) (v2 free-module-element))
  (let* ((dim (dimension-of domain))							  (let* ((dim (dimension-of domain))
	 (ans (make-array dim)))								 (ans (make-array dim)))
    (loop-vector-bind (i dim)								    (loop-vector-bind (i dim)
	((e1 (tuple-value v1))									((e1 (tuple-value v1))
	 (e2 (tuple-value v2)))									 (e2 (tuple-value v2)))
      (setf (svref ans i) (+ e1 e2)))							      (setf (svref ans i) (+ e1 e2)))
    (make-element domain ans)))								    (make-element domain ans)))

(defmethod minus ((vector free-module-element))						(defmethod minus ((vector free-module-element))
  (let* ((vector-space (domain-of vector))						  (let* ((vector-space (domain-of vector))
	 (dim (dimension-of vector-space))							 (dim (dimension-of vector-space))
	 (ans (make-array dim)))								 (ans (make-array dim)))
    (loop-vector-bind (i dim) ((e (tuple-value vector)))				    (loop-vector-bind (i dim) ((e (tuple-value vector)))
      (setf (svref ans i) (minus e)))							      (setf (svref ans i) (minus e)))
    (make-element vector-space ans)))							    (make-element vector-space ans)))

(defmethod-sd difference ((v1 free-module-element) (v2 free-module-element))		(defmethod-sd difference ((v1 free-module-element) (v2 free-module-element))
  (let* ((dim (dimension-of domain))							  (let* ((dim (dimension-of domain))
	 (ans (make-array dim)))								 (ans (make-array dim)))
    (loop-vector-bind (i dim)								    (loop-vector-bind (i dim)
	((e1 (tuple-value v1))									((e1 (tuple-value v1))
	 (e2 (tuple-value v2)))									 (e2 (tuple-value v2)))
      (setf (svref ans i) (- e1 e2)))							      (setf (svref ans i) (- e1 e2)))
    (make-element domain ans)))								    (make-element domain ans)))

;; The checks to see if the scalar is a free-module element are				;; The checks to see if the scalar is a free-module element are
;; necessary because we can multiple two quaternion's together.  There			;; necessary because we can multiple two quaternion's together.  There
;; are some complications here.  --RZ 11/2/94						;; are some complications here.  --RZ 11/2/94

(defmethod times :around (scalar (vector free-module-element))				(defmethod times :around (scalar (vector free-module-element))
  (let ((coeff-domain (coefficient-domain-of (domain-of vector)))			  (let ((coeff-domain (coefficient-domain-of (domain-of vector)))
	(coerced-scalar nil))									(coerced-scalar nil))
    (cond ((and *coerce-where-possible*							    (cond ((and *coerce-where-possible*
		;; Don't clobber the arg, the next cluase needs it					;; Don't clobber the arg, the next cluase needs it
		(setq coerced-scalar (coercible? scalar coeff-domain)))					(setq coerced-scalar (coercible? scalar coeff-domain)))
	   (multiply-vector-by-scalar vector coerced-scalar))					   (multiply-vector-by-scalar vector coerced-scalar))
	  ((typep scalar 'free-module-element)							  ((typep scalar 'free-module-element)
	   (call-next-method))									   (call-next-method))
	  (t (multiply-vector-by-scalar vector scalar)))))					  (t (multiply-vector-by-scalar vector scalar)))))

;; The :around methods for this method and the next are not really			;; The :around methods for this method and the next are not really
;; needed since they are chosen in preference other similar methods			;; needed since they are chosen in preference other similar methods
;; since they have a more specialized first argument.  Nonetheless,			;; since they have a more specialized first argument.  Nonetheless,
;; I'm leaving the :around's here for symmetry and emphasis.				;; I'm leaving the :around's here for symmetry and emphasis.
;;  --RZ 7/12/94									;;  --RZ 7/12/94
(defmethod times :around ((vector free-module-element) scalar)				(defmethod times :around ((vector free-module-element) scalar)
  (let ((coeff-domain (coefficient-domain-of (domain-of vector)))			  (let ((coeff-domain (coefficient-domain-of (domain-of vector)))
	(coerced-scalar nil))									(coerced-scalar nil))
    (cond ((and *coerce-where-possible*							    (cond ((and *coerce-where-possible*
		;; Don't clobber the arg, the next cluase needs it					;; Don't clobber the arg, the next cluase needs it
		(setq coerced-scalar (coercible? scalar coeff-domain)))					(setq coerced-scalar (coercible? scalar coeff-domain)))
	   (multiply-vector-by-scalar vector coerced-scalar))					   (multiply-vector-by-scalar vector coerced-scalar))
	  ((typep scalar 'free-module-element)							  ((typep scalar 'free-module-element)
	   (call-next-method))									   (call-next-method))
	  (t (multiply-vector-by-scalar vector scalar)))))					  (t (multiply-vector-by-scalar vector scalar)))))

(defmethod quotient :around ((vector free-module-element) scalar)			(defmethod quotient :around ((vector free-module-element) scalar)
  (let ((coeff-domain (coefficient-domain-of (domain-of vector)))			  (let ((coeff-domain (coefficient-domain-of (domain-of vector)))
	(coerced-scalar nil))									(coerced-scalar nil))
    (cond ((and (not (numberp scalar))							    (cond ((and (not (numberp scalar))
		(eql (domain-of scalar) coeff-domain))							(eql (domain-of scalar) coeff-domain))
	   (multiply-vector-by-scalar vector (/ scalar)))					   (multiply-vector-by-scalar vector (/ scalar)))
	  ((and *coerce-where-possible*								  ((and *coerce-where-possible*
		;; Don't clobber the arg, the next cluase needs it					;; Don't clobber the arg, the next cluase needs it
		(setq coerced-scalar (coercible? scalar coeff-domain)))					(setq coerced-scalar (coercible? scalar coeff-domain)))
	   (multiply-vector-by-scalar vector (/ coerced-scalar)))				   (multiply-vector-by-scalar vector (/ coerced-scalar)))
	  (t (call-next-method scalar vector)))))						  (t (call-next-method scalar vector)))))

(defun multiply-vector-by-scalar (vector scalar)					(defun multiply-vector-by-scalar (vector scalar)
  (let* ((vector-space (domain-of vector))						  (let* ((vector-space (domain-of vector))
	 (dim (dimension-of vector-space))							 (dim (dimension-of vector-space))
	 (ans (make-array dim)))								 (ans (make-array dim)))
    (loop-vector-bind (i dim) ((e (tuple-value vector)))				    (loop-vector-bind (i dim) ((e (tuple-value vector)))
      (setf (svref ans i) (* e scalar)))						      (setf (svref ans i) (* e scalar)))
    (make-element vector-space ans)))							    (make-element vector-space ans)))

(defmethod-sd dot-product ((v1 free-module-element) (v2 free-module-element))		(defmethod-sd dot-product ((v1 free-module-element) (v2 free-module-element))
  (loop for i fixnum upfrom 1 below (dimension-of domain)				  (loop for i fixnum upfrom 1 below (dimension-of domain)
	with ans = (* (ref v1 0) (ref v2 0))							with ans = (* (ref v1 0) (ref v2 0))
	do (setq ans (+ ans (* (ref v1 i) (ref v2 i))))						do (setq ans (+ ans (* (ref v1 i) (ref v2 i))))
	finally (return ans)))									finally (return ans)))

(defmethod-sd inner-product ((v1 free-module-element) (v2 free-module-element))		(defmethod-sd inner-product ((v1 free-module-element) (v2 free-module-element))
  (dot-product v1 v2))									  (dot-product v1 v2))

(defmethod cross-product (v1 v2)							(defmethod cross-product (v1 v2)
  (error "CROSS-PRODUCT product is not implemented for elements of ~S and ~S"		  (error "CROSS-PRODUCT product is not implemented for elements of ~S and ~S"
	 (domain-of v1) (domain-of v2)))							 (domain-of v1) (domain-of v2)))

(defmethod cross-product ((v1 free-module-element) (v2 free-module-element))		(defmethod cross-product ((v1 free-module-element) (v2 free-module-element))
  (let ((domain (domain-of v1))								  (let ((domain (domain-of v1))
	a b)											a b)
    (cond ((and (eql domain (domain-of v2))						    (cond ((and (eql domain (domain-of v2))
		(= 3 (dimension-of domain)))								(= 3 (dimension-of domain)))
	   (setq a (tuple-value v1)								   (setq a (tuple-value v1)
		 b (tuple-value v2))									 b (tuple-value v2))
	   (make-element domain 								   (make-element domain 
			 (- (* (aref a 1) (aref b 2))								 (- (* (aref a 1) (aref b 2))
			    (* (aref a 2) (aref b 1)))								    (* (aref a 2) (aref b 1)))
			 (- (* (aref a 2) (aref b 0))								 (- (* (aref a 2) (aref b 0))
			    (* (aref a 0) (aref b 2)))								    (* (aref a 0) (aref b 2)))
			 (- (* (aref a 0) (aref b 1))								 (- (* (aref a 0) (aref b 1))
			    (* (aref a 1) (aref b 0)))))							    (* (aref a 1) (aref b 0)))))
	  (t (call-next-method)))))								  (t (call-next-method)))))

(defmethod tilde (vect)									(defmethod tilde (vect)
  (error "TILDE is not implemented for elements of ~S" (domain-of vect)))		  (error "TILDE is not implemented for elements of ~S" (domain-of vect)))

(defmethod tilde ((vect free-module-element))						(defmethod tilde ((vect free-module-element))
  (cond ((= 3 (dimension-of (domain-of vect)))						  (cond ((= 3 (dimension-of (domain-of vect)))
	 (let ((matrix-space (get-matrix-space							 (let ((matrix-space (get-matrix-space
			      (coefficient-domain-of (domain-of vect))))					      (coefficient-domain-of (domain-of vect))))
	       (v1 (ref vect 0))								       (v1 (ref vect 0))
	       (v2 (ref vect 1))								       (v2 (ref vect 1))
	       (v3 (ref vect 2))								       (v3 (ref vect 2))
	       (zero (zero (coefficient-domain-of (domain-of vect)))))				       (zero (zero (coefficient-domain-of (domain-of vect)))))
	   (make-element matrix-space 								   (make-element matrix-space 
			 (make-array (list 3 3) 								 (make-array (list 3 3) 
				     :initial-contents									     :initial-contents
				     `((,zero ,(- v3) ,v2) 								     `((,zero ,(- v3) ,v2) 
				       (,v3   ,zero   ,(- v1))								       (,v3   ,zero   ,(- v1))
				       (,(- v2) ,v1   ,zero))))))							       (,(- v2) ,v1   ,zero))))))
	(t (call-next-method))))								(t (call-next-method))))

(defmethod derivation ((vector free-module-element))					(defmethod derivation ((vector free-module-element))
  (let* ((vector-space (domain-of vector))						  (let* ((vector-space (domain-of vector))
	 (coef-domain (coefficient-domain-of vector-space)))					 (coef-domain (coefficient-domain-of vector-space)))
    (cond ((member 'deriv (list-operations coef-domain))				    (cond ((member 'deriv (list-operations coef-domain))
	   (let* ((vector-space (domain-of vector))						   (let* ((vector-space (domain-of vector))
		  (dim (dimension-of vector-space))							  (dim (dimension-of vector-space))
		  (ans (make-array dim)))								  (ans (make-array dim)))
	     (loop-vector-bind (i dim) ((e (tuple-value vector)))				     (loop-vector-bind (i dim) ((e (tuple-value vector)))
	       (setf (svref ans i) (deriv e)))							       (setf (svref ans i) (deriv e)))
	     (make-element vector-space ans)))							     (make-element vector-space ans)))
	  (t (error "Derivation is not a legal operation for domain ~S~%"			  (t (error "Derivation is not a legal operation for domain ~S~%"
		    vector-space)))))									    vector-space)))))

(defmethod deriv ((vector free-module-element) &rest vars)				(defmethod deriv ((vector free-module-element) &rest vars)
  (let* ((vector-space (domain-of vector))						  (let* ((vector-space (domain-of vector))
	 (dim (dimension-of vector-space))							 (dim (dimension-of vector-space))
	 (ans (make-array dim)))								 (ans (make-array dim)))
    (loop-vector-bind (i dim) ((e (tuple-value vector)))				    (loop-vector-bind (i dim) ((e (tuple-value vector)))
      (setf (svref ans i) (%apply #'deriv e vars)))					      (setf (svref ans i) (%apply #'deriv e vars)))
    (make-element vector-space ans)))							    (make-element vector-space ans)))

;; v1 - v2 has no negative components							;; v1 - v2 has no negative components
(defmethod-sd dominates ((v1 lisp-vector) (v2 lisp-vector))				(defmethod-sd dominates ((v1 lisp-vector) (v2 lisp-vector))
  (loop	with dimension = (dimension-of domain)						  (loop	with dimension = (dimension-of domain)
        and vect1 = (tuple-value v1) and vect2 = (tuple-value v2)			        and vect1 = (tuple-value v1) and vect2 = (tuple-value v2)
        for i below dimension								        for i below dimension
	when (< (aref vect1 i) (aref vect2 i))							when (< (aref vect1 i) (aref vect2 i))
	  do (return nil)									  do (return nil)
        finally (return t)))								        finally (return t)))

(defmethod-sd disjoint ((v1 lisp-vector) (v2 lisp-vector))				(defmethod-sd disjoint ((v1 lisp-vector) (v2 lisp-vector))
  (loop	with dimension = (dimension-of domain)						  (loop	with dimension = (dimension-of domain)
        and vect1 = (tuple-value v1) and vect2 = (tuple-value v2)			        and vect1 = (tuple-value v1) and vect2 = (tuple-value v2)
        for i below dimension								        for i below dimension
	when (not (or (0? (aref vect2 i)) (0? (aref vect1 i))))					when (not (or (0? (aref vect2 i)) (0? (aref vect1 i))))
	 do (return nil)									 do (return nil)
        finally (return t)))								        finally (return t)))

(defmethod substitute ((values list) (variables list) (v free-module-element)		(defmethod substitute ((values list) (variables list) (v free-module-element)
		       &rest ignore)									       &rest ignore)
  (declare (ignore ignore))								  (declare (ignore ignore))
  (let* ((dim (dimension-of (domain-of v)))						  (let* ((dim (dimension-of (domain-of v)))
	 (ans (make-array dim)))								 (ans (make-array dim)))
    (loop-vector-bind (i dim) ((e (tuple-value v)))					    (loop-vector-bind (i dim) ((e (tuple-value v)))
      (setf (svref ans i) (substitute values variables e)))				      (setf (svref ans i) (substitute values variables e)))
    (make-element (domain-of v) ans)))							    (make-element (domain-of v) ans)))


;; Should the absolute value of a vector be defined?  The phase?			;; Should the absolute value of a vector be defined?  The phase?

(defmethod conjugate ((vector free-module-element))					(defmethod conjugate ((vector free-module-element))
  (let* ((vector-space (domain-of vector))						  (let* ((vector-space (domain-of vector))
	 (dim (dimension-of vector-space))							 (dim (dimension-of vector-space))
	 (ans (make-array dim)))								 (ans (make-array dim)))
    (loop-vector-bind (i dim)								    (loop-vector-bind (i dim)
      ((e (tuple-value vector)))							      ((e (tuple-value vector)))
      (setf (aref ans i) (conjugate e)))						      (setf (aref ans i) (conjugate e)))
    (make-element vector-space ans)))							    (make-element vector-space ans)))

(defmethod realpart ((vector free-module-element))					(defmethod realpart ((vector free-module-element))
  (let* ((vector-space (domain-of vector))						  (let* ((vector-space (domain-of vector))
	 (dim (dimension-of vector-space))							 (dim (dimension-of vector-space))
	 (ans (make-array dim)))								 (ans (make-array dim)))
    (loop-vector-bind (i dim)								    (loop-vector-bind (i dim)
      ((e (tuple-value vector)))							      ((e (tuple-value vector)))
      (setf (aref ans i) (realpart e)))							      (setf (aref ans i) (realpart e)))
    (make-element vector-space ans)))							    (make-element vector-space ans)))

(defmethod imagpart ((vector free-module-element))					(defmethod imagpart ((vector free-module-element))
  (let* ((vector-space (domain-of vector))						  (let* ((vector-space (domain-of vector))
	 (dim (dimension-of vector-space))							 (dim (dimension-of vector-space))
	 (ans (make-array dim)))								 (ans (make-array dim)))
    (loop-vector-bind (i dim)								    (loop-vector-bind (i dim)
      ((e (tuple-value vector)))							      ((e (tuple-value vector)))
      (setf (aref ans i) (imagpart e)))							      (setf (aref ans i) (imagpart e)))
    (make-element vector-space ans)))							    (make-element vector-space ans)))


;;; the dimension of a vector is the dimension of it's domain				;;; the dimension of a vector is the dimension of it's domain
(defmethod dimension-of ((v vector-space-element))					(defmethod dimension-of ((v vector-space-element))
  (dimension-of (domain-of v)))								  (dimension-of (domain-of v)))
;;;-*- Mode:LISP; Package:(WALKER LISP 1000); Base:10; Syntax:Common-lisp -*-		;;;-*- Mode:LISP; Package:(WALKER LISP 1000); Base:10; Syntax:Common-lisp -*-
;;;											;;;
;;; *************************************************************************		;;; *************************************************************************
;;; Copyright (c) 1985, 1986, 1987, 1988, 1989, 1990 Xerox Corporation.			;;; Copyright (c) 1985, 1986, 1987, 1988, 1989, 1990 Xerox Corporation.
;;; All rights reserved.								;;; All rights reserved.
;;;											;;;
;;; Use and copying of this software and preparation of derivative works		;;; Use and copying of this software and preparation of derivative works
;;; based upon this software are permitted.  Any distribution of this			;;; based upon this software are permitted.  Any distribution of this
;;; software or derivative works must comply with all applicable United			;;; software or derivative works must comply with all applicable United
;;; States export control laws.								;;; States export control laws.
;;; 											;;; 
;;; This software is made available AS IS, and Xerox Corporation makes no		;;; This software is made available AS IS, and Xerox Corporation makes no
;;; warranty about the software, its performance or its conformity to any		;;; warranty about the software, its performance or its conformity to any
;;; specification.									;;; specification.
;;; 											;;; 
;;; Any person obtaining a copy of this software is requested to send their		;;; Any person obtaining a copy of this software is requested to send their
;;; name and post office or electronic mail address to:					;;; name and post office or electronic mail address to:
;;;   CommonLoops Coordinator								;;;   CommonLoops Coordinator
;;;   Xerox PARC									;;;   Xerox PARC
;;;   3333 Coyote Hill Rd.								;;;   3333 Coyote Hill Rd.
;;;   Palo Alto, CA 94304								;;;   Palo Alto, CA 94304
;;; (or send Arpanet mail to CommonLoops-Coordinator.pa@Xerox.arpa)			;;; (or send Arpanet mail to CommonLoops-Coordinator.pa@Xerox.arpa)
;;;											;;;
;;; Suggestions, comments and requests for improvements are also welcome.		;;; Suggestions, comments and requests for improvements are also welcome.
;;; *************************************************************************		;;; *************************************************************************
;;; 											;;; 
;;; A simple code walker, based IN PART on: (roll the credits)				;;; A simple code walker, based IN PART on: (roll the credits)
;;;   Larry Masinter's Masterscope							;;;   Larry Masinter's Masterscope
;;;   Moon's Common Lisp code walker							;;;   Moon's Common Lisp code walker
;;;   Gary Drescher's code walker							;;;   Gary Drescher's code walker
;;;   Larry Masinter's simple code walker						;;;   Larry Masinter's simple code walker
;;;   .											;;;   .
;;;   .											;;;   .
;;;   boy, thats fair (I hope).								;;;   boy, thats fair (I hope).
;;;											;;;
;;; For now at least, this code walker really only does what PCL needs it to		;;; For now at least, this code walker really only does what PCL needs it to
;;; do.  Maybe it will grow up someday.							;;; do.  Maybe it will grow up someday.
;;;											;;;

;;;											;;;
;;; This code walker used to be completely portable.  Now it is just "Real		;;; This code walker used to be completely portable.  Now it is just "Real
;;; easy to port".  This change had to happen because the hack that made it		;;; easy to port".  This change had to happen because the hack that made it
;;; completely portable kept breaking in different releases of different		;;; completely portable kept breaking in different releases of different
;;; Common Lisps, and in addition it never worked entirely anyways.  So,		;;; Common Lisps, and in addition it never worked entirely anyways.  So,
;;; its now easy to port.  To port this walker, all you have to write is one		;;; its now easy to port.  To port this walker, all you have to write is one
;;; simple macro and two simple functions.  These macros and functions are		;;; simple macro and two simple functions.  These macros and functions are
;;; used by the walker to manipluate the macroexpansion environments of			;;; used by the walker to manipluate the macroexpansion environments of
;;; the Common Lisp it is running in.							;;; the Common Lisp it is running in.
;;;											;;;
;;; The code which implements the macroexpansion environment manipulation		;;; The code which implements the macroexpansion environment manipulation
;;; mechanisms is in the first part of the file, the real walker follows it.		;;; mechanisms is in the first part of the file, the real walker follows it.
;;; 											;;; 

(in-package :walker)									(in-package :walker)

;;;											;;;
;;; The user entry points are walk-form and nested-walked-form.  In addition,		;;; The user entry points are walk-form and nested-walked-form.  In addition,
;;; it is legal for user code to call the variable information functions:		;;; it is legal for user code to call the variable information functions:
;;; variable-lexical-p, variable-special-p and variable-class.  Some users		;;; variable-lexical-p, variable-special-p and variable-class.  Some users
;;; will need to call define-walker-template, they will have to figure that		;;; will need to call define-walker-template, they will have to figure that
;;; out for themselves.									;;; out for themselves.
;;; 											;;; 
(export '(define-walker-template							(export '(define-walker-template
	  walk-form										  walk-form
	  walk-form-expand-macros-p								  walk-form-expand-macros-p
	  nested-walk-form									  nested-walk-form
	  variable-lexical-p									  variable-lexical-p
	  variable-special-p									  variable-special-p
	  variable-globally-special-p								  variable-globally-special-p
	  *variable-declarations*								  *variable-declarations*
	  variable-declaration									  variable-declaration
	  macroexpand-all									  macroexpand-all
	  ))											  ))


											
;;;											;;;
;;; On the following pages are implementations of the implementation specific		;;; On the following pages are implementations of the implementation specific
;;; environment hacking functions for each of the implementations this walker		;;; environment hacking functions for each of the implementations this walker
;;; has been ported to.  If you add a new one, so this walker can run in a new		;;; has been ported to.  If you add a new one, so this walker can run in a new
;;; implementation of Common Lisp, please send the changes back to us so that		;;; implementation of Common Lisp, please send the changes back to us so that
;;; others can also use this walker in that implementation of Common Lisp.		;;; others can also use this walker in that implementation of Common Lisp.
;;;											;;;
;;; This code just hacks 'macroexpansion environments'.  That is, it is only		;;; This code just hacks 'macroexpansion environments'.  That is, it is only
;;; concerned with the function binding of symbols in the environment.  The		;;; concerned with the function binding of symbols in the environment.  The
;;; walker needs to be able to tell if the symbol names a lexical macro or		;;; walker needs to be able to tell if the symbol names a lexical macro or
;;; function, and it needs to be able to build environments which contain		;;; function, and it needs to be able to build environments which contain
;;; lexical macro or function bindings.  It must be able, when walking a		;;; lexical macro or function bindings.  It must be able, when walking a
;;; macrolet, flet or labels form to construct an environment which reflects		;;; macrolet, flet or labels form to construct an environment which reflects
;;; the bindings created by that form.  Note that the environment created		;;; the bindings created by that form.  Note that the environment created
;;; does NOT have to be sufficient to evaluate the body, merely to walk its		;;; does NOT have to be sufficient to evaluate the body, merely to walk its
;;; body.  This means that definitions do not have to be supplied for lexical		;;; body.  This means that definitions do not have to be supplied for lexical
;;; functions, only the fact that that function is bound is important.  For		;;; functions, only the fact that that function is bound is important.  For
;;; macros, the macroexpansion function must be supplied.				;;; macros, the macroexpansion function must be supplied.
;;;											;;;
;;; This code is organized in a way that lets it work in implementations that		;;; This code is organized in a way that lets it work in implementations that
;;; stack cons their environments.  That is reflected in the fact that the		;;; stack cons their environments.  That is reflected in the fact that the
;;; only operation that lets a user build a new environment is a with-body		;;; only operation that lets a user build a new environment is a with-body
;;; macro which executes its body with the specified symbol bound to the new		;;; macro which executes its body with the specified symbol bound to the new
;;; environment.  No code in this walker or in PCL will hold a pointer to		;;; environment.  No code in this walker or in PCL will hold a pointer to
;;; these environments after the body returns.  Other user code is free to do		;;; these environments after the body returns.  Other user code is free to do
;;; so in implementations where it works, but that code is not considered		;;; so in implementations where it works, but that code is not considered
;;; portable.										;;; portable.
;;;											;;;
;;; There are 3 environment hacking tools.  One macro which is used for			;;; There are 3 environment hacking tools.  One macro which is used for
;;; creating new environments, and two functions which are used to access the		;;; creating new environments, and two functions which are used to access the
;;; bindings of existing environments.							;;; bindings of existing environments.
;;;											;;;
;;; WITH-AUGMENTED-ENVIRONMENT								;;; WITH-AUGMENTED-ENVIRONMENT
;;;											;;;
;;; ENVIRONMENT-FUNCTION								;;; ENVIRONMENT-FUNCTION
;;;											;;;
;;; ENVIRONMENT-MACRO									;;; ENVIRONMENT-MACRO
;;; 											;;; 

(defun unbound-lexical-function (&rest args)						(defun unbound-lexical-function (&rest args)
  (declare (ignore args))								  (declare (ignore args))
  (error "The evaluator was called to evaluate a form in a macroexpansion~%~		  (error "The evaluator was called to evaluate a form in a macroexpansion~%~
          environment constructed by the PCL portable code walker.  These~%~		          environment constructed by the PCL portable code walker.  These~%~
          environments are only useful for macroexpansion, they cannot be~%~		          environments are only useful for macroexpansion, they cannot be~%~
          used for evaluation.~%~							          used for evaluation.~%~
          This error should never occur when using PCL.~%~				          This error should never occur when using PCL.~%~
          This most likely source of this error is a program which tries to~%~		          This most likely source of this error is a program which tries to~%~
          to use the PCL portable code walker to build its own evaluator."))		          to use the PCL portable code walker to build its own evaluator."))

											
;;;											;;;
;;; In Coral Common Lisp, the macroexpansion environment is just a list			;;; In Coral Common Lisp, the macroexpansion environment is just a list
;;; of environment entries.  The cadr of each element specifies the type		;;; of environment entries.  The cadr of each element specifies the type
;;; of the element.  The only types that interest us are CCL::MACRO and			;;; of the element.  The only types that interest us are CCL::MACRO and
;;; FUNCTION.  In these cases the element is interpreted as follows.			;;; FUNCTION.  In these cases the element is interpreted as follows.
;;;											;;;
;;;   (<function-name> CCL::MACRO . macroexpansion-function)				;;;   (<function-name> CCL::MACRO . macroexpansion-function)
;;;   											;;;   
;;;   (<function-name> FUNCTION . <fn>)							;;;   (<function-name> FUNCTION . <fn>)
;;;   											;;;   
;;;   When in the compiler, <fn> is a gensym which will be				;;;   When in the compiler, <fn> is a gensym which will be
;;;   a variable which bound at run-time to the function.				;;;   a variable which bound at run-time to the function.
;;;   When in the interpreter, <fn> is the actual function.				;;;   When in the interpreter, <fn> is the actual function.
;;;   											;;;   
;;;											;;;
#+:Coral										#+:Coral
(progn 											(progn 
  #-ccl-2										  #-ccl-2
  (progn										  (progn
    											    
    (defmacro with-augmented-environment						    (defmacro with-augmented-environment
	      ((new-env old-env &key functions macros) &body body)				      ((new-env old-env &key functions macros) &body body)
      `(let ((,new-env (with-augmented-environment-internal ,old-env			      `(let ((,new-env (with-augmented-environment-internal ,old-env
                         ,functions							                         ,functions
                         ,macros)))							                         ,macros)))
         ,@body))									         ,@body))
    											    
    (defun with-augmented-environment-internal (env functions macros)			    (defun with-augmented-environment-internal (env functions macros)
      (dolist (f functions)								      (dolist (f functions)
        (push (list* f 'function (gensym)) env))					        (push (list* f 'function (gensym)) env))
      (dolist (m macros)								      (dolist (m macros)
        (push (list* (car m) 'ccl::macro (cadr m)) env))				        (push (list* (car m) 'ccl::macro (cadr m)) env))
      env)										      env)
    											    
    (defun environment-function (env fn)						    (defun environment-function (env fn)
      (let ((entry (assoc fn env :test #'equal)))					      (let ((entry (assoc fn env :test #'equal)))
        (and entry									        (and entry
	     (eq (cadr entry) 'function)							     (eq (cadr entry) 'function)
	     (cddr entry))))									     (cddr entry))))
    											    
    (defun environment-macro (env macro)						    (defun environment-macro (env macro)
      (let ((entry (assoc macro env :test #'equal)))					      (let ((entry (assoc macro env :test #'equal)))
        (and entry									        (and entry
	     (eq (cadr entry) 'ccl::macro)							     (eq (cadr entry) 'ccl::macro)
	     (cddr entry))))									     (cddr entry))))
    											    
    )											    )
  #+ccl-2                              ; This isn't Coral specific			  #+ccl-2                              ; This isn't Coral specific
     (defmacro with-augmented-environment						     (defmacro with-augmented-environment
	      ((new-env old-env &key functions macros) &body body)				      ((new-env old-env &key functions macros) &body body)
      `(let ((,new-env (with-augmented-environment-internal ,old-env			      `(let ((,new-env (with-augmented-environment-internal ,old-env
                         ,functions							                         ,functions
                         ,macros)))							                         ,macros)))
         ,@body))									         ,@body))
     ;; Should work in any ClTl2 implimentation						     ;; Should work in any ClTl2 implimentation
  #+ccl-2(progn										  #+ccl-2(progn
    (defun with-augmented-environment-internal (env functions macros)			    (defun with-augmented-environment-internal (env functions macros)
      (let ((functions-and-defs								      (let ((functions-and-defs
             (mapcar #'(lambda (f)							             (mapcar #'(lambda (f)
                         (car f) ) functions))						                         (car f) ) functions))
            (macros-and-defs								            (macros-and-defs
             (mapcar #'(lambda (m)							             (mapcar #'(lambda (m)
                         (list (car m) (cadr m))) macros)))				                         (list (car m) (cadr m))) macros)))
        (cl:augment-environment env							        (cl:augment-environment env
                                :function functions-and-defs :macro macros-and-def	                                :function functions-and-defs :macro macros-and-def
        )										        )
      )											      )
    											    
    (defun environment-function (env fn)						    (defun environment-function (env fn)
      (multiple-value-bind (type )							      (multiple-value-bind (type )
                           (cl:function-information fn env)				                           (cl:function-information fn env)
        (eql type :function)))								        (eql type :function)))
    											    
    (defun environment-macro (env fn)							    (defun environment-macro (env fn)
      (multiple-value-bind (type )							      (multiple-value-bind (type )
                           (cl:function-information fn env)				                           (cl:function-information fn env)
        (if (eql type :macro)								        (if (eql type :macro)
          (macro-function fn env ))))							          (macro-function fn env ))))
    											    
    ));#+:Coral										    ));#+:Coral

											
;;;											;;;
;;; Franz Common Lisp is a lot like Coral Lisp.  The macroexpansion			;;; Franz Common Lisp is a lot like Coral Lisp.  The macroexpansion
;;; environment is just a list of entries.  The cadr of each element			;;; environment is just a list of entries.  The cadr of each element
;;; specifies the type of the element.  The types that interest us			;;; specifies the type of the element.  The types that interest us
;;; are FUNCTION, EXCL::MACRO, and COMPILER::FUNCTION-VALUE.  These			;;; are FUNCTION, EXCL::MACRO, and COMPILER::FUNCTION-VALUE.  These
;;; are interpreted as follows:								;;; are interpreted as follows:
;;;											;;;
;;;   (<function-name> FUNCTION . <a lexical closure>)					;;;   (<function-name> FUNCTION . <a lexical closure>)
;;;											;;;
;;;      This happens in the interpreter with lexically					;;;      This happens in the interpreter with lexically
;;;      bound functions.								;;;      bound functions.
;;;											;;;
;;;   (<function-name> COMPILER::FUNCTION-VALUE . <gensym>)				;;;   (<function-name> COMPILER::FUNCTION-VALUE . <gensym>)
;;;											;;;
;;;      This happens in the compiler.  The gensym represents				;;;      This happens in the compiler.  The gensym represents
;;;      a variable which will be bound at run time to the				;;;      a variable which will be bound at run time to the
;;;      function object.								;;;      function object.
;;;											;;;
;;;   (<function-name> EXCL::MACRO . <a lambda>)					;;;   (<function-name> EXCL::MACRO . <a lambda>)
;;;											;;;
;;;      In both interpreter and compiler, this is the					;;;      In both interpreter and compiler, this is the
;;;      representation used for macro definitions.					;;;      representation used for macro definitions.
;;;   											;;;   
;;;											;;;
#+:ExCL											#+:ExCL
(progn											(progn

#+(or allegro-v4.1 allegro-v4.2)							#+(or allegro-v4.1 allegro-v4.2)
(pushnew :allegro-v4.1+ *features*)							(pushnew :allegro-v4.1+ *features*)

(defmacro special-form-p (sym) `(cltl1:special-form-p ,sym))				(defmacro special-form-p (sym) `(cltl1:special-form-p ,sym))

(defmacro with-augmented-environment							(defmacro with-augmented-environment
	  ((new-env old-env &key functions macros) &body body)					  ((new-env old-env &key functions macros) &body body)
  `(let ((,new-env (with-augmented-environment-internal ,old-env			  `(let ((,new-env (with-augmented-environment-internal ,old-env
							,functions										,functions
							,macros)))										,macros)))
     ,@body))										     ,@body))

(defun with-augmented-environment-internal (env functions macros)			(defun with-augmented-environment-internal (env functions macros)
  (let (#+allegro-v4.1+ (env-tail (cdr env)) #+allegro-v4.1+ (env (car env)))		  (let (#+allegro-v4.1+ (env-tail (cdr env)) #+allegro-v4.1+ (env (car env)))
    (dolist (f functions)								    (dolist (f functions)
      (push (list* f 'function #'unbound-lexical-function) env))			      (push (list* f 'function #'unbound-lexical-function) env))
    (dolist (m macros) 									    (dolist (m macros) 
      (push (list* (car m) 'excl::macro (cadr m)) env))					      (push (list* (car m) 'excl::macro (cadr m)) env))
    #-allegro-v4.1+ env									    #-allegro-v4.1+ env
    #+allegro-v4.1+ (cons env env-tail)))						    #+allegro-v4.1+ (cons env env-tail)))

(defun environment-function (env fn)							(defun environment-function (env fn)
  (let* (#+allegro-v4.1 (env (car env))							  (let* (#+allegro-v4.1 (env (car env))
	 (entry (assoc fn env :test #'equal)))							 (entry (assoc fn env :test #'equal)))
    (and entry										    (and entry
	 (or (eq (cadr entry) 'function)							 (or (eq (cadr entry) 'function)
	     (eq (cadr entry) 'compiler::function-value))					     (eq (cadr entry) 'compiler::function-value))
	 (cddr entry))))									 (cddr entry))))

(defun environment-macro (env macro)							(defun environment-macro (env macro)
  (let* (#+allegro-v4.1+ (env (car env))						  (let* (#+allegro-v4.1+ (env (car env))
	 (entry (assoc macro env :test #'equal)))						 (entry (assoc macro env :test #'equal)))
    (and entry										    (and entry
	 (eq (cadr entry) 'excl::macro)								 (eq (cadr entry) 'excl::macro)
	 (cddr entry))))									 (cddr entry))))

);#+:ExCL										);#+:ExCL

											
#+Lucid											#+Lucid
(progn											(progn
  											  
(proclaim '(inline									(proclaim '(inline
	    %alphalex-p										    %alphalex-p
	    add-contour-to-env-shape								    add-contour-to-env-shape
	    make-function-variable								    make-function-variable
	    make-sfc-contour									    make-sfc-contour
	    sfc-contour-type									    sfc-contour-type
	    sfc-contour-elements								    sfc-contour-elements
	    add-sfc-contour									    add-sfc-contour
	    add-function-contour								    add-function-contour
	    add-macrolet-contour								    add-macrolet-contour
	    find-variable-in-contour								    find-variable-in-contour
	    find-alist-element-in-contour							    find-alist-element-in-contour
	    find-macrolet-in-contour))								    find-macrolet-in-contour))

(defun %alphalex-p (object)								(defun %alphalex-p (object)
  #-Prime										  #-Prime
  (eq (cadddr (cddddr object)) 'lucid::%alphalex)					  (eq (cadddr (cddddr object)) 'lucid::%alphalex)
  #+Prime										  #+Prime
  (eq (caddr (cddddr object)) 'lucid::%alphalex))					  (eq (caddr (cddddr object)) 'lucid::%alphalex))

#+Prime 										#+Prime 
(defun lucid::augment-lexenv-fvars-dummy (lexical vars)					(defun lucid::augment-lexenv-fvars-dummy (lexical vars)
  (lucid::augment-lexenv-fvars-aux lexical vars '() '() 'flet '()))			  (lucid::augment-lexenv-fvars-aux lexical vars '() '() 'flet '()))

;; FIXTHIS The problem seems to be around here.  the type of contour			;; FIXTHIS The problem seems to be around here.  the type of contour
;; being created by this version of PCL doesn't match					;; being created by this version of PCL doesn't match

(defconstant function-contour 1)							(defconstant function-contour 1)
(defconstant macrolet-contour 5)							(defconstant macrolet-contour 5)

(defstruct lucid::contour								(defstruct lucid::contour
  type											  type
  elements)										  elements)
				   											   
(defun add-contour-to-env-shape (contour-type elements env-shape)			(defun add-contour-to-env-shape (contour-type elements env-shape)
  (cons (make-contour :type contour-type						  (cons (make-contour :type contour-type
		      :elements elements)								      :elements elements)
			     env-shape))									     env-shape))

(defstruct (variable (:constructor make-variable (name source-type)))			(defstruct (variable (:constructor make-variable (name source-type)))
  name											  name
  (identifier nil)									  (identifier nil)
  source-type)										  source-type)

(defconstant function-sfc-contour 1)							(defconstant function-sfc-contour 1)
(defconstant macrolet-sfc-contour 8)							(defconstant macrolet-sfc-contour 8)
(defconstant function-variable-type 1)							(defconstant function-variable-type 1)

(defun make-function-variable (name)							(defun make-function-variable (name)
  (make-variable name function-variable-type))						  (make-variable name function-variable-type))

(defun make-sfc-contour (type elements)							(defun make-sfc-contour (type elements)
  (cons type elements))									  (cons type elements))

(defun sfc-contour-type (sfc-contour)							(defun sfc-contour-type (sfc-contour)
  (car sfc-contour))									  (car sfc-contour))

(defun sfc-contour-elements (sfc-contour)						(defun sfc-contour-elements (sfc-contour)
  (cdr sfc-contour))									  (cdr sfc-contour))

(defun add-sfc-contour (element-list environment type)					(defun add-sfc-contour (element-list environment type)
  (cons (make-sfc-contour type element-list) environment))				  (cons (make-sfc-contour type element-list) environment))

(defun add-function-contour (variable-list environment)					(defun add-function-contour (variable-list environment)
  (add-sfc-contour variable-list environment function-sfc-contour))			  (add-sfc-contour variable-list environment function-sfc-contour))

(defun add-macrolet-contour (alist environment)						(defun add-macrolet-contour (alist environment)
  (add-sfc-contour alist environment macrolet-sfc-contour))				  (add-sfc-contour alist environment macrolet-sfc-contour))

(defun find-variable-in-contour (name contour)						(defun find-variable-in-contour (name contour)
  (dolist (element (sfc-contour-elements contour) nil)					  (dolist (element (sfc-contour-elements contour) nil)
    (when (eq (variable-name element) name)						    (when (eq (variable-name element) name)
      (return element))))								      (return element))))

(defun find-alist-element-in-contour (name contour)					(defun find-alist-element-in-contour (name contour)
  (cdr (assoc name (sfc-contour-elements contour))))					  (cdr (assoc name (sfc-contour-elements contour))))

(defun find-macrolet-in-contour (name contour)						(defun find-macrolet-in-contour (name contour)
  (find-alist-element-in-contour name contour))						  (find-alist-element-in-contour name contour))

(defmacro do-sfc-contours ((contour-var environment &optional result)			(defmacro do-sfc-contours ((contour-var environment &optional result)
			   &body body)										   &body body)
  `(dolist (,contour-var ,environment ,result) ,@body))					  `(dolist (,contour-var ,environment ,result) ,@body))


(defmacro with-augmented-environment							(defmacro with-augmented-environment
	  ((new-env old-env &key functions macros) &body body)     				  ((new-env old-env &key functions macros) &body body)     
  `(let* ((,new-env (with-augmented-environment-internal ,old-env			  `(let* ((,new-env (with-augmented-environment-internal ,old-env
							 ,functions										 ,functions
							 ,macros)))										 ,macros)))
     ,@body))										     ,@body))

;;;											;;;
;;; with-augmented-environment-internal is where the real work of augmenting		;;; with-augmented-environment-internal is where the real work of augmenting
;;; the environment happens.								;;; the environment happens.
;;; 											;;; 
(defun with-augmented-environment-internal (env functions macros)			(defun with-augmented-environment-internal (env functions macros)
  (let ((function-names (mapcar #'first functions))					  (let ((function-names (mapcar #'first functions))
	(macro-names (mapcar #'first macros))							(macro-names (mapcar #'first macros))
	(macro-functions (mapcar #'second macros)))						(macro-functions (mapcar #'second macros)))
    (cond ((or (null env)								    (cond ((or (null env)
	       (contour-p (first env)))								       (contour-p (first env)))
	   (when function-names									   (when function-names
	     (setq env (add-contour-to-env-shape function-contour				     (setq env (add-contour-to-env-shape function-contour
						 function-names										 function-names
						 env)))											 env)))
	   (when macro-names									   (when macro-names
	     (setq env (add-contour-to-env-shape macrolet-contour				     (setq env (add-contour-to-env-shape macrolet-contour
						 (pairlis macro-names									 (pairlis macro-names
							  macro-functions)									  macro-functions)
						 env))))										 env))))
	  ((%alphalex-p env)									  ((%alphalex-p env)
	   (when function-names									   (when function-names
	     (setq env (lucid::augment-lexenv-fvars-dummy env function-names)))			     (setq env (lucid::augment-lexenv-fvars-dummy env function-names)))
	   (when macro-names									   (when macro-names
	     (setq env (lucid::augment-lexenv-mvars env						     (setq env (lucid::augment-lexenv-mvars env
						    macro-names										    macro-names
						    macro-functions))))									    macro-functions))))
	  (t											  (t
	   (when function-names									   (when function-names
	     (setq env (add-function-contour							     (setq env (add-function-contour
			 (mapcar #'make-function-variable function-names)					 (mapcar #'make-function-variable function-names)
			 env)))											 env)))
	   (when macro-names									   (when macro-names
	     (setq env (add-macrolet-contour							     (setq env (add-macrolet-contour
			 (pairlis macro-names macro-functions)							 (pairlis macro-names macro-functions)
			 env)))))										 env)))))
    env))										    env))
	 											 

(defun environment-function (env fn)							(defun environment-function (env fn)
  (cond ((null env) nil)								  (cond ((null env) nil)
	((contour-p (first env))								((contour-p (first env))
	 (if (lucid::find-lexical-function fn env)						 (if (lucid::find-lexical-function fn env)
	     t											     t
	     nil))										     nil))
	((%alphalex-p env)									((%alphalex-p env)
	 (if (lucid::lexenv-fvar fn env)							 (if (lucid::lexenv-fvar fn env)
	     t											     t
	     nil))										     nil))
	(t (do-sfc-contours (contour env nil)							(t (do-sfc-contours (contour env nil)
	     (let ((type (sfc-contour-type contour)))						     (let ((type (sfc-contour-type contour)))
	       (cond ((eql type function-sfc-contour)						       (cond ((eql type function-sfc-contour)
		      (when (find-variable-in-contour fn contour)					      (when (find-variable-in-contour fn contour)
			(return t)))										(return t)))
		     ((eql type macrolet-sfc-contour)							     ((eql type macrolet-sfc-contour)
		      (when (find-macrolet-in-contour fn contour)					      (when (find-macrolet-in-contour fn contour)
			(return nil)))))))))									(return nil)))))))))
		      											      
(defun environment-macro (env macro)							(defun environment-macro (env macro)
  (cond ((null env) nil)								  (cond ((null env) nil)
	((contour-p (first env))								((contour-p (first env))
	 (lucid::find-lexical-macro macro env))							 (lucid::find-lexical-macro macro env))
	((%alphalex-p env)									((%alphalex-p env)
	 (lucid::lexenv-mvar macro env))							 (lucid::lexenv-mvar macro env))
	(t (do-sfc-contours (contour env nil)							(t (do-sfc-contours (contour env nil)
	     (let ((type (sfc-contour-type contour)))						     (let ((type (sfc-contour-type contour)))
	       (cond ((eql type function-sfc-contour)						       (cond ((eql type function-sfc-contour)
		      (when (find-variable-in-contour macro contour)					      (when (find-variable-in-contour macro contour)
			(return nil)))										(return nil)))
		     ((eql type macrolet-sfc-contour)							     ((eql type macrolet-sfc-contour)
		      (let ((fn (find-macrolet-in-contour macro contour)))				      (let ((fn (find-macrolet-in-contour macro contour)))
			(when fn										(when fn
			  (return fn))))))))))									  (return fn))))))))))
  											  

);#+Lucid										);#+Lucid


											
;;;											;;;
;;; On the 3600, the documentation for how the environments are represented		;;; On the 3600, the documentation for how the environments are represented
;;; is in sys:sys;eval.lisp.  That total information is not repeated here.		;;; is in sys:sys;eval.lisp.  That total information is not repeated here.
;;; The important points are that:							;;; The important points are that:
;;;    si:env-variables returns a list of which each element is:			;;;    si:env-variables returns a list of which each element is:
;;;											;;;
;;;		(symbol value)								;;;		(symbol value)
;;;	     or (symbol . locative)							;;;	     or (symbol . locative)
;;;											;;;
;;;	The first form is for lexical variables, the second for				;;;	The first form is for lexical variables, the second for
;;;	special and instance variables.  In either case CADR of				;;;	special and instance variables.  In either case CADR of
;;;	the entry is the value and SETF of CADR is used to change			;;;	the entry is the value and SETF of CADR is used to change
;;;	the value.  Variables are looked up with ASSQ.					;;;	the value.  Variables are looked up with ASSQ.
;;;											;;;
;;;    si:env-functions returns a list of which each element is:			;;;    si:env-functions returns a list of which each element is:
;;;     										;;;     
;;;		(symbol definition)							;;;		(symbol definition)
;;;											;;;
;;;	where definition is anything that could go in a function cell.			;;;	where definition is anything that could go in a function cell.
;;;	This is used for both local functions and local macros.				;;;	This is used for both local functions and local macros.
;;;											;;;
;;; The 3600 stack conses its environments (at least in the interpreter).		;;; The 3600 stack conses its environments (at least in the interpreter).
;;; This means that code written using this walker and running on the 3600		;;; This means that code written using this walker and running on the 3600
;;; must not hold on to the environment after the walk-function returns.		;;; must not hold on to the environment after the walk-function returns.
;;; No code in this walker or in PCL does that.						;;; No code in this walker or in PCL does that.
;;;											;;;
#+Genera										#+Genera
(progn											(progn

(defmacro with-augmented-environment							(defmacro with-augmented-environment
	  ((new-env old-env &key functions macros) &body body)					  ((new-env old-env &key functions macros) &body body)
  (let ((funs (make-symbol "FNS"))							  (let ((funs (make-symbol "FNS"))
	(macs (make-symbol "MACROS"))								(macs (make-symbol "MACROS"))
	(new  (make-symbol "NEW")))								(new  (make-symbol "NEW")))
    `(let ((,funs ,functions)								    `(let ((,funs ,functions)
	   (,macs ,macros)									   (,macs ,macros)
	   (,new ()))										   (,new ()))
       (dolist (f ,funs)								       (dolist (f ,funs)
	 (push `(,(car f) ,#'unbound-lexical-function) ,new))					 (push `(,(car f) ,#'unbound-lexical-function) ,new))
       (dolist (m ,macs)								       (dolist (m ,macs)
	 (push `(,(car m) (special ,(cadr m))) ,new))						 (push `(,(car m) (special ,(cadr m))) ,new))
       (let* ((.old-env. ,old-env)							       (let* ((.old-env. ,old-env)
	      (.old-vars. (pop .old-env.))							      (.old-vars. (pop .old-env.))
	      (.old-funs. (pop .old-env.))							      (.old-funs. (pop .old-env.))
	      (.old-blks. (pop .old-env.))							      (.old-blks. (pop .old-env.))
	      (.old-tags. (pop .old-env.))							      (.old-tags. (pop .old-env.))
	      (.old-dcls. (pop .old-env.)))							      (.old-dcls. (pop .old-env.)))
	 (si:with-interpreter-environment (,new-env						 (si:with-interpreter-environment (,new-env
					   .old-env.										   .old-env.
					   .old-vars.										   .old-vars.
					   (append ,new .old-funs.)								   (append ,new .old-funs.)
					   .old-blks.										   .old-blks.
					   .old-tags.										   .old-tags.
					   .old-dcls.)										   .old-dcls.)
	   ,@body)))))										   ,@body)))))
  											  

(defun environment-function (env fn)							(defun environment-function (env fn)
  (if (null env)									  (if (null env)
      (values nil nil)									      (values nil nil)
      (let ((entry (assoc fn (si:env-functions env) :test #'equal)))			      (let ((entry (assoc fn (si:env-functions env) :test #'equal)))
	(if (and entry										(if (and entry
		 (or (not (listp (cadr entry)))								 (or (not (listp (cadr entry)))
		     (not (eq (caadr entry) 'special))))						     (not (eq (caadr entry) 'special))))
	    (values (cadr entry) t)								    (values (cadr entry) t)
	    (environment-function (si:env-parent env) fn)))))					    (environment-function (si:env-parent env) fn)))))

(defun environment-macro (env macro)							(defun environment-macro (env macro)
  (if (null env)									  (if (null env)
      (values nil nil)									      (values nil nil)
      (let ((entry (assoc macro (si:env-functions env) :test #'equal)))			      (let ((entry (assoc macro (si:env-functions env) :test #'equal)))
	(if (and entry										(if (and entry
		 (listp (cadr entry))									 (listp (cadr entry))
		 (eq (caadr entry) 'special))								 (eq (caadr entry) 'special))
	    (values (cadadr entry) t)								    (values (cadadr entry) t)
	    (environment-macro (si:env-parent env) macro)))))					    (environment-macro (si:env-parent env) macro)))))

);#+Genera										);#+Genera

#+Cloe-Runtime										#+Cloe-Runtime
(progn											(progn

(defmacro with-augmented-environment							(defmacro with-augmented-environment
	  ((new-env old-env &key functions macros) &body body)					  ((new-env old-env &key functions macros) &body body)
  `(let ((,new-env (with-augmented-environment-internal ,old-env ,functions ,macro	  `(let ((,new-env (with-augmented-environment-internal ,old-env ,functions ,macro
     ,@body))										     ,@body))

(defun with-augmented-environment-internal (env functions macros)			(defun with-augmented-environment-internal (env functions macros)
  functions										  functions
  (dolist (m macros)									  (dolist (m macros)
    (setf env `(,(first m) (compiler::macro . ,(second m)) ,@env)))			    (setf env `(,(first m) (compiler::macro . ,(second m)) ,@env)))
  env)											  env)

(defun environment-function (env fn)							(defun environment-function (env fn)
  nil)											  nil)

(defun environment-macro (env macro)							(defun environment-macro (env macro)
  (let ((entry (getf env macro)))							  (let ((entry (getf env macro)))
    (if (and (consp entry)								    (if (and (consp entry)
	     (eq (car entry) 'compiler::macro))							     (eq (car entry) 'compiler::macro))
	(values (cdr entry) t)									(values (cdr entry) t)
	(values nil nil))))									(values nil nil))))

);#+Cloe-Runtime									);#+Cloe-Runtime

											
;;;											;;;
;;; In Xerox Lisp, the compiler and interpreter use different structures for		;;; In Xerox Lisp, the compiler and interpreter use different structures for
;;; the environment.  This doesn't cause a serious problem, the parts of the		;;; the environment.  This doesn't cause a serious problem, the parts of the
;;; environments we are concerned with are fairly similar.				;;; environments we are concerned with are fairly similar.
;;; 											;;; 
#+:Xerox										#+:Xerox
(progn											(progn

(defmacro with-augmented-environment							(defmacro with-augmented-environment
	  ((new-env old-env &key functions macros) &body body)     				  ((new-env old-env &key functions macros) &body body)     
  `(let* ((,new-env (with-augmented-environment-internal ,old-env			  `(let* ((,new-env (with-augmented-environment-internal ,old-env
							 ,functions										 ,functions
							 ,macros)))										 ,macros)))
     ,@body))										     ,@body))

;;;											;;;
;;; with-augmented-environment-internal is where the real work of augmenting		;;; with-augmented-environment-internal is where the real work of augmenting
;;; the environment happens.  Before it gets there, env had better not be NIL		;;; the environment happens.  Before it gets there, env had better not be NIL
;;; anymore because we have to know what kind of environment we are supposed		;;; anymore because we have to know what kind of environment we are supposed
;;; to be building up.  This is probably never a real concern in practice.		;;; to be building up.  This is probably never a real concern in practice.
;;; It better not be because we don't do anything about it.				;;; It better not be because we don't do anything about it.
;;; 											;;; 
(defun with-augmented-environment-internal (env functions macros)			(defun with-augmented-environment-internal (env functions macros)
  (cond											  (cond
     ((compiler::env-p env)								     ((compiler::env-p env)
	(dolist (f functions)									(dolist (f functions)
	   (setq env (compiler::copy-env-with-function						   (setq env (compiler::copy-env-with-function
		       env f :function)))								       env f :function)))
	(dolist (m macros)									(dolist (m macros)
	   (setq env (compiler::copy-env-with-function						   (setq env (compiler::copy-env-with-function
	 	  env (car m) :macro (cadr m)))))						 	  env (car m) :macro (cadr m)))))
     (t (setq env (if (il:environment-p env)						     (t (setq env (if (il:environment-p env)
		    (il:\\copy-environment env)								    (il:\\copy-environment env)
		    (il:\\make-environment)))								    (il:\\make-environment)))
	;; The functions field of the environment is a plist of function names			;; The functions field of the environment is a plist of function names
	;; and conses like (:function . fn) or (:macro . expansion-fn).				;; and conses like (:function . fn) or (:macro . expansion-fn).
	;; Note that we can't smash existing entries in this plist since these			;; Note that we can't smash existing entries in this plist since these
	;; are likely shared with older environments.						;; are likely shared with older environments.
	(dolist (f functions)									(dolist (f functions)
	  (setf (il:environment-functions env)							  (setf (il:environment-functions env)
		(list* f (cons :function #'unbound-lexical-function)					(list* f (cons :function #'unbound-lexical-function)
		       (il:environment-functions env))))						       (il:environment-functions env))))
	(dolist (m macros)									(dolist (m macros)
	  (setf (il:environment-functions env)							  (setf (il:environment-functions env)
		(list* (car m) (cons :macro (cadr m))							(list* (car m) (cons :macro (cadr m))
		       (il:environment-functions env))))))						       (il:environment-functions env))))))
  env)											  env)

(defun environment-function (env fn)							(defun environment-function (env fn)
  (cond ((compiler::env-p env) (eq (compiler:env-fboundp env fn) :function))		  (cond ((compiler::env-p env) (eq (compiler:env-fboundp env fn) :function))
	((il:environment-p env) (eq (getf (il:environment-functions env) fn)			((il:environment-p env) (eq (getf (il:environment-functions env) fn)
				    :function))										    :function))
	(t nil)))										(t nil)))

(defun environment-macro (env macro) 							(defun environment-macro (env macro) 
  (cond ((compiler::env-p env)								  (cond ((compiler::env-p env)
	 (multiple-value-bind (type def)							 (multiple-value-bind (type def)
	     (compiler:env-fboundp env macro)							     (compiler:env-fboundp env macro)
	   (when (eq type :macro) def)))							   (when (eq type :macro) def)))
	((il:environment-p env)									((il:environment-p env)
	 (xcl:destructuring-bind (type . def)							 (xcl:destructuring-bind (type . def)
	     (getf (il:environment-functions env) macro)					     (getf (il:environment-functions env) macro)
	   (when (eq type :macro) def)))							   (when (eq type :macro) def)))
	(t nil)))										(t nil)))

);#+:Xerox										);#+:Xerox

											
;;;											;;;
;;; In IBUKI Common Lisp, the macroexpansion environment is a three element		;;; In IBUKI Common Lisp, the macroexpansion environment is a three element
;;; list.  The second element describes lexical functions and macros.  The 		;;; list.  The second element describes lexical functions and macros.  The 
;;; function entries in this list have the form 					;;; function entries in this list have the form 
;;;     (<name> . (FUNCTION . (<function-value> . nil))					;;;     (<name> . (FUNCTION . (<function-value> . nil))
;;; The macro entries have the form 							;;; The macro entries have the form 
;;;     (<name> . (MACRO . (<macro-value> . nil)).					;;;     (<name> . (MACRO . (<macro-value> . nil)).
;;;											;;;
;;;											;;;
#+(or KCL IBCL)										#+(or KCL IBCL)
(progn											(progn

(defmacro with-augmented-environment							(defmacro with-augmented-environment
	  ((new-env old-env &key functions macros) &body body)					  ((new-env old-env &key functions macros) &body body)
	  `(let ((,new-env (with-augmented-environment-internal ,old-env			  `(let ((,new-env (with-augmented-environment-internal ,old-env
								,functions										,functions
								,macros)))										,macros)))
	     ,@body))										     ,@body))

(defun with-augmented-environment-internal (env functions macros)			(defun with-augmented-environment-internal (env functions macros)
  (let ((first (first env))								  (let ((first (first env))
	(lexicals (second env))									(lexicals (second env))
	(third (third env)))									(third (third env)))
    (dolist (f functions)								    (dolist (f functions)
      (push `(,(car f) .  (function  . (,#'unbound-lexical-function . nil)))		      (push `(,(car f) .  (function  . (,#'unbound-lexical-function . nil)))
	    lexicals))										    lexicals))
    (dolist (m macros)									    (dolist (m macros)
      (push `(,(car m)  .  (macro . ( ,(cadr m) . nil))) 				      (push `(,(car m)  .  (macro . ( ,(cadr m) . nil))) 
	    lexicals))										    lexicals))
    (list first lexicals third)))							    (list first lexicals third)))

(defun environment-function (env fn)							(defun environment-function (env fn)
  (when env										  (when env
	(let ((entry (assoc fn (second env))))							(let ((entry (assoc fn (second env))))
	  (and entry										  (and entry
	       (eq (cadr entry) 'function)							       (eq (cadr entry) 'function)
	       (caddr entry)))))								       (caddr entry)))))

(defun environment-macro (env macro)							(defun environment-macro (env macro)
  (when env										  (when env
	(let ((entry (assoc macro (second env))))						(let ((entry (assoc macro (second env))))
	  (and entry										  (and entry
	       (eq (cadr entry) 'macro)								       (eq (cadr entry) 'macro)
	       (caddr entry)))))								       (caddr entry)))))
);#+(or KCL IBCL)									);#+(or KCL IBCL)

											
;;;   --- TI Explorer --								;;;   --- TI Explorer --

;;; An environment is a two element list, whose car we can ignore and			;;; An environment is a two element list, whose car we can ignore and
;;; whose cadr is list of the local-definitions-frames. Each				;;; whose cadr is list of the local-definitions-frames. Each
;;; local-definitions-frame holds either macros or functions, but not			;;; local-definitions-frame holds either macros or functions, but not
;;; both.  Each frame is a plist of <name> <def> <name> <def> ...  where		;;; both.  Each frame is a plist of <name> <def> <name> <def> ...  where
;;; <name> is a locative to the function cell of the symbol that names			;;; <name> is a locative to the function cell of the symbol that names
;;; the function or macro, and <def> is the new def or NIL if this is function		;;; the function or macro, and <def> is the new def or NIL if this is function
;;; redefinition or (cons 'ticl:macro <macro-expansion-function>) if this is a mac	;;; redefinition or (cons 'ticl:macro <macro-expansion-function>) if this is a mac
;;; redefinition.									;;; redefinition.
;;;											;;;
;;; Here's an example.  For the form:							;;; Here's an example.  For the form:
;;; (defun foo ()									;;; (defun foo ()
;;;   (macrolet ((bar (a b) (list a b))							;;;   (macrolet ((bar (a b) (list a b))
;;;	         (bar2 (a b) (list a b)))						;;;	         (bar2 (a b) (list a b)))
;;;     (flet ((some-local-fn (c d) (print (list c d)))					;;;     (flet ((some-local-fn (c d) (print (list c d)))
;;;	       (another (c d) (print (list c d))))					;;;	       (another (c d) (print (list c d))))
;;;       (bar (some-local-fn 1 2) 3))))						;;;       (bar (some-local-fn 1 2) 3))))

;;; the environment arg to macroexpand-1 when called on					;;; the environment arg to macroexpand-1 when called on
;;; (bar (some-local-fn 1 2) 3)								;;; (bar (some-local-fn 1 2) 3)
;;;is 											;;;is 
;;;(NIL ((#<DTP-LOCATIVE 4710602> NIL							;;;(NIL ((#<DTP-LOCATIVE 4710602> NIL
;;;       #<DTP-LOCATIVE 4710671> NIL)							;;;       #<DTP-LOCATIVE 4710671> NIL)
;;;      (#<DTP-LOCATIVE 7346562>							;;;      (#<DTP-LOCATIVE 7346562>
;;;       (TICL:MACRO TICL:NAMED-LAMBDA (BAR (:DESCRIPTIVE-ARGLIST (A B)))		;;;       (TICL:MACRO TICL:NAMED-LAMBDA (BAR (:DESCRIPTIVE-ARGLIST (A B)))
;;;		   (SYS::*MACROARG* &OPTIONAL SYS::*MACROENVIRONMENT*)			;;;		   (SYS::*MACROARG* &OPTIONAL SYS::*MACROENVIRONMENT*)
;;;		   (BLOCK BAR ....))							;;;		   (BLOCK BAR ....))
;;;       #<DTP-LOCATIVE 4710664>							;;;       #<DTP-LOCATIVE 4710664>
;;;       (TICL:MACRO TICL:NAMED-LAMBDA (BAR2 (:DESCRIPTIVE-ARGLIST (A B)))		;;;       (TICL:MACRO TICL:NAMED-LAMBDA (BAR2 (:DESCRIPTIVE-ARGLIST (A B)))
;;;		   (SYS::*MACROARG* &OPTIONAL SYS::*MACROENVIRONMENT*)			;;;		   (SYS::*MACROARG* &OPTIONAL SYS::*MACROENVIRONMENT*)
;;;		   (BLOCK BAR2 ....))))							;;;		   (BLOCK BAR2 ....))))
#+TI											#+TI
(progn 											(progn 

;;; from sys:site;macros.lisp								;;; from sys:site;macros.lisp
(eval-when (compile load eval)								(eval-when (compile load eval)
  											  
(DEFMACRO MACRO-DEF? (thing)								(DEFMACRO MACRO-DEF? (thing)
  `(AND (CONSP ,thing) (EQ (CAR ,thing) 'TICL::MACRO)))					  `(AND (CONSP ,thing) (EQ (CAR ,thing) 'TICL::MACRO)))

;; the following macro generates code to check the 'local' environment			;; the following macro generates code to check the 'local' environment
;; for a macro definition for THE SYMBOL <name>. Such a definition would		;; for a macro definition for THE SYMBOL <name>. Such a definition would
;; be set up only by a MACROLET. If a macro definition for <name> is			;; be set up only by a MACROLET. If a macro definition for <name> is
;; found, its expander function is returned.						;; found, its expander function is returned.

(DEFMACRO FIND-LOCAL-DEFINITION (name local-function-environment)			(DEFMACRO FIND-LOCAL-DEFINITION (name local-function-environment)
  `(IF ,local-function-environment							  `(IF ,local-function-environment
       (LET ((vcell (ticl::LOCF (SYMBOL-FUNCTION ,name))))				       (LET ((vcell (ticl::LOCF (SYMBOL-FUNCTION ,name))))
	 (DOLIST (frame  ,local-function-environment)						 (DOLIST (frame  ,local-function-environment)
	   ;; <value> is nil or a locative							   ;; <value> is nil or a locative
	   (LET ((value (sys::GET-LOCATION-OR-NIL (ticl::LOCF frame)				   (LET ((value (sys::GET-LOCATION-OR-NIL (ticl::LOCF frame)
						  vcell))) 										  vcell))) 
	     (When value (RETURN (CAR value))))))						     (When value (RETURN (CAR value))))))
       nil)))										       nil)))

 											 
;;;Edited by Reed Hastings         13 Jan 88  16:29					;;;Edited by Reed Hastings         13 Jan 88  16:29
(defun environment-macro (env macro)							(defun environment-macro (env macro)
  "returns what macro-function would, ie. the expansion function"			  "returns what macro-function would, ie. the expansion function"
  ;;some code picked off macroexpand-1							  ;;some code picked off macroexpand-1
  (let* ((local-definitions (cadr env))							  (let* ((local-definitions (cadr env))
	 (local-def (find-local-definition macro local-definitions)))				 (local-def (find-local-definition macro local-definitions)))
    (if (macro-def? local-def)								    (if (macro-def? local-def)
	(cdr local-def))))									(cdr local-def))))

;;;Edited by Reed Hastings         13 Jan 88  16:29					;;;Edited by Reed Hastings         13 Jan 88  16:29
;;;Edited by Reed Hastings         7 Mar 88  19:07					;;;Edited by Reed Hastings         7 Mar 88  19:07
(defun environment-function (env fn)							(defun environment-function (env fn)
  (let* ((local-definitions (cadr env)))						  (let* ((local-definitions (cadr env)))
    (dolist (frame local-definitions)							    (dolist (frame local-definitions)
      (let ((val (getf frame								      (let ((val (getf frame
		       (ticl::locf (symbol-function fn))						       (ticl::locf (symbol-function fn))
		       :not-found-marker)))								       :not-found-marker)))
	(cond ((eq val :not-found-marker))							(cond ((eq val :not-found-marker))
	      ((functionp val) (return t))							      ((functionp val) (return t))
	      ((and (listp val)									      ((and (listp val)
		    (eq (car val) 'ticl::macro))							    (eq (car val) 'ticl::macro))
	       (return nil))									       (return nil))
	      (t										      (t
	       (error "we are confused")))))))							       (error "we are confused")))))))
	     											     

;;;Edited by Reed Hastings         13 Jan 88  16:29					;;;Edited by Reed Hastings         13 Jan 88  16:29
;;;Edited by Reed Hastings         7 Mar 88  19:07					;;;Edited by Reed Hastings         7 Mar 88  19:07
(defun with-augmented-environment-internal (env functions macros)			(defun with-augmented-environment-internal (env functions macros)
  (let ((local-definitions (cadr env))							  (let ((local-definitions (cadr env))
	(new-local-fns-frame									(new-local-fns-frame
	  (mapcan #'(lambda (fn)								  (mapcan #'(lambda (fn)
		      (list (ticl:locf (symbol-function (car fn)))					      (list (ticl:locf (symbol-function (car fn)))
			    #'unbound-lexical-function))							    #'unbound-lexical-function))
		  functions))										  functions))
	 (new-local-macros-frame								 (new-local-macros-frame
	   (mapcan #'(lambda (m)								   (mapcan #'(lambda (m)
		       (list (ticl:locf (symbol-function (car m))) (cons 'ticl::ma			       (list (ticl:locf (symbol-function (car m))) (cons 'ticl::ma
		   macros)))										   macros)))
    (when new-local-fns-frame 								    (when new-local-fns-frame 
      (push new-local-fns-frame local-definitions))					      (push new-local-fns-frame local-definitions))
    (when new-local-macros-frame							    (when new-local-macros-frame
      (push new-local-macros-frame local-definitions))   				      (push new-local-macros-frame local-definitions))   
    `(,(car env) ,local-definitions)))							    `(,(car env) ,local-definitions)))


;;;Edited by Reed Hastings         7 Mar 88  19:07					;;;Edited by Reed Hastings         7 Mar 88  19:07
(defmacro with-augmented-environment							(defmacro with-augmented-environment
	  ((new-env old-env &key functions macros) &body body)					  ((new-env old-env &key functions macros) &body body)
  `(let ((,new-env (with-augmented-environment-internal ,old-env			  `(let ((,new-env (with-augmented-environment-internal ,old-env
							,functions										,functions
							,macros)))										,macros)))
     ,@body))										     ,@body))

);#+TI											);#+TI

											
#+(and dec vax common)									#+(and dec vax common)
(progn											(progn

(defmacro with-augmented-environment							(defmacro with-augmented-environment
	  ((new-env old-env &key functions macros) &body body)					  ((new-env old-env &key functions macros) &body body)
  `(let ((,new-env (with-augmented-environment-internal ,old-env			  `(let ((,new-env (with-augmented-environment-internal ,old-env
							,functions										,functions
							,macros)))										,macros)))
     ,@body))										     ,@body))

(defun with-augmented-environment-internal (env functions macros)			(defun with-augmented-environment-internal (env functions macros)
  #'(lambda (op &optional (arg nil arg-p))						  #'(lambda (op &optional (arg nil arg-p))
      (cond ((eq op :macro-function) 							      (cond ((eq op :macro-function) 
	     (unless arg-p (error "Invalid environment use."))					     (unless arg-p (error "Invalid environment use."))
	     (lookup-macro-function arg env functions macros))					     (lookup-macro-function arg env functions macros))
            (arg-p									            (arg-p
	     (error "Invalid environment operation: ~S ~S" op arg))				     (error "Invalid environment operation: ~S ~S" op arg))
            (t										            (t
	     (lookup-macro-function op env functions macros)))))				     (lookup-macro-function op env functions macros)))))

(defun lookup-macro-function (name env fns macros)					(defun lookup-macro-function (name env fns macros)
  (let ((m (assoc name macros)))							  (let ((m (assoc name macros)))
    (cond (m                (cadr m))							    (cond (m                (cadr m))
          ((assoc name fns) :function)							          ((assoc name fns) :function)
          (env              (funcall env name))						          (env              (funcall env name))
          (t                nil))))							          (t                nil))))

(defun environment-macro (env macro)							(defun environment-macro (env macro)
  (let ((m (and env (funcall env macro))))						  (let ((m (and env (funcall env macro))))
    (and (not (eq m :function)) 							    (and (not (eq m :function)) 
         m)))										         m)))

;;; Nobody calls environment-function.  What would it return, anyway?			;;; Nobody calls environment-function.  What would it return, anyway?
);#+(and dec vax common)								);#+(and dec vax common)

											
;;;											;;;
;;; In Golden Common Lisp, the macroexpansion environment is just a list		;;; In Golden Common Lisp, the macroexpansion environment is just a list
;;; of environment entries.  Unless the car of the list is :compiler-menv 		;;; of environment entries.  Unless the car of the list is :compiler-menv 
;;; it is an interpreted environment.  The cadr of each element specifies 		;;; it is an interpreted environment.  The cadr of each element specifies 
;;; the type of the element.  The only types that interest us are GCL:MACRO		;;; the type of the element.  The only types that interest us are GCL:MACRO
;;; and FUNCTION.  In these cases the element is interpreted as follows.		;;; and FUNCTION.  In these cases the element is interpreted as follows.
;;;											;;;
;;; Compiled:										;;; Compiled:
;;;   (<function-name> <gensym> macroexpansion-function)				;;;   (<function-name> <gensym> macroexpansion-function)
;;;   (<function-name> <fn>)								;;;   (<function-name> <fn>)
;;;   											;;;   
;;; Interpreted:									;;; Interpreted:
;;;   (<function-name> GCL:MACRO macroexpansion-function)				;;;   (<function-name> GCL:MACRO macroexpansion-function)
;;;   (<function-name> <fn>)								;;;   (<function-name> <fn>)
;;;   											;;;   
;;;   When in the compiler, <fn> is a gensym which will be				;;;   When in the compiler, <fn> is a gensym which will be
;;;   a variable which bound at run-time to the function.				;;;   a variable which bound at run-time to the function.
;;;   When in the interpreter, <fn> is the actual function.				;;;   When in the interpreter, <fn> is the actual function.
;;;   											;;;   
;;;											;;;
#+gclisp										#+gclisp
(progn											(progn

(defmacro with-augmented-environment							(defmacro with-augmented-environment
	  ((new-env old-env &key functions macros) &body body)					  ((new-env old-env &key functions macros) &body body)
  `(let ((,new-env (with-augmented-environment-internal ,old-env			  `(let ((,new-env (with-augmented-environment-internal ,old-env
							,functions										,functions
							,macros)))										,macros)))
     ,@body))										     ,@body))

(defun with-augmented-environment-internal (env functions macros)			(defun with-augmented-environment-internal (env functions macros)
  (let ((new-entries nil))								  (let ((new-entries nil))
    (dolist (f functions)								    (dolist (f functions)
      (push (cons (car f) nil) new-entries))						      (push (cons (car f) nil) new-entries))
    (dolist (m macros)									    (dolist (m macros)
      (push (cons (car m)								      (push (cons (car m)
		  (if (eq :compiler-menv (car env))							  (if (eq :compiler-menv (car env))
		      (if (eq (caadr m) 'lisp::lambda)							      (if (eq (caadr m) 'lisp::lambda)
			  `(,(gensym) ,(cadr m))								  `(,(gensym) ,(cadr m))
			`(,(gensym) ,@(cadr m)))								`(,(gensym) ,@(cadr m)))
		    `(gclisp:MACRO ,@(cadr m))))							    `(gclisp:MACRO ,@(cadr m))))
	      new-entries))									      new-entries))
    (if (eq :compiler-menv (car env))							    (if (eq :compiler-menv (car env))
	`(:compiler-menv ,@new-entries ,@(cdr env))						`(:compiler-menv ,@new-entries ,@(cdr env))
      (append new-entries env))))							      (append new-entries env))))

(defun environment-function (env fn)							(defun environment-function (env fn)
  (let ((entry (lisp::lexical-function fn env)))					  (let ((entry (lisp::lexical-function fn env)))
    (and entry 										    (and entry 
	 (eq entry 'lisp::lexical-function)							 (eq entry 'lisp::lexical-function)
	 fn)))											 fn)))

(defun environment-macro (env macro)							(defun environment-macro (env macro)
  (let ((entry (assoc macro (if (eq :compiler-menv (first env))				  (let ((entry (assoc macro (if (eq :compiler-menv (first env))
				 (rest env)										 (rest env)
			       env))))										       env))))
    (and entry										    (and entry
	 (consp entry)										 (consp entry)
	 (symbolp (car entry))			;name						 (symbolp (car entry))			;name
	 (symbolp (cadr entry))			;gcl:macro or gensym				 (symbolp (cadr entry))			;gcl:macro or gensym
	 (nthcdr 2 entry))))									 (nthcdr 2 entry))))

);#+gclisp										);#+gclisp

											
;;;; CMU Common Lisp version of environment frobbing stuff.				;;;; CMU Common Lisp version of environment frobbing stuff.

;;; In CMU Common Lisp, the environment is represented with a structure			;;; In CMU Common Lisp, the environment is represented with a structure
;;; that holds alists for the functional things, variables, blocks, etc.		;;; that holds alists for the functional things, variables, blocks, etc.
;;; Only the c::lexenv-functions slot is relevent.  It holds:				;;; Only the c::lexenv-functions slot is relevent.  It holds:
;;; Alist (name . what), where What is either a Functional (a local function)		;;; Alist (name . what), where What is either a Functional (a local function)
;;; or a list (MACRO . <function>) (a local macro, with the specifier			;;; or a list (MACRO . <function>) (a local macro, with the specifier
;;; expander.)    Note that Name may be a (SETF <name>) function.			;;; expander.)    Note that Name may be a (SETF <name>) function.

#+:CMU											#+:CMU
(progn											(progn

(defmacro with-augmented-environment							(defmacro with-augmented-environment
	  ((new-env old-env &key functions macros) &body body)					  ((new-env old-env &key functions macros) &body body)
  `(let ((,new-env (with-augmented-environment-internal ,old-env			  `(let ((,new-env (with-augmented-environment-internal ,old-env
							,functions										,functions
							,macros)))										,macros)))
     ,@body))										     ,@body))

(defun with-augmented-environment-internal (env functions macros)			(defun with-augmented-environment-internal (env functions macros)
  ;; Note: In order to record the correct function definition, we would			  ;; Note: In order to record the correct function definition, we would
  ;; have to create an interpreted closure, but the with-new-definition			  ;; have to create an interpreted closure, but the with-new-definition
  ;; macro down below makes no distinction between flet and labels, so			  ;; macro down below makes no distinction between flet and labels, so
  ;; we have no idea what to use for the environment.  So we just blow it		  ;; we have no idea what to use for the environment.  So we just blow it
  ;; off, 'cause anything real we do would be wrong.  We still have to			  ;; off, 'cause anything real we do would be wrong.  We still have to
  ;; make an entry so we can tell functions from macros.				  ;; make an entry so we can tell functions from macros.
  (let ((env (or env (c::make-null-environment))))					  (let ((env (or env (c::make-null-environment))))
    (c::make-lexenv 									    (c::make-lexenv 
      :default env									      :default env
      :functions									      :functions
      (append (mapcar #'(lambda (f)							      (append (mapcar #'(lambda (f)
			  (cons (car f) (c::make-functional :lexenv env)))					  (cons (car f) (c::make-functional :lexenv env)))
		      functions)									      functions)
	      (mapcar #'(lambda (m)								      (mapcar #'(lambda (m)
			  (list* (car m) 'c::macro								  (list* (car m) 'c::macro
				 (coerce (cadr m) 'function)))								 (coerce (cadr m) 'function)))
		      macros)))))									      macros)))))

(defun environment-function (env fn)							(defun environment-function (env fn)
  (when env										  (when env
    (let ((entry (assoc fn (c::lexenv-functions env) :test #'equal)))			    (let ((entry (assoc fn (c::lexenv-functions env) :test #'equal)))
      (and entry									      (and entry
	   (c::functional-p (cdr entry))							   (c::functional-p (cdr entry))
	   (cdr entry)))))									   (cdr entry)))))

(defun environment-macro (env macro)							(defun environment-macro (env macro)
  (when env										  (when env
    (let ((entry (assoc macro (c::lexenv-functions env) :test #'eq)))			    (let ((entry (assoc macro (c::lexenv-functions env) :test #'eq)))
      (and entry 									      (and entry 
	   (eq (cadr entry) 'c::macro)								   (eq (cadr entry) 'c::macro)
	   (function-lambda-expression (cddr entry))))))					   (function-lambda-expression (cddr entry))))))

); end of #+:CMU									); end of #+:CMU

											

(defmacro with-new-definition-in-environment						(defmacro with-new-definition-in-environment
	  ((new-env old-env macrolet/flet/labels-form) &body body)				  ((new-env old-env macrolet/flet/labels-form) &body body)
  (let ((functions (make-symbol "Functions"))						  (let ((functions (make-symbol "Functions"))
	(macros (make-symbol "Macros")))							(macros (make-symbol "Macros")))
    `(let ((,functions ())								    `(let ((,functions ())
	   (,macros ()))									   (,macros ()))
       (ecase (car ,macrolet/flet/labels-form)						       (ecase (car ,macrolet/flet/labels-form)
	 ((flet labels)										 ((flet labels)
	  (dolist (fn (cadr ,macrolet/flet/labels-form))					  (dolist (fn (cadr ,macrolet/flet/labels-form))
	    (push fn ,functions)))								    (push fn ,functions)))
	 ((macrolet)										 ((macrolet)
	  (dolist (mac (cadr ,macrolet/flet/labels-form))					  (dolist (mac (cadr ,macrolet/flet/labels-form))
	    (push (list (car mac)								    (push (list (car mac)
			(convert-macro-to-lambda (cadr mac)							(convert-macro-to-lambda (cadr mac)
						 (cddr mac)										 (cddr mac)
						 (string (car mac))))									 (string (car mac))))
		  ,macros))))										  ,macros))))
       (with-augmented-environment							       (with-augmented-environment
	      (,new-env ,old-env :functions ,functions :macros ,macros)				      (,new-env ,old-env :functions ,functions :macros ,macros)
	 ,@body))))										 ,@body))))

#-Genera										#-Genera
(defun convert-macro-to-lambda (llist body &optional (name "Dummy Macro"))		(defun convert-macro-to-lambda (llist body &optional (name "Dummy Macro"))
  (let ((gensym (make-symbol name)))							  (let ((gensym (make-symbol name)))
    (eval `(defmacro ,gensym ,llist ,@body))						    (eval `(defmacro ,gensym ,llist ,@body))
    (macro-function gensym)))								    (macro-function gensym)))

#+Genera										#+Genera
(defun convert-macro-to-lambda (llist body &optional (name "Dummy Macro"))		(defun convert-macro-to-lambda (llist body &optional (name "Dummy Macro"))
  (si:defmacro-1									  (si:defmacro-1
    'sys:named-lambda 'sys:special (make-symbol name) llist body))			    'sys:named-lambda 'sys:special (make-symbol name) llist body))



											
											
;;;											;;;
;;; Now comes the real walker.								;;; Now comes the real walker.
;;;											;;;
;;; As the walker walks over the code, it communicates information to itself		;;; As the walker walks over the code, it communicates information to itself
;;; about the walk.  This information includes the walk function, variable		;;; about the walk.  This information includes the walk function, variable
;;; bindings, declarations in effect etc.  This information is inherently		;;; bindings, declarations in effect etc.  This information is inherently
;;; lexical, so the walker passes it around in the actual environment the		;;; lexical, so the walker passes it around in the actual environment the
;;; walker passes to macroexpansion functions.  This is what makes the			;;; walker passes to macroexpansion functions.  This is what makes the
;;; nested-walk-form facility work properly.						;;; nested-walk-form facility work properly.
;;;											;;;
(defmacro walker-environment-bind ((var env &rest key-args)				(defmacro walker-environment-bind ((var env &rest key-args)
				      &body body)									      &body body)
  `(with-augmented-environment								  `(with-augmented-environment
     (,var ,env :macros (walker-environment-bind-1 ,env ,.key-args))			     (,var ,env :macros (walker-environment-bind-1 ,env ,.key-args))
     .,body))										     .,body))

(defvar *key-to-walker-environment* (gensym))						(defvar *key-to-walker-environment* (gensym))

(defun env-lock (env)									(defun env-lock (env)
  (environment-macro env *key-to-walker-environment*))					  (environment-macro env *key-to-walker-environment*))

(defun walker-environment-bind-1 (env &key (walk-function nil wfnp)			(defun walker-environment-bind-1 (env &key (walk-function nil wfnp)
					   (walk-form nil wfop)									   (walk-form nil wfop)
					   (declarations nil decp)								   (declarations nil decp)
					   (lexical-variables nil lexp))							   (lexical-variables nil lexp))
  (let ((lock (environment-macro env *key-to-walker-environment*)))			  (let ((lock (environment-macro env *key-to-walker-environment*)))
    (list										    (list
      (list *key-to-walker-environment*							      (list *key-to-walker-environment*
	    (list (if wfnp walk-function     (car lock))					    (list (if wfnp walk-function     (car lock))
		  (if wfop walk-form         (cadr lock))						  (if wfop walk-form         (cadr lock))
		  (if decp declarations      (caddr lock))						  (if decp declarations      (caddr lock))
		  (if lexp lexical-variables (cadddr lock)))))))					  (if lexp lexical-variables (cadddr lock)))))))
		  											  
(defun env-walk-function (env)								(defun env-walk-function (env)
  (car (env-lock env)))									  (car (env-lock env)))

(defun env-walk-form (env)								(defun env-walk-form (env)
  (cadr (env-lock env)))								  (cadr (env-lock env)))

(defun env-declarations (env)								(defun env-declarations (env)
  (caddr (env-lock env)))								  (caddr (env-lock env)))

(defun env-lexical-variables (env)							(defun env-lexical-variables (env)
  (cadddr (env-lock env)))								  (cadddr (env-lock env)))


(defun note-declaration (declaration env)						(defun note-declaration (declaration env)
  (push declaration (caddr (env-lock env))))						  (push declaration (caddr (env-lock env))))

(defun note-lexical-binding (thing env)							(defun note-lexical-binding (thing env)
  (push (list thing :lexical-var) (cadddr (env-lock env))))				  (push (list thing :lexical-var) (cadddr (env-lock env))))


(defun VARIABLE-LEXICAL-P (var env)							(defun VARIABLE-LEXICAL-P (var env)
  (let ((entry (member var (env-lexical-variables env) :key #'car)))			  (let ((entry (member var (env-lexical-variables env) :key #'car)))
    (when (eq (cadar entry) :lexical-var)						    (when (eq (cadar entry) :lexical-var)
      entry)))										      entry)))

(defun variable-symbol-macro-p (var env)						(defun variable-symbol-macro-p (var env)
  (let ((entry (member var (env-lexical-variables env) :key #'car)))			  (let ((entry (member var (env-lexical-variables env) :key #'car)))
    (when (eq (cadar entry) :macro)							    (when (eq (cadar entry) :macro)
      entry)))										      entry)))


(defvar *VARIABLE-DECLARATIONS* '(special))						(defvar *VARIABLE-DECLARATIONS* '(special))

(defun VARIABLE-DECLARATION (declaration var env)					(defun VARIABLE-DECLARATION (declaration var env)
  (if (not (member declaration *variable-declarations*))				  (if (not (member declaration *variable-declarations*))
      (error "~S is not a recognized variable declaration." declaration)		      (error "~S is not a recognized variable declaration." declaration)
      (let ((id (or (variable-lexical-p var env) var)))					      (let ((id (or (variable-lexical-p var env) var)))
	(dolist (decl (env-declarations env))							(dolist (decl (env-declarations env))
	  (when (and (eq (car decl) declaration)						  (when (and (eq (car decl) declaration)
		     (eq (cadr decl) id))								     (eq (cadr decl) id))
	    (return decl))))))									    (return decl))))))

(defun VARIABLE-SPECIAL-P (var env)							(defun VARIABLE-SPECIAL-P (var env)
  (or (not (null (variable-declaration 'special var env)))				  (or (not (null (variable-declaration 'special var env)))
      (variable-globally-special-p var)))						      (variable-globally-special-p var)))

;;;											;;;
;;; VARIABLE-GLOBALLY-SPECIAL-P is used to ask if a variable has been			;;; VARIABLE-GLOBALLY-SPECIAL-P is used to ask if a variable has been
;;; declared globally special.  Any particular CommonLisp implementation		;;; declared globally special.  Any particular CommonLisp implementation
;;; should customize this function accordingly and send their customization		;;; should customize this function accordingly and send their customization
;;; back.										;;; back.
;;;											;;;
;;; The default version of variable-globally-special-p is probably pretty		;;; The default version of variable-globally-special-p is probably pretty
;;; slow, so it uses *globally-special-variables* as a cache to remember		;;; slow, so it uses *globally-special-variables* as a cache to remember
;;; variables that it has already figured out are globally special.			;;; variables that it has already figured out are globally special.
;;;											;;;
;;; This would need to be reworked if an unspecial declaration got added to		;;; This would need to be reworked if an unspecial declaration got added to
;;; Common Lisp.									;;; Common Lisp.
;;;											;;;
;;; Common Lisp nit:									;;; Common Lisp nit:
;;;   variable-globally-special-p should be defined in Common Lisp.			;;;   variable-globally-special-p should be defined in Common Lisp.
;;;											;;;
#-(or Genera Cloe-Runtime Lucid Xerox Excl KCL IBCL (and dec vax common) :CMU HP-H	#-(or Genera Cloe-Runtime Lucid Xerox Excl KCL IBCL (and dec vax common) :CMU HP-H
      GCLisp TI pyramid)								      GCLisp TI pyramid)
(defvar *globally-special-variables* ())						(defvar *globally-special-variables* ())

(defun variable-globally-special-p (symbol)						(defun variable-globally-special-p (symbol)
  #+Genera                      (si:special-variable-p symbol)				  #+Genera                      (si:special-variable-p symbol)
  #+Cloe-Runtime		(compiler::specialp symbol)				  #+Cloe-Runtime		(compiler::specialp symbol)
  #+Lucid                       (lucid::proclaimed-special-p symbol)			  #+Lucid                       (lucid::proclaimed-special-p symbol)
  #+TI                          (get symbol 'special)					  #+TI                          (get symbol 'special)
  #+Xerox                       (il:variable-globally-special-p symbol)			  #+Xerox                       (il:variable-globally-special-p symbol)
  #+(and dec vax common)        (get symbol 'system::globally-special)			  #+(and dec vax common)        (get symbol 'system::globally-special)
  #+(or KCL IBCL)               (si:specialp symbol)					  #+(or KCL IBCL)               (si:specialp symbol)
  #+excl                        (get symbol 'excl::.globally-special.)			  #+excl                        (get symbol 'excl::.globally-special.)
  #+:CMU			(eq (ext:info variable kind symbol) :special)		  #+:CMU			(eq (ext:info variable kind symbol) :special)
  #+HP-HPLabs                   (member (get symbol 'impl:vartype)			  #+HP-HPLabs                   (member (get symbol 'impl:vartype)
					'(impl:fluid impl:global)								'(impl:fluid impl:global)
					:test #'eq)										:test #'eq)
  #+:GCLISP                     (gclisp::special-p symbol)				  #+:GCLISP                     (gclisp::special-p symbol)
  #+pyramid			(or (get symbol 'lisp::globally-special)		  #+pyramid			(or (get symbol 'lisp::globally-special)
				    (get symbol										    (get symbol
					 'clc::globally-special-in-compiler))							 'clc::globally-special-in-compiler))
  #+:CORAL                      (ccl::proclaimed-special-p symbol)			  #+:CORAL                      (ccl::proclaimed-special-p symbol)
  #-(or Genera Cloe-Runtime Lucid Xerox Excl KCL IBCL (and dec vax common) :CMU HP	  #-(or Genera Cloe-Runtime Lucid Xerox Excl KCL IBCL (and dec vax common) :CMU HP
	GCLisp TI pyramid :CORAL)								GCLisp TI pyramid :CORAL)
  (or (not (null (member symbol *globally-special-variables* :test #'eq)))		  (or (not (null (member symbol *globally-special-variables* :test #'eq)))
      (when (eval `(flet ((ref () ,symbol))						      (when (eval `(flet ((ref () ,symbol))
		     (let ((,symbol '#,(list nil)))							     (let ((,symbol '#,(list nil)))
		       (and (boundp ',symbol) (eq ,symbol (ref))))))					       (and (boundp ',symbol) (eq ,symbol (ref))))))
	(push symbol *globally-special-variables*)						(push symbol *globally-special-variables*)
	t)))											t)))

											
  ;;   											  ;;   
;;;;;; Handling of special forms (the infamous 24).					;;;;;; Handling of special forms (the infamous 24).
  ;;											  ;;
;;;											;;;
;;; and I quote...									;;; and I quote...
;;; 											;;; 
;;;     The set of special forms is purposely kept very small because			;;;     The set of special forms is purposely kept very small because
;;;     any program analyzing program (read code walker) must have			;;;     any program analyzing program (read code walker) must have
;;;     special knowledge about every type of special form. Such a			;;;     special knowledge about every type of special form. Such a
;;;     program needs no special knowledge about macros...				;;;     program needs no special knowledge about macros...
;;;											;;;
;;; So all we have to do here is a define a way to store and retrieve			;;; So all we have to do here is a define a way to store and retrieve
;;; templates which describe how to walk the 24 special forms and we are all		;;; templates which describe how to walk the 24 special forms and we are all
;;; set...										;;; set...
;;;											;;;
;;; Well, its a nice concept, and I have to admit to being naive enough that		;;; Well, its a nice concept, and I have to admit to being naive enough that
;;; I believed it for a while, but not everyone takes having only 24 special		;;; I believed it for a while, but not everyone takes having only 24 special
;;; forms as seriously as might be nice.  There are (at least) 3 ways to		;;; forms as seriously as might be nice.  There are (at least) 3 ways to
;;; lose:										;;; lose:
;;											;;
;;;   1 - Implementation x implements a Common Lisp special form as a macro		;;;   1 - Implementation x implements a Common Lisp special form as a macro
;;;       which expands into a special form which:					;;;       which expands into a special form which:
;;;         - Is a common lisp special form (not likely)				;;;         - Is a common lisp special form (not likely)
;;;         - Is not a common lisp special form (on the 3600 IF --> COND).		;;;         - Is not a common lisp special form (on the 3600 IF --> COND).
;;;											;;;
;;;     * We can safe ourselves from this case (second subcase really) by		;;;     * We can safe ourselves from this case (second subcase really) by
;;;       checking to see if there is a template defined for something			;;;       checking to see if there is a template defined for something
;;;       before we check to see if we we can macroexpand it.				;;;       before we check to see if we we can macroexpand it.
;;;											;;;
;;;   2 - Implementation x implements a Common Lisp macro as a special form.		;;;   2 - Implementation x implements a Common Lisp macro as a special form.
;;;											;;;
;;;     * This is a screw, but not so bad, we save ourselves from it by			;;;     * This is a screw, but not so bad, we save ourselves from it by
;;;       defining extra templates for the macros which are *likely* to			;;;       defining extra templates for the macros which are *likely* to
;;;       be implemented as special forms.  (DO, DO* ...)				;;;       be implemented as special forms.  (DO, DO* ...)
;;;											;;;
;;;   3 - Implementation x has a special form which is not on the list of		;;;   3 - Implementation x has a special form which is not on the list of
;;;       Common Lisp special forms.							;;;       Common Lisp special forms.
;;;											;;;
;;;     * This is a bad sort of a screw and happens more than I would like		;;;     * This is a bad sort of a screw and happens more than I would like
;;;       to think, especially in the implementations which provide more		;;;       to think, especially in the implementations which provide more
;;;       than just Common Lisp (3600, Xerox etc.).					;;;       than just Common Lisp (3600, Xerox etc.).
;;;       The fix is not terribly staisfactory, but will have to do for			;;;       The fix is not terribly staisfactory, but will have to do for
;;;       now.  There is a hook in get walker-template which can get a			;;;       now.  There is a hook in get walker-template which can get a
;;;       template from the implementation's own walker.  That template			;;;       template from the implementation's own walker.  That template
;;;       has to be converted, and so it may be that the right way to do		;;;       has to be converted, and so it may be that the right way to do
;;;       this would actually be for that implementation to provide an			;;;       this would actually be for that implementation to provide an
;;;       interface to its walker which looks like the interface to this		;;;       interface to its walker which looks like the interface to this
;;;       walker.									;;;       walker.
;;;											;;;

(eval-when (compile load eval)								(eval-when (compile load eval)

(defmacro get-walker-template-internal (x) ;Has to be inside eval-when because		(defmacro get-walker-template-internal (x) ;Has to be inside eval-when because
  `(get ,x 'walker-template))		   ;Golden Common Lisp doesn't hack		  `(get ,x 'walker-template))		   ;Golden Common Lisp doesn't hack
					   ;compile time definition of macros							   ;compile time definition of macros
					   ;right for setf.									   ;right for setf.

(defmacro define-walker-template							(defmacro define-walker-template
	  (name &optional (template '(nil repeat (eval))))					  (name &optional (template '(nil repeat (eval))))
  `(eval-when (load eval)								  `(eval-when (load eval)
     (setf (get-walker-template-internal ',name) ',template)))				     (setf (get-walker-template-internal ',name) ',template)))
)											)

(defun get-walker-template (x)								(defun get-walker-template (x)
  (cond ((symbolp x)									  (cond ((symbolp x)
	 (or (get-walker-template-internal x)							 (or (get-walker-template-internal x)
	     (get-implementation-dependent-walker-template x)))					     (get-implementation-dependent-walker-template x)))
	((and (listp x) (eq (car x) 'lambda))							((and (listp x) (eq (car x) 'lambda))
	 '(lambda repeat (eval)))								 '(lambda repeat (eval)))
	(t											(t
	 (error "Can't get template for ~S" x))))						 (error "Can't get template for ~S" x))))

(defun get-implementation-dependent-walker-template (x)					(defun get-implementation-dependent-walker-template (x)
  (declare (ignore x))									  (declare (ignore x))
  ())											  ())

											
  ;;   											  ;;   
;;;;;; The actual templates								;;;;;; The actual templates
  ;;   											  ;;   

(define-walker-template BLOCK                (NIL NIL REPEAT (EVAL)))			(define-walker-template BLOCK                (NIL NIL REPEAT (EVAL)))
(define-walker-template CATCH                (NIL EVAL REPEAT (EVAL)))			(define-walker-template CATCH                (NIL EVAL REPEAT (EVAL)))
(define-walker-template COMPILER-LET         walk-compiler-let)				(define-walker-template COMPILER-LET         walk-compiler-let)
(define-walker-template DECLARE              walk-unexpected-declare)			(define-walker-template DECLARE              walk-unexpected-declare)
(define-walker-template EVAL-WHEN            (NIL QUOTE REPEAT (EVAL)))			(define-walker-template EVAL-WHEN            (NIL QUOTE REPEAT (EVAL)))
(define-walker-template FLET                 walk-flet)					(define-walker-template FLET                 walk-flet)
(define-walker-template FUNCTION             (NIL CALL))				(define-walker-template FUNCTION             (NIL CALL))
(define-walker-template GO                   (NIL QUOTE))				(define-walker-template GO                   (NIL QUOTE))
(define-walker-template IF                   walk-if)					(define-walker-template IF                   walk-if)
(define-walker-template LABELS               walk-labels)				(define-walker-template LABELS               walk-labels)
(define-walker-template LAMBDA               walk-lambda)				(define-walker-template LAMBDA               walk-lambda)
(define-walker-template LET                  walk-let)					(define-walker-template LET                  walk-let)
(define-walker-template LET*                 walk-let*)					(define-walker-template LET*                 walk-let*)
(define-walker-template LOCALLY              walk-locally)				(define-walker-template LOCALLY              walk-locally)
(define-walker-template MACROLET             walk-macrolet)				(define-walker-template MACROLET             walk-macrolet)
(define-walker-template MULTIPLE-VALUE-CALL  (NIL EVAL REPEAT (EVAL)))			(define-walker-template MULTIPLE-VALUE-CALL  (NIL EVAL REPEAT (EVAL)))
(define-walker-template MULTIPLE-VALUE-PROG1 (NIL RETURN REPEAT (EVAL)))		(define-walker-template MULTIPLE-VALUE-PROG1 (NIL RETURN REPEAT (EVAL)))
(define-walker-template MULTIPLE-VALUE-SETQ  walk-multiple-value-setq)			(define-walker-template MULTIPLE-VALUE-SETQ  walk-multiple-value-setq)
(define-walker-template MULTIPLE-VALUE-BIND  walk-multiple-value-bind)			(define-walker-template MULTIPLE-VALUE-BIND  walk-multiple-value-bind)
(define-walker-template PROGN                (NIL REPEAT (EVAL)))			(define-walker-template PROGN                (NIL REPEAT (EVAL)))
(define-walker-template PROGV                (NIL EVAL EVAL REPEAT (EVAL)))		(define-walker-template PROGV                (NIL EVAL EVAL REPEAT (EVAL)))
(define-walker-template QUOTE                (NIL QUOTE))				(define-walker-template QUOTE                (NIL QUOTE))
(define-walker-template RETURN-FROM          (NIL QUOTE REPEAT (RETURN)))		(define-walker-template RETURN-FROM          (NIL QUOTE REPEAT (RETURN)))
(define-walker-template SETQ                 walk-setq)					(define-walker-template SETQ                 walk-setq)
(define-walker-template SYMBOL-MACROLET      walk-symbol-macrolet)			(define-walker-template SYMBOL-MACROLET      walk-symbol-macrolet)
(define-walker-template TAGBODY              walk-tagbody)				(define-walker-template TAGBODY              walk-tagbody)
(define-walker-template THE                  (NIL QUOTE EVAL))				(define-walker-template THE                  (NIL QUOTE EVAL))
#+cmu(define-walker-template EXT:TRULY-THE   (NIL QUOTE EVAL))				#+cmu(define-walker-template EXT:TRULY-THE   (NIL QUOTE EVAL))
(define-walker-template THROW                (NIL EVAL EVAL))				(define-walker-template THROW                (NIL EVAL EVAL))
(define-walker-template UNWIND-PROTECT       (NIL RETURN REPEAT (EVAL)))		(define-walker-template UNWIND-PROTECT       (NIL RETURN REPEAT (EVAL)))

;;; The new special form.								;;; The new special form.
;(define-walker-template pcl::LOAD-TIME-EVAL       (NIL EVAL))				;(define-walker-template pcl::LOAD-TIME-EVAL       (NIL EVAL))

;;;											;;;
;;; And the extra templates...								;;; And the extra templates...
;;;											;;;
(define-walker-template DO      walk-do)						(define-walker-template DO      walk-do)
(define-walker-template DO*     walk-do*)						(define-walker-template DO*     walk-do*)
(define-walker-template PROG    walk-prog)						(define-walker-template PROG    walk-prog)
(define-walker-template PROG*   walk-prog*)						(define-walker-template PROG*   walk-prog*)
(define-walker-template COND    (NIL REPEAT ((TEST REPEAT (EVAL)))))			(define-walker-template COND    (NIL REPEAT ((TEST REPEAT (EVAL)))))

#+Genera										#+Genera
(progn											(progn
  (define-walker-template zl::named-lambda walk-named-lambda)				  (define-walker-template zl::named-lambda walk-named-lambda)
  (define-walker-template SCL:LETF walk-let)						  (define-walker-template SCL:LETF walk-let)
  (define-walker-template SCL:LETF* walk-let*)						  (define-walker-template SCL:LETF* walk-let*)
  )											  )

#+Lucid											#+Lucid
(progn											(progn
  (define-walker-template #+LCL3.0 lucid-common-lisp:named-lambda			  (define-walker-template #+LCL3.0 lucid-common-lisp:named-lambda
			  #-LCL3.0 sys:named-lambda walk-named-lambda)						  #-LCL3.0 sys:named-lambda walk-named-lambda)
  )											  )

#+(or KCL IBCL)										#+(or KCL IBCL)
(progn											(progn
  (define-walker-template lambda-block walk-named-lambda);Not really right,		  (define-walker-template lambda-block walk-named-lambda);Not really right,
							 ;we don't hack block									 ;we don't hack block
						         ;names anyways.								         ;names anyways.
  )											  )

#+TI											#+TI
(progn											(progn
  (define-walker-template TICL::LET-IF walk-let-if)					  (define-walker-template TICL::LET-IF walk-let-if)
  )											  )

#+:Coral										#+:Coral
(progn											(progn
  (define-walker-template ccl:%stack-block walk-let)					  (define-walker-template ccl:%stack-block walk-let)
  )											  )

											

(defvar walk-form-expand-macros-p nil)							(defvar walk-form-expand-macros-p nil)

(defun macroexpand-all (form &optional environment)					(defun macroexpand-all (form &optional environment)
  (let ((walk-form-expand-macros-p t))							  (let ((walk-form-expand-macros-p t))
    (walk-form form environment)))							    (walk-form form environment)))

(defun WALK-FORM (form									(defun WALK-FORM (form
		  &optional environment									  &optional environment
			    (walk-function									    (walk-function
			      #'(lambda (subform context env)							      #'(lambda (subform context env)
				  (declare (ignore context env))							  (declare (ignore context env))
				  subform)))										  subform)))
  (walker-environment-bind (new-env environment :walk-function walk-function)		  (walker-environment-bind (new-env environment :walk-function walk-function)
    (walk-form-internal form :eval new-env)))						    (walk-form-internal form :eval new-env)))

;;;											;;;
;;; nested-walk-form provides an interface that allows nested macros, each		;;; nested-walk-form provides an interface that allows nested macros, each
;;; of which must walk their body to just do one walk of the body of the		;;; of which must walk their body to just do one walk of the body of the
;;; inner macro.  That inner walk is done with a walk function which is the		;;; inner macro.  That inner walk is done with a walk function which is the
;;; composition of the two walk functions.						;;; composition of the two walk functions.
;;;											;;;
;;; This facility works by having the walker annotate the environment that		;;; This facility works by having the walker annotate the environment that
;;; it passes to macroexpand-1 to know which form is being macroexpanded.		;;; it passes to macroexpand-1 to know which form is being macroexpanded.
;;; If then the &whole argument to the macroexpansion function is eq to			;;; If then the &whole argument to the macroexpansion function is eq to
;;; the env-walk-form of the environment, nested-walk-form can be certain		;;; the env-walk-form of the environment, nested-walk-form can be certain
;;; that there are no intervening layers and that a nested walk is alright.		;;; that there are no intervening layers and that a nested walk is alright.
;;;											;;;
;;; There are some semantic problems with this facility.  In particular, if		;;; There are some semantic problems with this facility.  In particular, if
;;; the outer walk function returns T as its walk-no-more-p value, this will		;;; the outer walk function returns T as its walk-no-more-p value, this will
;;; prevent the inner walk function from getting a chance to walk the subforms		;;; prevent the inner walk function from getting a chance to walk the subforms
;;; of the form.  This is almost never what you want, since it destroys the		;;; of the form.  This is almost never what you want, since it destroys the
;;; equivalence between this nested-walk-form function and two seperate			;;; equivalence between this nested-walk-form function and two seperate
;;; walk-forms.										;;; walk-forms.
;;;											;;;
(defun NESTED-WALK-FORM (whole								(defun NESTED-WALK-FORM (whole
			 form											 form
			 &optional environment									 &optional environment
				   (walk-function									   (walk-function
				     #'(lambda (subform context env)							     #'(lambda (subform context env)
					 (declare (ignore context env))								 (declare (ignore context env))
					 subform)))										 subform)))
  (if (eq whole (env-walk-form environment))						  (if (eq whole (env-walk-form environment))
      (let ((outer-walk-function (env-walk-function environment)))			      (let ((outer-walk-function (env-walk-function environment)))
	(throw whole										(throw whole
	  (walk-form										  (walk-form
	    form										    form
	    environment										    environment
	    #'(lambda (f c e)									    #'(lambda (f c e)
		;; First loop to make sure the inner walk function					;; First loop to make sure the inner walk function
		;; has done all it wants to do with this form.						;; has done all it wants to do with this form.
		;; Basically, what we are doing here is providing					;; Basically, what we are doing here is providing
		;; the same contract walk-form-internal normally					;; the same contract walk-form-internal normally
		;; provides to the inner walk function.							;; provides to the inner walk function.
		(let ((inner-result nil)								(let ((inner-result nil)
		      (inner-no-more-p nil)								      (inner-no-more-p nil)
		      (outer-result nil)								      (outer-result nil)
		      (outer-no-more-p nil))								      (outer-no-more-p nil))
		  (loop											  (loop
		    (multiple-value-setq (inner-result inner-no-more-p)					    (multiple-value-setq (inner-result inner-no-more-p)
					 (funcall walk-function f c e))								 (funcall walk-function f c e))
		    (cond (inner-no-more-p (return))							    (cond (inner-no-more-p (return))
			  ((not (eq inner-result f)))								  ((not (eq inner-result f)))
			  ((not (consp inner-result)) (return))							  ((not (consp inner-result)) (return))
			  ((get-walker-template (car inner-result)) (return))					  ((get-walker-template (car inner-result)) (return))
			  (t											  (t
			   (multiple-value-bind (expansion macrop)						   (multiple-value-bind (expansion macrop)
			       (walker-environment-bind								       (walker-environment-bind
				     (new-env e :walk-form inner-result)						     (new-env e :walk-form inner-result)
				 (macroexpand-1 inner-result new-env))							 (macroexpand-1 inner-result new-env))
			     (if macrop										     (if macrop
				 (setq inner-result expansion)								 (setq inner-result expansion)
				 (return)))))										 (return)))))
		    (setq f inner-result))								    (setq f inner-result))
		  (multiple-value-setq (outer-result outer-no-more-p)					  (multiple-value-setq (outer-result outer-no-more-p)
				       (funcall outer-walk-function							       (funcall outer-walk-function
						inner-result										inner-result
						c											c
						e))											e))
		  (values outer-result									  (values outer-result
			  (and inner-no-more-p outer-no-more-p)))))))						  (and inner-no-more-p outer-no-more-p)))))))
      (walk-form form environment walk-function)))					      (walk-form form environment walk-function)))

;;;											;;;
;;; WALK-FORM-INTERNAL is the main driving function for the code walker. It		;;; WALK-FORM-INTERNAL is the main driving function for the code walker. It
;;; takes a form and the current context and walks the form calling itself or		;;; takes a form and the current context and walks the form calling itself or
;;; the appropriate template recursively.						;;; the appropriate template recursively.
;;;											;;;
;;;   "It is recommended that a program-analyzing-program process a form		;;;   "It is recommended that a program-analyzing-program process a form
;;;    that is a list whose car is a symbol as follows:					;;;    that is a list whose car is a symbol as follows:
;;;											;;;
;;;     1. If the program has particular knowledge about the symbol,			;;;     1. If the program has particular knowledge about the symbol,
;;;        process the form using special-purpose code.  All of the			;;;        process the form using special-purpose code.  All of the
;;;        standard special forms should fall into this category.			;;;        standard special forms should fall into this category.
;;;     2. Otherwise, if macro-function is true of the symbol apply			;;;     2. Otherwise, if macro-function is true of the symbol apply
;;;        either macroexpand or macroexpand-1 and start over.				;;;        either macroexpand or macroexpand-1 and start over.
;;;     3. Otherwise, assume it is a function call. "					;;;     3. Otherwise, assume it is a function call. "
;;;     										;;;     

(defun walk-form-internal (form context env)						(defun walk-form-internal (form context env)
  ;; First apply the walk-function to perform whatever translation			  ;; First apply the walk-function to perform whatever translation
  ;; the user wants to this form.  If the second value returned				  ;; the user wants to this form.  If the second value returned
  ;; by walk-function is T then we don't recurse...					  ;; by walk-function is T then we don't recurse...
  (catch form										  (catch form
    (multiple-value-bind (newform walk-no-more-p)					    (multiple-value-bind (newform walk-no-more-p)
      (funcall (env-walk-function env) form context env)				      (funcall (env-walk-function env) form context env)
      (catch newform									      (catch newform
	(cond											(cond
	 (walk-no-more-p newform)								 (walk-no-more-p newform)
	 ((not (eq form newform))								 ((not (eq form newform))
	  (walk-form-internal newform context env))						  (walk-form-internal newform context env))
	 ((not (consp newform))									 ((not (consp newform))
	  (let ((symmac (car (variable-symbol-macro-p newform env))))				  (let ((symmac (car (variable-symbol-macro-p newform env))))
	    (if symmac										    (if symmac
		(let ((newnewform (walk-form-internal (cddr symmac)					(let ((newnewform (walk-form-internal (cddr symmac)
						      context env)))									      context env)))
		  (if (eq newnewform (cddr symmac))							  (if (eq newnewform (cddr symmac))
		      (if walk-form-expand-macros-p newnewform newform)					      (if walk-form-expand-macros-p newnewform newform)
		      newnewform))									      newnewform))
		newform)))										newform)))
	 (t											 (t
	  (let* ((fn (car newform))								  (let* ((fn (car newform))
		 (template (get-walker-template fn)))							 (template (get-walker-template fn)))
	    (if template									    (if template
		(if (symbolp template)									(if (symbolp template)
		    (funcall template newform context env)						    (funcall template newform context env)
		    (walk-template newform template context env))					    (walk-template newform template context env))
		(multiple-value-bind									(multiple-value-bind
		    (newnewform macrop)									    (newnewform macrop)
		    (walker-environment-bind								    (walker-environment-bind
			(new-env env :walk-form newform)							(new-env env :walk-form newform)
		      (macroexpand-1 newform new-env))							      (macroexpand-1 newform new-env))
		  (cond											  (cond
		   (macrop										   (macrop
		    (let ((newnewnewform (walk-form-internal newnewform context				    (let ((newnewnewform (walk-form-internal newnewform context
							     env)))										     env)))
		      (if (eq newnewnewform newnewform)							      (if (eq newnewnewform newnewform)
			  (if walk-form-expand-macros-p newnewform newform)					  (if walk-form-expand-macros-p newnewform newform)
			  newnewnewform)))									  newnewnewform)))
		   ((and (symbolp fn)									   ((and (symbolp fn)
			 (not (fboundp fn))									 (not (fboundp fn))
			 (special-form-p fn))									 (special-form-p fn))
		    (error										    (error
		     "~S is a special form, not defined in the CommonLisp.~%~				     "~S is a special form, not defined in the CommonLisp.~%~
		      manual This code walker doesn't know how to walk it.~%~				      manual This code walker doesn't know how to walk it.~%~
		      Define a template for this special form and try again."				      Define a template for this special form and try again."
		     fn))										     fn))
		   (t											   (t
		    ;; Otherwise, walk the form as if its just a standard 				    ;; Otherwise, walk the form as if its just a standard 
		    ;; functioncall using a template for standard function				    ;; functioncall using a template for standard function
		    ;; call.										    ;; call.
		    (walk-template									    (walk-template
		     newnewform '(call repeat (eval)) context env))))))))))))				     newnewform '(call repeat (eval)) context env))))))))))))

(defun walk-template (form template context env)					(defun walk-template (form template context env)
  (if (atom template)									  (if (atom template)
      (ecase template									      (ecase template
        ((EVAL FUNCTION TEST EFFECT RETURN)						        ((EVAL FUNCTION TEST EFFECT RETURN)
         (walk-form-internal form :EVAL env))						         (walk-form-internal form :EVAL env))
        ((QUOTE NIL) form)								        ((QUOTE NIL) form)
        (SET										        (SET
          (walk-form-internal form :SET env))						          (walk-form-internal form :SET env))
        ((LAMBDA CALL)									        ((LAMBDA CALL)
	 (cond ((or (symbolp form)								 (cond ((or (symbolp form)
		    (and (listp form)									    (and (listp form)
			 (= (length form) 2)									 (= (length form) 2)
			 (eq (car form) 'setf)))								 (eq (car form) 'setf)))
		form)											form)
	       #+Lispm										       #+Lispm
	       ((sys:validate-function-spec form) form)						       ((sys:validate-function-spec form) form)
	       (t (walk-form-internal form context env)))))					       (t (walk-form-internal form context env)))))
      (case (car template)								      (case (car template)
        (REPEAT										        (REPEAT
          (walk-template-handle-repeat form						          (walk-template-handle-repeat form
                                       (cdr template)					                                       (cdr template)
				       ;; For the case where nothing happens						       ;; For the case where nothing happens
				       ;; after the repeat optimize out the						       ;; after the repeat optimize out the
				       ;; call to length.								       ;; call to length.
				       (if (null (cddr template))							       (if (null (cddr template))
					   ()											   ()
					   (nthcdr (- (length form)								   (nthcdr (- (length form)
						      (length										      (length
							(cddr template)))									(cddr template)))
						   form))										   form))
                                       context						                                       context
				       env))										       env))
        (IF										        (IF
	  (walk-template form									  (walk-template form
			 (if (if (listp (cadr template))							 (if (if (listp (cadr template))
				 (eval (cadr template))									 (eval (cadr template))
				 (funcall (cadr template) form))							 (funcall (cadr template) form))
			     (caddr template)									     (caddr template)
			     (cadddr template))									     (cadddr template))
			 context										 context
			 env))											 env))
        (REMOTE										        (REMOTE
          (walk-template form (cadr template) context env))				          (walk-template form (cadr template) context env))
        (otherwise									        (otherwise
          (cond ((atom form) form)							          (cond ((atom form) form)
                (t (recons form								                (t (recons form
                           (walk-template						                           (walk-template
			     (car form) (car template) context env)						     (car form) (car template) context env)
                           (walk-template						                           (walk-template
			     (cdr form) (cdr template) context env))))))))					     (cdr form) (cdr template) context env))))))))

(defun walk-template-handle-repeat (form template stop-form context env)		(defun walk-template-handle-repeat (form template stop-form context env)
  (if (eq form stop-form)								  (if (eq form stop-form)
      (walk-template form (cdr template) context env)					      (walk-template form (cdr template) context env)
      (walk-template-handle-repeat-1 form						      (walk-template-handle-repeat-1 form
				     template										     template
				     (car template)									     (car template)
				     stop-form										     stop-form
				     context										     context
				     env)))										     env)))

(defun walk-template-handle-repeat-1 (form template repeat-template			(defun walk-template-handle-repeat-1 (form template repeat-template
					   stop-form context env)								   stop-form context env)
  (cond ((null form) ())								  (cond ((null form) ())
        ((eq form stop-form)								        ((eq form stop-form)
         (if (null repeat-template)							         (if (null repeat-template)
             (walk-template stop-form (cdr template) context env)       		             (walk-template stop-form (cdr template) context env)       
             (error "While handling repeat:						             (error "While handling repeat:
                     ~%~Ran into stop while still in repeat template.")))		                     ~%~Ran into stop while still in repeat template.")))
        ((null repeat-template)								        ((null repeat-template)
         (walk-template-handle-repeat-1							         (walk-template-handle-repeat-1
	   form template (car template) stop-form context env))					   form template (car template) stop-form context env))
        (t										        (t
         (recons form									         (recons form
                 (walk-template (car form) (car repeat-template) context env)		                 (walk-template (car form) (car repeat-template) context env)
                 (walk-template-handle-repeat-1 (cdr form)				                 (walk-template-handle-repeat-1 (cdr form)
						template										template
						(cdr repeat-template)									(cdr repeat-template)
						stop-form										stop-form
						context											context
						env)))))										env)))))

(defun walk-repeat-eval (form env)							(defun walk-repeat-eval (form env)
  (and form										  (and form
       (recons form									       (recons form
	       (walk-form-internal (car form) :eval env)					       (walk-form-internal (car form) :eval env)
	       (walk-repeat-eval (cdr form) env))))						       (walk-repeat-eval (cdr form) env))))

(defun recons (x car cdr)								(defun recons (x car cdr)
  (if (or (not (eq (car x) car))							  (if (or (not (eq (car x) car))
          (not (eq (cdr x) cdr)))							          (not (eq (cdr x) cdr)))
      (cons car cdr)									      (cons car cdr)
      x))										      x))

(defun relist (x &rest args)								(defun relist (x &rest args)
  (if (null args)									  (if (null args)
      nil										      nil
      (relist-internal x args nil)))							      (relist-internal x args nil)))

(defun relist* (x &rest args)								(defun relist* (x &rest args)
  (relist-internal x args 't))								  (relist-internal x args 't))

(defun relist-internal (x args *p)							(defun relist-internal (x args *p)
  (if (null (cdr args))									  (if (null (cdr args))
      (if *p										      (if *p
	  (car args)										  (car args)
	  (recons x (car args) nil))								  (recons x (car args) nil))
      (recons x										      (recons x
	      (car args)									      (car args)
	      (relist-internal (cdr x) (cdr args) *p))))					      (relist-internal (cdr x) (cdr args) *p))))

											
  ;;   											  ;;   
;;;;;; Special walkers									;;;;;; Special walkers
  ;;											  ;;

(defun walk-declarations (body fn env							(defun walk-declarations (body fn env
			       &optional doc-string-p declarations old-body					       &optional doc-string-p declarations old-body
			       &aux (form (car body)) macrop new-form)						       &aux (form (car body)) macrop new-form)
  (cond ((and (stringp form)			;might be a doc string			  (cond ((and (stringp form)			;might be a doc string
              (cdr body)			;isn't the returned value		              (cdr body)			;isn't the returned value
              (null doc-string-p)		;no doc string yet			              (null doc-string-p)		;no doc string yet
              (null declarations))		;no declarations yet			              (null declarations))		;no declarations yet
         (recons body									         (recons body
                 form									                 form
                 (walk-declarations (cdr body) fn env t)))				                 (walk-declarations (cdr body) fn env t)))
        ((and (listp form) (eq (car form) 'declare))					        ((and (listp form) (eq (car form) 'declare))
         ;; Got ourselves a real live declaration.  Record it, look for more.		         ;; Got ourselves a real live declaration.  Record it, look for more.
         (dolist (declaration (cdr form))						         (dolist (declaration (cdr form))
	   (let ((type (car declaration))							   (let ((type (car declaration))
		 (name (cadr declaration))								 (name (cadr declaration))
		 (args (cddr declaration)))								 (args (cddr declaration)))
	     (if (member type *variable-declarations*)						     (if (member type *variable-declarations*)
		 (note-declaration `(,type								 (note-declaration `(,type
				     ,(or (variable-lexical-p name env) name)						     ,(or (variable-lexical-p name env) name)
				     ,.args)										     ,.args)
				   env)											   env)
		 (note-declaration declaration env))							 (note-declaration declaration env))
	     (push declaration declarations)))							     (push declaration declarations)))
         (recons body									         (recons body
                 form									                 form
                 (walk-declarations							                 (walk-declarations
		   (cdr body) fn env doc-string-p declarations)))					   (cdr body) fn env doc-string-p declarations)))
        ((and form									        ((and form
	      (listp form)									      (listp form)
	      (null (get-walker-template (car form)))						      (null (get-walker-template (car form)))
	      (progn										      (progn
		(multiple-value-setq (new-form macrop)							(multiple-value-setq (new-form macrop)
				     (macroexpand-1 form env))								     (macroexpand-1 form env))
		macrop))										macrop))
	 ;; This form was a call to a macro.  Maybe it expanded					 ;; This form was a call to a macro.  Maybe it expanded
	 ;; into a declare?  Recurse to find out.						 ;; into a declare?  Recurse to find out.
	 (walk-declarations (recons body new-form (cdr body))					 (walk-declarations (recons body new-form (cdr body))
			    fn env doc-string-p declarations							    fn env doc-string-p declarations
			    (or old-body body)))								    (or old-body body)))
	(t											(t
	 ;; Now that we have walked and recorded the declarations,				 ;; Now that we have walked and recorded the declarations,
	 ;; call the function our caller provided to expand the body.				 ;; call the function our caller provided to expand the body.
	 ;; We call that function rather than passing the real-body				 ;; We call that function rather than passing the real-body
	 ;; back, because we are RECONSING up the new body.					 ;; back, because we are RECONSING up the new body.
	 (funcall fn (or old-body body) env))))							 (funcall fn (or old-body body) env))))


(defun walk-unexpected-declare (form context env)					(defun walk-unexpected-declare (form context env)
  (declare (ignore context env))							  (declare (ignore context env))
  (warn "Encountered declare ~S in a place where a declare was not expected."		  (warn "Encountered declare ~S in a place where a declare was not expected."
	form)											form)
  form)											  form)

(defun walk-arglist (arglist context env &optional (destructuringp nil)			(defun walk-arglist (arglist context env &optional (destructuringp nil)
					 &aux arg)										 &aux arg)
  (cond ((null arglist) ())								  (cond ((null arglist) ())
        ((symbolp (setq arg (car arglist)))						        ((symbolp (setq arg (car arglist)))
         (or (member arg lambda-list-keywords)						         (or (member arg lambda-list-keywords)
             (note-lexical-binding arg env))						             (note-lexical-binding arg env))
         (recons arglist								         (recons arglist
                 arg									                 arg
                 (walk-arglist (cdr arglist)						                 (walk-arglist (cdr arglist)
                               context							                               context
			       env										       env
                               (and destructuringp					                               (and destructuringp
				    (not (member arg									    (not (member arg
						 lambda-list-keywords))))))								 lambda-list-keywords))))))
        ((consp arg)									        ((consp arg)
         (prog1 (recons arglist								         (prog1 (recons arglist
			(if destructuringp									(if destructuringp
			    (walk-arglist arg context env destructuringp)					    (walk-arglist arg context env destructuringp)
			    (relist* arg									    (relist* arg
				     (car arg)										     (car arg)
				     (walk-form-internal (cadr arg) :eval env)						     (walk-form-internal (cadr arg) :eval env)
				     (cddr arg)))									     (cddr arg)))
			(walk-arglist (cdr arglist) context env nil))						(walk-arglist (cdr arglist) context env nil))
                (if (symbolp (car arg))							                (if (symbolp (car arg))
                    (note-lexical-binding (car arg) env)				                    (note-lexical-binding (car arg) env)
                    (note-lexical-binding (cadar arg) env))				                    (note-lexical-binding (cadar arg) env))
                (or (null (cddr arg))							                (or (null (cddr arg))
                    (not (symbolp (caddr arg)))						                    (not (symbolp (caddr arg)))
                    (note-lexical-binding (caddr arg) env))))				                    (note-lexical-binding (caddr arg) env))))
          (t										          (t
	   (error "Can't understand something in the arglist ~S" arglist))))			   (error "Can't understand something in the arglist ~S" arglist))))

(defun walk-let (form context env)							(defun walk-let (form context env)
  (walk-let/let* form context env nil))							  (walk-let/let* form context env nil))

(defun walk-let* (form context env)							(defun walk-let* (form context env)
  (walk-let/let* form context env t))							  (walk-let/let* form context env t))

(defun walk-prog (form context env)							(defun walk-prog (form context env)
  (walk-prog/prog* form context env nil))						  (walk-prog/prog* form context env nil))

(defun walk-prog* (form context env)							(defun walk-prog* (form context env)
  (walk-prog/prog* form context env t))							  (walk-prog/prog* form context env t))

(defun walk-do (form context env)							(defun walk-do (form context env)
  (walk-do/do* form context env nil))							  (walk-do/do* form context env nil))

(defun walk-do* (form context env)							(defun walk-do* (form context env)
  (walk-do/do* form context env t))							  (walk-do/do* form context env t))

(defun walk-let/let* (form context old-env sequentialp)					(defun walk-let/let* (form context old-env sequentialp)
  (walker-environment-bind (new-env old-env)						  (walker-environment-bind (new-env old-env)
    (let* ((let/let* (car form))							    (let* ((let/let* (car form))
	   (bindings (cadr form))								   (bindings (cadr form))
	   (body (cddr form))									   (body (cddr form))
	   (walked-bindings 									   (walked-bindings 
	     (walk-bindings-1 bindings								     (walk-bindings-1 bindings
			      old-env										      old-env
			      new-env										      new-env
			      context										      context
			      sequentialp))									      sequentialp))
	   (walked-body										   (walked-body
	     (walk-declarations body #'walk-repeat-eval new-env)))				     (walk-declarations body #'walk-repeat-eval new-env)))
      (relist*										      (relist*
	form let/let* walked-bindings walked-body))))						form let/let* walked-bindings walked-body))))

(defun walk-locally (form context env)							(defun walk-locally (form context env)
  (declare (ignore context))								  (declare (ignore context))
  (let* ((locally (car form))								  (let* ((locally (car form))
	 (body (cdr form))									 (body (cdr form))
	 (walked-body										 (walked-body
	  (walk-declarations body #'walk-repeat-eval env)))					  (walk-declarations body #'walk-repeat-eval env)))
    (relist*										    (relist*
     form locally walked-body)))							     form locally walked-body)))

(defun walk-prog/prog* (form context old-env sequentialp)				(defun walk-prog/prog* (form context old-env sequentialp)
  (walker-environment-bind (new-env old-env)						  (walker-environment-bind (new-env old-env)
    (let* ((possible-block-name (second form))						    (let* ((possible-block-name (second form))
	   (blocked-prog (and (symbolp possible-block-name)					   (blocked-prog (and (symbolp possible-block-name)
			      (not (eq possible-block-name 'nil)))))						      (not (eq possible-block-name 'nil)))))
      (multiple-value-bind (let/let* block-name bindings body)				      (multiple-value-bind (let/let* block-name bindings body)
	  (if blocked-prog									  (if blocked-prog
	      (values (car form) (cadr form) (caddr form) (cdddr form))				      (values (car form) (cadr form) (caddr form) (cdddr form))
	      (values (car form) nil	     (cadr  form) (cddr  form)))			      (values (car form) nil	     (cadr  form) (cddr  form)))
	(let* ((walked-bindings 								(let* ((walked-bindings 
		 (walk-bindings-1 bindings								 (walk-bindings-1 bindings
				  old-env										  old-env
				  new-env										  new-env
				  context										  context
				  sequentialp))										  sequentialp))
	       (walked-body									       (walked-body
		 (walk-declarations 									 (walk-declarations 
		   body											   body
		   #'(lambda (real-body real-env)							   #'(lambda (real-body real-env)
		       (walk-tagbody-1 real-body context real-env))					       (walk-tagbody-1 real-body context real-env))
		   new-env)))										   new-env)))
	  (if block-name									  (if block-name
	      (relist*										      (relist*
		form let/let* block-name walked-bindings walked-body)					form let/let* block-name walked-bindings walked-body)
	      (relist*										      (relist*
		form let/let* walked-bindings walked-body)))))))					form let/let* walked-bindings walked-body)))))))

(defun walk-do/do* (form context old-env sequentialp)					(defun walk-do/do* (form context old-env sequentialp)
  (walker-environment-bind (new-env old-env)						  (walker-environment-bind (new-env old-env)
    (let* ((do/do* (car form))								    (let* ((do/do* (car form))
	   (bindings (cadr form))								   (bindings (cadr form))
	   (end-test (caddr form))								   (end-test (caddr form))
	   (body (cdddr form))									   (body (cdddr form))
	   (walked-bindings (walk-bindings-1 bindings						   (walked-bindings (walk-bindings-1 bindings
					     old-env										     old-env
					     new-env										     new-env
					     context										     context
					     sequentialp))									     sequentialp))
	   (walked-body										   (walked-body
	     (walk-declarations body #'walk-repeat-eval new-env)))				     (walk-declarations body #'walk-repeat-eval new-env)))
      (relist* form									      (relist* form
	       do/do*										       do/do*
	       (walk-bindings-2 bindings walked-bindings context new-env)			       (walk-bindings-2 bindings walked-bindings context new-env)
	       (walk-template end-test '(test repeat (eval)) context new-env)			       (walk-template end-test '(test repeat (eval)) context new-env)
	       walked-body))))									       walked-body))))

(defun walk-let-if (form context env)							(defun walk-let-if (form context env)
  (let ((test (cadr form))								  (let ((test (cadr form))
	(bindings (caddr form))									(bindings (caddr form))
	(body (cdddr form)))									(body (cdddr form)))
    (walk-form-internal									    (walk-form-internal
      `(let ()										      `(let ()
	 (declare (special ,@(mapcar #'(lambda (x) (if (listp x) (car x) x))			 (declare (special ,@(mapcar #'(lambda (x) (if (listp x) (car x) x))
				     bindings)))									     bindings)))
	 (flet ((.let-if-dummy. () ,@body))							 (flet ((.let-if-dummy. () ,@body))
	   (if ,test										   (if ,test
	       (let ,bindings (.let-if-dummy.))							       (let ,bindings (.let-if-dummy.))
	       (.let-if-dummy.))))								       (.let-if-dummy.))))
      context										      context
      env)))										      env)))

(defun walk-multiple-value-setq (form context env)					(defun walk-multiple-value-setq (form context env)
  (let ((vars (cadr form)))								  (let ((vars (cadr form)))
    (if (some #'(lambda (var)								    (if (some #'(lambda (var)
		  (variable-symbol-macro-p var env))							  (variable-symbol-macro-p var env))
	      vars)										      vars)
	(let* ((temps (mapcar #'(lambda (var) (declare (ignore var)) (gensym)) var		(let* ((temps (mapcar #'(lambda (var) (declare (ignore var)) (gensym)) var
	       (sets (mapcar #'(lambda (var temp) `(setq ,var ,temp)) vars temps))		       (sets (mapcar #'(lambda (var temp) `(setq ,var ,temp)) vars temps))
	       (expanded `(multiple-value-bind ,temps 						       (expanded `(multiple-value-bind ,temps 
			       ,(caddr form)									       ,(caddr form)
			     ,@sets))										     ,@sets))
	       (walked (walk-form-internal expanded context env)))				       (walked (walk-form-internal expanded context env)))
	  (if (eq walked expanded)								  (if (eq walked expanded)
	      form										      form
	      walked))										      walked))
	(walk-template form '(nil (repeat (set)) eval) context env))))				(walk-template form '(nil (repeat (set)) eval) context env))))

(defun walk-multiple-value-bind (form context old-env)					(defun walk-multiple-value-bind (form context old-env)
  (walker-environment-bind (new-env old-env)						  (walker-environment-bind (new-env old-env)
    (let* ((mvb (car form))								    (let* ((mvb (car form))
	   (bindings (cadr form))								   (bindings (cadr form))
	   (mv-form (walk-template (caddr form) 'eval context old-env))				   (mv-form (walk-template (caddr form) 'eval context old-env))
	   (body (cdddr form))									   (body (cdddr form))
	   walked-bindings									   walked-bindings
	   (walked-body										   (walked-body
	     (walk-declarations 								     (walk-declarations 
	       body										       body
	       #'(lambda (real-body real-env)							       #'(lambda (real-body real-env)
		   (setq walked-bindings								   (setq walked-bindings
			 (walk-bindings-1 bindings								 (walk-bindings-1 bindings
					  old-env										  old-env
					  new-env										  new-env
					  context										  context
					  nil))											  nil))
		   (walk-repeat-eval real-body real-env))						   (walk-repeat-eval real-body real-env))
	       new-env)))									       new-env)))
      (relist* form mvb walked-bindings mv-form walked-body))))				      (relist* form mvb walked-bindings mv-form walked-body))))

(defun walk-bindings-1 (bindings old-env new-env context sequentialp)			(defun walk-bindings-1 (bindings old-env new-env context sequentialp)
  (and bindings										  (and bindings
       (let ((binding (car bindings)))							       (let ((binding (car bindings)))
         (recons bindings								         (recons bindings
                 (if (symbolp binding)							                 (if (symbolp binding)
                     (prog1 binding							                     (prog1 binding
                            (note-lexical-binding binding new-env))			                            (note-lexical-binding binding new-env))
                     (prog1 (relist* binding						                     (prog1 (relist* binding
				     (car binding)									     (car binding)
				     (walk-form-internal (cadr binding)							     (walk-form-internal (cadr binding)
							 context										 context
							 (if sequentialp									 (if sequentialp
							     new-env										     new-env
							     old-env))										     old-env))
				     (cddr binding))	;save cddr for DO/DO*						     (cddr binding))	;save cddr for DO/DO*
						        ;it is the next value								        ;it is the next value
						        ;form. Don't walk it								        ;form. Don't walk it
						        ;now though.									        ;now though.
                            (note-lexical-binding (car binding) new-env)))		                            (note-lexical-binding (car binding) new-env)))
                 (walk-bindings-1 (cdr bindings)					                 (walk-bindings-1 (cdr bindings)
				  old-env										  old-env
				  new-env										  new-env
				  context										  context
				  sequentialp)))))									  sequentialp)))))

(defun walk-bindings-2 (bindings walked-bindings context env)				(defun walk-bindings-2 (bindings walked-bindings context env)
  (and bindings										  (and bindings
       (let ((binding (car bindings))							       (let ((binding (car bindings))
             (walked-binding (car walked-bindings)))					             (walked-binding (car walked-bindings)))
         (recons bindings								         (recons bindings
		 (if (symbolp binding)									 (if (symbolp binding)
		     binding										     binding
		     (relist* binding									     (relist* binding
			      (car walked-binding)								      (car walked-binding)
			      (cadr walked-binding)								      (cadr walked-binding)
			      (walk-template (cddr binding)							      (walk-template (cddr binding)
					     '(eval)										     '(eval)
					     context										     context
					     env)))		 								     env)))		 
                 (walk-bindings-2 (cdr bindings)					                 (walk-bindings-2 (cdr bindings)
				  (cdr walked-bindings)									  (cdr walked-bindings)
				  context										  context
				  env)))))										  env)))))

(defun walk-lambda (form context old-env)						(defun walk-lambda (form context old-env)
  (walker-environment-bind (new-env old-env)						  (walker-environment-bind (new-env old-env)
    (let* ((arglist (cadr form))							    (let* ((arglist (cadr form))
           (body (cddr form))								           (body (cddr form))
           (walked-arglist (walk-arglist arglist context new-env))			           (walked-arglist (walk-arglist arglist context new-env))
           (walked-body									           (walked-body
             (walk-declarations body #'walk-repeat-eval new-env)))			             (walk-declarations body #'walk-repeat-eval new-env)))
      (relist* form									      (relist* form
               (car form)								               (car form)
	       walked-arglist									       walked-arglist
               walked-body))))								               walked-body))))

(defun walk-named-lambda (form context old-env)						(defun walk-named-lambda (form context old-env)
  (walker-environment-bind (new-env old-env)						  (walker-environment-bind (new-env old-env)
    (let* ((name (cadr form))								    (let* ((name (cadr form))
	   (arglist (caddr form))								   (arglist (caddr form))
           (body (cdddr form))								           (body (cdddr form))
           (walked-arglist (walk-arglist arglist context new-env))			           (walked-arglist (walk-arglist arglist context new-env))
           (walked-body									           (walked-body
             (walk-declarations body #'walk-repeat-eval new-env)))			             (walk-declarations body #'walk-repeat-eval new-env)))
      (relist* form									      (relist* form
               (car form)								               (car form)
	       name										       name
	       walked-arglist									       walked-arglist
               walked-body))))  							               walked-body))))  

(defun walk-setq (form context env)							(defun walk-setq (form context env)
  (if (cdddr form)									  (if (cdddr form)
      (let* ((expanded (let ((rforms nil)						      (let* ((expanded (let ((rforms nil)
			     (tail (cdr form)))									     (tail (cdr form)))
			 (loop (when (null tail) (return (nreverse rforms)))					 (loop (when (null tail) (return (nreverse rforms)))
			       (let ((var (pop tail)) (val (pop tail)))						       (let ((var (pop tail)) (val (pop tail)))
				 (push `(setq ,var ,val) rforms)))))							 (push `(setq ,var ,val) rforms)))))
	     (walked (walk-repeat-eval expanded env)))						     (walked (walk-repeat-eval expanded env)))
	(if (eq expanded walked)								(if (eq expanded walked)
	    form										    form
	    `(progn ,@walked)))									    `(progn ,@walked)))
      (let* ((var (cadr form))								      (let* ((var (cadr form))
	     (val (caddr form))									     (val (caddr form))
	     (symmac (car (variable-symbol-macro-p var env))))					     (symmac (car (variable-symbol-macro-p var env))))
	(if symmac										(if symmac
	    (let* ((expanded `(setf ,(cddr symmac) ,val))					    (let* ((expanded `(setf ,(cddr symmac) ,val))
		   (walked (walk-form-internal expanded context env)))					   (walked (walk-form-internal expanded context env)))
	      (if (eq expanded walked)								      (if (eq expanded walked)
		  form											  form
		  walked))										  walked))
	    (relist form 'setq									    (relist form 'setq
		    (walk-form-internal var :set env)							    (walk-form-internal var :set env)
		    (walk-form-internal val :eval env))))))						    (walk-form-internal val :eval env))))))

(defun walk-symbol-macrolet (form context old-env)					(defun walk-symbol-macrolet (form context old-env)
  (declare (ignore context))								  (declare (ignore context))
  (let* ((bindings (cadr form)))							  (let* ((bindings (cadr form)))
    (walker-environment-bind								    (walker-environment-bind
	(new-env old-env									(new-env old-env
		 :lexical-variables									 :lexical-variables
		 (append (mapcar #'(lambda (binding)							 (append (mapcar #'(lambda (binding)
				     `(,(car binding)									     `(,(car binding)
				       :macro . ,(cadr binding)))							       :macro . ,(cadr binding)))
				 bindings)										 bindings)
			 (env-lexical-variables old-env)))							 (env-lexical-variables old-env)))
      (relist* form 'symbol-macrolet bindings						      (relist* form 'symbol-macrolet bindings
	       (walk-repeat-eval (cddr form) new-env)))))					       (walk-repeat-eval (cddr form) new-env)))))

(defun walk-tagbody (form context env)							(defun walk-tagbody (form context env)
  (recons form (car form) (walk-tagbody-1 (cdr form) context env)))			  (recons form (car form) (walk-tagbody-1 (cdr form) context env)))

(defun walk-tagbody-1 (form context env)						(defun walk-tagbody-1 (form context env)
  (and form										  (and form
       (recons form									       (recons form
               (walk-form-internal (car form)						               (walk-form-internal (car form)
				   (if (symbolp (car form)) 'quote context)						   (if (symbolp (car form)) 'quote context)
				   env)											   env)
               (walk-tagbody-1 (cdr form) context env))))				               (walk-tagbody-1 (cdr form) context env))))

(defun walk-compiler-let (form context old-env)						(defun walk-compiler-let (form context old-env)
  (declare (ignore context))								  (declare (ignore context))
  (let ((vars ())									  (let ((vars ())
	(vals ()))										(vals ()))
    (dolist (binding (cadr form))							    (dolist (binding (cadr form))
      (cond ((symbolp binding) (push binding vars) (push nil vals))			      (cond ((symbolp binding) (push binding vars) (push nil vals))
	    (t											    (t
	     (push (car binding) vars)								     (push (car binding) vars)
	     (push (eval (cadr binding)) vals))))						     (push (eval (cadr binding)) vals))))
    (relist* form									    (relist* form
	     (car form)										     (car form)
	     (cadr form)									     (cadr form)
	     (progv vars vals (walk-repeat-eval (cddr form) old-env)))))			     (progv vars vals (walk-repeat-eval (cddr form) old-env)))))

(defun walk-macrolet (form context old-env)						(defun walk-macrolet (form context old-env)
  (walker-environment-bind (macro-env							  (walker-environment-bind (macro-env
			    nil											    nil
			    :walk-function (env-walk-function old-env))						    :walk-function (env-walk-function old-env))
    (labels ((walk-definitions (definitions)						    (labels ((walk-definitions (definitions)
	       (and definitions									       (and definitions
		    (let ((definition (car definitions)))						    (let ((definition (car definitions)))
		      (recons definitions								      (recons definitions
                              (relist* definition					                              (relist* definition
                                       (car definition)					                                       (car definition)
                                       (walk-arglist (cadr definition)			                                       (walk-arglist (cadr definition)
						     context										     context
						     macro-env										     macro-env
						     t)											     t)
                                       (walk-declarations (cddr definition)		                                       (walk-declarations (cddr definition)
							  #'walk-repeat-eval									  #'walk-repeat-eval
							  macro-env))										  macro-env))
			      (walk-definitions (cdr definitions)))))))						      (walk-definitions (cdr definitions)))))))
      (with-new-definition-in-environment (new-env old-env form)			      (with-new-definition-in-environment (new-env old-env form)
	(relist* form										(relist* form
		 (car form)										 (car form)
		 (walk-definitions (cadr form))								 (walk-definitions (cadr form))
		 (walk-declarations (cddr form)								 (walk-declarations (cddr form)
				    #'walk-repeat-eval									    #'walk-repeat-eval
				    new-env))))))									    new-env))))))

(defun walk-flet (form context old-env)							(defun walk-flet (form context old-env)
  (labels ((walk-definitions (definitions)						  (labels ((walk-definitions (definitions)
	     (if (null definitions)								     (if (null definitions)
		 ()											 ()
		 (recons definitions									 (recons definitions
			 (walk-lambda (car definitions) context old-env)					 (walk-lambda (car definitions) context old-env)
			 (walk-definitions (cdr definitions))))))						 (walk-definitions (cdr definitions))))))
    (recons form									    (recons form
	    (car form)										    (car form)
	    (recons (cdr form)									    (recons (cdr form)
		    (walk-definitions (cadr form))							    (walk-definitions (cadr form))
		    (with-new-definition-in-environment (new-env old-env form)				    (with-new-definition-in-environment (new-env old-env form)
		      (walk-declarations (cddr form)							      (walk-declarations (cddr form)
					 #'walk-repeat-eval									 #'walk-repeat-eval
					 new-env))))))										 new-env))))))

(defun walk-labels (form context old-env)						(defun walk-labels (form context old-env)
  (with-new-definition-in-environment (new-env old-env form)				  (with-new-definition-in-environment (new-env old-env form)
    (labels ((walk-definitions (definitions)						    (labels ((walk-definitions (definitions)
	       (if (null definitions)								       (if (null definitions)
		   ()											   ()
		   (recons definitions									   (recons definitions
			   (walk-lambda (car definitions) context new-env)					   (walk-lambda (car definitions) context new-env)
			   (walk-definitions (cdr definitions))))))						   (walk-definitions (cdr definitions))))))
      (recons form									      (recons form
	      (car form)									      (car form)
	      (recons (cdr form)								      (recons (cdr form)
		      (walk-definitions (cadr form))							      (walk-definitions (cadr form))
		      (walk-declarations (cddr form)							      (walk-declarations (cddr form)
					 #'walk-repeat-eval									 #'walk-repeat-eval
					 new-env))))))										 new-env))))))

(defun walk-if (form context env)							(defun walk-if (form context env)
  (let ((predicate (cadr form))								  (let ((predicate (cadr form))
	(arm1 (caddr form))									(arm1 (caddr form))
	(arm2 											(arm2 
	  (if (cddddr form)									  (if (cddddr form)
	      (progn										      (progn
		(warn "In the form:~%~S~%~								(warn "In the form:~%~S~%~
                       IF only accepts three arguments, you are using ~D.~%~		                       IF only accepts three arguments, you are using ~D.~%~
                       It is true that some Common Lisps support this, but ~		                       It is true that some Common Lisps support this, but ~
                       it is not~%~							                       it is not~%~
                       truly legal Common Lisp.  For now, this code ~			                       truly legal Common Lisp.  For now, this code ~
                       walker is interpreting ~%~					                       walker is interpreting ~%~
                       the extra arguments as extra else clauses. ~			                       the extra arguments as extra else clauses. ~
                       Even if this is what~%~						                       Even if this is what~%~
                       you intended, you should fix your source code."			                       you intended, you should fix your source code."
		      form										      form
		      (length (cdr form)))								      (length (cdr form)))
		(cons 'progn (cdddr form)))								(cons 'progn (cdddr form)))
	      (cadddr form))))									      (cadddr form))))
    (relist form									    (relist form
	    'if											    'if
	    (walk-form-internal predicate context env)						    (walk-form-internal predicate context env)
	    (walk-form-internal arm1 context env)						    (walk-form-internal arm1 context env)
	    (walk-form-internal arm2 context env))))						    (walk-form-internal arm2 context env))))


;;;											;;;
;;; Tests tests tests									;;; Tests tests tests
;;;											;;;

#|											#|
;;; 											;;; 
;;; Here are some examples of the kinds of things you should be able to do		;;; Here are some examples of the kinds of things you should be able to do
;;; with your implementation of the macroexpansion environment hacking			;;; with your implementation of the macroexpansion environment hacking
;;; mechanism.										;;; mechanism.
;;; 											;;; 
;;; with-lexical-macros is kind of like macrolet, but it only takes names		;;; with-lexical-macros is kind of like macrolet, but it only takes names
;;; of the macros and actual macroexpansion functions to use to macroexpand		;;; of the macros and actual macroexpansion functions to use to macroexpand
;;; them.  The win about that is that for macros which want to wrap several		;;; them.  The win about that is that for macros which want to wrap several
;;; macrolets around their body, they can do this but have the macroexpansion		;;; macrolets around their body, they can do this but have the macroexpansion
;;; functions be compiled.  See the WITH-RPUSH example.					;;; functions be compiled.  See the WITH-RPUSH example.
;;;											;;;
;;; If the implementation had a special way of communicating the augmented		;;; If the implementation had a special way of communicating the augmented
;;; environment back to the evaluator that would be totally great.  It would		;;; environment back to the evaluator that would be totally great.  It would
;;; mean that we could just augment the environment then pass control back		;;; mean that we could just augment the environment then pass control back
;;; to the implementations own compiler or interpreter.  We wouldn't have		;;; to the implementations own compiler or interpreter.  We wouldn't have
;;; to call the actual walker.  That would make this much faster.  Since the		;;; to call the actual walker.  That would make this much faster.  Since the
;;; principal client of this is defmethod it would make compiling defmethods		;;; principal client of this is defmethod it would make compiling defmethods
;;; faster and that would certainly be a win.						;;; faster and that would certainly be a win.
;;;											;;;
(defmacro with-lexical-macros (macros &body body &environment old-env)			(defmacro with-lexical-macros (macros &body body &environment old-env)
  (with-augmented-environment (new-env old-env :macros macros)				  (with-augmented-environment (new-env old-env :macros macros)
    (walk-form (cons 'progn body) :environment new-env)))				    (walk-form (cons 'progn body) :environment new-env)))

(defun expand-rpush (form env)								(defun expand-rpush (form env)
  `(push ,(caddr form) ,(cadr form)))							  `(push ,(caddr form) ,(cadr form)))

(defmacro with-rpush (&body body)							(defmacro with-rpush (&body body)
  `(with-lexical-macros ,(list (list 'rpush #'expand-rpush)) ,@body))			  `(with-lexical-macros ,(list (list 'rpush #'expand-rpush)) ,@body))


;;;											;;;
;;; Unfortunately, I don't have an automatic tester for the walker.  			;;; Unfortunately, I don't have an automatic tester for the walker.  
;;; Instead there is this set of test cases with a description of			;;; Instead there is this set of test cases with a description of
;;; how each one should go.								;;; how each one should go.
;;; 											;;; 
(defmacro take-it-out-for-a-test-walk (form)						(defmacro take-it-out-for-a-test-walk (form)
  `(take-it-out-for-a-test-walk-1 ',form))						  `(take-it-out-for-a-test-walk-1 ',form))

(defun take-it-out-for-a-test-walk-1 (form)						(defun take-it-out-for-a-test-walk-1 (form)
  (terpri)										  (terpri)
  (terpri)										  (terpri)
  (let ((copy-of-form (copy-tree form))							  (let ((copy-of-form (copy-tree form))
	(result (walk-form form nil								(result (walk-form form nil
		  #'(lambda (x y env)									  #'(lambda (x y env)
		      (format t "~&Form: ~S ~3T Context: ~A" x y)					      (format t "~&Form: ~S ~3T Context: ~A" x y)
		      (when (symbolp x)									      (when (symbolp x)
			(let ((lexical (variable-lexical-p x env))						(let ((lexical (variable-lexical-p x env))
			      (special (variable-special-p x env)))						      (special (variable-special-p x env)))
			  (when lexical										  (when lexical
			    (format t ";~3T")									    (format t ";~3T")
			    (format t "lexically bound"))							    (format t "lexically bound"))
			  (when special										  (when special
			    (format t ";~3T")									    (format t ";~3T")
			    (format t "declared special"))							    (format t "declared special"))
			  (when (boundp x)									  (when (boundp x)
			    (format t ";~3T")									    (format t ";~3T")
			    (format t "bound: ~S " (eval x)))))							    (format t "bound: ~S " (eval x)))))
		      x))))										      x))))
    (cond ((not (equal result copy-of-form))						    (cond ((not (equal result copy-of-form))
	   (format t "~%Warning: Result not EQUAL to copy of start."))				   (format t "~%Warning: Result not EQUAL to copy of start."))
	  ((not (eq result form))								  ((not (eq result form))
	   (format t "~%Warning: Result not EQ to copy of start.")))				   (format t "~%Warning: Result not EQ to copy of start.")))
    (pprint result)									    (pprint result)
    result))										    result))

(defmacro foo (&rest ignore) ''global-foo)						(defmacro foo (&rest ignore) ''global-foo)

(defmacro bar (&rest ignore) ''global-bar)						(defmacro bar (&rest ignore) ''global-bar)

(take-it-out-for-a-test-walk (list arg1 arg2 arg3))					(take-it-out-for-a-test-walk (list arg1 arg2 arg3))
(take-it-out-for-a-test-walk (list (cons 1 2) (list 3 4 5)))				(take-it-out-for-a-test-walk (list (cons 1 2) (list 3 4 5)))

(take-it-out-for-a-test-walk (progn (foo) (bar 1)))					(take-it-out-for-a-test-walk (progn (foo) (bar 1)))

(take-it-out-for-a-test-walk (block block-name a b c))					(take-it-out-for-a-test-walk (block block-name a b c))
(take-it-out-for-a-test-walk (block block-name (list a) b c))				(take-it-out-for-a-test-walk (block block-name (list a) b c))

(take-it-out-for-a-test-walk (catch catch-tag (list a) b c))				(take-it-out-for-a-test-walk (catch catch-tag (list a) b c))
;;;											;;;
;;; This is a fairly simple macrolet case.  While walking the body of the		;;; This is a fairly simple macrolet case.  While walking the body of the
;;; macro, x should be lexically bound. In the body of the macrolet form		;;; macro, x should be lexically bound. In the body of the macrolet form
;;; itself, x should not be bound.							;;; itself, x should not be bound.
;;; 											;;; 
(take-it-out-for-a-test-walk								(take-it-out-for-a-test-walk
  (macrolet ((foo (x) (list x) ''inner))						  (macrolet ((foo (x) (list x) ''inner))
    x											    x
    (foo 1)))										    (foo 1)))

;;;											;;;
;;; A slightly more complex macrolet case.  In the body of the macro x			;;; A slightly more complex macrolet case.  In the body of the macro x
;;; should not be lexically bound.  In the body of the macrolet form itself		;;; should not be lexically bound.  In the body of the macrolet form itself
;;; x should be bound.  Note that THIS CASE WILL CAUSE AN ERROR when it			;;; x should be bound.  Note that THIS CASE WILL CAUSE AN ERROR when it
;;; tries to macroexpand the call to foo.						;;; tries to macroexpand the call to foo.
;;; 											;;; 
(take-it-out-for-a-test-walk								(take-it-out-for-a-test-walk
     (let ((x 1))									     (let ((x 1))
       (macrolet ((foo () (list x) ''inner))						       (macrolet ((foo () (list x) ''inner))
	 x											 x
	 (foo))))										 (foo))))

;;;											;;;
;;; A truly hairy use of compiler-let and macrolet.  In the body of the			;;; A truly hairy use of compiler-let and macrolet.  In the body of the
;;; macro x should not be lexically bound.  In the body of the macrolet			;;; macro x should not be lexically bound.  In the body of the macrolet
;;; itself x should not be lexically bound.  But the macro should expand		;;; itself x should not be lexically bound.  But the macro should expand
;;; into 1.										;;; into 1.
;;; 											;;; 
(take-it-out-for-a-test-walk								(take-it-out-for-a-test-walk
  (compiler-let ((x 1))									  (compiler-let ((x 1))
    (let ((x 2))									    (let ((x 2))
      (macrolet ((foo () x))								      (macrolet ((foo () x))
	x											x
	(foo)))))										(foo)))))


(take-it-out-for-a-test-walk								(take-it-out-for-a-test-walk
  (flet ((foo (x) (list x y))								  (flet ((foo (x) (list x y))
	 (bar (x) (list x y)))									 (bar (x) (list x y)))
    (foo 1)))										    (foo 1)))

(take-it-out-for-a-test-walk								(take-it-out-for-a-test-walk
  (let ((y 2))										  (let ((y 2))
    (flet ((foo (x) (list x y))								    (flet ((foo (x) (list x y))
	   (bar (x) (list x y)))								   (bar (x) (list x y)))
      (foo 1))))									      (foo 1))))

(take-it-out-for-a-test-walk								(take-it-out-for-a-test-walk
  (labels ((foo (x) (bar x))								  (labels ((foo (x) (bar x))
	   (bar (x) (foo x)))									   (bar (x) (foo x)))
    (foo 1)))										    (foo 1)))

(take-it-out-for-a-test-walk								(take-it-out-for-a-test-walk
  (flet ((foo (x) (foo x)))								  (flet ((foo (x) (foo x)))
    (foo 1)))										    (foo 1)))

(take-it-out-for-a-test-walk								(take-it-out-for-a-test-walk
  (flet ((foo (x) (foo x)))								  (flet ((foo (x) (foo x)))
    (flet ((bar (x) (foo x)))								    (flet ((bar (x) (foo x)))
      (bar 1))))									      (bar 1))))

(take-it-out-for-a-test-walk (compiler-let ((a 1) (b 2)) (foo a) b))			(take-it-out-for-a-test-walk (compiler-let ((a 1) (b 2)) (foo a) b))
(take-it-out-for-a-test-walk (prog () (declare (special a b))))				(take-it-out-for-a-test-walk (prog () (declare (special a b))))
(take-it-out-for-a-test-walk (let (a b c)						(take-it-out-for-a-test-walk (let (a b c)
                               (declare (special a b))					                               (declare (special a b))
                               (foo a) b c))						                               (foo a) b c))
(take-it-out-for-a-test-walk (let (a b c)						(take-it-out-for-a-test-walk (let (a b c)
                               (declare (special a) (special b))			                               (declare (special a) (special b))
                               (foo a) b c))						                               (foo a) b c))
(take-it-out-for-a-test-walk (let (a b c)						(take-it-out-for-a-test-walk (let (a b c)
                               (declare (special a))					                               (declare (special a))
                               (declare (special b))					                               (declare (special b))
                               (foo a) b c))						                               (foo a) b c))
(take-it-out-for-a-test-walk (let (a b c)						(take-it-out-for-a-test-walk (let (a b c)
                               (declare (special a))					                               (declare (special a))
                               (declare (special b))					                               (declare (special b))
                               (let ((a 1))						                               (let ((a 1))
                                 (foo a) b c)))						                                 (foo a) b c)))
(take-it-out-for-a-test-walk (eval-when ()						(take-it-out-for-a-test-walk (eval-when ()
                               a							                               a
                               (foo a)))						                               (foo a)))
(take-it-out-for-a-test-walk (eval-when (eval when load)				(take-it-out-for-a-test-walk (eval-when (eval when load)
                               a							                               a
                               (foo a)))						                               (foo a)))

(take-it-out-for-a-test-walk (multiple-value-bind (a b) (foo a b) (list a b)))		(take-it-out-for-a-test-walk (multiple-value-bind (a b) (foo a b) (list a b)))
(take-it-out-for-a-test-walk (multiple-value-bind (a b)					(take-it-out-for-a-test-walk (multiple-value-bind (a b)
				 (foo a b)										 (foo a b)
			       (declare (special a))								       (declare (special a))
			       (list a b)))									       (list a b)))
(take-it-out-for-a-test-walk (progn (function foo)))					(take-it-out-for-a-test-walk (progn (function foo)))
(take-it-out-for-a-test-walk (progn a b (go a)))					(take-it-out-for-a-test-walk (progn a b (go a)))
(take-it-out-for-a-test-walk (if a b c))						(take-it-out-for-a-test-walk (if a b c))
(take-it-out-for-a-test-walk (if a b))							(take-it-out-for-a-test-walk (if a b))
(take-it-out-for-a-test-walk ((lambda (a b) (list a b)) 1 2))				(take-it-out-for-a-test-walk ((lambda (a b) (list a b)) 1 2))
(take-it-out-for-a-test-walk ((lambda (a b) (declare (special a)) (list a b))		(take-it-out-for-a-test-walk ((lambda (a b) (declare (special a)) (list a b))
			      1 2))										      1 2))
(take-it-out-for-a-test-walk (let ((a a) (b a) (c b)) (list a b c)))			(take-it-out-for-a-test-walk (let ((a a) (b a) (c b)) (list a b c)))
(take-it-out-for-a-test-walk (let* ((a a) (b a) (c b)) (list a b c)))			(take-it-out-for-a-test-walk (let* ((a a) (b a) (c b)) (list a b c)))
(take-it-out-for-a-test-walk (let ((a a) (b a) (c b))					(take-it-out-for-a-test-walk (let ((a a) (b a) (c b))
                               (declare (special a b))					                               (declare (special a b))
                               (list a b c)))						                               (list a b c)))
(take-it-out-for-a-test-walk (let* ((a a) (b a) (c b))					(take-it-out-for-a-test-walk (let* ((a a) (b a) (c b))
                               (declare (special a b))					                               (declare (special a b))
                               (list a b c)))						                               (list a b c)))
(take-it-out-for-a-test-walk (let ((a 1) (b 2))						(take-it-out-for-a-test-walk (let ((a 1) (b 2))
                               (foo bar)						                               (foo bar)
                               (declare (special a))					                               (declare (special a))
                               (foo a b)))						                               (foo a b)))
(take-it-out-for-a-test-walk (multiple-value-call #'foo a b c))				(take-it-out-for-a-test-walk (multiple-value-call #'foo a b c))
(take-it-out-for-a-test-walk (multiple-value-prog1 a b c))				(take-it-out-for-a-test-walk (multiple-value-prog1 a b c))
(take-it-out-for-a-test-walk (progn a b c))						(take-it-out-for-a-test-walk (progn a b c))
(take-it-out-for-a-test-walk (progv vars vals a b c))					(take-it-out-for-a-test-walk (progv vars vals a b c))
(take-it-out-for-a-test-walk (quote a))							(take-it-out-for-a-test-walk (quote a))
(take-it-out-for-a-test-walk (return-from block-name a b c))				(take-it-out-for-a-test-walk (return-from block-name a b c))
(take-it-out-for-a-test-walk (setq a 1))						(take-it-out-for-a-test-walk (setq a 1))
(take-it-out-for-a-test-walk (setq a (foo 1) b (bar 2) c 3))				(take-it-out-for-a-test-walk (setq a (foo 1) b (bar 2) c 3))
(take-it-out-for-a-test-walk (tagbody a b c (go a)))					(take-it-out-for-a-test-walk (tagbody a b c (go a)))
(take-it-out-for-a-test-walk (the foo (foo-form a b c)))				(take-it-out-for-a-test-walk (the foo (foo-form a b c)))
(take-it-out-for-a-test-walk (throw tag-form a))					(take-it-out-for-a-test-walk (throw tag-form a))
(take-it-out-for-a-test-walk (unwind-protect (foo a b) d e f))				(take-it-out-for-a-test-walk (unwind-protect (foo a b) d e f))

(defmacro flet-1 (a b) ''outer)								(defmacro flet-1 (a b) ''outer)
(defmacro labels-1 (a b) ''outer)							(defmacro labels-1 (a b) ''outer)

(take-it-out-for-a-test-walk								(take-it-out-for-a-test-walk
  (flet ((flet-1 (a b) () (flet-1 a b) (list a b)))					  (flet ((flet-1 (a b) () (flet-1 a b) (list a b)))
    (flet-1 1 2)									    (flet-1 1 2)
    (foo 1 2)))										    (foo 1 2)))
(take-it-out-for-a-test-walk								(take-it-out-for-a-test-walk
  (labels ((label-1 (a b) () (label-1 a b)(list a b)))					  (labels ((label-1 (a b) () (label-1 a b)(list a b)))
    (label-1 1 2)									    (label-1 1 2)
    (foo 1 2)))										    (foo 1 2)))
(take-it-out-for-a-test-walk (macrolet ((macrolet-1 (a b) (list a b)))			(take-it-out-for-a-test-walk (macrolet ((macrolet-1 (a b) (list a b)))
                               (macrolet-1 a b)						                               (macrolet-1 a b)
                               (foo 1 2)))						                               (foo 1 2)))

(take-it-out-for-a-test-walk (macrolet ((foo (a) `(inner-foo-expanded ,a)))		(take-it-out-for-a-test-walk (macrolet ((foo (a) `(inner-foo-expanded ,a)))
                               (foo 1)))						                               (foo 1)))

(take-it-out-for-a-test-walk (progn (bar 1)						(take-it-out-for-a-test-walk (progn (bar 1)
                                    (macrolet ((bar (a)					                                    (macrolet ((bar (a)
						 `(inner-bar-expanded ,a)))								 `(inner-bar-expanded ,a)))
                                      (bar 2))))					                                      (bar 2))))

(take-it-out-for-a-test-walk (progn (bar 1)						(take-it-out-for-a-test-walk (progn (bar 1)
                                    (macrolet ((bar (s)					                                    (macrolet ((bar (s)
						 (bar s)										 (bar s)
						 `(inner-bar-expanded ,s)))								 `(inner-bar-expanded ,s)))
                                      (bar 2))))					                                      (bar 2))))

(take-it-out-for-a-test-walk (cond (a b)						(take-it-out-for-a-test-walk (cond (a b)
                                   ((foo bar) a (foo a))))				                                   ((foo bar) a (foo a))))


(let ((the-lexical-variables ()))							(let ((the-lexical-variables ()))
  (walk-form '(let ((a 1) (b 2))							  (walk-form '(let ((a 1) (b 2))
		#'(lambda (x) (list a b x y)))								#'(lambda (x) (list a b x y)))
	     ()											     ()
	     #'(lambda (form context env)							     #'(lambda (form context env)
		 (when (and (symbolp form)								 (when (and (symbolp form)
			    (variable-lexical-p form env))							    (variable-lexical-p form env))
		   (push form the-lexical-variables))							   (push form the-lexical-variables))
		 form))											 form))
  (or (and (= (length the-lexical-variables) 3)						  (or (and (= (length the-lexical-variables) 3)
	   (member 'a the-lexical-variables)							   (member 'a the-lexical-variables)
	   (member 'b the-lexical-variables)							   (member 'b the-lexical-variables)
	   (member 'x the-lexical-variables))							   (member 'x the-lexical-variables))
      (error "Walker didn't do lexical variables of a closure properly.")))		      (error "Walker didn't do lexical variables of a closure properly.")))
    											    
|#											|#

()											()

Files ../simlab/weyl/src/walk.lisp and ../weyl/walk.lisp are identical
